<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\huffyuvenc.c">





























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"huffyuv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"huffman.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"huffyuvencdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lossless_videoencdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"put_bits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>diff_bytes</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hencdsp</name><operator>.</operator><name>diff_int16</name></name><argument_list>(<argument><expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src0</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src1</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>sub_left_prediction</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_width</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_width</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> 
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>temp</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>temp</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>left</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">31</literal></expr></argument>, <argument><expr><name>w</name> <operator>-</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>src</name><index>[<expr><name>w</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>src16</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>dst16</name> <init>= <expr><operator>(</operator> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>dst</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_width</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> 
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>temp</name> <init>= <expr><name><name>src16</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dst16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>temp</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>left</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hencdsp</name><operator>.</operator><name>diff_int16</name></name><argument_list>(<argument><expr><name>dst16</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src16</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src16</name> <operator>+</operator> <literal type="number">31</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>w</name> <operator>-</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>src16</name><index>[<expr><name>w</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sub_left_prediction_bgr32</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>red</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>green</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>blue</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>alpha</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_width</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>*</operator><name>red</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>*</operator><name>green</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>blue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>alpha</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_width</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>R</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>gt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>G</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>B</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>at</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>A</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>R</name></expr>]</index></name> <operator>=</operator> <name>rt</name> <operator>-</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>G</name></expr>]</index></name> <operator>=</operator> <name>gt</name> <operator>-</operator> <name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>B</name></expr>]</index></name> <operator>=</operator> <name>bt</name> <operator>-</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>A</name></expr>]</index></name> <operator>=</operator> <name>at</name> <operator>-</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name> <operator>=</operator> <name>gt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>bt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">32</literal> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>w</name> <operator>*</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>red</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>R</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>green</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>G</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>blue</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>B</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>alpha</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>A</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sub_left_prediction_rgb24</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>red</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>green</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>blue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>*</operator><name>red</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>*</operator><name>green</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>blue</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>gt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bt</name> <init>= <expr><name><name>src</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>rt</name> <operator>-</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>gt</name> <operator>-</operator> <name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>bt</name> <operator>-</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name> <operator>=</operator> <name>gt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>bt</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <literal type="number">48</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">48</literal></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <literal type="number">48</literal> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>w</name> <operator>*</operator> <literal type="number">3</literal> <operator>-</operator> <literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>red</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>green</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>blue</name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>w</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sub_median_prediction</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>left_top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><name>left</name></expr></argument>, <argument><expr><name>left_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hencdsp</name><operator>.</operator><name>sub_hfyu_median_pred_int16</name></name><argument_list>(<argument><expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src1</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><name>left</name></expr></argument>, <argument><expr><name>left_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>store_table</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repeat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <name><name>len</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>val</name> <operator>&amp;&amp;</operator> <name>repeat</name> <operator>&lt;</operator> <literal type="number">255</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>repeat</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name><name>val</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>val</name></expr></argument> &gt;</argument_list></name><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>repeat</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>repeat</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>&gt;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>repeat</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>|</operator> <operator>(</operator><name>repeat</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>store_huffman_tables</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>alpha</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>chroma</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_huff_gen_len_table</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_huffyuv_generate_bits_table</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>store_table</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>encode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_huffyuv_common_init</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_huffyuvencdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hencdsp</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_llvidencdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>*</operator><name>MAX_N</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATS_OUT_SIZE</name></cpp:macro> <cpp:value>21*MAX_N*3 + 4</cpp:value></cpp:define>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name>STATS_OUT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_CODED_FRAME</name></expr></cpp:if>
<decl_stmt><decl><type><name>FF_DISABLE_DEPRECATION_WARNINGS</name></type>
<name><name>avctx</name><operator>-&gt;</operator><name>coded_frame</name><operator>-&gt;</operator><name>pict_type</name></name> <init>= <expr><name>AV_PICTURE_TYPE_I</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>coded_frame</name><operator>-&gt;</operator><name>key_frame</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>FF_ENABLE_DEPRECATION_WARNINGS</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_PRIVATE_OPT</name></expr></cpp:if>
<name>FF_DISABLE_DEPRECATION_WARNINGS</name></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>context_model</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>context_model</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>FF_ENABLE_DEPRECATION_WARNINGS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>yuv</name></name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_RGB</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>chroma</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>alpha</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_ALPHA</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_pix_fmt_get_chroma_sub_sample</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_v_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AV_PIX_FMT_YUV420P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Width must be even for this colorspace.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>=</operator> <ternary><condition><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_YUV420P</name></expr> ?</condition><then> <expr><literal type="number">12</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_YUV444P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV410P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV411P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV440P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP12</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP14</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRP16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GRAY8</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GRAY16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA444P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA420P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA422P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_GBRAP</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV420P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV420P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV420P12</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV420P14</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV420P16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P12</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P14</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P12</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P14</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA420P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA420P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA420P16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA422P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA422P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA422P16</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA444P9</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA444P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVA444P16</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_RGB32</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_RGB24</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"format not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name><name>s</name><operator>-&gt;</operator><name>bps</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>MAX_VLC_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>decorrelate</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>&gt;=</operator> <literal type="number">24</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>yuv</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_PLANAR</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_PRIVATE_OPT</name></expr></cpp:if>
<macro><name>FF_DISABLE_DEPRECATION_WARNINGS</name></macro>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>prediction_method</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>prediction_method</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>FF_ENABLE_DEPRECATION_WARNINGS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <init>= <expr><ternary><condition><expr><name><name>avctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_INTERLACED_ME</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>AV_CODEC_FLAG_PASS1</name> <operator>|</operator> <name>AV_CODEC_FLAG_PASS2</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"context=1 is not compatible with "</literal>
<literal type="string">"2 pass huffyuv encoding\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>codec</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>AV_CODEC_ID_HUFFYUV</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_YUV420P</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error: YV12 is not supported by huffyuv; use "</literal>
<literal type="string">"vcodec=ffvhuff or format=422p\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_PRIVATE_OPT</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error: per-frame huffman tables are not supported "</literal>
<literal type="string">"by huffyuv; use vcodec=ffvhuff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error: ver&gt;2 is not supported "</literal>
<literal type="string">"by huffyuv; use vcodec=ffvhuff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>!=</operator> <operator>(</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;</operator> <literal type="number">288</literal> <operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"using huffyuv 2.2.0 or newer interlacing flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>strict_std_compliance</name></name> <operator>&gt;</operator> <name>FF_COMPLIANCE_EXPERIMENTAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Ver &gt; 3 is under development, files encoded with it may not be decodable with future versions!!!\n"</literal>
<literal type="string">"Use vstrict=-2 / -strict -2 to use it anyway.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>&gt;=</operator> <literal type="number">24</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>MEDIAN</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error: RGB is incompatible with median predictor\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>|</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>decorrelate</name></name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr> ?</condition><then> <expr><literal type="number">0x10</literal></expr> </then><else>: <expr><literal type="number">0x20</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bps</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name> <operator>|</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_v_shift</name></name><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>chroma</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>|=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>yuv</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>alpha</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>|=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_in</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_in</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">100000000</literal> <operator>/</operator> <operator>(</operator><name>d</name><operator>*</operator><name>d</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>store_huffman_tables</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pels</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><literal type="number">40</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pels</name><operator>/</operator><operator>(</operator><name>d</name><operator>*</operator><name>d</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_huffyuv_alloc_temp</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_huffyuv_common_end</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>picture_number</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_422_bitstream</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>offset</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>offset</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf_end</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf</name></name> <operator>-</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">4</literal> <operator>*</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"encoded frame too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD4int</name></cpp:macro> <cpp:value>y0 = y[2 * i];int y1 = y[2 * i + 1];int u0 = u[i];int v0 = v[i];</cpp:value></cpp:define>





<expr_stmt><expr><name>count</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD4</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD4</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD4</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>u0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>v0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_plane_bitstream</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><name>width</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf_end</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf</name></name> <operator>-</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator> <name>count</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"encoded frame too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOADENDint</name></cpp:macro> <cpp:value>y0 = s-&gt;temp[0][width-1];</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOADEND_14int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp16[0][width-1] &amp; mask;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOADEND_16int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp16[0][width-1];</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATENDs</name></cpp:macro><cpp:value>-&gt;stats[plane][y0]++;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATEND_16s</name></cpp:macro><cpp:value>-&gt;stats[plane][y0&gt;&gt;2]++;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEENDput_bits</name><parameter_list>(<parameter><type><modifier>&amp;</modifier></type><parameter><type><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter></parameter>)</parameter_list></cpp:macro><cpp:value>;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEEND_16put_bits</name><parameter_list>(<parameter><type><modifier>&amp;</modifier></type><parameter><type><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name><operator>&gt;</operator></expr></index></name></type></parameter></parameter></parameter_list></cpp:macro>&gt;2], s-&gt;bits[plane][y0&gt;&gt;2]);put_bits(&amp;s-&gt;pb, 2, y0&amp;3);</cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD2int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp[0][2 * i];int y1 = s-&gt;temp[0][2 * i + 1];</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD2_14int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp16[0][2 * i] &amp; mask;int y1 = s-&gt;temp16[0][2 * i + 1] &amp; mask;</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD2_16int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp16[0][2 * i];int y1 = s-&gt;temp16[0][2 * i + 1];</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT2s</name></cpp:macro><cpp:value>-&gt;stats[plane][y0]++;s-&gt;stats[plane][y1]++;</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT2_16s</name></cpp:macro><cpp:value>-&gt;stats[plane][y0&gt;&gt;2]++;s-&gt;stats[plane][y1&gt;&gt;2]++;</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE2put_bits</name><parameter_list>(<parameter><type><modifier>&amp;</modifier></type><parameter><type><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter></parameter>)</parameter_list></cpp:macro><cpp:value>;put_bits(&amp;s-&gt;pb, s-&gt;len[plane][y1], s-&gt;bits[plane][y1]);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE2_16put_bits</name><parameter_list>(<parameter><type><modifier>&amp;</modifier></type><parameter><type><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>y0</name><operator>&gt;</operator></expr></index></name></type></parameter></parameter></parameter_list></cpp:macro>&gt;2], s-&gt;bits[plane][y0&gt;&gt;2]);put_bits(&amp;s-&gt;pb, 2, y0&amp;3);put_bits(&amp;s-&gt;pb, s-&gt;len[plane][y1&gt;&gt;2], s-&gt;bits[plane][y1&gt;&gt;2]);put_bits(&amp;s-&gt;pb, 2, y1&amp;3);</cpp:define>





<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bps</name></name> <operator>&lt;=</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_14</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2_16</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND_16</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2_16</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STATEND_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND_16</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2_16</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LOADEND_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITEEND_16</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOAD2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STAT2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WRITE2</name></cpp:undef>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_gray_bitstream</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf_end</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf</name></name> <operator>-</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"encoded frame too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD2int</name></cpp:macro> <cpp:value>y0 = s-&gt;temp[0][2 * i];int y1 = s-&gt;temp[0][2 * i + 1];</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT2s</name></cpp:macro><cpp:value>-&gt;stats[0][y0]++;s-&gt;stats[0][y1]++;</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE2put_bits</name><parameter_list>(<parameter><type><modifier>&amp;</modifier></type><parameter><type><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter>, <parameter><type><name><name>s</name><operator>-&gt;</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name></expr>]</index></name></type></parameter></parameter>)</parameter_list></cpp:macro><cpp:value>;put_bits(&amp;s-&gt;pb, s-&gt;len[0][y1], s-&gt;bits[0][y1]);</cpp:value></cpp:define>



<expr_stmt><expr><name>count</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE2</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>encode_bgra_bitstream</name><parameter_list>(<parameter><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>planes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf_end</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf</name></name> <operator>-</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;</operator>
<literal type="number">4</literal> <operator>*</operator> <name>planes</name> <operator>*</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"encoded frame too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_GBRA</name></cpp:macro> <cpp:value>int g = s-&gt;temp[0][planes == 3 ? 3 * i + 1 : 4 * i + G]; int b =(s-&gt;temp[0][planes == 3 ? 3 * i + 2 : 4 * i + B] - g) &amp; 0xFF;int r =(s-&gt;temp[0][planes == 3 ? 3 * i + 0 : 4 * i + R] - g) &amp; 0xFF;int a = s-&gt;temp[0][planes * i + A];</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT_BGRA</name></cpp:macro> <cpp:value>s-&gt;stats[0][b]++; s-&gt;stats[1][g]++; s-&gt;stats[2][r]++; if (planes == 4) s-&gt;stats[2][a]++;</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_GBRA</name></cpp:macro> <cpp:value>put_bits(&amp;s-&gt;pb, s-&gt;len[1][g], s-&gt;bits[1][g]); put_bits(&amp;s-&gt;pb, s-&gt;len[0][b], s-&gt;bits[0][b]); put_bits(&amp;s-&gt;pb, s-&gt;len[2][r], s-&gt;bits[2][r]); if (planes == 4) put_bits(&amp;s-&gt;pb, s-&gt;len[2][a], s-&gt;bits[2][a]);</cpp:value></cpp:define>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD_GBRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT_BGRA</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name> <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD_GBRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>STAT_BGRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE_GBRA</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>LOAD_GBRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>WRITE_GBRA</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>pict</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_packet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width2</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fake_ystride</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr> ?</condition><then> <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fake_ustride</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr> ?</condition><then> <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fake_vstride</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr> ?</condition><then> <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>pict</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>p</name> <init>= <expr><name>pict</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_alloc_packet2</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>width</name> <operator>*</operator> <name>height</name> <operator>*</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_MIN_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>store_huffman_tables</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>init_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_YUV422P</name> <operator>||</operator>
<name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_YUV420P</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lefty</name></decl>, <decl><type ref="prev"/><name>leftu</name></decl>, <decl><type ref="prev"/><name>leftv</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>cy</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftv</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>lefty</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftu</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftu</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftv</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>width</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name><operator>==</operator><name>MEDIAN</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lefttopy</name></decl>, <decl><type ref="prev"/><name>lefttopu</name></decl>, <decl><type ref="prev"/><name>lefttopv</name></decl>;</decl_stmt>
<expr_stmt><expr><name>cy</name> <operator>=</operator> <name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftu</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftv</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>cy</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>fake_ystride</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftu</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>fake_ustride</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>leftu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftv</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>fake_vstride</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>leftv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lefttopy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lefttopu</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lefttopv</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>fake_ystride</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefty</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>fake_ustride</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>width2</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>fake_vstride</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>width2</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>cy</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr><operator>,</operator><expr><name>cy</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ydst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>udst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vdst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><literal type="number">2</literal> <operator>*</operator> <name>cy</name> <operator>&gt;</operator> <name>y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ydst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name> <operator>-</operator> <name>fake_ystride</name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefty</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_gray_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&gt;=</operator> <name>height</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ydst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>udst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>cy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vdst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name>cy</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name> <operator>-</operator> <name>fake_ystride</name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefty</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>udst</name> <operator>-</operator> <name>fake_ustride</name></expr></argument>, <argument><expr><name>udst</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>sub_median_pred</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>vdst</name> <operator>-</operator> <name>fake_vstride</name></expr></argument>, <argument><expr><name>vdst</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttopv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>cy</name> <operator>=</operator> <name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr><operator>,</operator> <expr><name>cy</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ydst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>udst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vdst</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bitstream_bpp</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ydst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>PLANE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>&lt;</operator> <name>y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>ydst</name> <operator>-</operator> <name>fake_ystride</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>encode_gray_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&gt;=</operator> <name>height</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ydst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>udst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>cy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vdst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name>cy</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>PLANE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>&lt;</operator> <name>cy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>ydst</name> <operator>-</operator> <name>fake_ystride</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>udst</name></expr></argument>, <argument><expr><name>udst</name> <operator>-</operator> <name>fake_ustride</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>width2</name></expr></argument>, <argument><expr><name>vdst</name></expr></argument>, <argument><expr><name>vdst</name> <operator>-</operator> <name>fake_vstride</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftu</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftv</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>width2</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lefty</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ydst</name></expr></argument>, <argument><expr><name>width</name></expr></argument> , <argument><expr><name>lefty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftu</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>udst</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leftv</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>vdst</name></expr></argument>, <argument><expr><name>width2</name></expr></argument>, <argument><expr><name>leftv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>encode_422_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_RGB32</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>height</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stride</name> <init>= <expr><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fake_stride</name> <init>= <expr><operator>-</operator><name>fake_ystride</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftr</name></decl>, <decl><type ref="prev"/><name>leftg</name></decl>, <decl><type ref="prev"/><name>leftb</name></decl>, <decl><type ref="prev"/><name>lefta</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>lefta</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>A</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftr</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>R</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftg</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>G</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftb</name> <operator>=</operator> <name><name>data</name><index>[<expr><name>B</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sub_left_prediction_bgr32</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_bgra_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>data</name> <operator>+</operator> <name>y</name><operator>*</operator><name>stride</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>PLANE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>&lt;</operator> <name>y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst</name> <operator>-</operator> <name>fake_stride</name></expr></argument>, <argument><expr><name>width</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sub_left_prediction_bgr32</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sub_left_prediction_bgr32</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>width</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>encode_bgra_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>==</operator> <name>AV_PIX_FMT_RGB24</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>height</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stride</name> <init>= <expr><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fake_stride</name> <init>= <expr><operator>-</operator><name>fake_ystride</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>leftr</name></decl>, <decl><type ref="prev"/><name>leftg</name></decl>, <decl><type ref="prev"/><name>leftb</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftr</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftg</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>leftb</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sub_left_prediction_rgb24</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_bgra_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>data</name> <operator>+</operator> <name>y</name> <operator>*</operator> <name>stride</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>PLANE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>&lt;</operator> <name>y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>llvidencdsp</name><operator>.</operator><name>diff_bytes</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst</name> <operator>-</operator> <name>fake_stride</name></expr></argument>,
<argument><expr><name>width</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sub_left_prediction_rgb24</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sub_left_prediction_rgb24</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>width</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>leftr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>encode_bgra_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>plane</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>plane</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>plane</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>chroma</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>alpha</name></name></expr>;</condition> <incr><expr><name>plane</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fake_stride</name> <init>= <expr><name>fake_ystride</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>chroma</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>plane</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>plane</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_v_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fake_stride</name> <operator>=</operator> <ternary><condition><expr><name>plane</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>fake_ustride</name></expr> </then><else>: <expr><name>fake_vstride</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_plane_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name><operator>==</operator><name>MEDIAN</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lefttop</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_plane_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lefttop</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>*</operator> <name>y</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sub_median_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name> <operator>-</operator> <name>fake_stride</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_plane_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>*</operator> <name>y</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>predictor</name></name> <operator>==</operator> <name>PLANE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>&lt;</operator> <name>y</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>diff_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst</name> <operator>-</operator> <name>fake_stride</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>sub_left_prediction</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>w</name></expr></argument> , <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>encode_plane_bitstream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Format not supported!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>/=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_PASS1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>picture_number</name></name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <name>STATS_OUT_SIZE</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>vlc_n</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIu64</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>stats</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_NO_OUTPUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>bdsp</name><operator>.</operator><name>bswap_buf</name></name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>picture_number</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>AV_PKT_FLAG_KEY</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>got_packet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>encode_end</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HYuvContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_huffyuv_common_end</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>avctx</name><operator>-&gt;</operator><name>stats_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(HYuvContext, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VE</name></cpp:macro> <cpp:value>AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMON_OPTIONS</name></cpp:macro> <cpp:value>{ "non_deterministic", "Allow multithreading for e.g. context=1 at the expense of determinism", OFFSET(non_determ), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, VE }, { "pred", "Prediction method", OFFSET(predictor), AV_OPT_TYPE_INT, { .i64 = LEFT }, LEFT, MEDIAN, VE, "pred" }, { "left", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = LEFT }, INT_MIN, INT_MAX, VE, "pred" }, { "plane", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = PLANE }, INT_MIN, INT_MAX, VE, "pred" }, { "median", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MEDIAN }, INT_MIN, INT_MAX, VE, "pred" },</cpp:value></cpp:define> 








<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>normal_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>COMMON_OPTIONS</name>
<block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>ff_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>COMMON_OPTIONS</name>
<block>{ <expr><literal type="string">"context"</literal></expr>, <expr><literal type="string">"Set per-frame huffman tables"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{ <expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>VE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>normal_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"huffyuv"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>normal_options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>ff_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"ffvhuff"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>ff_options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_huffyuv_encoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"huffyuv"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Huffyuv / HuffYUV"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_HUFFYUV</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HYuvContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>encode_init</name></expr>,
<expr><operator>.</operator><name>encode2</name> <operator>=</operator> <name>encode_frame</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>encode_end</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_FRAME_THREADS</name> <operator>|</operator> <name>AV_CODEC_CAP_INTRA_ONLY</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>normal_class</name></expr>,
<expr><operator>.</operator><name>pix_fmts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> enum <name><name>AVPixelFormat</name><index>[]</index></name><operator>)</operator><block>{
<expr><name>AV_PIX_FMT_YUV422P</name></expr>, <expr><name>AV_PIX_FMT_RGB24</name></expr>,
<expr><name>AV_PIX_FMT_RGB32</name></expr>, <expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name> <operator>|</operator>
<name>FF_CODEC_CAP_INIT_CLEANUP</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_FFVHUFF_ENCODER</name></expr></cpp:if>
<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_ffvhuff_encoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"ffvhuff"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Huffyuv FFmpeg variant"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_FFVHUFF</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HYuvContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>encode_init</name></expr>,
<expr><operator>.</operator><name>encode2</name> <operator>=</operator> <name>encode_frame</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>encode_end</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_FRAME_THREADS</name> <operator>|</operator> <name>AV_CODEC_CAP_INTRA_ONLY</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>ff_class</name></expr>,
<expr><operator>.</operator><name>pix_fmts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> enum <name><name>AVPixelFormat</name><index>[]</index></name><operator>)</operator><block>{
<expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><name>AV_PIX_FMT_YUV422P</name></expr>, <expr><name>AV_PIX_FMT_YUV444P</name></expr>, <expr><name>AV_PIX_FMT_YUV411P</name></expr>,
<expr><name>AV_PIX_FMT_YUV410P</name></expr>, <expr><name>AV_PIX_FMT_YUV440P</name></expr>,
<expr><name>AV_PIX_FMT_GBRP</name></expr>,
<expr><name>AV_PIX_FMT_GBRP9</name></expr>, <expr><name>AV_PIX_FMT_GBRP10</name></expr>, <expr><name>AV_PIX_FMT_GBRP12</name></expr>, <expr><name>AV_PIX_FMT_GBRP14</name></expr>, <expr><name>AV_PIX_FMT_GBRP16</name></expr>,
<expr><name>AV_PIX_FMT_GRAY8</name></expr>, <expr><name>AV_PIX_FMT_GRAY16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA420P</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P</name></expr>,
<expr><name>AV_PIX_FMT_GBRAP</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P9</name></expr>, <expr><name>AV_PIX_FMT_YUV420P10</name></expr>, <expr><name>AV_PIX_FMT_YUV420P12</name></expr>, <expr><name>AV_PIX_FMT_YUV420P14</name></expr>, <expr><name>AV_PIX_FMT_YUV420P16</name></expr>,
<expr><name>AV_PIX_FMT_YUV422P9</name></expr>, <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><name>AV_PIX_FMT_YUV422P12</name></expr>, <expr><name>AV_PIX_FMT_YUV422P14</name></expr>, <expr><name>AV_PIX_FMT_YUV422P16</name></expr>,
<expr><name>AV_PIX_FMT_YUV444P9</name></expr>, <expr><name>AV_PIX_FMT_YUV444P10</name></expr>, <expr><name>AV_PIX_FMT_YUV444P12</name></expr>, <expr><name>AV_PIX_FMT_YUV444P14</name></expr>, <expr><name>AV_PIX_FMT_YUV444P16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA420P9</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P9</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA444P9</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P16</name></expr>,
<expr><name>AV_PIX_FMT_RGB24</name></expr>,
<expr><name>AV_PIX_FMT_RGB32</name></expr>, <expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name> <operator>|</operator>
<name>FF_CODEC_CAP_INIT_CLEANUP</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
