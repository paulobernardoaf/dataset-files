<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\vc2enc.c">




















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dirac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"put_bits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vc2enc_dwt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diractab.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SSIZE_ROUND</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FFALIGN((b), s-&gt;size_scaler) + 4 + s-&gt;prefix_bytes)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLICE_REDIST_TOTAL</name></cpp:macro> <cpp:value>150</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>VC2BaseVideoFormat</name> <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>pix_fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>time_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>, <name>height</name>, <name>interlaced</name>, <name>level</name>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>VC2BaseVideoFormat</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VC2BaseVideoFormat</name></type> <name><name>base_video_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>, 
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">15000</literal></expr> }</block></expr>, <expr><literal type="number">176</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"QSIF525"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">25</literal></expr> }</block></expr>, <expr><literal type="number">176</literal></expr>, <expr><literal type="number">144</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"QCIF"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">15000</literal></expr> }</block></expr>, <expr><literal type="number">352</literal></expr>, <expr><literal type="number">240</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"SIF525"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">25</literal></expr> }</block></expr>, <expr><literal type="number">352</literal></expr>, <expr><literal type="number">288</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"CIF"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">15000</literal></expr> }</block></expr>, <expr><literal type="number">704</literal></expr>, <expr><literal type="number">480</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"4SIF525"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">25</literal></expr> }</block></expr>, <expr><literal type="number">704</literal></expr>, <expr><literal type="number">576</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"4CIF"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">30000</literal></expr> }</block></expr>, <expr><literal type="number">720</literal></expr>, <expr><literal type="number">480</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="string">"SD480I-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">25</literal></expr> }</block></expr>, <expr><literal type="number">720</literal></expr>, <expr><literal type="number">576</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="string">"SD576I-50"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">60000</literal></expr> }</block></expr>, <expr><literal type="number">1280</literal></expr>, <expr><literal type="number">720</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD720P-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">50</literal></expr> }</block></expr>, <expr><literal type="number">1280</literal></expr>, <expr><literal type="number">720</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD720P-50"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">30000</literal></expr> }</block></expr>, <expr><literal type="number">1920</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD1080I-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">25</literal></expr> }</block></expr>, <expr><literal type="number">1920</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD1080I-50"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">60000</literal></expr> }</block></expr>, <expr><literal type="number">1920</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD1080P-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">50</literal></expr> }</block></expr>, <expr><literal type="number">1920</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD1080P-50"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV444P12</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">24</literal></expr> }</block></expr>, <expr><literal type="number">2048</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="string">"DC2K"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV444P12</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">24</literal></expr> }</block></expr>, <expr><literal type="number">4096</literal></expr>, <expr><literal type="number">2160</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="string">"DC4K"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">60000</literal></expr> }</block></expr>, <expr><literal type="number">3840</literal></expr>, <expr><literal type="number">2160</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="string">"UHDTV 4K-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">50</literal></expr> }</block></expr>, <expr><literal type="number">3840</literal></expr>, <expr><literal type="number">2160</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="string">"UHDTV 4K-50"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">60000</literal></expr> }</block></expr>, <expr><literal type="number">7680</literal></expr>, <expr><literal type="number">4320</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="string">"UHDTV 8K-60"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">50</literal></expr> }</block></expr>, <expr><literal type="number">7680</literal></expr>, <expr><literal type="number">4320</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="string">"UHDTV 8K-50"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">24000</literal></expr> }</block></expr>, <expr><literal type="number">1920</literal></expr>, <expr><literal type="number">1080</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"HD1080P-24"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><block>{ <expr><literal type="number">1001</literal></expr>, <expr><literal type="number">30000</literal></expr> }</block></expr>, <expr><literal type="number">720</literal></expr>, <expr><literal type="number">486</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="string">"SD Pro486"</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>base_video_fmts_len</name> <init>= <expr><call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>base_video_fmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<enum>enum <name>VC2_QM</name> <block>{
<decl><name>VC2_QM_DEF</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>VC2_QM_COL</name></decl>,
<decl><name>VC2_QM_FLAT</name></decl>,

<decl><name>VC2_QM_NB</name></decl>
}</block>;</enum>

<typedef>typedef <type><struct>struct <name>SubBand</name> <block>{
<decl_stmt><decl><type><name>dwtcoef</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>
}</block></struct></type> <name>SubBand</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Plane</name> <block>{
<decl_stmt><decl><type><name>SubBand</name></type> <name><name>band</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dwtcoef</name> <modifier>*</modifier></type><name>coef_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dwt_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dwt_height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>coef_stride</name></decl>;</decl_stmt>
}</block></struct></type> <name>Plane</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SliceArgs</name> <block>{
<decl_stmt><decl><type><name>PutBitContext</name></type> <name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>cache</name><index>[<expr><name>DIRAC_MAX_QUANT_INDEX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quant_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_ceil</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_floor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
}</block></struct></type> <name>SliceArgs</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TransformArgs</name> <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>plane</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>idata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>istride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>field</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2TransformContext</name></type> <name>t</name></decl>;</decl_stmt>
}</block></struct></type> <name>TransformArgs</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VC2EncContext</name> <block>{
<decl_stmt><decl><type><name>AVClass</name> <modifier>*</modifier></type><name>av_class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PutBitContext</name></type> <name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Plane</name></type> <name><name>plane</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracVersionInfo</name></type> <name>ver</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>slice_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TransformArgs</name></type> <name><name>transform_args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>diff_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bpp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bpp_idx</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>picture_number</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>base_vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>profile</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>quant</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>custom_quant_matrix</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>qmagic_lut</name><index>[<expr><literal type="number">116</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_x</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>num_y</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>prefix_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size_scaler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_x_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_y_shift</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>frame_max_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_max_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_min_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>q_ceil</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>q_avg</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>double</name></type> <name>tolerance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wavelet_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wavelet_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strict_compliance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>interlaced</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>VC2_QM</name></name></type> <name>quant_matrix</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>next_parse_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>DiracParseCodes</name></name></type> <name>last_parse_code</name></decl>;</decl_stmt>
}</block></struct></type> <name>VC2EncContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>put_vc2_ue_uint</name><parameter_list>(<parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pbits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>topbit</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>val</name> <operator>&gt;</operator> <name>maxval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>topbit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>ff_log2</name><argument_list>(<argument><expr><name>topbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>topbit</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pbits</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;</operator> <name>topbit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pbits</name> <operator>|=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>bits</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>pbits</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>count_vc2_ue_uint</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>topbit</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>val</name> <operator>&gt;</operator> <name>maxval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>topbit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><call><name>ff_log2</name><argument_list>(<argument><expr><name>topbit</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_parse_info</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>DiracParseCodes</name></name></type> <name>pcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>cur_pos</name></decl>, <decl><type ref="prev"/><name>dist</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_pos</name> <operator>=</operator> <call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>avpriv_put_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="string">"BBCD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>pcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>cur_pos</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>next_parse_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>next_parse_offset</name></name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_parse_offset</name></name> <operator>=</operator> <name>cur_pos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>pcode</name> <operator>==</operator> <name>DIRAC_PCODE_END_SEQ</name></expr> ?</condition><then> <expr><literal type="number">13</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bits32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>last_parse_code</name></name> <operator>==</operator> <name>DIRAC_PCODE_END_SEQ</name></expr> ?</condition><then> <expr><literal type="number">13</literal></expr> </then><else>: <expr><name>dist</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_parse_code</name></name> <operator>=</operator> <name>pcode</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_parse_params</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ver</name><operator>.</operator><name>major</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ver</name><operator>.</operator><name>minor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>profile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_frame_size</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_sample_fmt</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_scan_format</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_frame_rate</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_aspect_ratio</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_aspect_ratio</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_aspect_ratio</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_clean_area</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_signal_range</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bpp_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_color_spec</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>==</operator> <name>AVCOL_PRI_BT470BG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>==</operator> <name>AVCOL_PRI_SMPTE170M</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>==</operator> <name>AVCOL_PRI_SMPTE240M</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>==</operator> <name>AVCOL_SPC_RGB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>==</operator> <name>AVCOL_SPC_YCOCG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>==</operator> <name>AVCOL_SPC_BT470BG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>==</operator> <name>AVCOL_TRC_LINEAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>==</operator> <name>AVCOL_TRC_BT1361_ECG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_source_params</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>encode_frame_size</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_sample_fmt</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_scan_format</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_frame_rate</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_aspect_ratio</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_clean_area</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_signal_range</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_color_spec</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_seq_header</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_parse_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_source_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_picture_header</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>picture_number</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_slice_params</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>vc2_qm_col_tab</name><index>[]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>vc2_qm_flat_tab</name><index>[]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_quant_matrix</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>, <decl><type ref="prev"/><name>orientation</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>quant_matrix</name></name> <operator>==</operator> <name>VC2_QM_DEF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>custom_quant_matrix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>custom_quant_matrix</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>quant_matrix</name></name> <operator>==</operator> <name>VC2_QM_DEF</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>vc2_qm_col_tab</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>quant_matrix</name></name> <operator>==</operator> <name>VC2_QM_COL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>vc2_qm_col_tab</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>vc2_qm_flat_tab</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_quant_matrix</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>custom_quant_matrix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>custom_quant_matrix</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_transform_params</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>encode_slice_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_quant_matrix</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_wavelet_transform</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>encode_transform_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_picture_start</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_picture_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_wavelet_transform</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUANT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>mul</name></type></parameter>, <parameter><type><name>add</name></type></parameter>, <parameter><type><name>shift</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((mul) * (c) + (add)) &gt;&gt; (shift))</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>encode_subband</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sy</name></decl></parameter>,
<parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>left</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <operator>(</operator><name>sx</name><operator>+</operator><literal type="number">0</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>right</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <operator>(</operator><name>sx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>top</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <operator>(</operator><name>sy</name><operator>+</operator><literal type="number">0</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bottom</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <operator>(</operator><name>sy</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dwtcoef</name> <modifier>*</modifier></type><name>coeff</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>top</name> <operator>*</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>q_m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>quant</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>q_a</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>quant</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>q_s</name> <init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><name><name>ff_dirac_qscale_tab</name><index>[<expr><name>quant</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c_abs</name> <init>= <expr><call><name>QUANT</name><argument_list>(<argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>coeff</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>q_m</name></expr></argument>, <argument><expr><name>q_a</name></expr></argument>, <argument><expr><name>q_s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_vc2_ue_uint</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>c_abs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c_abs</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>coeff</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>coeff</name> <operator>+=</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>count_hq_slice</name><parameter_list>(<parameter><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quant_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>quants</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>p</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>orientation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>slice</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>quant_idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>slice</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>quant_idx</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bits</name> <operator>+=</operator> <literal type="number">8</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>quants</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>quant_idx</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bytes_start</name></decl>, <decl><type ref="prev"/><name>bytes_len</name></decl>, <decl><type ref="prev"/><name>pad_s</name></decl>, <decl><type ref="prev"/><name>pad_c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_start</name> <operator>=</operator> <name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>q_idx</name> <init>= <expr><name><name>quants</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>q_m</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>q_idx</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>q_a</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>q_idx</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>q_s</name> <init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><name><name>ff_dirac_qscale_tab</name><index>[<expr><name>q_idx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>left</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>slice</name><operator>-&gt;</operator><name>x</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>right</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator><operator>(</operator><name><name>slice</name><operator>-&gt;</operator><name>x</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>top</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <name><name>slice</name><operator>-&gt;</operator><name>y</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bottom</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator><operator>(</operator><name><name>slice</name><operator>-&gt;</operator><name>y</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dwtcoef</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>top</name> <operator>*</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c_abs</name> <init>= <expr><call><name>QUANT</name><argument_list>(<argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>q_m</name></expr></argument>, <argument><expr><name>q_a</name></expr></argument>, <argument><expr><name>q_s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <call><name>count_vc2_ue_uint</name><argument_list>(<argument><expr><name>c_abs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><name>c_abs</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_len</name> <operator>=</operator> <operator>(</operator><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <name>bytes_start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pad_s</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name>bytes_len</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr></argument>)</argument_list></call><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pad_c</name> <operator>=</operator> <operator>(</operator><name>pad_s</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name><operator>)</operator> <operator>-</operator> <name>bytes_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>+=</operator> <name>pad_c</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>quant_idx</name></expr>]</index></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>

<return>return <expr><name>bits</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>rate_control</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>slice_dat</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>top</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>bits_ceil</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bottom</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>bits_floor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>quant_buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quant</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>quant_idx</name></name></expr></init></decl>, <decl><type ref="prev"/><name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_last</name></decl>, <decl><type ref="prev"/><name>bits</name> <init>= <expr><call><name>count_hq_slice</name><argument_list>(<argument><expr><name>slice_dat</name></expr></argument>, <argument><expr><name>quant</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>bits</name> <operator>&gt;</operator> <name>top</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bits</name> <operator>&lt;</operator> <name>bottom</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>signed_step</name> <init>= <expr><ternary><condition><expr><name>bits</name> <operator>&gt;</operator> <name>top</name></expr> ?</condition><then> <expr><operator>+</operator><name>step</name></expr> </then><else>: <expr><operator>-</operator><name>step</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>quant</name> <operator>+</operator> <name>signed_step</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>q_ceil</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>count_hq_slice</name><argument_list>(<argument><expr><name>slice_dat</name></expr></argument>, <argument><expr><name>quant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quant_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>quant</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name><name>quant_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>quant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <ternary><condition><expr><name>quant</name> <operator>==</operator> <name><name>quant_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>bits_last</name></expr> </then><else>: <expr><name>bits</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>step</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>q_ceil</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quant_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>quant_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quant_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>quant</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits_last</name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>slice_dat</name><operator>-&gt;</operator><name>quant_idx</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>quant</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>q_ceil</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slice_dat</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <call><name>SSIZE_ROUND</name><argument_list>(<argument><expr><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>calc_slice_sizes</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>slice_x</name></decl>, <decl><type ref="prev"/><name>slice_y</name></decl>, <decl><type ref="prev"/><name>bytes_left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>bytes_top</name><index>[<expr><name>SLICE_REDIST_TOTAL</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>total_bytes_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_redist_range</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>SLICE_REDIST_TOTAL</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>enc_args</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>slice_args</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name><name>top_loc</name><index>[<expr><name>SLICE_REDIST_TOTAL</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_quant_matrix</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>slice_y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slice_y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>slice_y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>slice_x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slice_x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</condition> <incr><expr><name>slice_x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>&amp;</operator><name><name>enc_args</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name>slice_y</name> <operator>+</operator> <name>slice_x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>slice_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>slice_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits_ceil</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bits_floor</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>slice_min_bytes</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>q_ceil</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>args</name><operator>-&gt;</operator><name>cache</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>rate_control</name></expr></argument>, <argument><expr><name>enc_args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SliceArgs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>&amp;</operator><name><name>enc_args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_left</name> <operator>+=</operator> <name><name>args</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>slice_redist_range</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>bytes</name></name> <operator>&gt;</operator> <name><name>bytes_top</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bytes_top</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top_loc</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>frame_max_bytes</name></name> <operator>-</operator> <name>bytes_left</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>bytes_left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>distributed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>slice_redist_range</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>, <decl><type ref="prev"/><name>bytes</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>, <decl><type ref="prev"/><name>prev_bytes</name></decl>, <decl><type ref="prev"/><name>new_idx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_left</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>top_loc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>top_loc</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>quant_idx</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>top_loc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_bytes</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_idx</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>quant_idx</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>count_hq_slice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>new_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>SSIZE_ROUND</name><argument_list>(<argument><expr><name>bits</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>bytes</name> <operator>-</operator> <name>prev_bytes</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bytes_left</name> <operator>-</operator> <name>diff</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>quant_idx</name></name> <operator>=</operator> <name>new_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_left</name> <operator>-=</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>distributed</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distributed</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>&amp;</operator><name><name>enc_args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>total_bytes_needed</name> <operator>+=</operator> <name><name>args</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>q_avg</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>q_avg</name></name> <operator>+</operator> <name><name>args</name><operator>-&gt;</operator><name>quant_idx</name></name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>total_bytes_needed</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_hq_slice</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>slice_dat</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><operator>&amp;</operator><name><name>slice_dat</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>slice_x</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>slice_y</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>quant_idx</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>quant_idx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>slice_bytes_max</name> <init>= <expr><name><name>slice_dat</name><operator>-&gt;</operator><name>bytes</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>quants</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>orientation</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>put_bits_ptr</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_put_bytes</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>quant_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>quants</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>quant_idx</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bytes_start</name></decl>, <decl><type ref="prev"/><name>bytes_len</name></decl>, <decl><type ref="prev"/><name>pad_s</name></decl>, <decl><type ref="prev"/><name>pad_c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_start</name> <operator>=</operator> <call><name>put_bits_count</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>encode_subband</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>slice_x</name></expr></argument>, <argument><expr><name>slice_y</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>quants</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_len</name> <operator>=</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <name>bytes_start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len_diff</name> <init>= <expr><name>slice_bytes_max</name> <operator>-</operator> <operator>(</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pad_s</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><operator>(</operator><name>bytes_len</name> <operator>+</operator> <name>len_diff</name><operator>)</operator></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr></argument>)</argument_list></call><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pad_c</name> <operator>=</operator> <operator>(</operator><name>pad_s</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name><operator>)</operator> <operator>-</operator> <name>bytes_len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pad_s</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name>bytes_len</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr></argument>)</argument_list></call><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pad_c</name> <operator>=</operator> <operator>(</operator><name>pad_s</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name><operator>)</operator> <operator>-</operator> <name>bytes_len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>pb</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>bytes_start</name></expr>]</index></name> <operator>=</operator> <name>pad_s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>put_bits_ptr</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>pad_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_put_bytes</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pad_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_slices</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_x</name></decl>, <decl><type ref="prev"/><name>slice_y</name></decl>, <decl><type ref="prev"/><name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>enc_args</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>slice_args</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>avpriv_align_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>put_bits_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>slice_y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slice_y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>slice_y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>slice_x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slice_x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</condition> <incr><expr><name>slice_x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceArgs</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>&amp;</operator><name><name>enc_args</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name>slice_y</name> <operator>+</operator> <name>slice_x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>skip</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>bytes</name></name><operator>+</operator><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> <operator>+=</operator> <name><name>args</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>encode_hq_slice</name></expr></argument>, <argument><expr><name>enc_args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SliceArgs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>skip_put_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




































<function><type><specifier>static</specifier> <name>int</name></type> <name>dwt_plane</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>TransformArgs</name> <modifier>*</modifier></type><name>transform_dat</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>transform_dat</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>frame_data</name> <init>= <expr><name><name>transform_dat</name><operator>-&gt;</operator><name>idata</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>linesize</name> <init>= <expr><name><name>transform_dat</name><operator>-&gt;</operator><name>istride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>field</name> <init>= <expr><name><name>transform_dat</name><operator>-&gt;</operator><name>field</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>transform_dat</name><operator>-&gt;</operator><name>plane</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2TransformContext</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>&amp;</operator><name><name>transform_dat</name><operator>-&gt;</operator><name>t</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dwtcoef</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>coef_buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>skip</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>pix_stride</name> <init>= <expr><name>linesize</name> <operator>&gt;&gt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pix_stride</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>field</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>pix_stride</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pix_stride</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>pix</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>frame_data</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name><operator>*</operator><name>skip</name></expr>;</condition> <incr><expr><name>y</name><operator>+=</operator><name>skip</name></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>pix</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dwtcoef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pix</name> <operator>+=</operator> <name>pix_stride</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>pix</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator><name>frame_data</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name><operator>*</operator><name>skip</name></expr>;</condition> <incr><expr><name>y</name><operator>+=</operator><name>skip</name></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>pix</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dwtcoef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pix</name> <operator>+=</operator> <name>pix_stride</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>dwt_height</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dwtcoef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>level</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>level</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SubBand</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>vc2_subband_dwt</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name>t</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_buf</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name><operator>,</operator>
<name><name>b</name><operator>-&gt;</operator><name>width</name></name><operator>,</operator> <name><name>b</name><operator>-&gt;</operator><name>height</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_frame</name><parameter_list>(<parameter><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aux_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>header_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>max_frame_bytes</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ctx</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>field</name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plane</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idata</name> <operator>=</operator> <name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>istride</name> <operator>=</operator> <name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>dwt_plane</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>transform_args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransformArgs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>max_frame_bytes</name> <operator>=</operator> <name>header_size</name> <operator>+</operator> <call><name>calc_slice_sizes</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_alloc_packet2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>avpkt</name></expr></argument>,
<argument><expr><name>max_frame_bytes</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></argument>,
<argument><expr><name>max_frame_bytes</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error getting output packet.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>init_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>encode_parse_info</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>DIRAC_PCODE_SEQ_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_seq_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>aux_data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>encode_parse_info</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>DIRAC_PCODE_AUX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_put_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>aux_data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>encode_parse_info</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>DIRAC_PCODE_PICTURE_HQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>encode_picture_start</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>encode_slices</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>encode_parse_info</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>DIRAC_PCODE_END_SEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>vc2_encode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_packet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_ceil</name></decl>, <decl><type ref="prev"/><name>sig_size</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bitexact</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_BITEXACT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aux_data</name> <init>= <expr><ternary><condition><expr><name>bitexact</name></expr> ?</condition><then> <expr><literal type="string">"Lavc"</literal></expr> </then><else>: <expr><name>LIBAVCODEC_IDENT</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>aux_data_size</name> <init>= <expr><ternary><condition><expr><name>bitexact</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"Lavc"</literal></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>LIBAVCODEC_IDENT</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>header_size</name> <init>= <expr><literal type="number">100</literal> <operator>+</operator> <name>aux_data_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>r_bitrate</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prefix_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_parse_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next_parse_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_max_bytes</name></name> <operator>=</operator> <operator>(</operator><call><name>av_rescale</name><argument_list>(<argument><expr><name>r_bitrate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <name>header_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name> <operator>=</operator> <name>slice_ceil</name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_max_bytes</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><name>sig_size</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r_size</name> <init>= <expr><call><name>SSIZE_ROUND</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r_size</name> <operator>&gt;</operator> <name>slice_ceil</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name> <operator>-=</operator> <name>r_size</name> <operator>-</operator> <name>slice_ceil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r_size</name> <operator>=</operator> <call><name>SSIZE_ROUND</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sig_size</name> <operator>=</operator> <name>r_size</name><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size_scaler</name></name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_min_bytes</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name><operator>*</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>tolerance</name></name><operator>/</operator><literal type="number">100.0f</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>encode_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>avpkt</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>aux_data</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>encode_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>avpkt</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>aux_data</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>got_packet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>vc2_encode_end</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Qavg: %i\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>q_avg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_vc2enc_free_transforms</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>coef_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>slice_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>vc2_encode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>o</name></decl>, <decl><type ref="prev"/><name>shift</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>depth</name> <init>= <expr><name><name>fmt</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VC2EncContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>picture_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>q_ceil</name></name> <operator>=</operator> <name>DIRAC_MAX_QUANT_INDEX</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ver</name><operator>.</operator><name>major</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ver</name><operator>.</operator><name>minor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>q_avg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_max_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_min_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>=</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>field_order</name></name> <operator>==</operator> <name>AV_FIELD_UNKNOWN</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>field_order</name></name> <operator>==</operator> <name>AV_FIELD_PROGRESSIVE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>base_video_fmts_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VC2BaseVideoFormat</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><operator>&amp;</operator><name><name>base_video_fmts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>width</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>height</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name> <operator>!=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>base_video_fmts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>level</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Interlacing enabled!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_width</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_width</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_height</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_height</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Slice size is not a power of two!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_UNKNOWN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_width</name></name> <operator>&gt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>slice_height</name></name> <operator>&gt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Slice size is bigger than the image!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_UNKNOWN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>strict_std_compliance</name></name> <operator>&lt;</operator> <name>FF_COMPLIANCE_STRICT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strict_compliance</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Format does not strictly comply with VC2 specs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Given format does not strictly comply with "</literal>
<literal type="string">"the specifications, decrease strictness to use it.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_UNKNOWN</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Selected base video format = %i (%s)\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name></expr></argument>, <argument><expr><name><name>base_video_fmts</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>base_vf</name></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_pix_fmt_get_chroma_sub_sample</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>==</operator> <name>AVCOL_RANGE_JPEG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp_idx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>==</operator> <name>AVCOL_RANGE_MPEG</name> <operator>||</operator>
<name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>==</operator> <name>AVCOL_RANGE_UNSPECIFIED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp_idx</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp_idx</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bpp_idx</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diff_offset</name></name> <operator>=</operator> <literal type="number">2048</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interlaced</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dwt_width</name></name> <operator>=</operator> <name>w</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dwt_height</name></name> <operator>=</operator> <name>h</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dwt_width</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coef_buf</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>dwt_height</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>dwtcoef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>coef_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>alloc_fail</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>level</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>level</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>o</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>o</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stride</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <operator>(</operator><name>o</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>b</name><operator>-&gt;</operator><name>height</name></name><operator>*</operator><name><name>b</name><operator>-&gt;</operator><name>stride</name></name> <operator>+</operator> <operator>(</operator><name>o</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>b</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>coef_buf</name></name> <operator>+</operator> <name>shift</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><call><name>ff_vc2enc_init_transforms</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>transform_args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>t</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>coef_stride</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dwt_height</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>slice_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>slice_height</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>alloc_fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dwt_width</name><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>slice_width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dwt_height</name><operator>/</operator><name><name>s</name><operator>-&gt;</operator><name>slice_height</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_args</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SliceArgs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>slice_args</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>alloc_fail</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">116</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>qf</name> <init>= <expr><name><name>ff_dirac_qscale_tab</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>m</name> <init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><name>qf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>t</name> <init>= <expr><operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>m</name> <operator>+</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>qf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>t</name><operator>*</operator><name>qf</name> <operator>+</operator> <name>qf</name><operator>)</operator> <operator>&amp;</operator> <name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>qf</name> <operator>&amp;</operator> <operator>(</operator><name>qf</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>m</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmagic_lut</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>alloc_fail</name>:</label>
<expr_stmt><expr><call><name>vc2_encode_end</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unable to allocate memory!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VC2ENC_FLAGS</name></cpp:macro> <cpp:value>(AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>vc2enc_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"tolerance"</literal></expr>, <expr><literal type="string">"Max undershoot in percent"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>tolerance</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_DOUBLE</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name> <operator>=</operator> <literal type="number">5.0f</literal></expr>}</block></expr>, <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">45.0f</literal></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"tolerance"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"slice_width"</literal></expr>, <expr><literal type="string">"Slice width"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>slice_width</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">32</literal></expr>}</block></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"slice_width"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"slice_height"</literal></expr>, <expr><literal type="string">"Slice height"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>slice_height</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">16</literal></expr>}</block></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"slice_height"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"wavelet_depth"</literal></expr>, <expr><literal type="string">"Transform depth"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>wavelet_depth</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">4</literal></expr>}</block></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_depth"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"wavelet_type"</literal></expr>, <expr><literal type="string">"Transform type"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>wavelet_idx</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_TRANSFORM_9_7</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>VC2_TRANSFORMS_NB</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_idx"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"9_7"</literal></expr>, <expr><literal type="string">"Deslauriers-Dubuc (9,7)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_TRANSFORM_9_7</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_idx"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"5_3"</literal></expr>, <expr><literal type="string">"LeGall (5,3)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_TRANSFORM_5_3</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_idx"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"haar"</literal></expr>, <expr><literal type="string">"Haar (with shift)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_TRANSFORM_HAAR_S</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_idx"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"haar_noshift"</literal></expr>, <expr><literal type="string">"Haar (without shift)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_TRANSFORM_HAAR</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"wavelet_idx"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"qm"</literal></expr>, <expr><literal type="string">"Custom quantization matrix"</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>, <argument><expr><name>quant_matrix</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_QM_DEF</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>VC2_QM_NB</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"quant_matrix"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"default"</literal></expr>, <expr><literal type="string">"Default from the specifications"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_QM_DEF</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"quant_matrix"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"color"</literal></expr>, <expr><literal type="string">"Prevents low bitrate discoloration"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_QM_COL</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"quant_matrix"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"flat"</literal></expr>, <expr><literal type="string">"Optimize for PSNR"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>VC2_QM_FLAT</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VC2ENC_FLAGS</name></expr>, <expr><literal type="string">"quant_matrix"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>vc2enc_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"SMPTE VC-2 encoder"</literal></expr>,
<expr><operator>.</operator><name>category</name> <operator>=</operator> <name>AV_CLASS_CATEGORY_ENCODER</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>vc2enc_options</name></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVCodecDefault</name></type> <name><name>vc2enc_defaults</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">"600000000"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>allowed_pix_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><name>AV_PIX_FMT_YUV422P</name></expr>, <expr><name>AV_PIX_FMT_YUV444P</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P10</name></expr>, <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><name>AV_PIX_FMT_YUV444P10</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P12</name></expr>, <expr><name>AV_PIX_FMT_YUV422P12</name></expr>, <expr><name>AV_PIX_FMT_YUV444P12</name></expr>,
<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_vc2_encoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"vc2"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"SMPTE VC-2"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_DIRAC</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VC2EncContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>vc2_encode_init</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>vc2_encode_end</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_SLICE_THREADS</name></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name></expr>,
<expr><operator>.</operator><name>encode2</name> <operator>=</operator> <name>vc2_encode_frame</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>vc2enc_class</name></expr>,
<expr><operator>.</operator><name>defaults</name> <operator>=</operator> <name>vc2enc_defaults</name></expr>,
<expr><operator>.</operator><name>pix_fmts</name> <operator>=</operator> <name>allowed_pix_fmts</name></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
