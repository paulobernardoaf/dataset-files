<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\mips\sbrdsp_mips.c">























































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/sbrdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mips/asmdefs.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_qmf_pre_shuffle_mips</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>Temp1</name></decl>, <decl><type ref="prev"/><name>Temp2</name></decl>, <decl><type ref="prev"/><name>Temp3</name></decl>, <decl><type ref="prev"/><name>Temp4</name></decl>, <decl><type ref="prev"/><name>Temp5</name></decl>, <decl><type ref="prev"/><name>Temp6</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z1</name> <init>= <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">66</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">59</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z3</name> <init>= <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z4</name> <init>= <expr><name>z1</name> <operator>+</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>


<asm>__asm__ <specifier>volatile</specifier> (
"lui %[Temp6], 0x8000 \n\t"
"1: \n\t"
"lw %[Temp1], 0(%[z2]) \n\t"
"lw %[Temp2], 4(%[z2]) \n\t"
"lw %[Temp3], 8(%[z2]) \n\t"
"lw %[Temp4], 12(%[z2]) \n\t"
"lw %[Temp5], 16(%[z2]) \n\t"
"xor %[Temp1], %[Temp1], %[Temp6] \n\t"
"xor %[Temp2], %[Temp2], %[Temp6] \n\t"
"xor %[Temp3], %[Temp3], %[Temp6] \n\t"
"xor %[Temp4], %[Temp4], %[Temp6] \n\t"
"xor %[Temp5], %[Temp5], %[Temp6] \n\t"
PTR_ADDIU "%[z2], %[z2], -20 \n\t"
"sw %[Temp1], 32(%[z1]) \n\t"
"sw %[Temp2], 24(%[z1]) \n\t"
"sw %[Temp3], 16(%[z1]) \n\t"
"sw %[Temp4], 8(%[z1]) \n\t"
"sw %[Temp5], 0(%[z1]) \n\t"
"lw %[Temp1], 0(%[z3]) \n\t"
"lw %[Temp2], 4(%[z3]) \n\t"
"lw %[Temp3], 8(%[z3]) \n\t"
"lw %[Temp4], 12(%[z3]) \n\t"
"lw %[Temp5], 16(%[z3]) \n\t"
"sw %[Temp1], 4(%[z1]) \n\t"
"sw %[Temp2], 12(%[z1]) \n\t"
"sw %[Temp3], 20(%[z1]) \n\t"
"sw %[Temp4], 28(%[z1]) \n\t"
"sw %[Temp5], 36(%[z1]) \n\t"
PTR_ADDIU "%[z3], %[z3], 20 \n\t"
PTR_ADDIU "%[z1], %[z1], 40 \n\t"
"bne %[z1], %[z4], 1b \n\t"
"lw %[Temp1], 132(%[z]) \n\t"
"lw %[Temp2], 128(%[z]) \n\t"
"lw %[Temp3], 0(%[z]) \n\t"
"lw %[Temp4], 4(%[z]) \n\t"
"xor %[Temp1], %[Temp1], %[Temp6] \n\t"
"sw %[Temp1], 504(%[z]) \n\t"
"sw %[Temp2], 508(%[z]) \n\t"
"sw %[Temp3], 256(%[z]) \n\t"
"sw %[Temp4], 260(%[z]) \n\t"

: [Temp1]"=&amp;r"(Temp1), [Temp2]"=&amp;r"(Temp2),
[Temp3]"=&amp;r"(Temp3), [Temp4]"=&amp;r"(Temp4),
[Temp5]"=&amp;r"(Temp5), [Temp6]"=&amp;r"(Temp6),
[z1]"+r"(z1), [z2]"+r"(z2), [z3]"+r"(z3)
: [z4]"r"(z4), [z]"r"(z)
: "memory"
);</asm>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_qmf_post_shuffle_mips</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name><name>W</name><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>Temp1</name></decl>, <decl><type ref="prev"/><name>Temp2</name></decl>, <decl><type ref="prev"/><name>Temp3</name></decl>, <decl><type ref="prev"/><name>Temp4</name></decl>, <decl><type ref="prev"/><name>Temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>W_ptr</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>W</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z1</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>z</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z_end</name> <init>= <expr><name>z1</name> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>


<asm>__asm__ <specifier>volatile</specifier> (
"lui %[Temp5], 0x8000 \n\t"
"1: \n\t"
"lw %[Temp1], 0(%[z2]) \n\t"
"lw %[Temp2], 4(%[z2]) \n\t"
"lw %[Temp3], 8(%[z2]) \n\t"
"lw %[Temp4], 12(%[z2]) \n\t"
"xor %[Temp1], %[Temp1], %[Temp5] \n\t"
"xor %[Temp2], %[Temp2], %[Temp5] \n\t"
"xor %[Temp3], %[Temp3], %[Temp5] \n\t"
"xor %[Temp4], %[Temp4], %[Temp5] \n\t"
PTR_ADDIU "%[z2], %[z2], -16 \n\t"
"sw %[Temp1], 24(%[W_ptr]) \n\t"
"sw %[Temp2], 16(%[W_ptr]) \n\t"
"sw %[Temp3], 8(%[W_ptr]) \n\t"
"sw %[Temp4], 0(%[W_ptr]) \n\t"
"lw %[Temp1], 0(%[z1]) \n\t"
"lw %[Temp2], 4(%[z1]) \n\t"
"lw %[Temp3], 8(%[z1]) \n\t"
"lw %[Temp4], 12(%[z1]) \n\t"
"sw %[Temp1], 4(%[W_ptr]) \n\t"
"sw %[Temp2], 12(%[W_ptr]) \n\t"
"sw %[Temp3], 20(%[W_ptr]) \n\t"
"sw %[Temp4], 28(%[W_ptr]) \n\t"
PTR_ADDIU "%[z1], %[z1], 16 \n\t"
PTR_ADDIU "%[W_ptr],%[W_ptr], 32 \n\t"
"bne %[z1], %[z_end], 1b \n\t"

: [Temp1]"=&amp;r"(Temp1), [Temp2]"=&amp;r"(Temp2),
[Temp3]"=&amp;r"(Temp3), [Temp4]"=&amp;r"(Temp4),
[Temp5]"=&amp;r"(Temp5), [z1]"+r"(z1),
[z2]"+r"(z2), [W_ptr]"+r"(W_ptr)
: [z_end]"r"(z_end)
: "memory"
);</asm>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_sum64x5_mips</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>f1</name></decl>, <decl><type ref="prev"/><name>f2</name></decl>, <decl><type ref="prev"/><name>f3</name></decl>, <decl><type ref="prev"/><name>f4</name></decl>, <decl><type ref="prev"/><name>f5</name></decl>, <decl><type ref="prev"/><name>f6</name></decl>, <decl><type ref="prev"/><name>f7</name></decl>, <decl><type ref="prev"/><name>f8</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>k</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>z1</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>


<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 $f0, 0(%[z1]) \n\t"
"lwc1 $f1, 256(%[z1]) \n\t"
"lwc1 $f2, 4(%[z1]) \n\t"
"lwc1 $f3, 260(%[z1]) \n\t"
"lwc1 $f4, 8(%[z1]) \n\t"
"add.s %[f1], $f0, $f1 \n\t"
"lwc1 $f5, 264(%[z1]) \n\t"
"add.s %[f2], $f2, $f3 \n\t"
"lwc1 $f6, 12(%[z1]) \n\t"
"lwc1 $f7, 268(%[z1]) \n\t"
"add.s %[f3], $f4, $f5 \n\t"
"lwc1 $f8, 16(%[z1]) \n\t"
"lwc1 $f9, 272(%[z1]) \n\t"
"add.s %[f4], $f6, $f7 \n\t"
"lwc1 $f10, 20(%[z1]) \n\t"
"lwc1 $f11, 276(%[z1]) \n\t"
"add.s %[f5], $f8, $f9 \n\t"
"lwc1 $f12, 24(%[z1]) \n\t"
"lwc1 $f13, 280(%[z1]) \n\t"
"add.s %[f6], $f10, $f11 \n\t"
"lwc1 $f14, 28(%[z1]) \n\t"
"lwc1 $f15, 284(%[z1]) \n\t"
"add.s %[f7], $f12, $f13 \n\t"
"lwc1 $f0, 512(%[z1]) \n\t"
"lwc1 $f1, 516(%[z1]) \n\t"
"add.s %[f8], $f14, $f15 \n\t"
"lwc1 $f2, 520(%[z1]) \n\t"
"add.s %[f1], %[f1], $f0 \n\t"
"add.s %[f2], %[f2], $f1 \n\t"
"lwc1 $f3, 524(%[z1]) \n\t"
"add.s %[f3], %[f3], $f2 \n\t"
"lwc1 $f4, 528(%[z1]) \n\t"
"lwc1 $f5, 532(%[z1]) \n\t"
"add.s %[f4], %[f4], $f3 \n\t"
"lwc1 $f6, 536(%[z1]) \n\t"
"add.s %[f5], %[f5], $f4 \n\t"
"add.s %[f6], %[f6], $f5 \n\t"
"lwc1 $f7, 540(%[z1]) \n\t"
"add.s %[f7], %[f7], $f6 \n\t"
"lwc1 $f0, 768(%[z1]) \n\t"
"lwc1 $f1, 772(%[z1]) \n\t"
"add.s %[f8], %[f8], $f7 \n\t"
"lwc1 $f2, 776(%[z1]) \n\t"
"add.s %[f1], %[f1], $f0 \n\t"
"add.s %[f2], %[f2], $f1 \n\t"
"lwc1 $f3, 780(%[z1]) \n\t"
"add.s %[f3], %[f3], $f2 \n\t"
"lwc1 $f4, 784(%[z1]) \n\t"
"lwc1 $f5, 788(%[z1]) \n\t"
"add.s %[f4], %[f4], $f3 \n\t"
"lwc1 $f6, 792(%[z1]) \n\t"
"add.s %[f5], %[f5], $f4 \n\t"
"add.s %[f6], %[f6], $f5 \n\t"
"lwc1 $f7, 796(%[z1]) \n\t"
"add.s %[f7], %[f7], $f6 \n\t"
"lwc1 $f0, 1024(%[z1]) \n\t"
"lwc1 $f1, 1028(%[z1]) \n\t"
"add.s %[f8], %[f8], $f7 \n\t"
"lwc1 $f2, 1032(%[z1]) \n\t"
"add.s %[f1], %[f1], $f0 \n\t"
"add.s %[f2], %[f2], $f1 \n\t"
"lwc1 $f3, 1036(%[z1]) \n\t"
"add.s %[f3], %[f3], $f2 \n\t"
"lwc1 $f4, 1040(%[z1]) \n\t"
"lwc1 $f5, 1044(%[z1]) \n\t"
"add.s %[f4], %[f4], $f3 \n\t"
"lwc1 $f6, 1048(%[z1]) \n\t"
"add.s %[f5], %[f5], $f4 \n\t"
"add.s %[f6], %[f6], $f5 \n\t"
"lwc1 $f7, 1052(%[z1]) \n\t"
"add.s %[f7], %[f7], $f6 \n\t"
"swc1 %[f1], 0(%[z1]) \n\t"
"swc1 %[f2], 4(%[z1]) \n\t"
"add.s %[f8], %[f8], $f7 \n\t"
"swc1 %[f3], 8(%[z1]) \n\t"
"swc1 %[f4], 12(%[z1]) \n\t"
"swc1 %[f5], 16(%[z1]) \n\t"
"swc1 %[f6], 20(%[z1]) \n\t"
"swc1 %[f7], 24(%[z1]) \n\t"
"swc1 %[f8], 28(%[z1]) \n\t"

: [f1]"=&amp;f"(f1), [f2]"=&amp;f"(f2), [f3]"=&amp;f"(f3),
[f4]"=&amp;f"(f4), [f5]"=&amp;f"(f5), [f6]"=&amp;f"(f6),
[f7]"=&amp;f"(f7), [f8]"=&amp;f"(f8)
: [z1]"r"(z1)
: "$f0", "$f1", "$f2", "$f3", "$f4", "$f5",
"$f6", "$f7", "$f8", "$f9", "$f10", "$f11",
"$f12", "$f13", "$f14", "$f15",
"memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>sbr_sum_square_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><name>int</name> <name>n</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>sum0</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>, <decl><type ref="prev"/><name>sum1</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>loop_end</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p_x</name> <operator>=</operator> <operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>loop_end</name> <operator>=</operator> <name>p_x</name> <operator>+</operator> <operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
".set push \n\t"
".set noreorder \n\t"
"lwc1 %[temp0], 0(%[p_x]) \n\t"
"lwc1 %[temp1], 4(%[p_x]) \n\t"
"lwc1 %[temp2], 8(%[p_x]) \n\t"
"lwc1 %[temp3], 12(%[p_x]) \n\t"
"1: \n\t"
PTR_ADDIU "%[p_x], %[p_x], 16 \n\t"
"madd.s %[sum0], %[sum0], %[temp0], %[temp0] \n\t"
"lwc1 %[temp0], 0(%[p_x]) \n\t"
"madd.s %[sum1], %[sum1], %[temp1], %[temp1] \n\t"
"lwc1 %[temp1], 4(%[p_x]) \n\t"
"madd.s %[sum0], %[sum0], %[temp2], %[temp2] \n\t"
"lwc1 %[temp2], 8(%[p_x]) \n\t"
"madd.s %[sum1], %[sum1], %[temp3], %[temp3] \n\t"
"bne %[p_x], %[loop_end], 1b \n\t"
" lwc1 %[temp3], 12(%[p_x]) \n\t"
"madd.s %[sum0], %[sum0], %[temp0], %[temp0] \n\t"
"madd.s %[sum1], %[sum1], %[temp1], %[temp1] \n\t"
"madd.s %[sum0], %[sum0], %[temp2], %[temp2] \n\t"
"madd.s %[sum1], %[sum1], %[temp3], %[temp3] \n\t"
".set pop \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [sum0]"+f"(sum0), [sum1]"+f"(sum1),
[p_x]"+r"(p_x)
: [loop_end]"r"(loop_end)
: "memory"
);</asm>
<return>return <expr><name>sum0</name> <operator>+</operator> <name>sum1</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_qmf_deint_bfly_mips</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>src0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>src1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp6</name></decl>, <decl><type ref="prev"/><name>temp7</name></decl>, <decl><type ref="prev"/><name>temp8</name></decl>, <decl><type ref="prev"/><name>temp9</name></decl>, <decl><type ref="prev"/><name>temp10</name></decl>, <decl><type ref="prev"/><name>temp11</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>v0</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><index>[<expr><literal type="number">127</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>psrc0</name> <init>= <expr><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><name>src0</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>psrc1</name> <init>= <expr><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>src1</name><index>[<expr><literal type="number">63</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[temp0], 0(%[src0]) \n\t"
"lwc1 %[temp1], 0(%[src1]) \n\t"
"lwc1 %[temp3], 4(%[src0]) \n\t"
"lwc1 %[temp4], -4(%[src1]) \n\t"
"lwc1 %[temp6], 8(%[src0]) \n\t"
"lwc1 %[temp7], -8(%[src1]) \n\t"
"lwc1 %[temp9], 12(%[src0]) \n\t"
"lwc1 %[temp10], -12(%[src1]) \n\t"
"add.s %[temp2], %[temp0], %[temp1] \n\t"
"add.s %[temp5], %[temp3], %[temp4] \n\t"
"add.s %[temp8], %[temp6], %[temp7] \n\t"
"add.s %[temp11], %[temp9], %[temp10] \n\t"
"sub.s %[temp0], %[temp0], %[temp1] \n\t"
"sub.s %[temp3], %[temp3], %[temp4] \n\t"
"sub.s %[temp6], %[temp6], %[temp7] \n\t"
"sub.s %[temp9], %[temp9], %[temp10] \n\t"
"swc1 %[temp2], 0(%[v1]) \n\t"
"swc1 %[temp0], 0(%[v0]) \n\t"
"swc1 %[temp5], -4(%[v1]) \n\t"
"swc1 %[temp3], 4(%[v0]) \n\t"
"swc1 %[temp8], -8(%[v1]) \n\t"
"swc1 %[temp6], 8(%[v0]) \n\t"
"swc1 %[temp11], -12(%[v1]) \n\t"
"swc1 %[temp9], 12(%[v0]) \n\t"
"lwc1 %[temp0], 16(%[src0]) \n\t"
"lwc1 %[temp1], -16(%[src1]) \n\t"
"lwc1 %[temp3], 20(%[src0]) \n\t"
"lwc1 %[temp4], -20(%[src1]) \n\t"
"lwc1 %[temp6], 24(%[src0]) \n\t"
"lwc1 %[temp7], -24(%[src1]) \n\t"
"lwc1 %[temp9], 28(%[src0]) \n\t"
"lwc1 %[temp10], -28(%[src1]) \n\t"
"add.s %[temp2], %[temp0], %[temp1] \n\t"
"add.s %[temp5], %[temp3], %[temp4] \n\t"
"add.s %[temp8], %[temp6], %[temp7] \n\t"
"add.s %[temp11], %[temp9], %[temp10] \n\t"
"sub.s %[temp0], %[temp0], %[temp1] \n\t"
"sub.s %[temp3], %[temp3], %[temp4] \n\t"
"sub.s %[temp6], %[temp6], %[temp7] \n\t"
"sub.s %[temp9], %[temp9], %[temp10] \n\t"
"swc1 %[temp2], -16(%[v1]) \n\t"
"swc1 %[temp0], 16(%[v0]) \n\t"
"swc1 %[temp5], -20(%[v1]) \n\t"
"swc1 %[temp3], 20(%[v0]) \n\t"
"swc1 %[temp8], -24(%[v1]) \n\t"
"swc1 %[temp6], 24(%[v0]) \n\t"
"swc1 %[temp11], -28(%[v1]) \n\t"
"swc1 %[temp9], 28(%[v0]) \n\t"
"lwc1 %[temp0], 32(%[src0]) \n\t"
"lwc1 %[temp1], -32(%[src1]) \n\t"
"lwc1 %[temp3], 36(%[src0]) \n\t"
"lwc1 %[temp4], -36(%[src1]) \n\t"
"lwc1 %[temp6], 40(%[src0]) \n\t"
"lwc1 %[temp7], -40(%[src1]) \n\t"
"lwc1 %[temp9], 44(%[src0]) \n\t"
"lwc1 %[temp10], -44(%[src1]) \n\t"
"add.s %[temp2], %[temp0], %[temp1] \n\t"
"add.s %[temp5], %[temp3], %[temp4] \n\t"
"add.s %[temp8], %[temp6], %[temp7] \n\t"
"add.s %[temp11], %[temp9], %[temp10] \n\t"
"sub.s %[temp0], %[temp0], %[temp1] \n\t"
"sub.s %[temp3], %[temp3], %[temp4] \n\t"
"sub.s %[temp6], %[temp6], %[temp7] \n\t"
"sub.s %[temp9], %[temp9], %[temp10] \n\t"
"swc1 %[temp2], -32(%[v1]) \n\t"
"swc1 %[temp0], 32(%[v0]) \n\t"
"swc1 %[temp5], -36(%[v1]) \n\t"
"swc1 %[temp3], 36(%[v0]) \n\t"
"swc1 %[temp8], -40(%[v1]) \n\t"
"swc1 %[temp6], 40(%[v0]) \n\t"
"swc1 %[temp11], -44(%[v1]) \n\t"
"swc1 %[temp9], 44(%[v0]) \n\t"
"lwc1 %[temp0], 48(%[src0]) \n\t"
"lwc1 %[temp1], -48(%[src1]) \n\t"
"lwc1 %[temp3], 52(%[src0]) \n\t"
"lwc1 %[temp4], -52(%[src1]) \n\t"
"lwc1 %[temp6], 56(%[src0]) \n\t"
"lwc1 %[temp7], -56(%[src1]) \n\t"
"lwc1 %[temp9], 60(%[src0]) \n\t"
"lwc1 %[temp10], -60(%[src1]) \n\t"
"add.s %[temp2], %[temp0], %[temp1] \n\t"
"add.s %[temp5], %[temp3], %[temp4] \n\t"
"add.s %[temp8], %[temp6], %[temp7] \n\t"
"add.s %[temp11], %[temp9], %[temp10] \n\t"
"sub.s %[temp0], %[temp0], %[temp1] \n\t"
"sub.s %[temp3], %[temp3], %[temp4] \n\t"
"sub.s %[temp6], %[temp6], %[temp7] \n\t"
"sub.s %[temp9], %[temp9], %[temp10] \n\t"
"swc1 %[temp2], -48(%[v1]) \n\t"
"swc1 %[temp0], 48(%[v0]) \n\t"
"swc1 %[temp5], -52(%[v1]) \n\t"
"swc1 %[temp3], 52(%[v0]) \n\t"
"swc1 %[temp8], -56(%[v1]) \n\t"
"swc1 %[temp6], 56(%[v0]) \n\t"
"swc1 %[temp11], -60(%[v1]) \n\t"
"swc1 %[temp9], 60(%[v0]) \n\t"
PTR_ADDIU " %[src0], %[src0], 64 \n\t"
PTR_ADDIU " %[src1], %[src1], -64 \n\t"
PTR_ADDIU " %[v0], %[v0], 64 \n\t"
PTR_ADDIU " %[v1], %[v1], -64 \n\t"

: [v0]"+r"(v0), [v1]"+r"(v1), [src0]"+r"(psrc0), [src1]"+r"(psrc1),
[temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[temp6]"=&amp;f"(temp6), [temp7]"=&amp;f"(temp7), [temp8]"=&amp;f"(temp8),
[temp9]"=&amp;f"(temp9), [temp10]"=&amp;f"(temp10), [temp11]"=&amp;f"(temp11)
:
:"memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_autocorrelate_mips</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>x</name><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name><name>phi</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>real_sum_0</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>real_sum_1</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>real_sum_2</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>imag_sum_1</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>imag_sum_2</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_phi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>, <decl><type ref="prev"/><name>temp6</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp7</name></decl>, <decl><type ref="prev"/><name>temp_r</name></decl>, <decl><type ref="prev"/><name>temp_r1</name></decl>, <decl><type ref="prev"/><name>temp_r2</name></decl>, <decl><type ref="prev"/><name>temp_r3</name></decl>, <decl><type ref="prev"/><name>temp_r4</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p_x</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_phi</name> <operator>=</operator> <operator>&amp;</operator><name><name>phi</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp0], 8(%[p_x]) \n\t"
"lwc1 %[temp1], 12(%[p_x]) \n\t"
"lwc1 %[temp2], 16(%[p_x]) \n\t"
"lwc1 %[temp3], 20(%[p_x]) \n\t"
"lwc1 %[temp4], 24(%[p_x]) \n\t"
"lwc1 %[temp5], 28(%[p_x]) \n\t"
"mul.s %[temp_r], %[temp1], %[temp1] \n\t"
"mul.s %[temp_r1], %[temp1], %[temp3] \n\t"
"mul.s %[temp_r2], %[temp1], %[temp2] \n\t"
"mul.s %[temp_r3], %[temp1], %[temp5] \n\t"
"mul.s %[temp_r4], %[temp1], %[temp4] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp0], %[temp0] \n\t"
"madd.s %[temp_r1], %[temp_r1], %[temp0], %[temp2] \n\t"
"msub.s %[temp_r2], %[temp_r2], %[temp0], %[temp3] \n\t"
"madd.s %[temp_r3], %[temp_r3], %[temp0], %[temp4] \n\t"
"msub.s %[temp_r4], %[temp_r4], %[temp0], %[temp5] \n\t"
"add.s %[real_sum_0], %[real_sum_0], %[temp_r] \n\t"
"add.s %[real_sum_1], %[real_sum_1], %[temp_r1] \n\t"
"add.s %[imag_sum_1], %[imag_sum_1], %[temp_r2] \n\t"
"add.s %[real_sum_2], %[real_sum_2], %[temp_r3] \n\t"
"add.s %[imag_sum_2], %[imag_sum_2], %[temp_r4] \n\t"
PTR_ADDIU "%[p_x], %[p_x], 8 \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[real_sum_0]"+f"(real_sum_0), [real_sum_1]"+f"(real_sum_1),
[imag_sum_1]"+f"(imag_sum_1), [real_sum_2]"+f"(real_sum_2),
[temp_r]"=&amp;f"(temp_r), [temp_r1]"=&amp;f"(temp_r1), [temp_r2]"=&amp;f"(temp_r2),
[temp_r3]"=&amp;f"(temp_r3), [temp_r4]"=&amp;f"(temp_r4),
[p_x]"+r"(p_x), [imag_sum_2]"+f"(imag_sum_2)
:
: "memory"
);</asm>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp0], 8(%[p_x]) \n\t"
"lwc1 %[temp1], 12(%[p_x]) \n\t"
"lwc1 %[temp2], 16(%[p_x]) \n\t"
"lwc1 %[temp3], 20(%[p_x]) \n\t"
"lwc1 %[temp4], 24(%[p_x]) \n\t"
"lwc1 %[temp5], 28(%[p_x]) \n\t"
"mul.s %[temp_r], %[temp1], %[temp1] \n\t"
"mul.s %[temp_r1], %[temp1], %[temp3] \n\t"
"mul.s %[temp_r2], %[temp1], %[temp2] \n\t"
"mul.s %[temp_r3], %[temp1], %[temp5] \n\t"
"mul.s %[temp_r4], %[temp1], %[temp4] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp0], %[temp0] \n\t"
"madd.s %[temp_r1], %[temp_r1], %[temp0], %[temp2] \n\t"
"msub.s %[temp_r2], %[temp_r2], %[temp0], %[temp3] \n\t"
"madd.s %[temp_r3], %[temp_r3], %[temp0], %[temp4] \n\t"
"msub.s %[temp_r4], %[temp_r4], %[temp0], %[temp5] \n\t"
"add.s %[real_sum_0], %[real_sum_0], %[temp_r] \n\t"
"add.s %[real_sum_1], %[real_sum_1], %[temp_r1] \n\t"
"add.s %[imag_sum_1], %[imag_sum_1], %[temp_r2] \n\t"
"add.s %[real_sum_2], %[real_sum_2], %[temp_r3] \n\t"
"add.s %[imag_sum_2], %[imag_sum_2], %[temp_r4] \n\t"
"lwc1 %[temp0], 32(%[p_x]) \n\t"
"lwc1 %[temp1], 36(%[p_x]) \n\t"
"mul.s %[temp_r], %[temp3], %[temp3] \n\t"
"mul.s %[temp_r1], %[temp3], %[temp5] \n\t"
"mul.s %[temp_r2], %[temp3], %[temp4] \n\t"
"mul.s %[temp_r3], %[temp3], %[temp1] \n\t"
"mul.s %[temp_r4], %[temp3], %[temp0] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp2], %[temp2] \n\t"
"madd.s %[temp_r1], %[temp_r1], %[temp2], %[temp4] \n\t"
"msub.s %[temp_r2], %[temp_r2], %[temp2], %[temp5] \n\t"
"madd.s %[temp_r3], %[temp_r3], %[temp2], %[temp0] \n\t"
"msub.s %[temp_r4], %[temp_r4], %[temp2], %[temp1] \n\t"
"add.s %[real_sum_0], %[real_sum_0], %[temp_r] \n\t"
"add.s %[real_sum_1], %[real_sum_1], %[temp_r1] \n\t"
"add.s %[imag_sum_1], %[imag_sum_1], %[temp_r2] \n\t"
"add.s %[real_sum_2], %[real_sum_2], %[temp_r3] \n\t"
"add.s %[imag_sum_2], %[imag_sum_2], %[temp_r4] \n\t"
"lwc1 %[temp2], 40(%[p_x]) \n\t"
"lwc1 %[temp3], 44(%[p_x]) \n\t"
"mul.s %[temp_r], %[temp5], %[temp5] \n\t"
"mul.s %[temp_r1], %[temp5], %[temp1] \n\t"
"mul.s %[temp_r2], %[temp5], %[temp0] \n\t"
"mul.s %[temp_r3], %[temp5], %[temp3] \n\t"
"mul.s %[temp_r4], %[temp5], %[temp2] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp4], %[temp4] \n\t"
"madd.s %[temp_r1], %[temp_r1], %[temp4], %[temp0] \n\t"
"msub.s %[temp_r2], %[temp_r2], %[temp4], %[temp1] \n\t"
"madd.s %[temp_r3], %[temp_r3], %[temp4], %[temp2] \n\t"
"msub.s %[temp_r4], %[temp_r4], %[temp4], %[temp3] \n\t"
"add.s %[real_sum_0], %[real_sum_0], %[temp_r] \n\t"
"add.s %[real_sum_1], %[real_sum_1], %[temp_r1] \n\t"
"add.s %[imag_sum_1], %[imag_sum_1], %[temp_r2] \n\t"
"add.s %[real_sum_2], %[real_sum_2], %[temp_r3] \n\t"
"add.s %[imag_sum_2], %[imag_sum_2], %[temp_r4] \n\t"
PTR_ADDIU "%[p_x], %[p_x], 24 \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[real_sum_0]"+f"(real_sum_0), [real_sum_1]"+f"(real_sum_1),
[imag_sum_1]"+f"(imag_sum_1), [real_sum_2]"+f"(real_sum_2),
[temp_r]"=&amp;f"(temp_r), [temp_r1]"=&amp;f"(temp_r1),
[temp_r2]"=&amp;f"(temp_r2), [temp_r3]"=&amp;f"(temp_r3),
[temp_r4]"=&amp;f"(temp_r4), [p_x]"+r"(p_x),
[imag_sum_2]"+f"(imag_sum_2)
:
: "memory"
);</asm>
</block_content>}</block></for>
<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp0], -296(%[p_x]) \n\t"
"lwc1 %[temp1], -292(%[p_x]) \n\t"
"lwc1 %[temp2], 8(%[p_x]) \n\t"
"lwc1 %[temp3], 12(%[p_x]) \n\t"
"lwc1 %[temp4], -288(%[p_x]) \n\t"
"lwc1 %[temp5], -284(%[p_x]) \n\t"
"lwc1 %[temp6], -280(%[p_x]) \n\t"
"lwc1 %[temp7], -276(%[p_x]) \n\t"
"madd.s %[temp_r], %[real_sum_0], %[temp0], %[temp0] \n\t"
"madd.s %[temp_r1], %[real_sum_0], %[temp2], %[temp2] \n\t"
"madd.s %[temp_r2], %[real_sum_1], %[temp0], %[temp4] \n\t"
"madd.s %[temp_r3], %[imag_sum_1], %[temp0], %[temp5] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp1], %[temp1] \n\t"
"madd.s %[temp_r1], %[temp_r1], %[temp3], %[temp3] \n\t"
"madd.s %[temp_r2], %[temp_r2], %[temp1], %[temp5] \n\t"
"nmsub.s %[temp_r3], %[temp_r3], %[temp1], %[temp4] \n\t"
"lwc1 %[temp4], 16(%[p_x]) \n\t"
"lwc1 %[temp5], 20(%[p_x]) \n\t"
"swc1 %[temp_r], 40(%[p_phi]) \n\t"
"swc1 %[temp_r1], 16(%[p_phi]) \n\t"
"swc1 %[temp_r2], 24(%[p_phi]) \n\t"
"swc1 %[temp_r3], 28(%[p_phi]) \n\t"
"madd.s %[temp_r], %[real_sum_1], %[temp2], %[temp4] \n\t"
"madd.s %[temp_r1], %[imag_sum_1], %[temp2], %[temp5] \n\t"
"madd.s %[temp_r2], %[real_sum_2], %[temp0], %[temp6] \n\t"
"madd.s %[temp_r3], %[imag_sum_2], %[temp0], %[temp7] \n\t"
"madd.s %[temp_r], %[temp_r], %[temp3], %[temp5] \n\t"
"nmsub.s %[temp_r1], %[temp_r1], %[temp3], %[temp4] \n\t"
"madd.s %[temp_r2], %[temp_r2], %[temp1], %[temp7] \n\t"
"nmsub.s %[temp_r3], %[temp_r3], %[temp1], %[temp6] \n\t"
"swc1 %[temp_r], 0(%[p_phi]) \n\t"
"swc1 %[temp_r1], 4(%[p_phi]) \n\t"
"swc1 %[temp_r2], 8(%[p_phi]) \n\t"
"swc1 %[temp_r3], 12(%[p_phi]) \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[temp6]"=&amp;f"(temp6), [temp7]"=&amp;f"(temp7), [temp_r]"=&amp;f"(temp_r),
[real_sum_0]"+f"(real_sum_0), [real_sum_1]"+f"(real_sum_1),
[real_sum_2]"+f"(real_sum_2), [imag_sum_1]"+f"(imag_sum_1),
[temp_r2]"=&amp;f"(temp_r2), [temp_r3]"=&amp;f"(temp_r3),
[temp_r1]"=&amp;f"(temp_r1), [p_phi]"+r"(p_phi),
[imag_sum_2]"+f"(imag_sum_2)
: [p_x]"r"(p_x)
: "memory"
);</asm>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_gen_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>X_high</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>X_low</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <name><name>alpha0</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><specifier>const</specifier> <name>float</name> <name><name>alpha1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>float</name> <name>bw</name></expr></argument>, <argument><expr><name>int</name> <name>start</name></expr></argument>, <argument><expr><name>int</name> <name>end</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>alpha</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x_low</name> <init>= <expr><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>X_low</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x_high</name> <init>= <expr><operator>&amp;</operator><name><name>X_high</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>, <decl><type ref="prev"/><name>temp6</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp7</name></decl>, <decl><type ref="prev"/><name>temp8</name></decl>, <decl><type ref="prev"/><name>temp9</name></decl>, <decl><type ref="prev"/><name>temp10</name></decl>, <decl><type ref="prev"/><name>temp11</name></decl>, <decl><type ref="prev"/><name>temp12</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>alpha</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>alpha1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>bw</name> <operator>*</operator> <name>bw</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>alpha1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>bw</name> <operator>*</operator> <name>bw</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>alpha0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>bw</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>alpha0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>bw</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp0], -16(%[p_x_low]) \n\t"
"lwc1 %[temp1], -12(%[p_x_low]) \n\t"
"lwc1 %[temp2], -8(%[p_x_low]) \n\t"
"lwc1 %[temp3], -4(%[p_x_low]) \n\t"
"lwc1 %[temp5], 0(%[p_x_low]) \n\t"
"lwc1 %[temp6], 4(%[p_x_low]) \n\t"
"lwc1 %[temp7], 0(%[alpha]) \n\t"
"lwc1 %[temp8], 4(%[alpha]) \n\t"
"lwc1 %[temp9], 8(%[alpha]) \n\t"
"lwc1 %[temp10], 12(%[alpha]) \n\t"
PTR_ADDIU "%[p_x_high], %[p_x_high], 8 \n\t"
PTR_ADDIU "%[p_x_low], %[p_x_low], 8 \n\t"
"mul.s %[temp11], %[temp1], %[temp8] \n\t"
"msub.s %[temp11], %[temp11], %[temp0], %[temp7] \n\t"
"madd.s %[temp11], %[temp11], %[temp2], %[temp9] \n\t"
"nmsub.s %[temp11], %[temp11], %[temp3], %[temp10] \n\t"
"add.s %[temp11], %[temp11], %[temp5] \n\t"
"swc1 %[temp11], -8(%[p_x_high]) \n\t"
"mul.s %[temp12], %[temp1], %[temp7] \n\t"
"madd.s %[temp12], %[temp12], %[temp0], %[temp8] \n\t"
"madd.s %[temp12], %[temp12], %[temp3], %[temp9] \n\t"
"madd.s %[temp12], %[temp12], %[temp2], %[temp10] \n\t"
"add.s %[temp12], %[temp12], %[temp6] \n\t"
"swc1 %[temp12], -4(%[p_x_high]) \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[temp6]"=&amp;f"(temp6), [temp7]"=&amp;f"(temp7), [temp8]"=&amp;f"(temp8),
[temp9]"=&amp;f"(temp9), [temp10]"=&amp;f"(temp10), [temp11]"=&amp;f"(temp11),
[temp12]"=&amp;f"(temp12), [p_x_high]"+r"(p_x_high),
[p_x_low]"+r"(p_x_low)
: [alpha]"r"(alpha)
: "memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_g_filt_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>Y</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>X_high</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>g_filt</name></expr></argument>, <argument><expr><name>int</name> <name>m_max</name></expr></argument>, <argument><expr><name>intptr_t</name> <name>ixh</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>p_x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_g</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>loop_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p_g</name> <operator>=</operator> <operator>&amp;</operator><name><name>g_filt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_y</name> <operator>=</operator> <operator>&amp;</operator><name><name>Y</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p_x</name> <operator>=</operator> <operator>&amp;</operator><name><name>X_high</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>ixh</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>loop_end</name> <operator>=</operator> <name>p_g</name> <operator>+</operator> <name>m_max</name></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
".set push \n\t"
".set noreorder \n\t"
"1: \n\t"
"lwc1 %[temp0], 0(%[p_g]) \n\t"
"lwc1 %[temp1], 0(%[p_x]) \n\t"
"lwc1 %[temp2], 4(%[p_x]) \n\t"
"mul.s %[temp1], %[temp1], %[temp0] \n\t"
"mul.s %[temp2], %[temp2], %[temp0] \n\t"
PTR_ADDIU "%[p_g], %[p_g], 4 \n\t"
PTR_ADDIU "%[p_x], %[p_x], 320 \n\t"
"swc1 %[temp1], 0(%[p_y]) \n\t"
"swc1 %[temp2], 4(%[p_y]) \n\t"
"bne %[p_g], %[loop_end], 1b \n\t"
PTR_ADDIU "%[p_y], %[p_y], 8 \n\t"
".set pop \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1),
[temp2]"=&amp;f"(temp2), [p_x]"+r"(p_x),
[p_y]"+r"(p_y), [p_g]"+r"(p_g)
: [loop_end]"r"(loop_end)
: "memory"
);</asm>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_apply_noise_0_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>Y</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>s_m</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>q_filt</name></expr></argument>, <argument><expr><name>int</name> <name>noise</name></expr></argument>,
<argument><expr><name>int</name> <name>kx</name></expr></argument>, <argument><expr><name>int</name> <name>m_max</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>Y1</name><init>=<expr><operator>&amp;</operator><name><name>Y</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ff_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y0</name></decl>,<decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>s_m1</name><init>=<expr><operator>&amp;</operator><name><name>s_m</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>q_filt1</name><init>= <expr><operator>&amp;</operator><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[y0], 0(%[Y1]) \n\t"
"lwc1 %[temp1], 0(%[s_m1]) \n\t"
"addiu %[noise], %[noise], 1 \n\t"
"andi %[noise], %[noise], 0x1ff \n\t"
"sll %[temp0], %[noise], 3 \n\t"
PTR_ADDU "%[ff_table],%[ff_sbr_noise_table], %[temp0] \n\t"
"add.s %[y0], %[y0], %[temp1] \n\t"
"mfc1 %[temp3], %[temp1] \n\t"
"bne %[temp3], $0, 1f \n\t"
"lwc1 %[y1], 4(%[Y1]) \n\t"
"lwc1 %[temp2], 0(%[q_filt1]) \n\t"
"lwc1 %[temp4], 0(%[ff_table]) \n\t"
"lwc1 %[temp5], 4(%[ff_table]) \n\t"
"madd.s %[y0], %[y0], %[temp2], %[temp4] \n\t"
"madd.s %[y1], %[y1], %[temp2], %[temp5] \n\t"
"swc1 %[y1], 4(%[Y1]) \n\t"
"1: \n\t"
"swc1 %[y0], 0(%[Y1]) \n\t"

: [ff_table]"=&amp;r"(ff_table), [y0]"=&amp;f"(y0), [y1]"=&amp;f"(y1),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;r"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5)
: [ff_sbr_noise_table]"r"(ff_sbr_noise_table), [noise]"r"(noise),
[Y1]"r"(Y1), [s_m1]"r"(s_m1), [q_filt1]"r"(q_filt1)
: "memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_apply_noise_1_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>Y</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>s_m</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>q_filt</name></expr></argument>, <argument><expr><name>int</name> <name>noise</name></expr></argument>,
<argument><expr><name>int</name> <name>kx</name></expr></argument>, <argument><expr><name>int</name> <name>m_max</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>y0</name></decl>,<decl><type ref="prev"/><name>y1</name></decl>,<decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>phi_sign</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>kx</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ff_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>Y1</name><init>=<expr><operator>&amp;</operator><name><name>Y</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>s_m1</name><init>=<expr><operator>&amp;</operator><name><name>s_m</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>q_filt1</name><init>= <expr><operator>&amp;</operator><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[y1], 4(%[Y1]) \n\t"
"lwc1 %[temp1], 0(%[s_m1]) \n\t"
"lw %[temp3], 0(%[s_m1]) \n\t"
"addiu %[noise], %[noise], 1 \n\t"
"andi %[noise], %[noise], 0x1ff \n\t"
"sll %[temp0], %[noise], 3 \n\t"
PTR_ADDU "%[ff_table],%[ff_sbr_noise_table],%[temp0] \n\t"
"madd.s %[y1], %[y1], %[temp1], %[phi_sign] \n\t"
"bne %[temp3], $0, 1f \n\t"
"lwc1 %[y0], 0(%[Y1]) \n\t"
"lwc1 %[temp2], 0(%[q_filt1]) \n\t"
"lwc1 %[temp4], 0(%[ff_table]) \n\t"
"lwc1 %[temp5], 4(%[ff_table]) \n\t"
"madd.s %[y0], %[y0], %[temp2], %[temp4] \n\t"
"madd.s %[y1], %[y1], %[temp2], %[temp5] \n\t"
"swc1 %[y0], 0(%[Y1]) \n\t"
"1: \n\t"
"swc1 %[y1], 4(%[Y1]) \n\t"

: [ff_table] "=&amp;r" (ff_table), [y0] "=&amp;f" (y0), [y1] "=&amp;f" (y1),
[temp0] "=&amp;r" (temp0), [temp1] "=&amp;f" (temp1), [temp2] "=&amp;f" (temp2),
[temp3] "=&amp;r" (temp3), [temp4] "=&amp;f" (temp4), [temp5] "=&amp;f" (temp5)
: [ff_sbr_noise_table] "r" (ff_sbr_noise_table), [noise] "r" (noise),
[Y1] "r" (Y1), [s_m1] "r" (s_m1), [q_filt1] "r" (q_filt1),
[phi_sign] "f" (phi_sign)
: "memory"
);</asm>
<expr_stmt><expr><name>phi_sign</name> <operator>=</operator> <operator>-</operator><name>phi_sign</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_apply_noise_2_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>Y</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>s_m</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>q_filt</name></expr></argument>, <argument><expr><name>int</name> <name>noise</name></expr></argument>,
<argument><expr><name>int</name> <name>kx</name></expr></argument>, <argument><expr><name>int</name> <name>m_max</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ff_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y0</name></decl>,<decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>Y1</name><init>=<expr><operator>&amp;</operator><name><name>Y</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>s_m1</name><init>=<expr><operator>&amp;</operator><name><name>s_m</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>q_filt1</name><init>= <expr><operator>&amp;</operator><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[y0], 0(%[Y1]) \n\t"
"lwc1 %[temp1], 0(%[s_m1]) \n\t"
"addiu %[noise], %[noise], 1 \n\t"
"andi %[noise], %[noise], 0x1ff \n\t"
"sll %[temp0], %[noise], 3 \n\t"
PTR_ADDU "%[ff_table],%[ff_sbr_noise_table],%[temp0] \n\t"
"sub.s %[y0], %[y0], %[temp1] \n\t"
"mfc1 %[temp3], %[temp1] \n\t"
"bne %[temp3], $0, 1f \n\t"
"lwc1 %[y1], 4(%[Y1]) \n\t"
"lwc1 %[temp2], 0(%[q_filt1]) \n\t"
"lwc1 %[temp4], 0(%[ff_table]) \n\t"
"lwc1 %[temp5], 4(%[ff_table]) \n\t"
"madd.s %[y0], %[y0], %[temp2], %[temp4] \n\t"
"madd.s %[y1], %[y1], %[temp2], %[temp5] \n\t"
"swc1 %[y1], 4(%[Y1]) \n\t"
"1: \n\t"
"swc1 %[y0], 0(%[Y1]) \n\t"

: [temp0]"=&amp;r"(temp0), [ff_table]"=&amp;r"(ff_table), [y0]"=&amp;f"(y0),
[y1]"=&amp;f"(y1), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;r"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5)
: [ff_sbr_noise_table]"r"(ff_sbr_noise_table), [noise]"r"(noise),
[Y1]"r"(Y1), [s_m1]"r"(s_m1), [q_filt1]"r"(q_filt1)
: "memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_apply_noise_3_mips</name><argument_list>(<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>Y</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>s_m</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <operator>*</operator><name>q_filt</name></expr></argument>, <argument><expr><name>int</name> <name>noise</name></expr></argument>,
<argument><expr><name>int</name> <name>kx</name></expr></argument>, <argument><expr><name>int</name> <name>m_max</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>phi_sign</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>kx</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>Y1</name><init>=<expr><operator>&amp;</operator><name><name>Y</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ff_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y0</name></decl>,<decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>s_m1</name><init>=<expr><operator>&amp;</operator><name><name>s_m</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>q_filt1</name><init>= <expr><operator>&amp;</operator><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[y1], 4(%[Y1]) \n\t"
"lwc1 %[temp1], 0(%[s_m1]) \n\t"
"addiu %[noise], %[noise], 1 \n\t"
"andi %[noise], %[noise], 0x1ff \n\t"
"sll %[temp0], %[noise], 3 \n\t"
PTR_ADDU "%[ff_table],%[ff_sbr_noise_table], %[temp0] \n\t"
"nmsub.s %[y1], %[y1], %[temp1], %[phi_sign] \n\t"
"mfc1 %[temp3], %[temp1] \n\t"
"bne %[temp3], $0, 1f \n\t"
"lwc1 %[y0], 0(%[Y1]) \n\t"
"lwc1 %[temp2], 0(%[q_filt1]) \n\t"
"lwc1 %[temp4], 0(%[ff_table]) \n\t"
"lwc1 %[temp5], 4(%[ff_table]) \n\t"
"madd.s %[y0], %[y0], %[temp2], %[temp4] \n\t"
"madd.s %[y1], %[y1], %[temp2], %[temp5] \n\t"
"swc1 %[y0], 0(%[Y1]) \n\t"
"1: \n\t"
"swc1 %[y1], 4(%[Y1]) \n\t"

: [ff_table]"=&amp;r"(ff_table), [y0]"=&amp;f"(y0), [y1]"=&amp;f"(y1),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;r"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5)
: [ff_sbr_noise_table]"r"(ff_sbr_noise_table), [noise]"r"(noise),
[Y1]"r"(Y1), [s_m1]"r"(s_m1), [q_filt1]"r"(q_filt1),
[phi_sign]"f"(phi_sign)
: "memory"
);</asm>
<expr_stmt><expr><name>phi_sign</name> <operator>=</operator> <operator>-</operator><name>phi_sign</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>void</name></type> <name>ff_sbrdsp_init_mips</name><parameter_list>(<parameter><decl><type><name>SBRDSPContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmf_pre_shuffle</name></name> <operator>=</operator> <name>sbr_qmf_pre_shuffle_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmf_post_shuffle</name></name> <operator>=</operator> <name>sbr_qmf_post_shuffle_mips</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sum64x5</name></name> <operator>=</operator> <name>sbr_sum64x5_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sum_square</name></name> <operator>=</operator> <name>sbr_sum_square_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qmf_deint_bfly</name></name> <operator>=</operator> <name>sbr_qmf_deint_bfly_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>autocorrelate</name></name> <operator>=</operator> <name>sbr_autocorrelate_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_gen</name></name> <operator>=</operator> <name>sbr_hf_gen_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_g_filt</name></name> <operator>=</operator> <name>sbr_hf_g_filt_mips</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_apply_noise</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sbr_hf_apply_noise_0_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_apply_noise</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sbr_hf_apply_noise_1_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_apply_noise</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sbr_hf_apply_noise_2_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hf_apply_noise</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>sbr_hf_apply_noise_3_mips</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</block_content>}</block></function>
</unit>
