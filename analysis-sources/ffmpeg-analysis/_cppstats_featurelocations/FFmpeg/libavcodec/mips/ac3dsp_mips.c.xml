<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\mips\ac3dsp_mips.c">






















































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/ac3dsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/ac3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mips/asmdefs.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSDSP</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ac3_bit_alloc_calc_bap_mips</name><parameter_list>(<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>psd</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>snr_offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>floor</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>bap_tab</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>band</name></decl>, <decl><type ref="prev"/><name>band_end</name></decl>, <decl><type ref="prev"/><name>cond</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>address1</name></decl>, <decl><type ref="prev"/><name>address2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>psd1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>psd_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bap1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>snr_offset</name> <operator>==</operator> <operator>-</operator><literal type="number">960</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AC3_MAX_COEFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>psd1</name> <operator>=</operator> <operator>&amp;</operator><name><name>psd</name><index>[<expr><name>start</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bap1</name> <operator>=</operator> <operator>&amp;</operator><name><name>bap</name><index>[<expr><name>start</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>band</name> <operator>=</operator> <name><name>ff_ac3_bin_to_band_tab</name><index>[<expr><name>start</name></expr>]</index></name></expr>;</expr_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name><name>mask</name><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>snr_offset</name> <operator>-</operator> <name>floor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x1FE0</literal><operator>)</operator> <operator>+</operator> <name>floor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>band_end</name> <operator>=</operator> <name><name>ff_ac3_band_start_tab</name><index>[<expr><operator>++</operator><name>band</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>band_end</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>band_end</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>psd_end</name> <operator>=</operator> <name>psd</name> <operator>+</operator> <name>band_end</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
"slt %[cond], %[psd1], %[psd_end] \n\t"
"beqz %[cond], 1f \n\t"
"2: \n\t"
"lh %[address1], 0(%[psd1]) \n\t"
"lh %[address2], 2(%[psd1]) \n\t"
PTR_ADDIU " %[psd1], %[psd1], 4 \n\t"
"subu %[address1], %[address1], %[m] \n\t"
"sra %[address1], %[address1], 5 \n\t"
"addiu %[address1], %[address1], -32 \n\t"
"shll_s.w %[address1], %[address1], 26 \n\t"
"subu %[address2], %[address2], %[m] \n\t"
"sra %[address2], %[address2], 5 \n\t"
"sra %[address1], %[address1], 26 \n\t"
"addiu %[address1], %[address1], 32 \n\t"
"lbux %[address1], %[address1](%[bap_tab]) \n\t"
"addiu %[address2], %[address2], -32 \n\t"
"shll_s.w %[address2], %[address2], 26 \n\t"
"sb %[address1], 0(%[bap1]) \n\t"
"slt %[cond], %[psd1], %[psd_end] \n\t"
"sra %[address2], %[address2], 26 \n\t"
"addiu %[address2], %[address2], 32 \n\t"
"lbux %[address2], %[address2](%[bap_tab]) \n\t"
"sb %[address2], 1(%[bap1]) \n\t"
PTR_ADDIU " %[bap1], %[bap1], 2 \n\t"
"bnez %[cond], 2b \n\t"
PTR_ADDIU " %[psd_end], %[psd_end], 2 \n\t"
"slt %[cond], %[psd1], %[psd_end] \n\t"
"beqz %[cond], 3f \n\t"
"1: \n\t"
"lh %[address1], 0(%[psd1]) \n\t"
PTR_ADDIU " %[psd1], %[psd1], 2 \n\t"
"subu %[address1], %[address1], %[m] \n\t"
"sra %[address1], %[address1], 5 \n\t"
"addiu %[address1], %[address1], -32 \n\t"
"shll_s.w %[address1], %[address1], 26 \n\t"
"sra %[address1], %[address1], 26 \n\t"
"addiu %[address1], %[address1], 32 \n\t"
"lbux %[address1], %[address1](%[bap_tab]) \n\t"
"sb %[address1], 0(%[bap1]) \n\t"
PTR_ADDIU " %[bap1], %[bap1], 1 \n\t"
"3: \n\t"

: [address1]"=&amp;r"(address1), [address2]"=&amp;r"(address2),
[cond]"=&amp;r"(cond), [bap1]"+r"(bap1),
[psd1]"+r"(psd1), [psd_end]"+r"(psd_end)
: [m]"r"(m), [bap_tab]"r"(bap_tab)
: "memory"
);</asm>
</block_content>}</block> while <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>band_end</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ac3_update_bap_counts_mips</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name><name>mant_cnt</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bap</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>temp0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp4</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp5</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp6</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp7</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp1</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
"andi %[temp3], %[len], 3 \n\t"
PTR_ADDU "%[temp2], %[bap], %[len] \n\t"
PTR_ADDU "%[temp4], %[bap], %[temp3] \n\t"
"beq %[temp2], %[temp4], 4f \n\t"
"1: \n\t"
"lbu %[temp0], -1(%[temp2]) \n\t"
"lbu %[temp5], -2(%[temp2]) \n\t"
"lbu %[temp6], -3(%[temp2]) \n\t"
"sll %[temp0], %[temp0], 1 \n\t"
PTR_ADDU "%[temp0], %[mant_cnt], %[temp0] \n\t"
"sll %[temp5], %[temp5], 1 \n\t"
PTR_ADDU "%[temp5], %[mant_cnt], %[temp5] \n\t"
"lhu %[temp1], 0(%[temp0]) \n\t"
"sll %[temp6], %[temp6], 1 \n\t"
PTR_ADDU "%[temp6], %[mant_cnt], %[temp6] \n\t"
"addiu %[temp1], %[temp1], 1 \n\t"
"sh %[temp1], 0(%[temp0]) \n\t"
"lhu %[temp1], 0(%[temp5]) \n\t"
"lbu %[temp7], -4(%[temp2]) \n\t"
PTR_ADDIU "%[temp2],%[temp2], -4 \n\t"
"addiu %[temp1], %[temp1], 1 \n\t"
"sh %[temp1], 0(%[temp5]) \n\t"
"lhu %[temp1], 0(%[temp6]) \n\t"
"sll %[temp7], %[temp7], 1 \n\t"
PTR_ADDU "%[temp7], %[mant_cnt], %[temp7] \n\t"
"addiu %[temp1], %[temp1],1 \n\t"
"sh %[temp1], 0(%[temp6]) \n\t"
"lhu %[temp1], 0(%[temp7]) \n\t"
"addiu %[temp1], %[temp1], 1 \n\t"
"sh %[temp1], 0(%[temp7]) \n\t"
"bne %[temp2], %[temp4], 1b \n\t"
"4: \n\t"
"beqz %[temp3], 2f \n\t"
"3: \n\t"
"addiu %[temp3], %[temp3], -1 \n\t"
"lbu %[temp0], -1(%[temp2]) \n\t"
PTR_ADDIU "%[temp2],%[temp2], -1 \n\t"
"sll %[temp0], %[temp0], 1 \n\t"
PTR_ADDU "%[temp0], %[mant_cnt], %[temp0] \n\t"
"lhu %[temp1], 0(%[temp0]) \n\t"
"addiu %[temp1], %[temp1], 1 \n\t"
"sh %[temp1], 0(%[temp0]) \n\t"
"bgtz %[temp3], 3b \n\t"
"2: \n\t"

: [temp0] "=&amp;r" (temp0), [temp1] "=&amp;r" (temp1),
[temp2] "=&amp;r" (temp2), [temp3] "=&amp;r" (temp3),
[temp4] "=&amp;r" (temp4), [temp5] "=&amp;r" (temp5),
[temp6] "=&amp;r" (temp6), [temp7] "=&amp;r" (temp7)
: [len] "r" (len), [bap] "r" (bap),
[mant_cnt] "r" (mant_cnt)
: "memory"
);</asm>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>float_to_fixed24_mips</name><parameter_list>(<parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>src0</name></decl>, <decl><type ref="prev"/><name>src1</name></decl>, <decl><type ref="prev"/><name>src2</name></decl>, <decl><type ref="prev"/><name>src3</name></decl>, <decl><type ref="prev"/><name>src4</name></decl>, <decl><type ref="prev"/><name>src5</name></decl>, <decl><type ref="prev"/><name>src6</name></decl>, <decl><type ref="prev"/><name>src7</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>, <decl><type ref="prev"/><name>temp6</name></decl>, <decl><type ref="prev"/><name>temp7</name></decl>;</decl_stmt>

<do>do <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[src0], 0(%[src]) \n\t"
"lwc1 %[src1], 4(%[src]) \n\t"
"lwc1 %[src2], 8(%[src]) \n\t"
"lwc1 %[src3], 12(%[src]) \n\t"
"lwc1 %[src4], 16(%[src]) \n\t"
"lwc1 %[src5], 20(%[src]) \n\t"
"lwc1 %[src6], 24(%[src]) \n\t"
"lwc1 %[src7], 28(%[src]) \n\t"
"mul.s %[src0], %[src0], %[scale] \n\t"
"mul.s %[src1], %[src1], %[scale] \n\t"
"mul.s %[src2], %[src2], %[scale] \n\t"
"mul.s %[src3], %[src3], %[scale] \n\t"
"mul.s %[src4], %[src4], %[scale] \n\t"
"mul.s %[src5], %[src5], %[scale] \n\t"
"mul.s %[src6], %[src6], %[scale] \n\t"
"mul.s %[src7], %[src7], %[scale] \n\t"
"cvt.w.s %[src0], %[src0] \n\t"
"cvt.w.s %[src1], %[src1] \n\t"
"cvt.w.s %[src2], %[src2] \n\t"
"cvt.w.s %[src3], %[src3] \n\t"
"cvt.w.s %[src4], %[src4] \n\t"
"cvt.w.s %[src5], %[src5] \n\t"
"cvt.w.s %[src6], %[src6] \n\t"
"cvt.w.s %[src7], %[src7] \n\t"
"mfc1 %[temp0], %[src0] \n\t"
"mfc1 %[temp1], %[src1] \n\t"
"mfc1 %[temp2], %[src2] \n\t"
"mfc1 %[temp3], %[src3] \n\t"
"mfc1 %[temp4], %[src4] \n\t"
"mfc1 %[temp5], %[src5] \n\t"
"mfc1 %[temp6], %[src6] \n\t"
"mfc1 %[temp7], %[src7] \n\t"
"sw %[temp0], 0(%[dst]) \n\t"
"sw %[temp1], 4(%[dst]) \n\t"
"sw %[temp2], 8(%[dst]) \n\t"
"sw %[temp3], 12(%[dst]) \n\t"
"sw %[temp4], 16(%[dst]) \n\t"
"sw %[temp5], 20(%[dst]) \n\t"
"sw %[temp6], 24(%[dst]) \n\t"
"sw %[temp7], 28(%[dst]) \n\t"

: [dst] "+r" (dst), [src] "+r" (src),
[src0] "=&amp;f" (src0), [src1] "=&amp;f" (src1),
[src2] "=&amp;f" (src2), [src3] "=&amp;f" (src3),
[src4] "=&amp;f" (src4), [src5] "=&amp;f" (src5),
[src6] "=&amp;f" (src6), [src7] "=&amp;f" (src7),
[temp0] "=r" (temp0), [temp1] "=r" (temp1),
[temp2] "=r" (temp2), [temp3] "=r" (temp3),
[temp4] "=r" (temp4), [temp5] "=r" (temp5),
[temp6] "=r" (temp6), [temp7] "=r" (temp7)
: [scale] "f" (scale)
: "memory"
);</asm>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name>src</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>dst</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>ac3_downmix_mips</name><argument_list>(<argument><expr><name>float</name> <operator>*</operator><operator>*</operator><name>samples</name></expr></argument>, <argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>matrix</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,
<argument><expr><name>int</name> <name>out_ch</name></expr></argument>, <argument><expr><name>int</name> <name>in_ch</name></expr></argument>, <argument><expr><name>int</name> <name>len</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>, <decl><type ref="prev"/><name>i3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>v0</name></decl>, <decl><type ref="prev"/><name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>v3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>v4</name></decl>, <decl><type ref="prev"/><name>v5</name></decl>, <decl><type ref="prev"/><name>v6</name></decl>, <decl><type ref="prev"/><name>v7</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>samples0</name></decl>, <decl><type ref="prev"/><name>samples1</name></decl>, <decl><type ref="prev"/><name>samples2</name></decl>, <decl><type ref="prev"/><name>samples3</name></decl>, <decl><type ref="prev"/><name>matrix_j</name></decl>, <decl><type ref="prev"/><name>matrix_j2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>samples_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>samples_sw</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>matrix_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>samples_x</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>samples_end</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
".set push \n\t"
".set noreorder \n\t"

"li %[i1], 2 \n\t"
"sll %[len], 2 \n\t"
"move %[i], $zero \n\t"
"sll %[j], %[in_ch], " PTRLOG " \n\t"

"bne %[out_ch], %[i1], 3f \n\t" 
" li %[i2], 1 \n\t"

"2: \n\t" 
"move %[matrix_p], %[matrix] \n\t"
"move %[samples_x], %[samples] \n\t"
"mtc1 $zero, %[v0] \n\t"
"mtc1 $zero, %[v1] \n\t"
"mtc1 $zero, %[v2] \n\t"
"mtc1 $zero, %[v3] \n\t"
"mtc1 $zero, %[v4] \n\t"
"mtc1 $zero, %[v5] \n\t"
"mtc1 $zero, %[v6] \n\t"
"mtc1 $zero, %[v7] \n\t"
"addiu %[i1], %[i], 4 \n\t"
"addiu %[i2], %[i], 8 \n\t"
PTR_L " %[samples_p], 0(%[samples_x]) \n\t"
"addiu %[i3], %[i], 12 \n\t"
PTR_ADDU "%[samples_end],%[samples_x], %[j] \n\t"
"move %[samples_sw], %[samples_p] \n\t"

"1: \n\t" 
"lwc1 %[matrix_j], 0(%[matrix_p]) \n\t"
"lwc1 %[matrix_j2], 4(%[matrix_p]) \n\t"
"lwxc1 %[samples0], %[i](%[samples_p]) \n\t"
"lwxc1 %[samples1], %[i1](%[samples_p]) \n\t"
"lwxc1 %[samples2], %[i2](%[samples_p]) \n\t"
"lwxc1 %[samples3], %[i3](%[samples_p]) \n\t"
PTR_ADDIU "%[matrix_p], 8 \n\t"
PTR_ADDIU "%[samples_x]," PTRSIZE " \n\t"
"madd.s %[v0], %[v0], %[samples0], %[matrix_j] \n\t"
"madd.s %[v1], %[v1], %[samples1], %[matrix_j] \n\t"
"madd.s %[v2], %[v2], %[samples2], %[matrix_j] \n\t"
"madd.s %[v3], %[v3], %[samples3], %[matrix_j] \n\t"
"madd.s %[v4], %[v4], %[samples0], %[matrix_j2]\n\t"
"madd.s %[v5], %[v5], %[samples1], %[matrix_j2]\n\t"
"madd.s %[v6], %[v6], %[samples2], %[matrix_j2]\n\t"
"madd.s %[v7], %[v7], %[samples3], %[matrix_j2]\n\t"
"bne %[samples_x], %[samples_end], 1b \n\t"
PTR_L " %[samples_p], 0(%[samples_x]) \n\t"

PTR_L " %[samples_p], " PTRSIZE "(%[samples]) \n\t"
"swxc1 %[v0], %[i](%[samples_sw]) \n\t"
"swxc1 %[v1], %[i1](%[samples_sw]) \n\t"
"swxc1 %[v2], %[i2](%[samples_sw]) \n\t"
"swxc1 %[v3], %[i3](%[samples_sw]) \n\t"
"swxc1 %[v4], %[i](%[samples_p]) \n\t"
"addiu %[i], 16 \n\t"
"swxc1 %[v5], %[i1](%[samples_p]) \n\t"
"swxc1 %[v6], %[i2](%[samples_p]) \n\t"
"bne %[i], %[len], 2b \n\t"
" swxc1 %[v7], %[i3](%[samples_p]) \n\t"

"3: \n\t"
"bne %[out_ch], %[i2], 6f \n\t" 
" nop \n\t"

"5: \n\t" 
"move %[matrix_p], %[matrix] \n\t"
"move %[samples_x], %[samples] \n\t"
"mtc1 $zero, %[v0] \n\t"
"mtc1 $zero, %[v1] \n\t"
"mtc1 $zero, %[v2] \n\t"
"mtc1 $zero, %[v3] \n\t"
"addiu %[i1], %[i], 4 \n\t"
"addiu %[i2], %[i], 8 \n\t"
PTR_L " %[samples_p], 0(%[samples_x]) \n\t"
"addiu %[i3], %[i], 12 \n\t"
PTR_ADDU "%[samples_end],%[samples_x], %[j] \n\t"
"move %[samples_sw], %[samples_p] \n\t"

"4: \n\t" 
"lwc1 %[matrix_j], 0(%[matrix_p]) \n\t"
"lwxc1 %[samples0], %[i](%[samples_p]) \n\t"
"lwxc1 %[samples1], %[i1](%[samples_p]) \n\t"
"lwxc1 %[samples2], %[i2](%[samples_p]) \n\t"
"lwxc1 %[samples3], %[i3](%[samples_p]) \n\t"
PTR_ADDIU "%[matrix_p], 8 \n\t"
PTR_ADDIU "%[samples_x]," PTRSIZE " \n\t"
"madd.s %[v0], %[v0], %[samples0], %[matrix_j] \n\t"
"madd.s %[v1], %[v1], %[samples1], %[matrix_j] \n\t"
"madd.s %[v2], %[v2], %[samples2], %[matrix_j] \n\t"
"madd.s %[v3], %[v3], %[samples3], %[matrix_j] \n\t"
"bne %[samples_x], %[samples_end], 4b \n\t"
PTR_L " %[samples_p], 0(%[samples_x]) \n\t"

"swxc1 %[v0], %[i](%[samples_sw]) \n\t"
"addiu %[i], 16 \n\t"
"swxc1 %[v1], %[i1](%[samples_sw]) \n\t"
"swxc1 %[v2], %[i2](%[samples_sw]) \n\t"
"bne %[i], %[len], 5b \n\t"
" swxc1 %[v3], %[i3](%[samples_sw]) \n\t"
"6: \n\t"

".set pop"
:[samples_p]"=&amp;r"(samples_p), [matrix_j]"=&amp;f"(matrix_j), [matrix_j2]"=&amp;f"(matrix_j2),
[samples0]"=&amp;f"(samples0), [samples1]"=&amp;f"(samples1),
[samples2]"=&amp;f"(samples2), [samples3]"=&amp;f"(samples3),
[v0]"=&amp;f"(v0), [v1]"=&amp;f"(v1), [v2]"=&amp;f"(v2), [v3]"=&amp;f"(v3),
[v4]"=&amp;f"(v4), [v5]"=&amp;f"(v5), [v6]"=&amp;f"(v6), [v7]"=&amp;f"(v7),
[samples_x]"=&amp;r"(samples_x), [matrix_p]"=&amp;r"(matrix_p),
[samples_end]"=&amp;r"(samples_end), [samples_sw]"=&amp;r"(samples_sw),
[i1]"=&amp;r"(i1), [i2]"=&amp;r"(i2), [i3]"=&amp;r"(i3), [i]"=&amp;r"(i),
[j]"=&amp;r"(j), [len]"+r"(len)
:[samples]"r"(samples), [matrix]"r"(matrix),
[in_ch]"r"(in_ch), [out_ch]"r"(out_ch)
:"memory"
);</asm>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>void</name></type> <name>ff_ac3dsp_init_mips</name><parameter_list>(<parameter><decl><type><name>AC3DSPContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bit_exact</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSDSP</name></expr></cpp:if>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bit_alloc_calc_bap</name></name> <operator>=</operator> <name>ac3_bit_alloc_calc_bap_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>update_bap_counts</name></name> <operator>=</operator> <name>ac3_update_bap_counts_mips</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>float_to_fixed24</name></name> <operator>=</operator> <name>float_to_fixed24_mips</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
