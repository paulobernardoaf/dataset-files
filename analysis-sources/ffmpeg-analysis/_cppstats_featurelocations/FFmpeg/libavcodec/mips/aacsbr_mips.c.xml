<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\mips\aacsbr_mips.c">




















































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/aac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/aacsbr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mips/asmdefs.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVELOPE_ADJUSTMENT_OFFSET</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sbr_lf_gen_mips</name><parameter_list>(<parameter><decl><type><name>AACContext</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, <parameter><decl><type><name>SpectralBandReplication</name> <modifier>*</modifier></type><name>sbr</name></decl></parameter>,
<parameter><decl><type><name>float</name></type> <name><name>X_low</name><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>W</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>buf_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>, <decl><type ref="prev"/><name>temp6</name></decl>, <decl><type ref="prev"/><name>temp7</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x_low</name> <init>= <expr><operator>&amp;</operator><name><name>X_low</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_w</name> <init>= <expr><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>W</name><index>[<expr><name>buf_idx</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_x1_low</name> <init>= <expr><operator>&amp;</operator><name><name>X_low</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>p_w1</name> <init>= <expr><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>W</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>buf_idx</name></expr>]</index><index>[<expr><literal type="number">24</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>loop_end</name><init>=<expr><name>p_x1_low</name> <operator>+</operator> <literal type="number">2560</literal></expr></init></decl>;</decl_stmt>


<asm>__asm__ <specifier>volatile</specifier> (
"1: \n\t"
"sw $0, 0(%[p_x1_low]) \n\t"
"sw $0, 4(%[p_x1_low]) \n\t"
"sw $0, 8(%[p_x1_low]) \n\t"
"sw $0, 12(%[p_x1_low]) \n\t"
"sw $0, 16(%[p_x1_low]) \n\t"
"sw $0, 20(%[p_x1_low]) \n\t"
"sw $0, 24(%[p_x1_low]) \n\t"
"sw $0, 28(%[p_x1_low]) \n\t"
PTR_ADDIU "%[p_x1_low],%[p_x1_low], 32 \n\t"
"bne %[p_x1_low], %[loop_end], 1b \n\t"
PTR_ADDIU "%[p_x1_low],%[p_x1_low], -10240 \n\t"

: [p_x1_low]"+r"(p_x1_low)
: [loop_end]"r"(loop_end)
: "memory"
);</asm>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>

<asm>__asm__ <specifier>volatile</specifier> (
"lw %[temp0], 0(%[p_w]) \n\t"
"lw %[temp1], 4(%[p_w]) \n\t"
"lw %[temp2], 256(%[p_w]) \n\t"
"lw %[temp3], 260(%[p_w]) \n\t"
"lw %[temp4], 512(%[p_w]) \n\t"
"lw %[temp5], 516(%[p_w]) \n\t"
"lw %[temp6], 768(%[p_w]) \n\t"
"lw %[temp7], 772(%[p_w]) \n\t"
"sw %[temp0], 0(%[p_x_low]) \n\t"
"sw %[temp1], 4(%[p_x_low]) \n\t"
"sw %[temp2], 8(%[p_x_low]) \n\t"
"sw %[temp3], 12(%[p_x_low]) \n\t"
"sw %[temp4], 16(%[p_x_low]) \n\t"
"sw %[temp5], 20(%[p_x_low]) \n\t"
"sw %[temp6], 24(%[p_x_low]) \n\t"
"sw %[temp7], 28(%[p_x_low]) \n\t"
PTR_ADDIU "%[p_x_low], %[p_x_low], 32 \n\t"
PTR_ADDIU "%[p_w], %[p_w], 1024 \n\t"

: [temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1),
[temp2]"=&amp;r"(temp2), [temp3]"=&amp;r"(temp3),
[temp4]"=&amp;r"(temp4), [temp5]"=&amp;r"(temp5),
[temp6]"=&amp;r"(temp6), [temp7]"=&amp;r"(temp7),
[p_w]"+r"(p_w), [p_x_low]"+r"(p_x_low)
:
: "memory"
);</asm>
</block_content>}</block></for>
<expr_stmt><expr><name>p_x_low</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p_w</name> <operator>-=</operator> <literal type="number">2046</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<asm>__asm__ <specifier>volatile</specifier> (
"lw %[temp0], 0(%[p_w1]) \n\t"
"lw %[temp1], 4(%[p_w1]) \n\t"
"lw %[temp2], 256(%[p_w1]) \n\t"
"lw %[temp3], 260(%[p_w1]) \n\t"
"lw %[temp4], 512(%[p_w1]) \n\t"
"lw %[temp5], 516(%[p_w1]) \n\t"
"lw %[temp6], 768(%[p_w1]) \n\t"
"lw %[temp7], 772(%[p_w1]) \n\t"
"sw %[temp0], 0(%[p_x1_low]) \n\t"
"sw %[temp1], 4(%[p_x1_low]) \n\t"
"sw %[temp2], 8(%[p_x1_low]) \n\t"
"sw %[temp3], 12(%[p_x1_low]) \n\t"
"sw %[temp4], 16(%[p_x1_low]) \n\t"
"sw %[temp5], 20(%[p_x1_low]) \n\t"
"sw %[temp6], 24(%[p_x1_low]) \n\t"
"sw %[temp7], 28(%[p_x1_low]) \n\t"
PTR_ADDIU "%[p_x1_low], %[p_x1_low], 32 \n\t"
PTR_ADDIU "%[p_w1], %[p_w1], 1024 \n\t"

: [temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1),
[temp2]"=&amp;r"(temp2), [temp3]"=&amp;r"(temp3),
[temp4]"=&amp;r"(temp4), [temp5]"=&amp;r"(temp5),
[temp6]"=&amp;r"(temp6), [temp7]"=&amp;r"(temp7),
[p_w1]"+r"(p_w1), [p_x1_low]"+r"(p_x1_low)
:
: "memory"
);</asm>
</block_content>}</block></for>
<expr_stmt><expr><name>p_x1_low</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p_w1</name> <operator>-=</operator> <literal type="number">510</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sbr_x_gen_mips</name><parameter_list>(<parameter><decl><type><name>SpectralBandReplication</name> <modifier>*</modifier></type><name>sbr</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name><name>X</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">38</literal></expr>]</index><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>Y0</name><index>[<expr><literal type="number">38</literal></expr>]</index><index>[<expr><literal type="number">64</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>Y1</name><index>[<expr><literal type="number">38</literal></expr>]</index><index>[<expr><literal type="number">64</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>X_low</name><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>i_f</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>X_low1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Y01</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Y11</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>x1</name><init>=<expr><operator>&amp;</operator><name><name>X</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>j</name><init>=<expr><name>x1</name><operator>+</operator><literal type="number">4864</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>i_Temp</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name><name>sbr</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name>t_env_num_env_old</name> <operator>-</operator> <name>i_f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<asm>__asm__ <specifier>volatile</specifier> (
"1: \n\t"
"sw $0, 0(%[x1]) \n\t"
"sw $0, 4(%[x1]) \n\t"
"sw $0, 8(%[x1]) \n\t"
"sw $0, 12(%[x1]) \n\t"
"sw $0, 16(%[x1]) \n\t"
"sw $0, 20(%[x1]) \n\t"
"sw $0, 24(%[x1]) \n\t"
"sw $0, 28(%[x1]) \n\t"
PTR_ADDIU "%[x1],%[x1], 32 \n\t"
"bne %[x1], %[j], 1b \n\t"
PTR_ADDIU "%[x1],%[x1], -19456 \n\t"

: [x1]"+r"(x1)
: [j]"r"(j)
: "memory"
);</asm>

<if_stmt><if>if <condition>(<expr><name>i_Temp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>X_low1</name><operator>=</operator><operator>&amp;</operator><name><name>X_low</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<asm>__asm__ <specifier>volatile</specifier> (
"move %[i], $zero \n\t"
"2: \n\t"
"lw %[temp0], 0(%[X_low1]) \n\t"
"lw %[temp1], 4(%[X_low1]) \n\t"
"sw %[temp0], 0(%[x1]) \n\t"
"sw %[temp1], 9728(%[x1]) \n\t"
PTR_ADDIU "%[x1], %[x1], 256 \n\t"
PTR_ADDIU "%[X_low1], %[X_low1], 8 \n\t"
"addiu %[i], %[i], 1 \n\t"
"bne %[i], %[i_Temp], 2b \n\t"

: [x1]"+r"(x1), [X_low1]"+r"(X_low1), [i]"=&amp;r"(i),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1)
: [i_Temp]"r"(i_Temp)
: "memory"
);</asm>
<expr_stmt><expr><name>x1</name><operator>-=</operator><operator>(</operator><name>i_Temp</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>X_low1</name><operator>-=</operator><operator>(</operator><name>i_Temp</name><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator><literal type="number">80</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>x1</name><operator>=</operator><operator>&amp;</operator><name><name>X</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>Y01</name><operator>=</operator><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>Y0</name><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>sbr</name><operator>-&gt;</operator><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"move %[i], $zero \n\t"
"3: \n\t"
"lw %[temp0], 0(%[Y01]) \n\t"
"lw %[temp1], 4(%[Y01]) \n\t"
"sw %[temp0], 0(%[x1]) \n\t"
"sw %[temp1], 9728(%[x1]) \n\t"
PTR_ADDIU "%[x1], %[x1], 256 \n\t"
PTR_ADDIU "%[Y01], %[Y01], 512 \n\t"
"addiu %[i], %[i], 1 \n\t"
"bne %[i], %[i_Temp], 3b \n\t"

: [x1]"+r"(x1), [Y01]"+r"(Y01), [i]"=&amp;r"(i),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1)
: [i_Temp]"r"(i_Temp)
: "memory"
);</asm>
<expr_stmt><expr><name>x1</name> <operator>-=</operator><operator>(</operator><name>i_Temp</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>Y01</name> <operator>-=</operator><operator>(</operator><name>i_Temp</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x1</name><operator>=</operator><operator>&amp;</operator><name><name>X</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i_Temp</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>X_low1</name><operator>=</operator><operator>&amp;</operator><name><name>X_low</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i_Temp</name><operator>+</operator><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp3</name><operator>=</operator><literal type="number">38</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<asm>__asm__ <specifier>volatile</specifier> (
"move %[i], %[i_Temp] \n\t"
"4: \n\t"
"lw %[temp0], 0(%[X_low1]) \n\t"
"lw %[temp1], 4(%[X_low1]) \n\t"
"sw %[temp0], 0(%[x1]) \n\t"
"sw %[temp1], 9728(%[x1]) \n\t"
PTR_ADDIU "%[x1], %[x1], 256 \n\t"
PTR_ADDIU "%[X_low1],%[X_low1], 8 \n\t"
"addiu %[i], %[i], 1 \n\t"
"bne %[i], %[temp3], 4b \n\t"

: [x1]"+r"(x1), [X_low1]"+r"(X_low1), [i]"=&amp;r"(i),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1),
[temp2]"=&amp;r"(temp2)
: [i_Temp]"r"(i_Temp), [temp3]"r"(temp3)
: "memory"
);</asm>
<expr_stmt><expr><name>x1</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><literal type="number">38</literal><operator>-</operator><name>i_Temp</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>X_low1</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><literal type="number">38</literal><operator>-</operator><name>i_Temp</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator><operator>-</operator> <literal type="number">80</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>x1</name><operator>=</operator><operator>&amp;</operator><name><name>X</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i_Temp</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>Y11</name><operator>=</operator><operator>&amp;</operator><name><name>Y1</name><index>[<expr><name>i_Temp</name></expr>]</index><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp2</name><operator>=</operator><literal type="number">32</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>sbr</name><operator>-&gt;</operator><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<asm>__asm__ <specifier>volatile</specifier> (
"move %[i], %[i_Temp] \n\t"
"5: \n\t"
"lw %[temp0], 0(%[Y11]) \n\t"
"lw %[temp1], 4(%[Y11]) \n\t"
"sw %[temp0], 0(%[x1]) \n\t"
"sw %[temp1], 9728(%[x1]) \n\t"
PTR_ADDIU "%[x1], %[x1], 256 \n\t"
PTR_ADDIU "%[Y11], %[Y11], 512 \n\t"
"addiu %[i], %[i], 1 \n\t"
"bne %[i], %[temp2], 5b \n\t"

: [x1]"+r"(x1), [Y11]"+r"(Y11), [i]"=&amp;r"(i),
[temp0]"=&amp;r"(temp0), [temp1]"=&amp;r"(temp1)
: [i_Temp]"r"(i_Temp), [temp3]"r"(temp3),
[temp2]"r"(temp2)
: "memory"
);</asm>

<expr_stmt><expr><name>x1</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><name>i_Temp</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>Y11</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><name>i_Temp</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_assemble_mips</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name><name>Y1</name><index>[<expr><literal type="number">38</literal></expr>]</index><index>[<expr><literal type="number">64</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>X_high</name><index>[<expr><literal type="number">64</literal></expr>]</index><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><name>SpectralBandReplication</name> <modifier>*</modifier></type><name>sbr</name></decl></parameter>, <parameter><decl><type><name>SBRData</name> <modifier>*</modifier></type><name>ch_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>e_a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>h_SL</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <operator>!</operator><name><name>sbr</name><operator>-&gt;</operator><name>bs_smoothing_mode</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>kx</name> <init>= <expr><name><name>sbr</name><operator>-&gt;</operator><name>kx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>m_max</name> <init>= <expr><name><name>sbr</name><operator>-&gt;</operator><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>float</name></type> <name><name>h_smooth</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">0.33333333333333</literal></expr>,
<expr><literal type="number">0.30150283239582</literal></expr>,
<expr><literal type="number">0.21816949906249</literal></expr>,
<expr><literal type="number">0.11516383427084</literal></expr>,
<expr><literal type="number">0.03183050093751</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>g_temp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">48</literal></expr>]</index> <operator>=</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>g_temp</name></name></expr><operator>,</operator> <expr><operator>(</operator><operator>*</operator><name>q_temp</name><operator>)</operator><index>[<expr><literal type="number">48</literal></expr>]</index> <operator>=</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>q_temp</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>indexnoise</name> <init>= <expr><name><name>ch_data</name><operator>-&gt;</operator><name>f_indexnoise</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>indexsine</name> <init>= <expr><name><name>ch_data</name><operator>-&gt;</operator><name>f_indexsine</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>g_temp1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q_temp1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pok</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pok1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>m_max</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sbr</name><operator>-&gt;</operator><name>reset</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>h_SL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>g_temp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sbr</name><operator>-&gt;</operator><name>gain</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>m_max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>sbr</name><operator>-&gt;</operator><name>gain</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>q_temp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sbr</name><operator>-&gt;</operator><name>q_m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>m_max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>sbr</name><operator>-&gt;</operator><name>q_m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>h_SL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>g_temp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>g_temp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env_num_env_old</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>g_temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>q_temp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>q_temp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name><name>ch_data</name><operator>-&gt;</operator><name>t_env_num_env_old</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>q_temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>e</name> <operator>&lt;</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>bs_num_env</name></name></expr>;</condition> <incr><expr><name>e</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><name>e</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>g_temp1</name> <operator>=</operator> <name><name>g_temp</name><index>[<expr><name>h_SL</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pok</name> <operator>=</operator> <name><name>sbr</name><operator>-&gt;</operator><name>gain</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q_temp1</name> <operator>=</operator> <name><name>q_temp</name><index>[<expr><name>h_SL</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pok1</name> <operator>=</operator> <name><name>sbr</name><operator>-&gt;</operator><name>q_m</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><operator>(</operator><name>size</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lw %[temp1], 0(%[pok]) \n\t"
"lw %[temp2], 4(%[pok]) \n\t"
"lw %[temp3], 8(%[pok]) \n\t"
"lw %[temp4], 12(%[pok]) \n\t"
"sw %[temp1], 0(%[g_temp1]) \n\t"
"sw %[temp2], 4(%[g_temp1]) \n\t"
"sw %[temp3], 8(%[g_temp1]) \n\t"
"sw %[temp4], 12(%[g_temp1]) \n\t"
"lw %[temp1], 0(%[pok1]) \n\t"
"lw %[temp2], 4(%[pok1]) \n\t"
"lw %[temp3], 8(%[pok1]) \n\t"
"lw %[temp4], 12(%[pok1]) \n\t"
"sw %[temp1], 0(%[q_temp1]) \n\t"
"sw %[temp2], 4(%[q_temp1]) \n\t"
"sw %[temp3], 8(%[q_temp1]) \n\t"
"sw %[temp4], 12(%[q_temp1]) \n\t"
PTR_ADDIU "%[pok], %[pok], 16 \n\t"
PTR_ADDIU "%[g_temp1], %[g_temp1], 16 \n\t"
PTR_ADDIU "%[pok1], %[pok1], 16 \n\t"
PTR_ADDIU "%[q_temp1], %[q_temp1], 16 \n\t"

: [temp1]"=&amp;r"(temp1), [temp2]"=&amp;r"(temp2),
[temp3]"=&amp;r"(temp3), [temp4]"=&amp;r"(temp4),
[pok]"+r"(pok), [g_temp1]"+r"(g_temp1),
[pok1]"+r"(pok1), [q_temp1]"+r"(q_temp1)
:
: "memory"
);</asm>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><operator>(</operator><name>size</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lw %[temp1], 0(%[pok]) \n\t"
"lw %[temp2], 0(%[pok1]) \n\t"
"sw %[temp1], 0(%[g_temp1]) \n\t"
"sw %[temp2], 0(%[q_temp1]) \n\t"
PTR_ADDIU "%[pok], %[pok], 4 \n\t"
PTR_ADDIU "%[g_temp1], %[g_temp1], 4 \n\t"
PTR_ADDIU "%[pok1], %[pok1], 4 \n\t"
PTR_ADDIU "%[q_temp1], %[q_temp1], 4 \n\t"

: [temp1]"=&amp;r"(temp1), [temp2]"=&amp;r"(temp2),
[temp3]"=&amp;r"(temp3), [temp4]"=&amp;r"(temp4),
[pok]"+r"(pok), [g_temp1]"+r"(g_temp1),
[pok1]"+r"(pok1), [q_temp1]"+r"(q_temp1)
:
: "memory"
);</asm>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>e</name> <operator>&lt;</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>bs_num_env</name></name></expr>;</condition> <incr><expr><name>e</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>ch_data</name><operator>-&gt;</operator><name>t_env</name><index>[<expr><name>e</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>g_filt_tab</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">48</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>q_filt_tab</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">48</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>g_filt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q_filt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h_SL</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>!=</operator> <name><name>e_a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>e</name> <operator>!=</operator> <name><name>e_a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>g_filt</name> <operator>=</operator> <name>g_filt_tab</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q_filt</name> <operator>=</operator> <name>q_filt_tab</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx1</name> <init>= <expr><name>i</name> <operator>+</operator> <name>h_SL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g_filt</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>h_SL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>g_filt</name><index>[<expr><name>m</name></expr>]</index></name> <operator>+=</operator> <name><name>g_temp</name><index>[<expr><name>idx1</name> <operator>-</operator> <name>j</name></expr>]</index><index>[<expr><name>m</name></expr>]</index></name> <operator>*</operator> <name><name>h_smooth</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q_filt</name><index>[<expr><name>m</name></expr>]</index></name> <operator>+=</operator> <name><name>q_temp</name><index>[<expr><name>idx1</name> <operator>-</operator> <name>j</name></expr>]</index><index>[<expr><name>m</name></expr>]</index></name> <operator>*</operator> <name><name>h_smooth</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>g_filt</name> <operator>=</operator> <name><name>g_temp</name><index>[<expr><name>i</name> <operator>+</operator> <name>h_SL</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q_filt</name> <operator>=</operator> <name><name>q_temp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name><name>sbr</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>hf_g_filt</name></name><argument_list>(<argument><expr><name><name>Y1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>kx</name></expr></argument>, <argument><expr><name>X_high</name> <operator>+</operator> <name>kx</name></expr></argument>, <argument><expr><name>g_filt</name></expr></argument>, <argument><expr><name>m_max</name></expr></argument>,
<argument><expr><name>i</name> <operator>+</operator> <name>ENVELOPE_ADJUSTMENT_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name><name>e_a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>e</name> <operator>!=</operator> <name><name>e_a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sbr</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>hf_apply_noise</name><index>[<expr><name>indexsine</name></expr>]</index></name><operator>(</operator><name><name>Y1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>kx</name><operator>,</operator> <name><name>sbr</name><operator>-&gt;</operator><name>s_m</name><index>[<expr><name>e</name></expr>]</index></name><operator>,</operator>
<name>q_filt</name><operator>,</operator> <name>indexnoise</name><operator>,</operator>
<name>kx</name><operator>,</operator> <name>m_max</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>indexsine</name><operator>&amp;</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>A</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>-</operator><operator>(</operator><operator>(</operator><name>indexsine</name><operator>+</operator><operator>(</operator><name>kx</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>B</name> <init>= <expr><operator>(</operator><name>A</name><operator>^</operator><operator>(</operator><operator>-</operator><name>idx</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>&amp;</operator><name><name>Y1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>kx</name></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name><name>sbr</name><operator>-&gt;</operator><name>s_m</name><index>[<expr><name>e</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>A_f</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>A</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>B_f</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>B</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>m</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>m_max</name></expr>;</condition> <incr><expr><name>m</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>temp2</name> <operator>=</operator> <name><name>out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp3</name> <operator>=</operator> <name><name>out</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier>(
"lwc1 %[temp0], 0(%[in]) \n\t"
"lwc1 %[temp1], 4(%[in]) \n\t"
"madd.s %[temp4], %[temp2], %[temp0], %[A_f] \n\t"
"madd.s %[temp5], %[temp3], %[temp1], %[B_f] \n\t"
"swc1 %[temp4], 0(%[out]) \n\t"
"swc1 %[temp5], 8(%[out]) \n\t"
PTR_ADDIU "%[in], %[in], 8 \n\t"
PTR_ADDIU "%[out], %[out], 16 \n\t"

: [temp0]"=&amp;f" (temp0), [temp1]"=&amp;f"(temp1),
[temp4]"=&amp;f" (temp4), [temp5]"=&amp;f"(temp5),
[in]"+r"(in), [out]"+r"(out)
: [A_f]"f"(A_f), [B_f]"f"(B_f), [temp2]"f"(temp2),
[temp3]"f"(temp3)
: "memory"
);</asm>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>m_max</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>m</name></expr> ]</index></name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>m</name></expr> ]</index></name> <operator>*</operator> <name>A</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>indexnoise</name> <operator>=</operator> <operator>(</operator><name>indexnoise</name> <operator>+</operator> <name>m_max</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1ff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>indexsine</name> <operator>=</operator> <operator>(</operator><name>indexsine</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ch_data</name><operator>-&gt;</operator><name>f_indexnoise</name></name> <operator>=</operator> <name>indexnoise</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch_data</name><operator>-&gt;</operator><name>f_indexsine</name></name> <operator>=</operator> <name>indexsine</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>sbr_hf_inverse_filter_mips</name><argument_list>(<argument><expr><name>SBRDSPContext</name> <operator>*</operator><name>dsp</name></expr></argument>,
<argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>alpha0</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><call><name>float</name> <argument_list>(<argument><expr><operator>*</operator><name>alpha1</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,
<argument><expr><specifier>const</specifier> <name>float</name> <name><name>X_low</name><index>[<expr><literal type="number">32</literal></expr>]</index><index>[<expr><literal type="number">40</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>temp0</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>, <decl><type ref="prev"/><name>temp4</name></decl>, <decl><type ref="prev"/><name>temp5</name></decl>, <decl><type ref="prev"/><name>temp6</name></decl>, <decl><type ref="prev"/><name>temp7</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>phi1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>alpha_1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>alpha_0</name></decl>, <decl><type ref="prev"/><name>res1</name></decl>, <decl><type ref="prev"/><name>res2</name></decl>, <decl><type ref="prev"/><name>temp_real</name></decl>, <decl><type ref="prev"/><name>temp_im</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">1.000001f</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>k0</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>phi</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">3</literal></expr>]</index></expr></argument>, <argument><expr><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>dk</name></decl>;</decl_stmt>
<expr_stmt><expr><name>phi1</name> <operator>=</operator> <operator>&amp;</operator><name><name>phi</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>alpha_1</name> <operator>=</operator> <operator>&amp;</operator><name><name>alpha1</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>alpha_0</name> <operator>=</operator> <operator>&amp;</operator><name><name>alpha0</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>dsp</name><operator>-&gt;</operator><name>autocorrelate</name></name><argument_list>(<argument><expr><name><name>X_low</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp0], 40(%[phi1]) \n\t"
"lwc1 %[temp1], 16(%[phi1]) \n\t"
"lwc1 %[temp2], 24(%[phi1]) \n\t"
"lwc1 %[temp3], 28(%[phi1]) \n\t"
"mul.s %[dk], %[temp0], %[temp1] \n\t"
"lwc1 %[temp4], 0(%[phi1]) \n\t"
"mul.s %[res2], %[temp2], %[temp2] \n\t"
"lwc1 %[temp5], 4(%[phi1]) \n\t"
"madd.s %[res2], %[res2], %[temp3], %[temp3] \n\t"
"lwc1 %[temp6], 8(%[phi1]) \n\t"
"div.s %[res2], %[res2], %[c] \n\t"
"lwc1 %[temp0], 12(%[phi1]) \n\t"
"sub.s %[dk], %[dk], %[res2] \n\t"

: [temp0]"=&amp;f"(temp0), [temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[temp3]"=&amp;f"(temp3), [temp4]"=&amp;f"(temp4), [temp5]"=&amp;f"(temp5),
[temp6]"=&amp;f"(temp6), [res2]"=&amp;f"(res2), [dk]"=&amp;f"(dk)
: [phi1]"r"(phi1), [c]"f"(c)
: "memory"
);</asm>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dk</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>alpha_1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha_1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"mul.s %[temp_real], %[temp4], %[temp2] \n\t"
"nmsub.s %[temp_real], %[temp_real], %[temp5], %[temp3] \n\t"
"nmsub.s %[temp_real], %[temp_real], %[temp6], %[temp1] \n\t"
"mul.s %[temp_im], %[temp4], %[temp3] \n\t"
"madd.s %[temp_im], %[temp_im], %[temp5], %[temp2] \n\t"
"nmsub.s %[temp_im], %[temp_im], %[temp0], %[temp1] \n\t"
"div.s %[temp_real], %[temp_real], %[dk] \n\t"
"div.s %[temp_im], %[temp_im], %[dk] \n\t"
"swc1 %[temp_real], 0(%[alpha_1]) \n\t"
"swc1 %[temp_im], 4(%[alpha_1]) \n\t"

: [temp_real]"=&amp;f" (temp_real), [temp_im]"=&amp;f"(temp_im)
: [phi1]"r"(phi1), [temp0]"f"(temp0), [temp1]"f"(temp1),
[temp2]"f"(temp2), [temp3]"f"(temp3), [temp4]"f"(temp4),
[temp5]"f"(temp5), [temp6]"f"(temp6),
[alpha_1]"r"(alpha_1), [dk]"f"(dk)
: "memory"
);</asm>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>phi1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>alpha_0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha_0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp6], 0(%[alpha_1]) \n\t"
"lwc1 %[temp7], 4(%[alpha_1]) \n\t"
"mul.s %[temp_real], %[temp6], %[temp2] \n\t"
"add.s %[temp_real], %[temp_real], %[temp4] \n\t"
"madd.s %[temp_real], %[temp_real], %[temp7], %[temp3] \n\t"
"mul.s %[temp_im], %[temp7], %[temp2] \n\t"
"add.s %[temp_im], %[temp_im], %[temp5] \n\t"
"nmsub.s %[temp_im], %[temp_im], %[temp6], %[temp3] \n\t"
"div.s %[temp_real], %[temp_real], %[temp1] \n\t"
"div.s %[temp_im], %[temp_im], %[temp1] \n\t"
"neg.s %[temp_real], %[temp_real] \n\t"
"neg.s %[temp_im], %[temp_im] \n\t"
"swc1 %[temp_real], 0(%[alpha_0]) \n\t"
"swc1 %[temp_im], 4(%[alpha_0]) \n\t"

: [temp_real]"=&amp;f"(temp_real), [temp_im]"=&amp;f"(temp_im),
[temp6]"=&amp;f"(temp6), [temp7]"=&amp;f"(temp7),
[res1]"=&amp;f"(res1), [res2]"=&amp;f"(res2)
: [alpha_1]"r"(alpha_1), [alpha_0]"r"(alpha_0),
[temp0]"f"(temp0), [temp1]"f"(temp1), [temp2]"f"(temp2),
[temp3]"f"(temp3), [temp4]"f"(temp4), [temp5]"f"(temp5)
: "memory"
);</asm>
</block_content>}</block></else></if_stmt>

<asm>__asm__ <specifier>volatile</specifier> (
"lwc1 %[temp1], 0(%[alpha_1]) \n\t"
"lwc1 %[temp2], 4(%[alpha_1]) \n\t"
"lwc1 %[temp_real], 0(%[alpha_0]) \n\t"
"lwc1 %[temp_im], 4(%[alpha_0]) \n\t"
"mul.s %[res1], %[temp1], %[temp1] \n\t"
"madd.s %[res1], %[res1], %[temp2], %[temp2] \n\t"
"mul.s %[res2], %[temp_real], %[temp_real] \n\t"
"madd.s %[res2], %[res2], %[temp_im], %[temp_im] \n\t"

: [temp_real]"=&amp;f"(temp_real), [temp_im]"=&amp;f"(temp_im),
[temp1]"=&amp;f"(temp1), [temp2]"=&amp;f"(temp2),
[res1]"=&amp;f"(res1), [res2]"=&amp;f"(res2)
: [alpha_1]"r"(alpha_1), [alpha_0]"r"(alpha_0)
: "memory"
);</asm>

<if_stmt><if>if <condition>(<expr><name>res1</name> <operator>&gt;=</operator> <literal type="number">16.0f</literal> <operator>||</operator> <name>res2</name> <operator>&gt;=</operator> <literal type="number">16.0f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>alpha_1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha_1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha_0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>alpha_0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>void</name></type> <name>ff_aacsbr_func_ptr_init_mips</name><parameter_list>(<parameter><decl><type><name>AACSBRContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_INLINE_ASM</name></expr></cpp:if>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sbr_lf_gen</name></name> <operator>=</operator> <name>sbr_lf_gen_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sbr_x_gen</name></name> <operator>=</operator> <name>sbr_x_gen_mips</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sbr_hf_inverse_filter</name></name> <operator>=</operator> <name>sbr_hf_inverse_filter_mips</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sbr_hf_assemble</name></name> <operator>=</operator> <name>sbr_hf_assemble_mips</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</block_content>}</block></function>
</unit>
