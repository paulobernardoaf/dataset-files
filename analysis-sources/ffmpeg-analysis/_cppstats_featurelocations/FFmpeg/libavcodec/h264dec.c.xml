<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\h264dec.c">


























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNCHECKED_BITSTREAM_READER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/display.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/imgutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/stereo3d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytestream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cabac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cabac_functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"error_resilience.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264dec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2645_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264chroma.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264_mvpred.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264_ps.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"golomb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hwaccel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mathops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"me_cmp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpegutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"profiles.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rectangle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name></type> <name><name>ff_h264_mb_sizes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">256</literal></expr>, <expr><literal type="number">384</literal></expr>, <expr><literal type="number">512</literal></expr>, <expr><literal type="number">768</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>avpriv_h264_has_num_reorder_frames</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>h</name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr> ?</condition><then> <expr><name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>num_reorder_frames</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>h264_er_decode_mb</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque</name></expr></argument>, <argument><expr><name>int</name> <name>ref</name></expr></argument>, <argument><expr><name>int</name> <name>mv_dir</name></expr></argument>, <argument><expr><name>int</name> <name>mv_type</name></expr></argument>,
<argument><expr><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><name>mv</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,
<argument><expr><name>int</name> <name>mb_x</name></expr></argument>, <argument><expr><name>int</name> <name>mb_y</name></expr></argument>, <argument><expr><name>int</name> <name>mb_intra</name></expr></argument>, <argument><expr><name>int</name> <name>mb_skipped</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>=</operator> <name>mb_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>=</operator> <name>mb_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name> <operator>=</operator> <name>mb_x</name> <operator>+</operator> <name>mb_y</name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>non_zero_count_cache</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>non_zero_count_cache</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>ref</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Reference not available for error concealing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>reference</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Reference invalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fill_rectangle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>ref_index</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_rectangle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fill_rectangle</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>mv_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
<argument><expr><call><name>pack16to32</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>mv</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>mv</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>mb_mbaff</name></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>mb_field_decoding_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_hl_decode_mb</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>ff_h264_draw_horiz_band</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vshift</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>field_pic</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>picture_structure</name></name> <operator>!=</operator> <name>PICT_FRAME</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>field_pic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>height</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>height</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>height</name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>-</operator> <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>field_pic</name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>first_field</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>slice_flags</name></name> <operator>&amp;</operator> <name>SLICE_FLAG_ALLOW_FIELD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>draw_horiz_band</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>offset</name><index>[<expr><name>AV_NUM_DATA_POINTERS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>offset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>y</name> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>offset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>offset</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>&gt;&gt;</operator> <name>vshift</name><operator>)</operator> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AV_NUM_DATA_POINTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>draw_horiz_band</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>picture_structure</name></name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ff_h264_free_tables</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>intra4x4_pred_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>chroma_pred_mode_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cbp_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>direct_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>non_zero_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_table_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>list_counts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>mb2b_xy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>mb2br_xy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>qscale_table_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>mb_type_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>motion_val_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ref_index_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>dc_val_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>mb_index2xy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>error_status_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>er_temp_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>bipred_scratchpad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>top_borders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>top_borders</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>bipred_scratchpad_allocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>edge_emu_buffer_allocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>top_borders_allocated</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>top_borders_allocated</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_h264_alloc_tables</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>big_mb_num</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>*</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>row_mb_num</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name><operator>*</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<macro><name>FF_ALLOCZ_ARRAY_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;intra4x4_pred_mode</argument>,
<argument>row_mb_num</argument>, <argument><literal type="number">8</literal> * sizeof(uint8_t)</argument>, <argument>fail</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>intra4x4_pred_mode</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>intra4x4_pred_mode</name></name></expr>;</expr_stmt>

<macro><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;non_zero_count</argument>,
<argument>big_mb_num * <literal type="number">48</literal> * sizeof(uint8_t)</argument>, <argument>fail</argument>)</argument_list></macro>
<macro><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;slice_table_base</argument>,
<argument>(big_mb_num + h-&gt;mb_stride) * sizeof(*h-&gt;slice_table_base)</argument>, <argument>fail</argument>)</argument_list></macro>
<macro><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;cbp_table</argument>,
<argument>big_mb_num * sizeof(uint16_t)</argument>, <argument>fail</argument>)</argument_list></macro>
<macro><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;chroma_pred_mode_table</argument>,
<argument>big_mb_num * sizeof(uint8_t)</argument>, <argument>fail</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>FF_ALLOCZ_ARRAY_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>row_mb_num</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FF_ALLOCZ_ARRAY_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>row_mb_num</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>mvd_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>mvd_table</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>direct_table</name></name></expr></argument>,
<argument><expr><literal type="number">4</literal> <operator>*</operator> <name>big_mb_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument>h-&gt;avctx</argument>, <argument>h-&gt;list_counts</argument>,
<argument>big_mb_num * sizeof(uint8_t)</argument>, <argument>fail</argument>)</argument_list></macro>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>slice_table_base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><operator>(</operator><name>big_mb_num</name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>h</name><operator>-&gt;</operator><name>slice_table_base</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_table</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>slice_table_base</name></name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb2b_xy</name></name></expr></argument>,
<argument><expr><name>big_mb_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb2br_xy</name></name></expr></argument>,
<argument><expr><name>big_mb_num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mb_xy</name> <init>= <expr><name>x</name> <operator>+</operator> <name>y</name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_xy</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name>x</name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name>y</name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>b_stride</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>mb2b_xy</name><index>[<expr><name>mb_xy</name></expr>]</index></name> <operator>=</operator> <name>b_xy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>mb2br_xy</name><index>[<expr><name>mb_xy</name></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>FMO</name></expr> ?</condition><then> <expr><name>mb_xy</name></expr> </then><else>: <expr><operator>(</operator><name>mb_xy</name> <operator>%</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>ff_h264_free_tables</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>ff_h264_slice_context_init</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ERContext</name> <modifier>*</modifier></type><name>er</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_array_size</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_size</name> <init>= <expr><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_size</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>*</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yc_size</name> <init>= <expr><name>y_size</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>c_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PART_NOT_AVAILABLE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sl</name> <operator>!=</operator> <name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>er</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>er</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else
if <condition>(<expr><name>CONFIG_ERROR_RESILIENCE</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>decode_mb</name></name> <operator>=</operator> <name>h264_er_decode_mb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>quarter_sample</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_num</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_width</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>b8_stride</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>er</name><operator>-&gt;</operator><name>mb_index2xy</name></name></expr></argument>,
<argument><expr><operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>mb_num</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_index2xy</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>]</index></name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>y</name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>mb_index2xy</name><index>[<expr><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>er</name><operator>-&gt;</operator><name>error_status_table</name></name></expr></argument>,
<argument><expr><name>mb_array_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOC_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>er</name><operator>-&gt;</operator><name>er_temp_buffer</name></name></expr></argument>,
<argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>*</operator> <operator>(</operator><literal type="number">4</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>dc_val_base</name></name></expr></argument>,
<argument><expr><name>yc_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>dc_val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>dc_val_base</name></name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>dc_val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>dc_val_base</name></name> <operator>+</operator> <name>y_size</name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>er</name><operator>-&gt;</operator><name>dc_val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>er</name><operator>-&gt;</operator><name>dc_val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>c_size</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yc_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>dc_val_base</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>h264_init_context</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_chroma_format_idc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>width_from_caller</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>height_from_caller</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>picture_structure</name></name> <operator>=</operator> <name>PICT_FRAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>workaround_bugs</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>workaround_bugs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_poc_msb</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>recovery_frame</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>frame_recovered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_frame_num</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>arrangement_cancel_flag</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>unregistered</name><operator>.</operator><name>x264_build</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next_outputed_poc</name></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_DELAYED_PIC_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>last_pocs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>ff_h264_sei_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_SLICE</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>H264_MAX_PICTURE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>f</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>h264</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>h264_decode_end</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_h264_remove_all_refs</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_free_tables</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>H264_MAX_PICTURE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_sei_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_ps_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h2645_packet_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>AVOnce</name></type> <name>h264_vlc_init</name> <init>= <expr><name>AV_ONCE_INIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>h264_decode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>h264_init_context</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_thread_once</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h264_vlc_init</name></expr></argument>, <argument><expr><name>ff_h264_decode_init_vlc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"pthread_once has failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_UNKNOWN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>ticks_per_frame</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name> <operator>&lt;</operator> <name>INT_MAX</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>ticks_per_frame</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h264_decode_extradata</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>,
<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>h264_decode_end</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>bitstream_restriction_flag</name></name> <operator>&amp;&amp;</operator>
<name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>has_b_frames</name></name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>num_reorder_frames</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>has_b_frames</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>num_reorder_frames</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>allocate_progress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_flush_change</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>enable_er</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_SLICE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>enable_er</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>enable_er</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_SLICE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Error resilience with slice threads is enabled. It is unsafe and unsupported and may crash. "</literal>
<literal type="string">"Use it at your own risk\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_THREADS</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_init_thread_copy</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>avctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>is_copy</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>h264_init_context</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>context_initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><specifier>static</specifier> <name>void</name></type> <name>idr</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_h264_remove_all_refs</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_frame_num</name></name> <operator>=</operator>
<name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_frame_num_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_poc_msb</name></name> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_poc_lsb</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_DELAYED_PIC_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>last_pocs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ff_h264_flush_change</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next_outputed_poc</name></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev_interlaced_frame</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>poc</name><operator>.</operator><name>prev_frame_num</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name><operator>-&gt;</operator><name>reference</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>first_field</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>recovery_frame</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>frame_recovered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>current_slice</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>mmco_reset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_dpb</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_flush_change</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_sei_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>H264_MAX_PICTURE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_free_tables</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>context_initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_last_needed_nal</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nals_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_slice</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nb_nals</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>





<switch>switch <condition>(<expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>H264_NAL_SPS</name></expr>:</case>
<case>case <expr><name>H264_NAL_PPS</name></expr>:</case>
<expr_stmt><expr><name>nals_needed</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>H264_NAL_DPA</name></expr>:</case>
<case>case <expr><name>H264_NAL_IDR_SLICE</name></expr>:</case>
<case>case <expr><name>H264_NAL_SLICE</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid zero-sized VCL NAL unit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call> <operator>||</operator> 
<operator>!</operator><name>first_slice</name> <operator>||</operator>
<name>first_slice</name> <operator>!=</operator> <name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nals_needed</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_slice</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_slice</name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>

<return>return <expr><name>nals_needed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>debug_green_metadata</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264SEIGreenMetaData</name> <modifier>*</modifier></type><name>gm</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>logctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Green Metadata Info SEI message\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" green_metadata_type: %d\n"</literal></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>green_metadata_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>green_metadata_type</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" green_metadata_period_type: %d\n"</literal></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>period_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>period_type</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" green_metadata_num_seconds: %d\n"</literal></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>num_seconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>period_type</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" green_metadata_num_pictures: %d\n"</literal></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>num_pictures</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" SEI GREEN Complexity Metrics: %f %f %f %f\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>gm</name><operator>-&gt;</operator><name>percent_non_zero_macroblocks</name></name><operator>/</operator><literal type="number">255</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>gm</name><operator>-&gt;</operator><name>percent_intra_coded_macroblocks</name></name><operator>/</operator><literal type="number">255</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>gm</name><operator>-&gt;</operator><name>percent_six_tap_filtering</name></name><operator>/</operator><literal type="number">255</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>gm</name><operator>-&gt;</operator><name>percent_alpha_point_deblocking_instance</name></name><operator>/</operator><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>green_metadata_type</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" xsd_metric_type: %d\n"</literal></expr></argument>, <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>xsd_metric_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>xsd_metric_type</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>logctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">" xsd_metric_value: %f\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>gm</name><operator>-&gt;</operator><name>xsd_metric_value</name></name><operator>/</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_nal_units</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>avctx</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nals_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>idr_cleared</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>has_slice</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nal_unit_type</name></name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_CHUNKS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>current_slice</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>first_field</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_h264_sei_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nal_length_size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf_size</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>buf_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if><if type="elseif">else if<condition>(<expr><name>buf_size</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>buf_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h2645_packet_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>,
<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_FAST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error splitting the input into NAL units.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_FRAME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nals_needed</name> <operator>=</operator> <call><name>get_last_needed_nal</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nals_needed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nals_needed</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nb_nals</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_slice_ctx</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_NONREF</name> <operator>&amp;&amp;</operator>
<name><name>nal</name><operator>-&gt;</operator><name>ref_idc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>nal</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>H264_NAL_SEI</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nal_ref_idc</name></name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>ref_idc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>H264_NAL_IDR_SLICE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>nal</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFC</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x98</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid inter IDR frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next_outputed_poc</name></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>idr_cleared</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>idr</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idr_cleared</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>has_recovery_point</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<case>case <expr><name>H264_NAL_SLICE</name></expr>:</case>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>has_slice</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>ff_h264_queue_decode_slice</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>nal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx_queued</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>current_slice</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_FRAME</name> <operator>&amp;&amp;</operator>
<name>i</name> <operator>&gt;=</operator> <name>nals_needed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>setup_finished</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_thread_finish_setup</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>setup_finished</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ret</name> <operator>=</operator> <call><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>start_frame</name></name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>max_slice_ctx</name> <operator>=</operator> <ternary><condition><expr><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx</name></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx_queued</name></name> <operator>==</operator> <name>max_slice_ctx</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_slice</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx_queued</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h264_execute_decode_slices</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>H264_NAL_DPA</name></expr>:</case>
<case>case <expr><name>H264_NAL_DPB</name></expr>:</case>
<case>case <expr><name>H264_NAL_DPC</name></expr>:</case>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><literal type="string">"data partitioning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>H264_NAL_SEI</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h264_sei_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nal</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>has_recovery_point</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>has_recovery_point</name></name> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>recovery_point</name><operator>.</operator><name>recovery_frame_cnt</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>debug</name></name> <operator>&amp;</operator> <name>FF_DEBUG_GREEN_MD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>debug_green_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>green_metadata</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>H264_NAL_SPS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>tmp_gb</name> <init>= <expr><name><name>nal</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_h264_decode_seq_parameter_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_gb</name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>,
<argument><expr><literal type="string">"SPS decoding failure, trying again with the complete NAL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_gb</name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_h264_decode_seq_parameter_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_gb</name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ff_h264_decode_seq_parameter_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nal</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>H264_NAL_PPS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h264_decode_picture_parameter_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nal</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>size_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>H264_NAL_AUD</name></expr>:</case>
<case>case <expr><name>H264_NAL_END_SEQUENCE</name></expr>:</case>
<case>case <expr><name>H264_NAL_END_STREAM</name></expr>:</case>
<case>case <expr><name>H264_NAL_FILLER_DATA</name></expr>:</case>
<case>case <expr><name>H264_NAL_SPS_EXT</name></expr>:</case>
<case>case <expr><name>H264_NAL_AUXILIARY_SLICE</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Unknown NAL code: %d (%d bits)\n"</literal></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>size_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"decode_slice_header error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h264_execute_decode_slices</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>error_occurred</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>decode_error_flags</name></name> <operator>|=</operator> <name>FF_DECODE_ERROR_DECODE_SLICES</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_ERROR_RESILIENCE</name></expr></cpp:if>












<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FIELD_PICTURE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>current_slice</name></name> <operator>&amp;&amp;</operator>
<name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>SPS</name><operator>*</operator><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>sps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name> <operator>&amp;&amp;</operator>
<name><name>h</name><operator>-&gt;</operator><name>enable_er</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_last_pic</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_h264_set_erpic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>cur_pic</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_last_pic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_h264_set_erpic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>last_pic</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>parent</name> <operator>=</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>linesize</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>linesize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>linesize</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>reference</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name><operator>.</operator><name>reference</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_h264_set_erpic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>last_pic</name></name></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_h264_set_erpic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>last_pic</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_h264_set_erpic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>next_pic</name></name></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>er</name><operator>.</operator><name>ref_count</name></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>ref_count</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_er_frame_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>er</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>use_last_pic</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>ref_list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>droppable</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>has_slice</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_thread_report_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>,
<argument><expr><name><name>h</name><operator>-&gt;</operator><name>picture_structure</name></name> <operator>==</operator> <name>PICT_BOTTOM_FIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ret</name></expr> </then><else>: <expr><name>buf_size</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>get_consumed_bytes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">10</literal> <operator>&gt;</operator> <name>buf_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>buf_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>output_frame</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>srcp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>srcp</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_frame_ref</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"stereo_mode"</literal></expr></argument>, <argument><expr><call><name>ff_h264_sei_stereo_mode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>srcp</name><operator>-&gt;</operator><name>sei_recovery_frame_cnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>key_frame</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_extra</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name><init>= <expr><name><name>buf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x1f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name><init>= <expr><name>buf</name><operator>+</operator><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cnt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>cnt</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nalsize</name><init>= <expr><call><name>AV_RB16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>nalsize</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <operator>(</operator><name>p</name><operator>-</operator><name>buf</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x9F</literal><operator>)</operator> <operator>!=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nalsize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cnt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>cnt</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nalsize</name><init>= <expr><call><name>AV_RB16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>nalsize</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <operator>(</operator><name>p</name><operator>-</operator><name>buf</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x9F</literal><operator>)</operator> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nalsize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>finalize_frame</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_OUTPUT_CORRUPT</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
<name><name>out</name><operator>-&gt;</operator><name>recovered</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>field_poc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INT_MAX</name> <operator>||</operator>
<name><name>out</name><operator>-&gt;</operator><name>field_poc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INT_MAX</name><operator>)</operator></expr>
)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>field</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>field_poc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>dst_data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>linesizes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>src_data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Duplicating field %d to fill missing\n"</literal></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>dst_data</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>p</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>field</name><operator>^</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>f</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>p</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src_data</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>p</name></expr>]</index></name> <operator>+</operator> <name>field</name> <operator>*</operator><name><name>f</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>p</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>linesizes</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name><name>f</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>p</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>av_image_copy</name><argument_list>(<argument><expr><name>dst_data</name></expr></argument>, <argument><expr><name>linesizes</name></expr></argument>, <argument><expr><name>src_data</name></expr></argument>, <argument><expr><name>linesizes</name></expr></argument>,
<argument><expr><name><name>f</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>height</name></name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>output_frame</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>CONFIG_MPEGVIDEO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_print_debug_info2</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>out</name><operator>-&gt;</operator><name>mb_type</name></name></expr></argument>,
<argument><expr><name><name>out</name><operator>-&gt;</operator><name>qscale_table</name></name></expr></argument>,
<argument><expr><name><name>out</name><operator>-&gt;</operator><name>motion_val</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb_width</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>mb_stride</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>send_next_delayed_frame</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst_frame</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>out_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>first_field</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>out_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init>
<condition><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>f</name><operator>-&gt;</operator><name>key_frame</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>mmco_reset</name></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>poc</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>poc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>out_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>out_idx</name></expr>;</init> <condition><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>delayed_pic</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>reference</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DELAYED_PIC_REF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>finalize_frame</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>dst_frame</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>got_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>buf_index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>h264_decode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_size</name> <init>= <expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>pict</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>setup_finished</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>nb_slice_ctx_queued</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>buf_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>send_next_delayed_frame</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>pict</name></expr></argument>, <argument><expr><name>got_frame</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name> <operator>&amp;&amp;</operator> <call><name>av_packet_get_side_data</name><argument_list>(<argument><expr><name>avpkt</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_NEW_EXTRADATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>side_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>side</name> <init>= <expr><call><name>av_packet_get_side_data</name><argument_list>(<argument><expr><name>avpkt</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_NEW_EXTRADATA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>side_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_extra</name><argument_list>(<argument><expr><name>side</name></expr></argument>, <argument><expr><name>side_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_h264_decode_extradata</name><argument_list>(<argument><expr><name>side</name></expr></argument>, <argument><expr><name>side_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>,
<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name> <operator>&amp;&amp;</operator> <name>buf_size</name> <operator>&gt;=</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xFC</literal><operator>)</operator><operator>==</operator><literal type="number">0xFC</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_extra</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ff_h264_decode_extradata</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>is_avc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>,
<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf_index</name> <operator>=</operator> <call><name>decode_nal_units</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>H264_NAL_END_SEQUENCE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>buf_index</name> <operator>&lt;=</operator> <name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>send_next_delayed_frame</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>pict</name></expr></argument>, <argument><expr><name>got_frame</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_CHUNKS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic_ptr</name></name> <operator>||</operator> <operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>has_slice</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_NONREF</name> <operator>||</operator>
<name>buf_size</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"Q264"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>buf_size</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"no frame!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>flags2</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG2_CHUNKS</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>&gt;=</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>mb_height</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_h264_field_end</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>slice_ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>next_output_pic</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>finalize_frame</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>pict</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>next_output_pic</name></name></expr></argument>, <argument><expr><name>got_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name><name>pict</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>got_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264_unref_picture</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>last_pic_for_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>get_consumed_bytes</name><argument_list>(<argument><expr><name>buf_index</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(H264Context, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VD</name></cpp:macro> <cpp:value>AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>h264_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"is_avc"</literal></expr>, <expr><literal type="string">"is avc"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>is_avc</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"nal_length_size"</literal></expr>, <expr><literal type="string">"nal_length_size"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>nal_length_size</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"enable_er"</literal></expr>, <expr><literal type="string">"Enable error resilience on damaged frames (unsafe)"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>enable_er</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{ <expr><operator>.</operator><name>i64</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> }</block></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>VD</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"x264_build"</literal></expr>, <expr><literal type="string">"Assume this x264 version if no x264 version found in any SEI"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>x264_build</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>h264_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"H264 Decoder"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>h264_options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_h264_decoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"h264"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_H264</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>H264Context</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>h264_decode_init</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>h264_decode_end</name></expr>,
<expr><operator>.</operator><name>decode</name> <operator>=</operator> <name>h264_decode_frame</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_DR1</name> <operator>|</operator>
<name>AV_CODEC_CAP_DELAY</name> <operator>|</operator> <name>AV_CODEC_CAP_SLICE_THREADS</name> <operator>|</operator>
<name>AV_CODEC_CAP_FRAME_THREADS</name></expr>,
<expr><operator>.</operator><name>hw_configs</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>AVCodecHWConfigInternal</name><operator>*</operator><index>[]</index><operator>)</operator> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_DXVA2_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_DXVA2</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_D3D11VA_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_D3D11VA</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_D3D11VA2_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_D3D11VA2</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_NVDEC_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_NVDEC</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_VAAPI_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VAAPI</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_VDPAU_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VDPAU</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_H264_VIDEOTOOLBOX_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VIDEOTOOLBOX</name><argument_list>(<argument><expr><name>h264</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name> <operator>|</operator> <name>FF_CODEC_CAP_EXPORTS_CROPPING</name></expr>,
<expr><operator>.</operator><name>flush</name> <operator>=</operator> <name>flush_dpb</name></expr>,
<expr><operator>.</operator><name>init_thread_copy</name> <operator>=</operator> <call><name>ONLY_IF_THREADS_ENABLED</name><argument_list>(<argument><expr><name>decode_init_thread_copy</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>update_thread_context</name> <operator>=</operator> <call><name>ONLY_IF_THREADS_ENABLED</name><argument_list>(<argument><expr><name>ff_h264_update_thread_context</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>profiles</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><name>ff_h264_profiles</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>h264_class</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
