<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\dca_core.c">



















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dcaadpcm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dcadec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dcadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dcahuff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dcamath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dca_syncwords.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ARCH_ARM</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arm/dca.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>HeaderType</name> <block>{
<decl><name>HEADER_CORE</name></decl>,
<decl><name>HEADER_XCH</name></decl>,
<decl><name>HEADER_XXCH</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int8_t</name></type> <name><name>prm_ch_to_spkr_map</name><index>[<expr><name>DCA_AMODE_COUNT</name></expr>]</index><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>DCA_SPEAKER_C</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_C</name></expr>, <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr> , <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><name>DCA_SPEAKER_Cs</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_C</name></expr>, <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr> , <expr><name>DCA_SPEAKER_Cs</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><name>DCA_SPEAKER_Ls</name></expr>, <expr><name>DCA_SPEAKER_Rs</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DCA_SPEAKER_C</name></expr>, <expr><name>DCA_SPEAKER_L</name></expr>, <expr><name>DCA_SPEAKER_R</name></expr>, <expr><name>DCA_SPEAKER_Ls</name></expr>, <expr><name>DCA_SPEAKER_Rs</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>audio_mode_ch_mask</name><index>[<expr><name>DCA_AMODE_COUNT</name></expr>]</index></name> <init>= <expr><block>{
<expr><name>DCA_SPEAKER_LAYOUT_MONO</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_STEREO</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_STEREO</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_STEREO</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_STEREO</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_3_0</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_2_1</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_3_1</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_2_2</name></expr>,
<expr><name>DCA_SPEAKER_LAYOUT_5POINT0</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>block_code_nbits</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">7</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">19</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dca_get_vlc</name><parameter_list>(<parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DCAVLC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>get_vlc2</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vlc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>table</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>vlc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bits</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>max_depth</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>v</name><operator>-&gt;</operator><name>offset</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_array</name><parameter_list>(<parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_sbits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_frame_header</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DCACoreFrameHeader</name></type> <name>h</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>ff_dca_parse_core_frame_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DCA_PARSE_ERROR_DEFICIT_SAMPLES</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Deficit samples are not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name><name>h</name><operator>.</operator><name>normal_frame</name></name></expr> ?</condition><then> <expr><name>AVERROR_INVALIDDATA</name></expr> </then><else>: <expr><name>AVERROR_PATCHWELCOME</name></expr></else></ternary></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_PCM_BLOCKS</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported number of PCM sample blocks (%d)\n"</literal></expr></argument>, <argument><expr><name><name>h</name><operator>.</operator><name>npcmblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>h</name><operator>.</operator><name>npcmblocks</name></name> <operator>&lt;</operator> <literal type="number">6</literal> <operator>||</operator> <name><name>h</name><operator>.</operator><name>normal_frame</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>AVERROR_INVALIDDATA</name></expr> </then><else>: <expr><name>AVERROR_PATCHWELCOME</name></expr></else></ternary></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_FRAME_SIZE</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid core frame size (%d bytes)\n"</literal></expr></argument>, <argument><expr><name><name>h</name><operator>.</operator><name>frame_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_AMODE</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported audio channel arrangement (%d)\n"</literal></expr></argument>, <argument><expr><name><name>h</name><operator>.</operator><name>audio_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_SAMPLE_RATE</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid core audio sampling frequency\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_RESERVED_BIT</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reserved bit set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_LFE_FLAG</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid low frequency effects flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

<case>case <expr><name>DCA_PARSE_ERROR_PCM_RES</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid source PCM resolution\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown core frame header error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>crc_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>crc_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>npcmblocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>frame_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>audio_mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>avpriv_dca_sample_rates</name><index>[<expr><name><name>h</name><operator>.</operator><name>sr_code</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>=</operator> <name><name>ff_dca_bit_rates</name><index>[<expr><name><name>h</name><operator>.</operator><name>br_code</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>drc_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>drc_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ts_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>ts_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>aux_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>aux_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_type</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>ext_audio_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>ext_audio_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sync_ssf</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>sync_ssf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>lfe_present</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>predictor_history</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>predictor_history</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>filter_perfect</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>filter_perfect</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>source_pcm_res</name></name> <operator>=</operator> <name><name>ff_dca_bits_per_sample</name><index>[<expr><name><name>h</name><operator>.</operator><name>pcmr_code</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>es_format</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>pcmr_code</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sumdiff_front</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>sumdiff_front</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sumdiff_surround</name></name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>sumdiff_surround</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_coding_header</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>HeaderType</name></name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>nchannels</name></decl>, <decl><type ref="prev"/><name>header_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>header</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HEADER_CORE</name></expr>:</case>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nsubframes</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>!=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid number of primary audio channels (%d) for audio channel arrangement (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>&lt;=</operator> <name>DCA_CHANNELS</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>=</operator> <name><name>audio_mode_ch_mask</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>|=</operator> <name>DCA_SPEAKER_MASK_LFE1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>HEADER_XCH</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>&lt;=</operator> <name>DCA_CHANNELS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>|=</operator> <name>DCA_SPEAKER_MASK_Cs</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>HEADER_XXCH</name></expr>:</case>

<expr_stmt><expr><name>header_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_crc_present</name></name>
<operator>&amp;&amp;</operator> <call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH channel set header checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>nchannels</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nchannels</name> <operator>&gt;</operator> <name>DCA_XXCH_CHANNELS_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"%d XXCH channels"</literal></expr></argument>, <argument><expr><name>nchannels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name> <operator>+</operator> <name>nchannels</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>&lt;=</operator> <name>DCA_CHANNELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name> <operator>-</operator> <name>DCA_SPEAKER_Cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name> <operator>=</operator> <name>mask</name> <operator>&lt;&lt;</operator> <name>DCA_SPEAKER_Cs</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>av_popcount</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nchannels</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH speaker layout mask (%#x)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XXCH speaker layout mask (%#x) overlaps with core (%#x)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>|</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>coeff_ptr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_coeff</name></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_embedded</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal> <operator>-</operator> <name>FF_DCA_DMIXTABLE_OFFSET</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>FF_DCA_INV_DMIXTABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH downmix scale index (%d)\n"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_scale_inv</name></name> <operator>=</operator> <name><name>ff_dca_inv_dmixtable</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name><operator>)</operator> <operator>!=</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH downmix channel mapping mask (%#x)\n"</literal></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_mask</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_mask</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><operator>(</operator><name>code</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&amp;=</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>code</name> <operator>*</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>FF_DCA_DMIXTABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH downmix coefficient index (%d)\n"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>coeff_ptr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name><name>ff_dca_dmixtable</name><index>[<expr><name>index</name></expr>]</index></name> <operator>^</operator> <name>sign</name><operator>)</operator> <operator>-</operator> <name>sign</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>coeff_ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_embedded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<break>break;</break>
</block_content>}</block></switch>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&gt;</operator> <name>DCA_SUBBANDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid subband activity count\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>header</name> <operator>==</operator> <name>HEADER_XXCH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name>xch_base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid joint intensity coding index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid scale factor code book\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid bit allocation quantizer select\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>DCA_CODE_BOOKS</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant_index_sel</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>ff_dca_quant_index_sel_nbits</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>DCA_CODE_BOOKS</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>quant_index_sel</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ff_dca_quant_index_group_size</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_adj</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>ff_dca_scale_factor_adj</name><index>[<expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>header</name> <operator>==</operator> <name>HEADER_XXCH</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XXCH channel set header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>crc_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_scale</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>scale_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>scale_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>scale_size</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scale_table</name> <operator>=</operator> <name>ff_dca_scale_factor_quant7</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale_size</name> <operator>=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_scale_factor_quant7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>scale_table</name> <operator>=</operator> <name>ff_dca_scale_factor_quant6</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale_size</name> <operator>=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_scale_factor_quant6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>scale_index</name> <operator>+=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ff_dca_vlc_scale_factor</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>scale_index</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>sel</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>*</operator><name>scale_index</name> <operator>&gt;=</operator> <name>scale_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>scale_table</name><index>[<expr><operator>*</operator><name>scale_index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_joint_scale</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>scale_index</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>scale_index</name> <operator>=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ff_dca_vlc_scale_factor</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>scale_index</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>sel</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>scale_index</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>scale_index</name> <operator>&gt;=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_joint_scale_factors</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid joint scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>ff_dca_joint_scale_factors</name><index>[<expr><name>scale_index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_subframe_header</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sf</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>HeaderType</name></name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>header</name> <operator>==</operator> <name>HEADER_CORE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_vq_index</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>abits</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>abits</name> <operator>=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ff_dca_vlc_bit_allocation</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>abits</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>sel</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>&gt;</operator> <name>DCA_ABITS_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid bit allocation index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name>abits</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ff_dca_vlc_transition_mode</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scale_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scale_index</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scale_index</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scale_index</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid joint scale factor code book\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_ch</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_ch</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_joint_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>drc_present</name></name> <operator>&amp;&amp;</operator> <name>header</name> <operator>==</operator> <name>HEADER_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>crc_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>decode_blockcodes</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>decode_blockcodes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levels</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>audio</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>levels</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>div</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>DCA_SUBBAND_SAMPLES</name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>div</name> <operator>=</operator> <call><name>FASTDIV</name><argument_list>(<argument><expr><name>code1</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>audio</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>code1</name> <operator>-</operator> <name>div</name> <operator>*</operator> <name>levels</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>code1</name> <operator>=</operator> <name>div</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>DCA_SUBBAND_SAMPLES</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>div</name> <operator>=</operator> <call><name>FASTDIV</name><argument_list>(<argument><expr><name>code2</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>audio</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>code2</name> <operator>-</operator> <name>div</name> <operator>*</operator> <name>levels</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>code2</name> <operator>=</operator> <name>div</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>code1</name> <operator>|</operator> <name>code2</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_block_codes</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>audio</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>abits</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>code1</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>block_code_nbits</name><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>code2</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>block_code_nbits</name><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>levels</name> <init>= <expr><name><name>ff_dca_quant_levels</name><index>[<expr><name>abits</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>decode_blockcodes</name><argument_list>(<argument><expr><name>code1</name></expr></argument>, <argument><expr><name>code2</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to decode block code(s)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_huffman_codes</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>audio</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>abits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DCA_SUBBAND_SAMPLES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>audio</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ff_dca_vlc_quant_index</name><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>extract_audio</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>audio</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>abits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>abits</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>abits</name> <operator>&lt;=</operator> <name>DCA_ABITS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>audio</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>audio</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>&lt;=</operator> <name>DCA_CODE_BOOKS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>quant_index_sel</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <name><name>ff_dca_quant_index_group_size</name><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>parse_huffman_codes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>abits</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>&lt;=</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>parse_block_codes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>abits</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>get_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name></expr></argument>, <argument><expr><name>abits</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>inverse_adpcm</name><parameter_list>(<parameter><decl><type><name>int32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>subband_samples</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>vq_index</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int8_t</name> <modifier>*</modifier></type><name>prediction_mode</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>sb_start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sb_end</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ofs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>sb_start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sb_end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>prediction_mode</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pred_id</name> <init>= <expr><name><name>vq_index</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>subband_samples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>ofs</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>x</name> <init>= <expr><call><name>ff_dcaadpcm_predict</name><argument_list>(<argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>j</name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>clip23</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_subframe_audio</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sf</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>HeaderType</name></name></type> <name>header</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sub_pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lfe_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>audio</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ssf</name></decl>, <decl><type ref="prev"/><name>ofs</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>nsamples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>*</operator> <name>DCA_SUBBAND_SAMPLES</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sub_pos</name> <operator>+</operator> <name>nsamples</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Subband sample buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>vq_index</name><index>[<expr><name>DCA_SUBBANDS</name></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>vq_index</name><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>decode_hf</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name>vq_index</name></expr></argument>,
<argument><expr><name>ff_dca_high_freq_vq</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>*</operator><name>sub_pos</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name> <operator>&amp;&amp;</operator> <name>header</name> <operator>==</operator> <name>HEADER_CORE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>nlfesamples</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>nlfesamples</name> <operator>&lt;=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>audio</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>get_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>nlfesamples</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_scale_factor_quant7</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid LFE scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>ff_dca_scale_factor_quant7</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>mul23</name><argument_list>(<argument><expr><literal type="number">4697620</literal></expr></argument> , <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ofs</name> <operator>=</operator> <operator>*</operator><name>lfe_pos</name></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nlfesamples</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>ofs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name><index>[<expr><name>ofs</name></expr>]</index></name> <operator>=</operator> <call><name>clip23</name><argument_list>(<argument><expr><name><name>audio</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name>scale</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><operator>*</operator><name>lfe_pos</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>ssf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ofs</name> <operator>=</operator> <operator>*</operator><name>sub_pos</name></expr>;</init> <condition><expr><name>ssf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ssf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_vq_start</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>trans_ssf</name></decl>, <decl><type ref="prev"/><name>abits</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>step_size</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>extract_audio</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>abits</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step_size</name> <operator>=</operator> <name><name>ff_dca_lossless_quant</name><index>[<expr><name>abits</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>step_size</name> <operator>=</operator> <name><name>ff_dca_lossy_quant</name><index>[<expr><name>abits</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>trans_ssf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>trans_ssf</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ssf</name> <operator>&lt;</operator> <name>trans_ssf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>adj</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_adj</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>abits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>clip23</name><argument_list>(<argument><expr><name>adj</name> <operator>*</operator> <name>scale</name> <operator>&gt;&gt;</operator> <literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_dca_core_dequantize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>+</operator> <name>ofs</name></expr></argument>,
<argument><expr><name>audio</name></expr></argument>, <argument><expr><name>step_size</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssf</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>sync_ssf</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"DSYNC check failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>DCA_SUBBAND_SAMPLES</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>inverse_adpcm</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_vq_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>*</operator><name>sub_pos</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_ch</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_ch</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>decode_joint</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_factors</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>sub_pos</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>*</operator><name>sub_pos</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>erase_adpcm_history</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>DCA_CHANNELS</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>AV_ZERO128</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_sample_buffer</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nchsamples</name> <init>= <expr><name>DCA_ADPCM_COEFFS</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nframesamples</name> <init>= <expr><name>nchsamples</name> <operator>*</operator> <name>DCA_CHANNELS</name> <operator>*</operator> <name>DCA_SUBBANDS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlfesamples</name> <init>= <expr><name>DCA_LFE_HISTORY</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>subband_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>av_fast_mallocz</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>subband_size</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>nframesamples</name> <operator>+</operator> <name>nlfesamples</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_size</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>DCA_CHANNELS</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name> <operator>+</operator>
<operator>(</operator><name>ch</name> <operator>*</operator> <name>DCA_SUBBANDS</name> <operator>+</operator> <name>band</name><operator>)</operator> <operator>*</operator> <name>nchsamples</name> <operator>+</operator> <name>DCA_ADPCM_COEFFS</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name> <operator>+</operator> <name>nframesamples</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>predictor_history</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>erase_adpcm_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_frame_data</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>HeaderType</name></name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sf</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>sub_pos</name></decl>, <decl><type ref="prev"/><name>lfe_pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_coding_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>sf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sub_pos</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>lfe_pos</name> <operator>=</operator> <name>DCA_LFE_HISTORY</name></expr>;</init> <condition><expr><name>sf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubframes</name></name></expr>;</condition> <incr><expr><name>sf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_subframe_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_subframe_audio</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfe_pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nsubbands</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nsubbands</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>nsubbands</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>nsubbands</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><name>samples</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>DCA_ADPCM_COEFFS</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_xch_frame</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Cs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XCH with Cs speaker already present\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_frame_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>HEADER_XCH</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XCH frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_xxch_frame</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>xxch_nchsets</name></decl>, <decl><type ref="prev"/><name>xxch_frame_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>, <decl><type ref="prev"/><name>header_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DCA_SYNCWORD_XXCH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH sync word\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>header_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XXCH frame header checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_crc_present</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name> <operator>&lt;=</operator> <name>DCA_SPEAKER_Cs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid number of bits for XXCH speaker mask (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>xxch_nchsets</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xxch_nchsets</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"%d XXCH channel sets"</literal></expr></argument>, <argument><expr><name>xxch_nchsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>xxch_frame_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>=</operator> <call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>mask</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Ls</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Lss</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>DCA_SPEAKER_MASK_Ls</name><operator>)</operator> <operator>|</operator> <name>DCA_SPEAKER_MASK_Lss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Rs</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Rss</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>DCA_SPEAKER_MASK_Rs</name><operator>)</operator> <operator>|</operator> <name>DCA_SPEAKER_MASK_Rss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XXCH core speaker activity mask (%#x) disagrees with core (%#x)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XXCH frame header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_frame_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>HEADER_XXCH</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <name>xxch_frame_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XXCH channel set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_xbr_subframe</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xbr_base_ch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xbr_nchannels</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>xbr_nsubbands</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xbr_transition_mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sub_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_nabits</name><index>[<expr><name>DCA_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_bit_allocation</name><index>[<expr><name>DCA_CHANNELS</name></expr>]</index><index>[<expr><name>DCA_SUBBANDS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_scale_nbits</name><index>[<expr><name>DCA_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>xbr_scale_factors</name><index>[<expr><name>DCA_CHANNELS</name></expr>]</index><index>[<expr><name>DCA_SUBBANDS</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ssf</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>ofs</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sub_pos</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>*</operator> <name>DCA_SUBBAND_SAMPLES</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Subband sample buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xbr_base_ch</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>xbr_nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>xbr_nabits</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xbr_base_ch</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>xbr_nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>xbr_nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>xbr_bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>xbr_nabits</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>xbr_bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>&gt;</operator> <name>DCA_ABITS_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XBR bit allocation index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xbr_base_ch</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>xbr_nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>xbr_scale_nbits</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xbr_scale_nbits</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid number of bits for XBR scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xbr_base_ch</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>xbr_nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>scale_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scale_size</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scale_table</name> <operator>=</operator> <name>ff_dca_scale_factor_quant7</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale_size</name> <operator>=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_scale_factor_quant7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>scale_table</name> <operator>=</operator> <name>ff_dca_scale_factor_quant6</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale_size</name> <operator>=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>ff_dca_scale_factor_quant6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>xbr_nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>xbr_bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>scale_index</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>xbr_scale_nbits</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>scale_index</name> <operator>&gt;=</operator> <name>scale_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XBR scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>xbr_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>scale_table</name><index>[<expr><name>scale_index</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xbr_transition_mode</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scale_index</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>xbr_scale_nbits</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scale_index</name> <operator>&gt;=</operator> <name>scale_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XBR scale factor index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>xbr_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>scale_table</name><index>[<expr><name>scale_index</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ssf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ofs</name> <operator>=</operator> <operator>*</operator><name>sub_pos</name></expr>;</init> <condition><expr><name>ssf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ssf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xbr_base_ch</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>xbr_nchannels</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>xbr_nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>trans_ssf</name></decl>, <decl><type ref="prev"/><name>abits</name> <init>= <expr><name><name>xbr_bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>audio</name><index>[<expr><name>DCA_SUBBAND_SAMPLES</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name>step_size</name></decl>, <decl><type ref="prev"/><name>scale</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>&gt;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>get_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name></expr></argument>, <argument><expr><name>abits</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>abits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_block_codes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>abits</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>step_size</name> <operator>=</operator> <name><name>ff_dca_lossless_quant</name><index>[<expr><name>abits</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>xbr_transition_mode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>trans_ssf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transition_mode</name><index>[<expr><name>sf</name></expr>]</index><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>trans_ssf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>trans_ssf</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ssf</name> <operator>&lt;</operator> <name>trans_ssf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>xbr_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>xbr_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>ff_dca_core_dequantize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>+</operator> <name>ofs</name></expr></argument>,
<argument><expr><name>audio</name></expr></argument>, <argument><expr><name>step_size</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssf</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>sync_ssf</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XBR-DSYNC check failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>DCA_SUBBAND_SAMPLES</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>*</operator><name>sub_pos</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_xbr_frame</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_frame_size</name><index>[<expr><name>DCA_EXSS_CHSETS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_nchannels</name><index>[<expr><name>DCA_EXSS_CHSETS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>xbr_nsubbands</name><index>[<expr><name>DCA_EXSS_CHSETS_MAX</name> <operator>*</operator> <name>DCA_EXSS_CHANNELS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xbr_nchsets</name></decl>, <decl><type ref="prev"/><name>xbr_transition_mode</name></decl>, <decl><type ref="prev"/><name>xbr_band_nbits</name></decl>, <decl><type ref="prev"/><name>xbr_base_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ch1</name></decl>, <decl><type ref="prev"/><name>ch2</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>, <decl><type ref="prev"/><name>header_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DCA_SYNCWORD_XBR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XBR sync word\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>header_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid XBR frame header checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>xbr_nchsets</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xbr_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>xbr_frame_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><name>xbr_transition_mode</name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ch2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xbr_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>xbr_nchannels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>xbr_band_nbits</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ch1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch1</name> <operator>&lt;</operator> <name><name>xbr_nchannels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ch1</name><operator>++</operator></expr><operator>,</operator> <expr><name>ch2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>xbr_nsubbands</name><index>[<expr><name>ch2</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>xbr_band_nbits</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>xbr_nsubbands</name><index>[<expr><name>ch2</name></expr>]</index></name> <operator>&gt;</operator> <name>DCA_SUBBANDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid number of active XBR subbands (%d)\n"</literal></expr></argument>, <argument><expr><name><name>xbr_nsubbands</name><index>[<expr><name>ch2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XBR frame header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>xbr_base_ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xbr_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>header_pos</name> <operator>=</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xbr_base_ch</name> <operator>+</operator> <name><name>xbr_nchannels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sf</name></decl>, <decl><type ref="prev"/><name>sub_pos</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>sf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sub_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubframes</name></name></expr>;</condition> <incr><expr><name>sf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_xbr_subframe</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xbr_base_ch</name></expr></argument>,
<argument><expr><name>xbr_base_ch</name> <operator>+</operator> <name><name>xbr_nchannels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name>xbr_nsubbands</name></expr></argument>, <argument><expr><name>xbr_transition_mode</name></expr></argument>,
<argument><expr><name>sf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>xbr_base_ch</name> <operator>+=</operator> <name><name>xbr_nchannels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name><name>xbr_frame_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of XBR channel set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>rand_x96</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rand</name></name> <operator>=</operator> <literal type="number">1103515245U</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_rand</name></name> <operator>+</operator> <literal type="number">12345U</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>x96_rand</name></name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator> <operator>-</operator> <literal type="number">0x40000000</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_subframe_audio</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sub_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ssf</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>ofs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>nsamples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>*</operator> <name>DCA_SUBBAND_SAMPLES</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sub_pos</name> <operator>+</operator> <name>nsamples</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Subband sample buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>+</operator> <operator>*</operator><name>sub_pos</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>scale</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>band</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nsamples</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nsamples</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>samples</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>mul31</name><argument_list>(<argument><expr><call><name>rand_x96</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 
<for>for <control>(<init><expr><name>ssf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ssf</name> <operator>&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>ssf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name> <modifier>*</modifier></type><name>vq_samples</name> <init>= <expr><name><name>ff_dca_high_freq_vq</name><index>[<expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>nsamples</name> <operator>-</operator> <name>ssf</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>samples</name><operator>++</operator> <operator>=</operator> <call><name>clip23</name><argument_list>(<argument><expr><name><name>vq_samples</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name>scale</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ssf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ofs</name> <operator>=</operator> <operator>*</operator><name>sub_pos</name></expr>;</init> <condition><expr><name>ssf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ssf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>abits</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>audio</name><index>[<expr><name>DCA_SUBBAND_SAMPLES</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name>step_size</name></decl>, <decl><type ref="prev"/><name>scale</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>abits</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>extract_audio</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>, <argument><expr><name>abits</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step_size</name> <operator>=</operator> <name><name>ff_dca_lossless_quant</name><index>[<expr><name>abits</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>step_size</name> <operator>=</operator> <name><name>ff_dca_lossy_quant</name><index>[<expr><name>abits</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>band</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_dca_core_dequantize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>+</operator> <name>ofs</name></expr></argument>,
<argument><expr><name>audio</name></expr></argument>, <argument><expr><name>step_size</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DCA_SUBBAND_SAMPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssf</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubsubframes</name><index>[<expr><name>sf</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>sync_ssf</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"X96-DSYNC check failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>DCA_SUBBAND_SAMPLES</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>inverse_adpcm</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_vq_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>*</operator><name>sub_pos</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_ch</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_ch</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>decode_joint</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_factors</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>sub_pos</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>*</operator><name>sub_pos</name> <operator>=</operator> <name>ofs</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>erase_x96_adpcm_history</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>DCA_CHANNELS</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS_X96</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>AV_ZERO128</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_x96_sample_buffer</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nchsamples</name> <init>= <expr><name>DCA_ADPCM_COEFFS</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nframesamples</name> <init>= <expr><name>nchsamples</name> <operator>*</operator> <name>DCA_CHANNELS</name> <operator>*</operator> <name>DCA_SUBBANDS_X96</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>av_fast_mallocz</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>x96_subband_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>x96_subband_size</name></name></expr></argument>,
<argument><expr><name>nframesamples</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>x96_subband_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_size</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>DCA_CHANNELS</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS_X96</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_buffer</name></name> <operator>+</operator>
<operator>(</operator><name>ch</name> <operator>*</operator> <name>DCA_SUBBANDS_X96</name> <operator>+</operator> <name>band</name><operator>)</operator> <operator>*</operator> <name>nchsamples</name> <operator>+</operator> <name>DCA_ADPCM_COEFFS</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>predictor_history</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>erase_x96_adpcm_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_subframe_header</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prediction_mode</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prediction_vq_index</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>abits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>abits</name> <operator>+=</operator> <call><name>dca_get_vlc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ff_dca_vlc_quant_index</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_high_res</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>abits</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_high_res</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>abits</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>abits</name></expr></argument> &gt;</argument_list></name> <literal type="number">7</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_high_res</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 bit allocation index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name>abits</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scale_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scale_index</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>band</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 joint scale factor code book\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_ch</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_ch</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_sel</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>src_ch</name></expr>]</index></name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_joint_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_scale_factors</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>crc_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_coding_header</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exss</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>header_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exss</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>header_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_crc_present</name></name>
<operator>&amp;&amp;</operator> <call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 channel set header checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_high_res</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name> <operator>&gt;</operator> <literal type="number">27</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 subband start index (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name> <operator>=</operator> <name>DCA_SUBBANDS</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&lt;</operator> <name>DCA_SUBBANDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 subband activity count (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>xch_base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name>xch_base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 joint intensity coding index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>scale_factor_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 scale factor code book\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_allocation_sel</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_high_res</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>quant_index_sel</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>ff_dca_quant_index_sel_nbits</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>exss</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of X96 channel set header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>crc_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_frame_data</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exss</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xch_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sf</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>band</name></decl>, <decl><type ref="prev"/><name>sub_pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_coding_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>exss</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>sf</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sub_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sf</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nsubframes</name></name></expr>;</condition> <incr><expr><name>sf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_subframe_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_subframe_audio</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>xch_base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nsubbands</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nsubbands</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>nsubbands</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nsubbands</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>joint_intensity_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>band</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>band</name> <operator>&lt;</operator> <name>DCA_SUBBANDS_X96</name></expr>;</condition> <incr><expr><name>band</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index><index>[<expr><name>band</name></expr>]</index></name> <operator>-</operator> <name>DCA_ADPCM_COEFFS</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>band</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_subband_start</name></name> <operator>&amp;&amp;</operator> <name>band</name> <operator>&lt;</operator> <name>nsubbands</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><name>samples</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>DCA_ADPCM_COEFFS</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_frame</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 revision (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_crc_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>alloc_x96_sample_buffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_frame_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of X96 frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_x96_frame_exss</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>x96_frame_size</name><index>[<expr><name>DCA_EXSS_CHSETS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>x96_nchannels</name><index>[<expr><name>DCA_EXSS_CHSETS_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x96_nchsets</name></decl>, <decl><type ref="prev"/><name>x96_base_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>, <decl><type ref="prev"/><name>header_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DCA_SYNCWORD_X96</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 sync word\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>header_size</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 frame header checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid X96 revision (%d)\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rev_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_crc_present</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>x96_nchsets</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>x96_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>x96_frame_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>x96_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>x96_nchannels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>




<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name>header_size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of X96 frame header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>alloc_x96_sample_buffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>x96_base_ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>x96_nchsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>header_pos</name> <operator>=</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x96_base_ch</name> <operator>+</operator> <name><name>x96_nchannels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name> <operator>=</operator> <name>x96_base_ch</name> <operator>+</operator> <name><name>x96_nchannels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_frame_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>x96_base_ch</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x96_base_ch</name> <operator>+=</operator> <name><name>x96_nchannels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>header_pos</name> <operator>+</operator> <name><name>x96_frame_size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of X96 channel set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_aux_data</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>aux_pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>-</operator><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DCA_SYNCWORD_REV1AUX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid auxiliary data sync word\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aux_pos</name> <operator>=</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_embedded</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name> <operator>&gt;=</operator> <name>DCA_DMIX_TYPE_COUNT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid primary channel set downmix type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>ff_dca_dmix_primary_nch</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name> <operator>+</operator> <operator>!</operator><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>m</name> <operator>*</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><operator>(</operator><name>code</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><name>code</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>FF_DCA_DMIXTABLE_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid downmix coefficient index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_coeff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>ff_dca_dmixtable</name><index>[<expr><name>index</name></expr>]</index></name> <operator>^</operator> <name>sign</name><operator>)</operator> <operator>-</operator> <name>sign</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>-</operator><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ff_dca_check_crc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>aux_pos</name></expr></argument>, <argument><expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid auxiliary data checksum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_optional_info</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DCAContext</name> <modifier>*</modifier></type><name>dca</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ts_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>aux_present</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_aux_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_embedded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_present</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dca</name><operator>-&gt;</operator><name>core_only</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sync_pos</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>size_in_bits</name></name> <operator>/</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_pos</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>dist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>w1</name></decl>, <decl><type ref="prev"/><name>w2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DCA_EXT_AUDIO_XCH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dca</name><operator>-&gt;</operator><name>request_channel_layout</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>






<for>for <control>(<init>;</init> <condition><expr><name>sync_pos</name> <operator>&gt;=</operator> <name>last_pos</name></expr>;</condition> <incr><expr><name>sync_pos</name><operator>--</operator></expr><operator>,</operator> <expr><name>w2</name> <operator>=</operator> <name>w1</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w1</name> <operator>=</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>w1</name> <operator>==</operator> <name>DCA_SYNCWORD_XCH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>w2</name> <operator>&gt;&gt;</operator> <literal type="number">22</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>-</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">96</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>size</name> <operator>==</operator> <name>dist</name> <operator>||</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal> <operator>==</operator> <name>dist</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>w2</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x08</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xch_pos</name></name> <operator>=</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">32</literal> <operator>+</operator> <literal type="number">49</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>xch_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XCH sync word not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>DCA_EXT_AUDIO_X96</name></expr>:</case>



<for>for <control>(<init>;</init> <condition><expr><name>sync_pos</name> <operator>&gt;=</operator> <name>last_pos</name></expr>;</condition> <incr><expr><name>sync_pos</name><operator>--</operator></expr><operator>,</operator> <expr><name>w2</name> <operator>=</operator> <name>w1</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w1</name> <operator>=</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>w1</name> <operator>==</operator> <name>DCA_SYNCWORD_X96</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>w2</name> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>-</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">96</literal> <operator>&amp;&amp;</operator> <name>size</name> <operator>==</operator> <name>dist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_pos</name></name> <operator>=</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">32</literal> <operator>+</operator> <literal type="number">44</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>x96_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"X96 sync word not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>DCA_EXT_AUDIO_XXCH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dca</name><operator>-&gt;</operator><name>request_channel_layout</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>



<for>for <control>(<init>;</init> <condition><expr><name>sync_pos</name> <operator>&gt;=</operator> <name>last_pos</name></expr>;</condition> <incr><expr><name>sync_pos</name><operator>--</operator></expr><operator>,</operator> <expr><name>w2</name> <operator>=</operator> <name>w1</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w1</name> <operator>=</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>w1</name> <operator>==</operator> <name>DCA_SYNCWORD_XXCH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>w2</name> <operator>&gt;&gt;</operator> <literal type="number">26</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dist</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>size_in_bits</name></name> <operator>/</operator> <literal type="number">8</literal> <operator>-</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">11</literal> <operator>&amp;&amp;</operator> <name>size</name> <operator>&lt;=</operator> <name>dist</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>av_crc</name><argument_list>(<argument><expr><name><name>dca</name><operator>-&gt;</operator><name>crctab</name></name></expr></argument>, <argument><expr><literal type="number">0xffff</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator>
<operator>(</operator><name>sync_pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_pos</name></name> <operator>=</operator> <name>sync_pos</name> <operator>*</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>xxch_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"XXCH sync word not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_dca_core_parse</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xch_pos</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_pos</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb_in</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_frame_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>alloc_sample_buffer</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_frame_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>HEADER_CORE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_optional_info</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ff_dca_seek_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read past end of core frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_dca_core_parse_exss</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>DCAExssAsset</name> <modifier>*</modifier></type><name>asset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DCAContext</name> <modifier>*</modifier></type><name>dca</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exss_mask</name> <init>= <expr><ternary><condition><expr><name>asset</name></expr> ?</condition><then> <expr><name><name>asset</name><operator>-&gt;</operator><name>extension_mask</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dca</name><operator>-&gt;</operator><name>request_channel_layout</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exss_mask</name> <operator>&amp;</operator> <name>DCA_EXSS_XXCH</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>asset</name><operator>-&gt;</operator><name>xxch_offset</name></name></expr></argument>, <argument><expr><name><name>asset</name><operator>-&gt;</operator><name>xxch_size</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_xxch_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext</name> <operator>=</operator> <name>DCA_EXSS_XXCH</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xxch_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_xxch_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext</name> <operator>=</operator> <name>DCA_CSS_XXCH</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xch_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xch_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_xch_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext</name> <operator>=</operator> <name>DCA_CSS_XCH</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>=</operator> <name><name>audio_mode_ch_mask</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>|=</operator> <name>DCA_SPEAKER_MASK_LFE1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>|=</operator> <name>ext</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>exss_mask</name> <operator>&amp;</operator> <name>DCA_EXSS_XBR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>asset</name><operator>-&gt;</operator><name>xbr_offset</name></name></expr></argument>, <argument><expr><name><name>asset</name><operator>-&gt;</operator><name>xbr_size</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_xbr_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>|=</operator> <name>DCA_EXSS_XBR</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dca</name><operator>-&gt;</operator><name>packet</name></name> <operator>&amp;</operator> <name>DCA_PACKET_XLL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exss_mask</name> <operator>&amp;</operator> <name>DCA_EXSS_X96</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>asset</name><operator>-&gt;</operator><name>x96_offset</name></name></expr></argument>, <argument><expr><name><name>asset</name><operator>-&gt;</operator><name>x96_size</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_frame_exss</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>|=</operator> <name>DCA_EXSS_X96</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_pos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>x96_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>parse_x96_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>|=</operator> <name>DCA_CSS_X96</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>map_prm_ch_to_spkr</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>spkr</name></decl>;</decl_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>spkr</name> <operator>=</operator> <name><name>prm_ch_to_spkr_map</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>spkr</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>spkr</name> <operator>==</operator> <name>DCA_SPEAKER_Ls</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Lss</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DCA_SPEAKER_Lss</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>spkr</name> <operator>==</operator> <name>DCA_SPEAKER_Rs</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <name>DCA_SPEAKER_MASK_Rss</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DCA_SPEAKER_Rss</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>spkr</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_CSS_XCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>ch</name> <operator>==</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DCA_SPEAKER_Cs</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <name>DCA_SPEAKER_Cs</name></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_spkr_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>pos</name><operator>++</operator> <operator>==</operator> <name>ch</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>spkr</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>


<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>erase_dsp_history</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_history_lfe_fixed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_history_lfe_float</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_filter_mode</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>filter_mode</name></name> <operator>!=</operator> <name>mode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>erase_dsp_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>filter_mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_dca_core_filter_fixed</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x96_synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>spkr</name></decl>, <decl><type ref="prev"/><name>nsamples</name></decl>, <decl><type ref="prev"/><name>x96_nchannels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name> <modifier>*</modifier></type><name>filter_coeff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>x96_synth</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_X96</name> <operator>|</operator> <name>DCA_EXSS_X96</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x96_nchannels</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x96_synth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>x96_synth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x96_synth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_rate</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>&lt;&lt;</operator> <name>x96_synth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>npcmsamples</name></name> <operator>=</operator> <name>nsamples</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>*</operator> <name>DCA_PCMBLOCK_SAMPLES</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>x96_synth</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>av_fast_malloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_size</name></name></expr></argument>,
<argument><expr><name>nsamples</name> <operator>*</operator> <call><name>av_popcount</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name>DCA_SPEAKER_COUNT</name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>nsamples</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>set_filter_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x96_synth</name> <operator>|</operator> <name>DCA_FILTER_MODE_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_64bands_fixed</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>filter_perfect</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_32bands_perfect_fixed</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_32bands_nonperfect_fixed</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>spkr</name> <operator>=</operator> <call><name>map_prm_ch_to_spkr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>spkr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>sub_qmf_fixed</name><index>[<expr><name>x96_synth</name></expr>]</index></name><operator>(</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name></name><operator>,</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dcadct</name></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name><operator>,</operator>
<ternary><condition><expr><name>ch</name> <operator>&lt;</operator> <name>x96_nchannels</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>fix</name><operator>.</operator><name>hist1</name></name><operator>,</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name>offset</name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>fix</name><operator>.</operator><name>hist2</name></name><operator>,</operator>
<name>filter_coeff</name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_LFE1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlfesamples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name> <operator>==</operator> <name>DCA_LFE_FLAG_128</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Fixed point mode doesn't support LFF=1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>samples</name> <operator>+=</operator> <name>nsamples</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>lfe_fir_fixed</name></name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name></name> <operator>+</operator> <name>DCA_LFE_HISTORY</name></expr></argument>,
<argument><expr><name>ff_dca_lfe_fir_64_fixed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>lfe_x96_fixed</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_LFE1</name></expr>]</index></name></expr></argument>,
<argument><expr><name>samples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_history_lfe_fixed</name></name></expr></argument>,
<argument><expr><name>nsamples</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>DCA_LFE_HISTORY</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name><index>[<expr><name>nlfesamples</name> <operator>+</operator> <name>n</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame_fixed</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DCAContext</name> <modifier>*</modifier></type><name>dca</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>spkr</name></decl>, <decl><type ref="prev"/><name>nsamples</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dca</name><operator>-&gt;</operator><name>packet</name></name> <operator>&amp;</operator> <name>DCA_PACKET_XLL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_dca_core_filter_fixed</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>output_rate</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_fmt</name></name> <operator>=</operator> <name>AV_SAMPLE_FMT_S32P</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bits_per_raw_sample</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>nb_samples</name></name> <operator>=</operator> <name>nsamples</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmsamples</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_get_buffer</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>es_format</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_CSS_XCH</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;=</operator> <name>DCA_AMODE_2F2R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>dmix_sub_xch</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Ls</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Rs</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Cs</name></expr>]</index></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_embedded</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>scale_inv</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_scale_inv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>coeff_ptr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_coeff</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xch_base</name> <init>= <expr><name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>-</operator> <name>xch_base</name> <operator>&lt;=</operator> <name>DCA_XXCH_CHANNELS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>dmix_scale_inv</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name>scale_inv</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_spkr</name> <init>= <expr><call><name>map_prm_ch_to_spkr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_spkr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_mask</name><index>[<expr><name>ch</name> <operator>-</operator> <name>xch_base</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coeff</name> <init>= <expr><call><name>mul16</name><argument_list>(<argument><expr><operator>*</operator><name>coeff_ptr</name><operator>++</operator></expr></argument>, <argument><expr><name>scale_inv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>coeff</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>dmix_sub</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>spkr</name></expr> ]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>src_spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name>coeff</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_CSS_XCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sumdiff_front</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;</operator> <name>DCA_AMODE_MONO</name><operator>)</operator>
<operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>==</operator> <name>DCA_AMODE_STEREO_SUMDIFF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>fixed_dsp</name><operator>-&gt;</operator><name>butterflies_fixed</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_L</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_R</name></expr>]</index></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sumdiff_surround</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;=</operator> <name>DCA_AMODE_2F2R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>fixed_dsp</name><operator>-&gt;</operator><name>butterflies_fixed</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Ls</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Rs</name></expr>]</index></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_dca_downmix_to_stereo_fixed</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_coeff</name></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>output_samples</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ch_remap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>plane</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>frame</name><operator>-&gt;</operator><name>extended_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nsamples</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>plane</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>clip23</name><argument_list>(<argument><expr><name><name>samples</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame_float</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x96_nchannels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>x96_synth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>spkr</name></decl>, <decl><type ref="prev"/><name>nsamples</name></decl>, <decl><type ref="prev"/><name>nchannels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_COUNT</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr> }</block></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>filter_coeff</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_X96</name> <operator>|</operator> <name>DCA_EXSS_X96</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x96_nchannels</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>x96_nchannels</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x96_synth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>&lt;&lt;</operator> <name>x96_synth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_fmt</name></name> <operator>=</operator> <name>AV_SAMPLE_FMT_FLTP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bits_per_raw_sample</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>nb_samples</name></name> <operator>=</operator> <name>nsamples</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>*</operator> <name>DCA_PCMBLOCK_SAMPLES</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>x96_synth</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_get_buffer</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>output_samples</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ch_remap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>frame</name><operator>-&gt;</operator><name>extended_data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><name>nchannels</name> <operator>=</operator> <call><name>av_popcount</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nchannels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_fast_malloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_size</name></name></expr></argument>,
<argument><expr><name>nsamples</name> <operator>*</operator> <name>nchannels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name>DCA_SPEAKER_COUNT</name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>nsamples</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>set_filter_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x96_synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_64bands</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>filter_perfect</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_32bands_perfect</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_fir_32bands_nonperfect</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>spkr</name> <operator>=</operator> <call><name>map_prm_ch_to_spkr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>spkr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>sub_qmf_float</name><index>[<expr><name>x96_synth</name></expr>]</index></name><operator>(</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name></name><operator>,</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>imdct</name><index>[<expr><name>x96_synth</name></expr>]</index></name><operator>,</operator>
<name><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name><operator>,</operator>
<ternary><condition><expr><name>ch</name> <operator>&lt;</operator> <name>x96_nchannels</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_samples</name><index>[<expr><name>ch</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>flt</name><operator>.</operator><name>hist1</name></name><operator>,</operator>
<operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name>offset</name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>dcadsp_data</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>flt</name><operator>.</operator><name>hist2</name></name><operator>,</operator>
<name>filter_coeff</name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name><operator>,</operator>
<literal type="number">1.0f</literal> <operator>/</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">17</literal> <operator>-</operator> <name>x96_synth</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>dec_select</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>lfe_present</name></name> <operator>==</operator> <name>DCA_LFE_FLAG_128</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>samples</name> <init>= <expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_LFE1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlfesamples</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>dec_select</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>samples</name> <operator>+=</operator> <name>nsamples</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>dec_select</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_lfe_fir_128</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>filter_coeff</name> <operator>=</operator> <name>ff_dca_lfe_fir_64</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>lfe_fir_float</name><index>[<expr><name>dec_select</name></expr>]</index></name><operator>(</operator>
<name>samples</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name></name> <operator>+</operator> <name>DCA_LFE_HISTORY</name><operator>,</operator>
<name>filter_coeff</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>npcmblocks</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x96_synth</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dcadsp</name><operator>-&gt;</operator><name>lfe_x96_float</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_LFE1</name></expr>]</index></name></expr></argument>,
<argument><expr><name>samples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_history_lfe_float</name></name></expr></argument>,
<argument><expr><name>nsamples</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>DCA_LFE_HISTORY</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name><index>[<expr><name>nlfesamples</name> <operator>+</operator> <name>n</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>es_format</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_CSS_XCH</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;=</operator> <name>DCA_AMODE_2F2R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>vector_fmac_scalar</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Ls</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Cs</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>-</operator><name>M_SQRT1_2</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>vector_fmac_scalar</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Rs</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Cs</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>-</operator><name>M_SQRT1_2</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_embedded</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>scale_inv</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_scale_inv</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>/</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>coeff_ptr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_coeff</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xch_base</name> <init>= <expr><name><name>ff_dca_channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name> <operator>-</operator> <name>xch_base</name> <operator>&lt;=</operator> <name>DCA_XXCH_CHANNELS_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name>xch_base</name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nchannels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>src_spkr</name> <init>= <expr><call><name>map_prm_ch_to_spkr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_spkr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_dmix_mask</name><index>[<expr><name>ch</name> <operator>-</operator> <name>xch_base</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coeff</name> <init>= <expr><operator>*</operator><name>coeff_ptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>coeff</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>vector_fmac_scalar</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[ <expr><name>spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>src_spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name>coeff</name> <operator>*</operator> <operator>(</operator><operator>-</operator><literal type="number">1.0f</literal> <operator>/</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">15</literal><operator>)</operator><operator>)</operator></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>spkr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>spkr</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xxch_mask_nbits</name></name></expr>;</condition> <incr><expr><name>spkr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xxch_core_mask</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>spkr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>vector_fmul_scalar</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>spkr</name></expr>]</index></name></expr></argument>,
<argument><expr><name>scale_inv</name></expr></argument>, <argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_CSS_XCH</name> <operator>|</operator> <name>DCA_EXSS_XXCH</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sumdiff_front</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;</operator> <name>DCA_AMODE_MONO</name><operator>)</operator>
<operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>==</operator> <name>DCA_AMODE_STEREO_SUMDIFF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>butterflies_float</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_L</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_R</name></expr>]</index></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sumdiff_surround</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;=</operator> <name>DCA_AMODE_2F2R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name><operator>-&gt;</operator><name>butterflies_float</name></name><argument_list>(<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Ls</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>output_samples</name><index>[<expr><name>DCA_SPEAKER_Rs</name></expr>]</index></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_dca_downmix_to_stereo_float</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name></name></expr></argument>, <argument><expr><name>output_samples</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_coeff</name></name></expr></argument>,
<argument><expr><name>nsamples</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_dca_core_filter_frame</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DCAContext</name> <modifier>*</modifier></type><name>dca</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DCAExssAsset</name> <modifier>*</modifier></type><name>asset</name> <init>= <expr><operator>&amp;</operator><name><name>dca</name><operator>-&gt;</operator><name>exss</name><operator>.</operator><name>assets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>AVMatrixEncoding</name></name></type> <name>matrix_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>dca</name><operator>-&gt;</operator><name>request_channel_layout</name></name> <operator>==</operator> <name>DCA_SPEAKER_LAYOUT_STEREO</name>
<operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>&gt;</operator> <name>DCA_AMODE_MONO</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>prim_dmix_embedded</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name> <operator>==</operator> <name>DCA_DMIX_TYPE_LoRo</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name> <operator>==</operator> <name>DCA_DMIX_TYPE_LtRt</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name> <operator>=</operator> <name>DCA_SPEAKER_LAYOUT_STEREO</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ff_dca_set_channel_layout</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ch_remap</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_CODEC_FLAG_BITEXACT</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>dca</name><operator>-&gt;</operator><name>packet</name></name> <operator>&amp;</operator> <name>DCA_PACKET_EXSS</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>asset</name><operator>-&gt;</operator><name>extension_mask</name></name> <operator>&amp;</operator> <name>DCA_EXSS_XLL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame_fixed</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame_float</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_EXSS_MASK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name>FF_PROFILE_DTS_HD_HRA</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>DCA_CSS_XXCH</name> <operator>|</operator> <name>DCA_CSS_XCH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name>FF_PROFILE_DTS_ES</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_CSS_X96</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name>FF_PROFILE_DTS_96_24</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name>FF_PROFILE_DTS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ext_audio_mask</name></name> <operator>&amp;</operator> <name>DCA_EXSS_MASK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>audio_mode</name></name> <operator>==</operator> <name>DCA_AMODE_STEREO_TOTAL</name> <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>request_mask</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ch_mask</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>prim_dmix_type</name></name> <operator>==</operator> <name>DCA_DMIX_TYPE_LtRt</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>matrix_encoding</name> <operator>=</operator> <name>AV_MATRIX_ENCODING_DOLBY</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>matrix_encoding</name> <operator>=</operator> <name>AV_MATRIX_ENCODING_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_side_data_update_matrix_encoding</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>matrix_encoding</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>av_cold</name> <name>void</name></type> <name>ff_dca_core_flush</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>erase_adpcm_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>lfe_samples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DCA_LFE_HISTORY</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>erase_x96_adpcm_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>erase_dsp_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>av_cold</name> <name>int</name></type> <name>ff_dca_core_init</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name></name> <operator>=</operator> <call><name>avpriv_float_dsp_alloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>fixed_dsp</name></name> <operator>=</operator> <call><name>avpriv_alloc_fixed_dsp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ff_dcadct_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dcadct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_mdct_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>imdct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_mdct_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>imdct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ff_synth_filter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_rand</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>av_cold</name> <name>void</name></type> <name>ff_dca_core_close</name><parameter_list>(<parameter><decl><type><name>DCACoreDecoder</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>float_dsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>fixed_dsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_mdct_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>imdct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_mdct_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>imdct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>subband_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subband_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>x96_subband_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>x96_subband_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
