<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\h264dec.h">


























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>AVCODEC_H264DEC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVCODEC_H264DEC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cabac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"error_resilience.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264_ps.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264_sei.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2645_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264chroma.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264dsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264pred.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264qpel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpegutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qpeldsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rectangle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"videodsp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H264_MAX_PICTURE_COUNT</name></cpp:macro> <cpp:value>36</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MMCO_COUNT</name></cpp:macro> <cpp:value>66</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DELAYED_PIC_COUNT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOW_INTERLACE</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FMO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SLICES</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALLOW_INTERLACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_MBAFF</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(h)-&gt;mb_mbaff</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_FIELD</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sl)-&gt;mb_field_decoding_flag</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_MBAFF</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(h)-&gt;mb_aff_frame</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_PICTURE</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((h)-&gt;picture_structure != PICT_FRAME)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_MBS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTOP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LBOT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(i)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_MBAFF</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_FIELD</name><parameter_list>(<parameter><type><name>sl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_MBAFF</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_PICTURE</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INTERLACED</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INTERLACED</name><parameter_list>(<parameter><type><name>mb_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_MBS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTOP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LBOT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_OR_MBAFF_PICTURE</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FRAME_MBAFF(h) || FIELD_PICTURE(h))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CABAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CABAC</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(h)-&gt;ps.pps-&gt;cabac</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHROMA</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((h)-&gt;ps.sps-&gt;chroma_format_idc)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHROMA422</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((h)-&gt;ps.sps-&gt;chroma_format_idc == 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHROMA444</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((h)-&gt;ps.sps-&gt;chroma_format_idc == 3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_TYPE_REF0</name></cpp:macro> <cpp:value>MB_TYPE_ACPRED</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_TYPE_8x8DCT</name></cpp:macro> <cpp:value>0x01000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_REF0</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &amp; MB_TYPE_REF0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_8x8DCT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &amp; MB_TYPE_8x8DCT)</cpp:value></cpp:define>




<typedef>typedef <type><enum>enum <name>MMCOOpcode</name> <block>{
<decl><name>MMCO_END</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>MMCO_SHORT2UNUSED</name></decl>,
<decl><name>MMCO_LONG2UNUSED</name></decl>,
<decl><name>MMCO_SHORT2LONG</name></decl>,
<decl><name>MMCO_SET_MAX_LONG</name></decl>,
<decl><name>MMCO_RESET</name></decl>,
<decl><name>MMCO_LONG</name></decl>,
}</block></enum></type> <name>MMCOOpcode</name>;</typedef>




<typedef>typedef <type><struct>struct <name>MMCO</name> <block>{
<decl_stmt><decl><type><name>MMCOOpcode</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>short_pic_num</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>long_arg</name></decl>;</decl_stmt> 
}</block></struct></type> <name>MMCO</name>;</typedef>

<typedef>typedef <type><struct>struct <name>H264Picture</name> <block>{
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ThreadFrame</name></type> <name>tf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>qscale_table_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>qscale_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name><name>motion_val_buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>int16_t</name> <argument_list>(<argument><expr><operator>*</operator><name><name>motion_val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>

<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>mb_type_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>mb_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>hwaccel_priv_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hwaccel_picture_private</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name><name>ref_index_buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name><name>ref_index</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>field_poc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>poc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>frame_num</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mmco_reset</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>pic_id</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>long_ref</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>ref_poc</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>ref_count</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mbaff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>field_picture</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>reference</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>recovered</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>invalid_gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sei_recovery_frame_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>H264Picture</name>;</typedef>

<typedef>typedef <type><struct>struct <name>H264Ref</name> <block>{
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>linesize</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reference</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>poc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
}</block></struct></type> <name>H264Ref</name>;</typedef>

<typedef>typedef <type><struct>struct <name>H264SliceContext</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>H264Context</name></name> <modifier>*</modifier></type><name>h264</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ERContext</name></type> <name>er</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>slice_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_type_nos</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>slice_type_fixed</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qscale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>chroma_qp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>qp_thresh</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>last_qscale_diff</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>deblocking_filter</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>slice_alpha_c0_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_beta_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264PredWeightTable</name></type> <name>pwt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_mb_skipped</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next_mb_skipped</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chroma_pred_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>intra16x16_pred_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int8_t</name></type> <name><name>intra4x4_pred_mode_cache</name><index>[<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>int8_t</name><argument_list>(<argument><expr><operator>*</operator><name>intra4x4_pred_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>topleft_mb_xy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top_mb_xy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>topright_mb_xy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>left_mb_xy</name><index>[<expr><name>LEFT_MBS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>topleft_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>topright_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>left_type</name><index>[<expr><name>LEFT_MBS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>left_block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>topleft_partition</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>topleft_samples_available</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>top_samples_available</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>topright_samples_available</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>left_samples_available</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>linesize</name></decl>, <name>uvlinesize</name>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>mb_linesize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>mb_uvlinesize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mb_x</name></decl>, <name>mb_y</name>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_xy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>resync_mb_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>resync_mb_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>first_mb_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>next_slice_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_skip_run</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_complex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>picture_structure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_field_decoding_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_mbaff</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>redundant_pic_count</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>neighbor_transform_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>direct_spatial_mv_pred</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col_parity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col_fieldoff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top_cbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>left_cbp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>dist_scale_factor</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>dist_scale_factor_field</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>map_col_to_list0</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>map_col_to_list0_field</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>ref_count</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>list_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Ref</name></type> <name><name>ref_list</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">48</literal></expr>]</index></name></decl>;</decl_stmt> 


<struct>struct <block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name></decl>;</decl_stmt>
}</block> <decl><name><name>ref_modifications</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><name>int</name></type> <name><name>nb_ref_modifications</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pps_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>intra_pcm_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>dc_val_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bipred_scratchpad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>edge_emu_buffer</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>uint8_t</name> <argument_list>(<argument><expr><operator>*</operator><name><name>top_borders</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><operator>(</operator><literal type="number">16</literal> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bipred_scratchpad_allocated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edge_emu_buffer_allocated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>top_borders_allocated</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>





<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>non_zero_count_cache</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></expr>;</expr_stmt>




<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>mv_cache</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><name>ref_cache</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>mvd_cache</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>direct_cache</name><index>[<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>uint16_t</name></expr></argument>, <argument><expr><name>sub_mb_type</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">4</literal></expr>]</index></expr>;</expr_stmt>


<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">48</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>mb_luma_dc</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>


<decl_stmt><decl><type><name>int16_t</name></type> <name><name>mb_padding</name><index>[<expr><literal type="number">256</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>uint8_t</name> <argument_list>(<argument><expr><operator>*</operator><name><name>mvd_table</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>




<decl_stmt><decl><type><name>CABACContext</name></type> <name>cabac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>cabac_state</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cabac_init_idc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MMCO</name></type> <name><name>mmco</name><index>[<expr><name>MAX_MMCO_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_mmco</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>explicit_ref_marking</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>frame_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>poc_lsb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta_poc_bottom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>delta_poc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_pic_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_pic_num</name></decl>;</decl_stmt>
}</block></struct></type> <name>H264SliceContext</name>;</typedef>




<typedef>typedef <type><struct>struct <name>H264Context</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VideoDSPContext</name></type> <name>vdsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264DSPContext</name></type> <name>h264dsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264ChromaContext</name></type> <name>h264chroma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264QpelContext</name></type> <name>h264qpel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264Picture</name></type> <name><name>DPB</name><index>[<expr><name>H264_MAX_PICTURE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>cur_pic_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name></type> <name>cur_pic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name></type> <name>last_pic_for_ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>slice_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_slice_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_slice_ctx_queued</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H2645Packet</name></type> <name>pkt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pixel_shift</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>, <name>height</name>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_x_shift</name></decl>, <name>chroma_y_shift</name>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>droppable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>coded_picture_number</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>context_initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>workaround_bugs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x264_build</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>postpone_filter</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>picture_idr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>crop_left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>crop_right</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>crop_top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>crop_bottom</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>int8_t</name><argument_list>(<argument><expr><operator>*</operator><name>intra4x4_pred_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>H264PredContext</name></type> <name>hpc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>uint8_t</name> <argument_list>(<argument><expr><operator>*</operator><name>non_zero_count</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">48</literal></expr>]</index></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_NOT_USED</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PART_NOT_AVAILABLE</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>





<decl_stmt><decl><type><name>int</name></type> <name><name>block_offset</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><literal type="number">16</literal> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>mb2b_xy</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>mb2br_xy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_stride</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>slice_table</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>mb_aff_frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>picture_structure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_field</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>list_counts</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>cbp_table</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>chroma_pred_mode_table</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>uint8_t</name> <argument_list>(<argument><expr><operator>*</operator><name><name>mvd_table</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>direct_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>scan_padding</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan8x8</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan8x8_cavlc</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan8x8</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan8x8_cavlc</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan_q0</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan8x8_q0</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>zigzag_scan8x8_cavlc_q0</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan_q0</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan8x8_q0</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>field_scan8x8_cavlc_q0</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mb_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_height</name></decl>, <name>mb_width</name>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_stride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mb_num</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>nal_ref_idc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nal_unit_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_slice</name></decl>;</decl_stmt> 




<decl_stmt><decl><type><name>int</name></type> <name>is_avc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>nal_length_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>bit_depth_luma</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>chroma_format_idc</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>H264ParamSets</name></type> <name>ps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>slice_table_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264POCContext</name></type> <name>poc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264Ref</name></type> <name><name>default_ref</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name><name>short_ref</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name><name>long_ref</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name><name>delayed_pic</name><index>[<expr><name>MAX_DELAYED_PIC_COUNT</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>last_pocs</name><index>[<expr><name>MAX_DELAYED_PIC_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>next_output_pic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next_outputed_poc</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>MMCO</name></type> <name><name>mmco</name><index>[<expr><name>MAX_MMCO_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_mmco</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mmco_reset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>explicit_ref_marking</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>long_ref_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>short_ref_count</name></decl>;</decl_stmt> 








<decl_stmt><decl><type><name>int</name></type> <name>current_slice</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>int</name></type> <name>prev_interlaced_frame</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>valid_recovery_point</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>int</name></type> <name>recovery_frame</name></decl>;</decl_stmt>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_RECOVERED_IDR</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_RECOVERED_SEI</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>frame_recovered</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>has_recovery_point</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>missing_fields</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>setup_finished</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cur_chroma_format_idc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cur_bit_depth_luma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>slice_row</name><index>[<expr><name>MAX_SLICES</name></expr>]</index></name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>int</name></type> <name>width_from_caller</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height_from_caller</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>enable_er</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264SEIContext</name></type> <name>sei</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVBufferPool</name> <modifier>*</modifier></type><name>qscale_table_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVBufferPool</name> <modifier>*</modifier></type><name>mb_type_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVBufferPool</name> <modifier>*</modifier></type><name>motion_val_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVBufferPool</name> <modifier>*</modifier></type><name>ref_index_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ref2frm</name><index>[<expr><name>MAX_SLICES</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>H264Context</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>ff_h264_mb_sizes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>




<function_decl><type><name>int</name></type> <name>ff_h264_get_slice_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>int</name></type> <name>ff_h264_alloc_tables</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_h264_decode_ref_pic_list_reordering</name><parameter_list>(<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>logctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ff_h264_build_ref_list</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_remove_all_refs</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>int</name></type> <name>ff_h264_execute_ref_pic_marking</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_h264_decode_ref_pic_marking</name><parameter_list>(<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>logctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_hl_decode_mb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_decode_init_vlc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>int</name></type> <name>ff_h264_decode_mb_cavlc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>int</name></type> <name>ff_h264_decode_mb_cabac</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_init_cabac_states</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_direct_dist_scale_factor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier><specifier>const</specifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_direct_ref_list_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier><specifier>const</specifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_pred_direct_motion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier><specifier>const</specifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mb_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_filter_mb_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_y</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_y</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_cb</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_cr</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>linesize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>uvlinesize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_filter_mb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_y</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_y</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_cb</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>img_cr</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>linesize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>uvlinesize</name></decl></parameter>)</parameter_list>;</function_decl>































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUMA_DC_BLOCK_INDEX</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHROMA_DC_BLOCK_INDEX</name></cpp:macro> <cpp:value>49</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>scan8</name><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">6</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">6</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">7</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">7</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">6</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">6</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">7</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">7</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">9</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">9</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">9</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">9</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">11</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">11</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">11</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">11</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">13</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">13</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">14</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">5</literal> <operator>+</operator> <literal type="number">14</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">13</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">13</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">14</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">14</literal> <operator>*</operator> <literal type="number">8</literal></expr>,
<expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">0</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">5</literal> <operator>*</operator> <literal type="number">8</literal></expr>, <expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">10</literal> <operator>*</operator> <literal type="number">8</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>uint32_t</name></type> <name>pack16to32</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>
<return>return <expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>a</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>b</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>uint16_t</name></type> <name>pack8to16</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>
<return>return <expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>a</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>b</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>get_chroma_qp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PPS</name> <modifier>*</modifier></type><name>pps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>pps</name><operator>-&gt;</operator><name>chroma_qp_table</name><index>[<expr><name>t</name></expr>]</index><index>[<expr><name>qscale</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>pred_intra_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index8</name> <init>= <expr><name><name>scan8</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>left</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>intra4x4_pred_mode_cache</name><index>[<expr><name>index8</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>top</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>intra4x4_pred_mode_cache</name><index>[<expr><name>index8</name> <operator>-</operator> <literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_tlog</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"mode:%d %d min:%d\n"</literal></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DC_PRED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>min</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>write_back_intra_pred_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>i4x4</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>intra4x4_pred_mode</name></name> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>mb2br_xy</name><index>[<expr><name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>i4x4_cache</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>intra4x4_pred_mode_cache</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><name>i4x4</name></expr></argument>, <argument><expr><name>i4x4_cache</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i4x4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>i4x4_cache</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i4x4</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>i4x4_cache</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i4x4</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>i4x4_cache</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>write_back_non_zero_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mb_xy</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>nnz</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>non_zero_count</name><index>[<expr><name>mb_xy</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>nnz_cache</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>non_zero_count_cache</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>h</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nnz</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nnz_cache</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">14</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>write_back_motion_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>b_stride</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>b_xy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b8_xy</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>mb_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>int16_t</name><argument_list>(<argument><expr><operator>*</operator><name>mv_dst</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>motion_val</name><index>[<expr><name>list</name></expr>]</index><index>[<expr><name>b_xy</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>int16_t</name><argument_list>(<argument><expr><operator>*</operator><name>mv_src</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>mv_cache</name><index>[<expr><name>list</name></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>mv_dst</name> <operator>+</operator> <literal type="number">0</literal> <operator>*</operator> <name>b_stride</name></expr></argument>, <argument><expr><name>mv_src</name> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>mv_dst</name> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <name>b_stride</name></expr></argument>, <argument><expr><name>mv_src</name> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>mv_dst</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>b_stride</name></expr></argument>, <argument><expr><name>mv_src</name> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY128</name><argument_list>(<argument><expr><name>mv_dst</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>b_stride</name></expr></argument>, <argument><expr><name>mv_src</name> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CABAC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>uint8_t</name> <argument_list>(<argument><expr><operator>*</operator><name>mvd_dst</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>mvd_table</name><index>[<expr><name>list</name></expr>]</index><index>[<expr><ternary><condition><expr><name>FMO</name></expr> ?</condition><then> <expr><literal type="number">8</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr>
</then><else>: <expr><name><name>h</name><operator>-&gt;</operator><name>mb2br_xy</name><index>[<expr><name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr>]</index></name></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uint8_t</name><argument_list>(<argument><expr><operator>*</operator><name>mvd_src</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>mvd_cache</name><index>[<expr><name>list</name></expr>]</index><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_SKIP</name><argument_list>(<argument><expr><name>mb_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AV_ZERO128</name><argument_list>(<argument><expr><name>mvd_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>AV_COPY64</name><argument_list>(<argument><expr><name>mvd_dst</name></expr></argument>, <argument><expr><name>mvd_src</name> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY16</name><argument_list>(<argument><expr><name>mvd_dst</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>mvd_src</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY16</name><argument_list>(<argument><expr><name>mvd_dst</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mvd_src</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_COPY16</name><argument_list>(<argument><expr><name>mvd_dst</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>mvd_src</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>ref_index</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>ref_index</name><index>[<expr><name>list</name></expr>]</index><index>[<expr><name>b8_xy</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>ref_cache</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>ref_cache</name><index>[<expr><name>list</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ref_index</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">0</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ref_cache</name><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref_index</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">0</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ref_cache</name><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref_index</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ref_cache</name><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref_index</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ref_cache</name><index>[<expr><name><name>scan8</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>write_back_motion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>mb_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_stride</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>b_stride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_xy</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>b_stride</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b8_xy</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>USES_LIST</name><argument_list>(<argument><expr><name>mb_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>write_back_motion_list</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>, <argument><expr><name>b_stride</name></expr></argument>, <argument><expr><name>b_xy</name></expr></argument>, <argument><expr><name>b8_xy</name></expr></argument>, <argument><expr><name>mb_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fill_rectangle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>cur_pic</name><operator>.</operator><name>ref_index</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>b8_xy</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name>LIST_NOT_USED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>USES_LIST</name><argument_list>(<argument><expr><name>mb_type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_back_motion_list</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>, <argument><expr><name>b_stride</name></expr></argument>, <argument><expr><name>b_xy</name></expr></argument>, <argument><expr><name>b8_xy</name></expr></argument>, <argument><expr><name>mb_type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>slice_type_nos</name></name> <operator>==</operator> <name>AV_PICTURE_TYPE_B</name> <operator>&amp;&amp;</operator> <call><name>CABAC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_8X8</name><argument_list>(<argument><expr><name>mb_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>direct_table</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>direct_table</name><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name><name>sl</name><operator>-&gt;</operator><name>mb_xy</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>direct_table</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>sub_mb_type</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>direct_table</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>sub_mb_type</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>direct_table</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>sub_mb_type</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>get_dct8x8_allowed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>direct_8x8_inference_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><operator>(</operator><call><name>AV_RN64A</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>sub_mb_type</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator>
<operator>(</operator><operator>(</operator><name>MB_TYPE_16x8</name> <operator>|</operator> <name>MB_TYPE_8x16</name> <operator>|</operator> <name>MB_TYPE_8x8</name><operator>)</operator> <operator>*</operator>
<literal type="number">0x0001000100010001ULL</literal><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><operator>(</operator><call><name>AV_RN64A</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>sub_mb_type</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator>
<operator>(</operator><operator>(</operator><name>MB_TYPE_16x8</name> <operator>|</operator> <name>MB_TYPE_8x16</name> <operator>|</operator> <name>MB_TYPE_8x8</name> <operator>|</operator> <name>MB_TYPE_DIRECT2</name><operator>)</operator> <operator>*</operator>
<literal type="number">0x0001000100010001ULL</literal><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>find_start_code</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>buf_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>next_avc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>state</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buf_index</name> <operator>=</operator> <call><name>avpriv_find_start_code</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>buf_index</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>next_avc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>buf</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>buf_index</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>ff_h264_field_end</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_setup</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_h264_ref_picture</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ff_h264_unref_picture</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>pic</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_h264_slice_context_init</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_draw_horiz_band</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>H264SliceContext</name> <modifier>*</modifier></type><name>sl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>int</name></type> <name>ff_h264_queue_decode_slice</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ff_h264_execute_decode_slices</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ff_h264_update_thread_context</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVCodecContext</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_flush_change</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_free_tables</name><parameter_list>(<parameter><decl><type><name>H264Context</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_h264_set_erpic</name><parameter_list>(<parameter><decl><type><name>ERPicture</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>H264Picture</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
