<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\hevcdec.c">
























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/attributes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/display.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mastering_display_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/stereo3d.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bswapdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytestream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cabac_functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"golomb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevc_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevc_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevcdec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hwaccel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"profiles.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>ff_hevc_pel_weight</name><index>[<expr><literal type="number">65</literal></expr>]</index></name> <init>= <expr><block>{ <expr><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><index>[<expr><literal type="number">4</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>, <expr><index>[<expr><literal type="number">6</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>, <expr><index>[<expr><literal type="number">8</literal></expr>]</index> <operator>=</operator> <literal type="number">3</literal></expr>, <expr><index>[<expr><literal type="number">12</literal></expr>]</index> <operator>=</operator> <literal type="number">4</literal></expr>, <expr><index>[<expr><literal type="number">16</literal></expr>]</index> <operator>=</operator> <literal type="number">5</literal></expr>, <expr><index>[<expr><literal type="number">24</literal></expr>]</index> <operator>=</operator> <literal type="number">6</literal></expr>, <expr><index>[<expr><literal type="number">32</literal></expr>]</index> <operator>=</operator> <literal type="number">7</literal></expr>, <expr><index>[<expr><literal type="number">48</literal></expr>]</index> <operator>=</operator> <literal type="number">8</literal></expr>, <expr><index>[<expr><literal type="number">64</literal></expr>]</index> <operator>=</operator> <literal type="number">9</literal></expr> }</block></expr></init></decl>;</decl_stmt>











<function><type><specifier>static</specifier> <name>void</name></type> <name>pic_arrays_free</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sao</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>deblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ct_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>cbf_luma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>is_pcm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>qp_y_tab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>filter_slice_edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>horizontal_bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>vertical_bs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_mvf_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_buffer_pool_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>rpl_tab_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>pic_arrays_init</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>log2_min_cb_size</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_size_in_ctb</name> <init>= <expr><operator>(</operator><operator>(</operator><name>width</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<operator>(</operator><operator>(</operator><name>height</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_count</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>*</operator> <name><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_pu_size</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name> <operator>*</operator> <name><name>sps</name><operator>-&gt;</operator><name>min_pu_height</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bs_width</name></name> <operator>=</operator> <operator>(</operator><name>width</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bs_height</name></name> <operator>=</operator> <operator>(</operator><name>height</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sao</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name>ctb_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>sao</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>deblock</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name>ctb_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>deblock</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sao</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>deblock</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_cb_height</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_cb_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_ct_depth</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_cb_height</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_cb_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ct_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cbf_luma</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_tb_width</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_tb_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name>min_pu_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_pcm</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>min_pu_height</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>cbf_luma</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_pcm</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>filter_slice_edges</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name>ctb_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>pic_size_in_ctb</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>qp_y_tab</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>pic_size_in_ctb</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>qp_y_tab</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>qp_y_tab</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>filter_slice_edges</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>horizontal_bs</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vertical_bs</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>horizontal_bs</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>vertical_bs</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_mvf_pool</name></name> <operator>=</operator> <call><name>av_buffer_pool_init</name><argument_list>(<argument><expr><name>min_pu_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MvField</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>av_buffer_allocz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rpl_tab_pool</name></name> <operator>=</operator> <call><name>av_buffer_pool_init</name><argument_list>(<argument><expr><name>ctb_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RefPicListTab</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>av_buffer_allocz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>tab_mvf_pool</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>rpl_tab_pool</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>pic_arrays_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pred_weight_table</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>luma_weight_l0_flag</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>chroma_weight_l0_flag</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>luma_weight_l1_flag</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>chroma_weight_l1_flag</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>luma_log2_weight_denom</name></decl>;</decl_stmt>

<expr_stmt><expr><name>luma_log2_weight_denom</name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>luma_log2_weight_denom</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>luma_log2_weight_denom</name></expr></argument> &gt;</argument_list></name> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"luma_log2_weight_denom %d is invalid\n"</literal></expr></argument>, <argument><expr><name>luma_log2_weight_denom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name> <operator>=</operator> <call><name>av_clip_uintp2</name><argument_list>(<argument><expr><name>luma_log2_weight_denom</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>chroma_log2_weight_denom</name> <init>= <expr><name>luma_log2_weight_denom</name> <operator>+</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chroma_log2_weight_denom</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>chroma_log2_weight_denom</name></expr></argument> &gt;</argument_list></name> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"chroma_log2_weight_denom %"</literal><name>PRId64</name><literal type="string">" is invalid\n"</literal></expr></argument>, <argument><expr><name>chroma_log2_weight_denom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name> <operator>=</operator> <name>chroma_log2_weight_denom</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>luma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>luma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>chroma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>chroma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>luma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delta_luma_weight_l0</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int8_t</name><operator>)</operator><name>delta_luma_weight_l0</name> <operator>!=</operator> <name>delta_luma_weight_l0</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <name>delta_luma_weight_l0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chroma_weight_l0_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delta_chroma_weight_l0</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta_chroma_offset_l0</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><name>int8_t</name><operator>)</operator><name>delta_chroma_weight_l0</name> <operator>!=</operator> <name>delta_chroma_weight_l0</name>
<operator>||</operator> <name>delta_chroma_offset_l0</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">17</literal><operator>)</operator> <operator>||</operator> <name>delta_chroma_offset_l0</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">17</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <name>delta_chroma_weight_l0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><operator>(</operator><name>delta_chroma_offset_l0</name> <operator>-</operator> <operator>(</operator><operator>(</operator><literal type="number">128</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator>
<operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <literal type="number">128</literal><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>luma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>luma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>chroma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>chroma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>luma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delta_luma_weight_l1</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int8_t</name><operator>)</operator><name>delta_luma_weight_l1</name> <operator>!=</operator> <name>delta_luma_weight_l1</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <name>delta_luma_weight_l1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chroma_weight_l1_flag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delta_chroma_weight_l1</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta_chroma_offset_l1</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><name>int8_t</name><operator>)</operator><name>delta_chroma_weight_l1</name> <operator>!=</operator> <name>delta_chroma_weight_l1</name>
<operator>||</operator> <name>delta_chroma_offset_l1</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">17</literal><operator>)</operator> <operator>||</operator> <name>delta_chroma_offset_l1</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">17</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <name>delta_chroma_weight_l1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><operator>(</operator><name>delta_chroma_offset_l1</name> <operator>-</operator> <operator>(</operator><operator>(</operator><literal type="number">128</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator>
<operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>)</operator> <operator>+</operator> <literal type="number">128</literal><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_lt_rps</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>LongTermRPS</name> <modifier>*</modifier></type><name>rps</name></decl></parameter>, <parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_poc_lsb</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>sps</name><operator>-&gt;</operator><name>log2_max_poc_lsb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_delta_msb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nb_sps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nb_sh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>nb_refs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sps</name><operator>-&gt;</operator><name>long_term_ref_pics_present_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>num_long_term_ref_pics_sps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nb_sps</name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nb_sh</name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nb_sps</name> <operator>&gt;</operator> <name><name>sps</name><operator>-&gt;</operator><name>num_long_term_ref_pics_sps</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nb_sh</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>nb_sps</name> <operator>&gt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>rps</name><operator>-&gt;</operator><name>poc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>nb_refs</name></name> <operator>=</operator> <name>nb_sh</name> <operator>+</operator> <name>nb_sps</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rps</name><operator>-&gt;</operator><name>nb_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>delta_poc_msb_present</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nb_sps</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>lt_idx_sps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>num_long_term_ref_pics_sps</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lt_idx_sps</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>av_ceil_log2</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>num_long_term_ref_pics_sps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>poc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>lt_ref_pic_poc_lsb_sps</name><index>[<expr><name>lt_idx_sps</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>used_by_curr_pic_lt_sps_flag</name><index>[<expr><name>lt_idx_sps</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>poc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>log2_max_poc_lsb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>delta_poc_msb_present</name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>delta_poc_msb_present</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>delta</name> <init>= <expr><call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>poc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>nb_sps</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>delta</name> <operator>+=</operator> <name>prev_delta_msb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>poc</name> <operator>=</operator> <name><name>rps</name><operator>-&gt;</operator><name>poc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>-</operator> <name>delta</name> <operator>*</operator> <name>max_poc_lsb</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>pic_order_cnt_lsb</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>poc</name> <operator>!=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>poc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>rps</name><operator>-&gt;</operator><name>poc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>poc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_delta_msb</name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>export_stream_params</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCParamSets</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCVPS</name> <modifier>*</modifier></type><name>vps</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HEVCVPS</name><operator>*</operator><operator>)</operator><name><name>ps</name><operator>-&gt;</operator><name>vps_list</name><index>[<expr><name><name>sps</name><operator>-&gt;</operator><name>vps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCWindow</name> <modifier>*</modifier></type><name>ow</name> <init>= <expr><operator>&amp;</operator><name><name>sps</name><operator>-&gt;</operator><name>output_window</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>den</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>coded_width</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>coded_height</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>-</operator> <name><name>ow</name><operator>-&gt;</operator><name>left_offset</name></name> <operator>-</operator> <name><name>ow</name><operator>-&gt;</operator><name>right_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>-</operator> <name><name>ow</name><operator>-&gt;</operator><name>top_offset</name></name> <operator>-</operator> <name><name>ow</name><operator>-&gt;</operator><name>bottom_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>has_b_frames</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>temporal_layer</name><index>[<expr><name><name>sps</name><operator>-&gt;</operator><name>max_sub_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>num_reorder_pics</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>ptl</name><operator>.</operator><name>general_ptl</name><operator>.</operator><name>profile_idc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>ptl</name><operator>.</operator><name>general_ptl</name><operator>.</operator><name>level_idc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_set_sar</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>sar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>video_signal_type_present_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>=</operator> <ternary><condition><expr><name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>video_full_range_flag</name></name></expr> ?</condition><then> <expr><name>AVCOL_RANGE_JPEG</name></expr>
</then><else>: <expr><name>AVCOL_RANGE_MPEG</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>=</operator> <name>AVCOL_RANGE_MPEG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>colour_description_present_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>colour_primaries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>transfer_characteristic</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>matrix_coeffs</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>=</operator> <name>AVCOL_PRI_UNSPECIFIED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>=</operator> <name>AVCOL_SPC_UNSPECIFIED</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vps</name><operator>-&gt;</operator><name>vps_timing_info_present_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>vps</name><operator>-&gt;</operator><name>vps_num_units_in_tick</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>den</name> <operator>=</operator> <name><name>vps</name><operator>-&gt;</operator><name>vps_time_scale</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>vui_timing_info_present_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>vui_num_units_in_tick</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>den</name> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>vui</name><operator>.</operator><name>vui_time_scale</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>den</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_reduce</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>avctx</name><operator>-&gt;</operator><name>framerate</name><operator>.</operator><name>den</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>avctx</name><operator>-&gt;</operator><name>framerate</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><name>num</name></expr></argument>, <argument><expr><name>den</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name><operator>.</operator><name>present</name></name> <operator>&amp;&amp;</operator>
<call><name>av_color_transfer_name</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name><operator>.</operator><name>preferred_transfer_characteristics</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name><operator>.</operator><name>preferred_transfer_characteristics</name></name> <operator>!=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name><operator>.</operator><name>preferred_transfer_characteristics</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>get_format</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HWACCEL_MAX</name></cpp:macro> <cpp:value>(CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL * 2 + CONFIG_HEVC_NVDEC_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)</cpp:value></cpp:define>





<decl_stmt><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>pix_fmts</name><index>[<expr><name>HWACCEL_MAX</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fmt</name> <init>= <expr><name>pix_fmts</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AV_PIX_FMT_YUV420P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUVJ420P</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_DXVA2_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_DXVA2_VLD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_D3D11VA_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_D3D11VA_VLD</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_D3D11</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VAAPI_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VAAPI</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VDPAU_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VDPAU</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_NVDEC_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_CUDA</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VIDEOTOOLBOX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_YUV420P10</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_DXVA2_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_DXVA2_VLD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_D3D11VA_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_D3D11VA_VLD</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_D3D11</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VAAPI_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VAAPI</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VIDEOTOOLBOX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_NVDEC_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_CUDA</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_YUV444P</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VDPAU_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VDPAU</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_NVDEC_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_CUDA</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_YUV422P</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV422P10LE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VAAPI_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_VAAPI</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>AV_PIX_FMT_YUV420P12</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P10</name></expr>:</case>
<case>case <expr><name>AV_PIX_FMT_YUV444P12</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_NVDEC_HWACCEL</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name>AV_PIX_FMT_CUDA</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>fmt</name><operator>++</operator> <operator>=</operator> <name><name>sps</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fmt</name> <operator>=</operator> <name>AV_PIX_FMT_NONE</name></expr>;</expr_stmt>

<return>return <expr><call><name>ff_thread_get_format</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>pix_fmts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_sps</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>pix_fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pic_arrays_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sps</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pic_arrays_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>export_stream_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>pix_fmt</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_hevc_pred_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hpc</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>bit_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_dsp_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>bit_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_videodsp_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>vdsp</name></name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>bit_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_h</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>sao_enabled</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c_count</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_idx</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>c_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c_idx</name> <operator>&lt;</operator> <name>c_count</name></expr>;</condition> <incr><expr><name>c_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;&gt;</operator> <name><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;</operator> <name><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_h</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>=</operator>
<call><name>av_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>w</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name><operator>)</operator> <operator>&lt;&lt;</operator>
<name><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_v</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>=</operator>
<call><name>av_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>h</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&lt;&lt;</operator>
<name><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>=</operator> <name>sps</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps</name></name> <operator>=</operator> <operator>(</operator><name>HEVCVPS</name><operator>*</operator><operator>)</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>pic_arrays_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_slice_header</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceHeader</name> <modifier>*</modifier></type><name>sh</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>&amp;&amp;</operator> <name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Two slices reporting being the first in the same frame.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_IDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BLA</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_IDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_clear_refs</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>no_output_of_prior_pics_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>no_output_of_prior_pics_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name> <operator>&gt;=</operator> <name>HEVC_MAX_PPS_COUNT</name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"PPS id out of range: %d\n"</literal></expr></argument>, <argument><expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name></name> <operator>!=</operator> <operator>(</operator><name>HEVCPPS</name><operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"PPS changed between slices.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name></name> <operator>=</operator> <operator>(</operator><name>HEVCPPS</name><operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name><name>sh</name><operator>-&gt;</operator><name>pps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_CRA_NUT</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_eos</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>no_output_of_prior_pics_flag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>!=</operator> <operator>(</operator><name>HEVCSPS</name><operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>sps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>HEVCSPS</name><operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>sps_id</name></name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>last_sps</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>pix_fmt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>last_sps</name> <operator>&amp;&amp;</operator> <call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_CRA_NUT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>!=</operator> <name><name>last_sps</name><operator>-&gt;</operator><name>width</name></name> <operator>||</operator> <name><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>!=</operator> <name><name>last_sps</name><operator>-&gt;</operator><name>height</name></name> <operator>||</operator>
<name><name>sps</name><operator>-&gt;</operator><name>temporal_layer</name><index>[<expr><name><name>sps</name><operator>-&gt;</operator><name>max_sub_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>max_dec_pic_buffering</name> <operator>!=</operator>
<name><name>last_sps</name><operator>-&gt;</operator><name>temporal_layer</name><index>[<expr><name><name>last_sps</name><operator>-&gt;</operator><name>max_sub_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>max_dec_pic_buffering</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>no_output_of_prior_pics_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ff_hevc_clear_refs</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>set_sps</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>, <argument><expr><name><name>sps</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pix_fmt</name> <operator>=</operator> <call><name>get_format</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pix_fmt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>pix_fmt</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>pix_fmt</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>dependent_slice_segment_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>slice_address_length</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>dependent_slice_segments_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>dependent_slice_segment_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>slice_address_length</name> <operator>=</operator> <call><name>av_ceil_log2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>*</operator>
<name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name> <operator>=</operator> <call><name>get_bitsz</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>slice_address_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid slice segment address: %u.\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>dependent_slice_segment_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_addr</name></name> <operator>=</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_idx</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name> <operator>=</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>dependent_slice_segment_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>num_extra_slice_header_bits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_I</name> <operator>||</operator>
<name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>||</operator>
<name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown slice type: %d.\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>!=</operator> <name>HEVC_SLICE_I</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Inter slices in an IRAP frame.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>pic_output_flag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>output_flag_present_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>pic_output_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>separate_colour_plane_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>colour_plane_id</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_IDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>poc</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>pic_order_cnt_lsb</name></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_max_poc_lsb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>poc</name> <operator>=</operator> <call><name>ff_hevc_compute_poc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pocTid0</name></name></expr></argument>, <argument><expr><name><name>sh</name><operator>-&gt;</operator><name>pic_order_cnt_lsb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name> <operator>&amp;&amp;</operator> <name>poc</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Ignoring POC change between slices: %d -&gt; %d\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr></argument>, <argument><expr><name>poc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>poc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>=</operator> <name>poc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>short_term_ref_pic_set_sps_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>short_term_ref_pic_set_sps_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_short_term_rps</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>slice_rps</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>short_term_rps</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>slice_rps</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>numbits</name></decl>, <decl><type ref="prev"/><name>rps_idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>nb_st_rps</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"No ref lists in the SPS.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>numbits</name> <operator>=</operator> <call><name>av_ceil_log2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>nb_st_rps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rps_idx</name> <operator>=</operator> <ternary><condition><expr><name>numbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>numbits</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>short_term_rps</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>st_rps</name><index>[<expr><name>rps_idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>short_term_ref_pic_set_size</name></name> <operator>=</operator> <name>pos</name> <operator>-</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>decode_lt_rps</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>long_term_rps</name></name></expr></argument>, <argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Invalid long term RPS.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>long_term_ref_pic_set_size</name></name> <operator>=</operator> <name>pos</name> <operator>-</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>sps_temporal_mvp_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_temporal_mvp_enabled_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_temporal_mvp_enabled_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>short_term_rps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>first_slice_in_pic_flag</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>temporal_id</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_TRAIL_N</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_TSA_N</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_STSA_N</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_RADL_N</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_RADL_R</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_RASL_N</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name>HEVC_NAL_RASL_R</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pocTid0</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>sao_enabled</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name> <operator>=</operator> <name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>||</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nb_refs</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>num_ref_idx_l0_default_active</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>num_ref_idx_l1_default_active</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name> <operator>&gt;</operator> <name>HEVC_MAX_REFS</name> <operator>||</operator> <name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name> <operator>&gt;</operator> <name>HEVC_MAX_REFS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too many refs: %d/%d.\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nb_refs</name> <operator>=</operator> <call><name>ff_hevc_frame_nb_refs</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nb_refs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Zero refs for a frame with P or B slices.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>lists_modification_present_flag</name></name> <operator>&amp;&amp;</operator> <name>nb_refs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>list_entry_lx</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>av_ceil_log2</name><argument_list>(<argument><expr><name>nb_refs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>rpl_modification_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>list_entry_lx</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>av_ceil_log2</name><argument_list>(<argument><expr><name>nb_refs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>mvd_l1_zero_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cabac_init_present_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>cabac_init_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>cabac_init_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_ref_idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_temporal_mvp_enabled_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_list</name></name> <operator>=</operator> <name>L0</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_list</name></name> <operator>=</operator> <operator>!</operator><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_list</name></name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_ref_idx</name></name> <operator>=</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_ref_idx</name></name> <operator>&gt;=</operator> <name><name>sh</name><operator>-&gt;</operator><name>nb_refs</name><index>[<expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_list</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid collocated_ref_idx: %d.\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>collocated_ref_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_pred_flag</name></name> <operator>&amp;&amp;</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_bipred_flag</name></name> <operator>&amp;&amp;</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>pred_weight_table</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>max_num_merge_cand</name></name> <operator>=</operator> <literal type="number">5</literal> <operator>-</operator> <call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>max_num_merge_cand</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>sh</name><operator>-&gt;</operator><name>max_num_merge_cand</name></name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid number of merging MVP candidates: %d.\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>max_num_merge_cand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_qp_delta</name></name> <operator>=</operator> <call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>pic_slice_level_chroma_qp_offsets_present_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_cb_qp_offset</name></name> <operator>=</operator> <call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_cr_qp_offset</name></name> <operator>=</operator> <call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_cb_qp_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_cr_qp_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>chroma_qp_offset_list_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>cu_chroma_qp_offset_enabled_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>cu_chroma_qp_offset_enabled_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>deblocking_filter_control_present_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>deblocking_filter_override_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>deblocking_filter_override_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deblocking_filter_override_flag</name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>deblocking_filter_override_flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>disable_deblocking_filter_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>disable_deblocking_filter_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>beta_offset_div2</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tc_offset_div2</name> <init>= <expr><call><name>get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>beta_offset_div2</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">6</literal> <operator>||</operator> <name>beta_offset_div2</name></expr></argument> &gt;</argument_list></name> <literal type="number">6</literal> <operator>||</operator>
<name><name>tc_offset_div2</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">6</literal> <operator>||</operator> <name>tc_offset_div2</name></expr></argument> &gt;</argument_list></name> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid deblock filter offsets: %d, %d\n"</literal></expr></argument>,
<argument><expr><name>beta_offset_div2</name></expr></argument>, <argument><expr><name>tc_offset_div2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>beta_offset</name></name> <operator>=</operator> <name>beta_offset_div2</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>tc_offset</name></name> <operator>=</operator> <name>tc_offset_div2</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>disable_deblocking_filter_flag</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>disable_dbf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>beta_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>beta_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>tc_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tc_offset</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>disable_deblocking_filter_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>beta_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>tc_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>seq_loop_filter_across_slices_enabled_flag</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<name><name>sh</name><operator>-&gt;</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator>
<operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>disable_deblocking_filter_flag</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_loop_filter_across_slices_enabled_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_loop_filter_across_slices_enabled_flag</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>seq_loop_filter_across_slices_enabled_flag</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>slice_initialized</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Independent slice segment missing.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tiles_enabled_flag</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>entropy_coding_sync_enabled_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>num_entry_point_offsets</name> <init>= <expr><call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num_entry_point_offsets</name> <operator>&gt;</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"num_entry_point_offsets %d is invalid\n"</literal></expr></argument>, <argument><expr><name>num_entry_point_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name> <operator>=</operator> <name>num_entry_point_offsets</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset_len</name> <init>= <expr><call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>offset_len</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>offset_len</name></expr></argument> &gt;</argument_list></name> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"offset_len %d is invalid\n"</literal></expr></argument>, <argument><expr><name>offset_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>entry_point_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sh</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>entry_point_offset</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>entry_point_offset</name></name> <operator>||</operator> <operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>offset</name></name> <operator>||</operator> <operator>!</operator><name><name>sh</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sh</name><operator>-&gt;</operator><name>num_entry_point_offsets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>val</name> <init>= <expr><call><name>get_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>offset_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>entry_point_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>num_tile_rows</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>num_tile_columns</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>enable_parallel_tiles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>enable_parallel_tiles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>enable_parallel_tiles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>slice_header_extension_present_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>length</name> <init>= <expr><call><name>get_ue_golomb_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name><operator>*</operator><literal type="number">8LL</literal> <operator>&gt;</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many slice_header_extension_data_bytes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>skip_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_qp</name></name> <operator>=</operator> <literal type="number">26U</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>pic_init_qp_minus26</name></name> <operator>+</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_qp_delta</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>-&gt;</operator><name>slice_qp</name></name> <operator>&gt;</operator> <literal type="number">51</literal> <operator>||</operator>
<name><name>sh</name><operator>-&gt;</operator><name>slice_qp</name></name> <operator>&lt;</operator> <operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"The slice_qp %d is outside the valid range "</literal>
<literal type="string">"[%d, 51].\n"</literal></expr></argument>,
<argument><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_qp</name></name></expr></argument>,
<argument><expr><operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sh</name><operator>-&gt;</operator><name>slice_ctb_addr_rs</name></name> <operator>=</operator> <name><name>sh</name><operator>-&gt;</operator><name>slice_segment_addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_ctb_addr_rs</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>dependent_slice_segment_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Impossible slice segment.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Overread slice header by %d bits\n"</literal></expr></argument>, <argument><expr><operator>-</operator><call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name><operator>-&gt;</operator><name>first_qp_group</name></name> <operator>=</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>dependent_slice_segment_flag</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cu_qp_delta_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name><operator>-&gt;</operator><name>qp_y</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_qp</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTB</name><parameter_list>(<parameter><type><name>tab</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((tab)[(y) * s-&gt;ps.sps-&gt;ctb_width + (x)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_SAO</name><parameter_list>(<parameter><type><name>elem</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!sao_merge_up_flag &amp;&amp; !sao_merge_left_flag) sao-&gt;elem = value; else if (sao_merge_left_flag) sao-&gt;elem = CTB(s-&gt;sao, rx-1, ry).elem; else if (sao_merge_up_flag) sao-&gt;elem = CTB(s-&gt;sao, rx, ry-1).elem; else sao-&gt;elem = 0; } while (0)</cpp:value></cpp:define>











<function><type><specifier>static</specifier> <name>void</name></type> <name>hls_sao_param</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sao_merge_left_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sao_merge_up_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SAOParams</name> <modifier>*</modifier></type><name>sao</name> <init>= <expr><operator>&amp;</operator><call><name>CTB</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sao</name></name></expr></argument>, <argument><expr><name>rx</name></expr></argument>, <argument><expr><name>ry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c_idx</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_left_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sao_merge_left_flag</name> <operator>=</operator> <call><name>ff_hevc_sao_merge_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ry</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>sao_merge_left_flag</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sao_merge_up_flag</name> <operator>=</operator> <call><name>ff_hevc_sao_merge_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>c_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c_idx</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>c_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>log2_sao_offset_scale</name> <init>= <expr><ternary><condition><expr><name>c_idx</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>log2_sao_offset_scale_luma</name></name></expr> </then><else>:
<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>log2_sao_offset_scale_chroma</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_sample_adaptive_offset_flag</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>=</operator> <name>SAO_NOT_APPLIED</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c_idx</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>eo_class</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>sao</name><operator>-&gt;</operator><name>eo_class</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SET_SAO</name><argument_list>(<argument><expr><name><name>type_idx</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>ff_hevc_sao_type_idx_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>==</operator> <name>SAO_NOT_APPLIED</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SET_SAO</name><argument_list>(<argument><expr><name><name>offset_abs</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>ff_hevc_sao_offset_abs_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>==</operator> <name>SAO_BAND</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sao</name><operator>-&gt;</operator><name>offset_abs</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_SAO</name><argument_list>(<argument><expr><name><name>offset_sign</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>ff_hevc_sao_offset_sign_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_sign</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>SET_SAO</name><argument_list>(<argument><expr><name><name>band_position</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>ff_hevc_sao_band_position_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c_idx</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_SAO</name><argument_list>(<argument><expr><name><name>eo_class</name><index>[<expr><name>c_idx</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>ff_hevc_sao_eo_class_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sao</name><operator>-&gt;</operator><name>offset_abs</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sao</name><operator>-&gt;</operator><name>type_idx</name><index>[<expr><name>c_idx</name></expr>]</index></name> <operator>==</operator> <name>SAO_EDGE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sao</name><operator>-&gt;</operator><name>offset_sign</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sao</name><operator>-&gt;</operator><name>offset_val</name><index>[<expr><name>c_idx</name></expr>]</index><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_sao_offset_scale</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_SAO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CTB</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_cross_component_pred</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log2_res_scale_abs_plus1</name> <init>= <expr><call><name>ff_hevc_log2_res_scale_abs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>log2_res_scale_abs_plus1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res_scale_sign_flag</name> <init>= <expr><call><name>ff_hevc_res_scale_sign_flag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>res_scale_val</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_res_scale_abs_plus1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>res_scale_sign_flag</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>res_scale_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_transform_unit</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>xBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb_xBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb_yBase</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_trafo_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>blk_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cbf_luma</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cbf_cb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cbf_cr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>log2_trafo_size_c</name> <init>= <expr><name>log2_trafo_size</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>trafo_size</name></expr></argument>, <argument><expr><name>trafo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name><operator>,</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cbf_luma</name> <operator>||</operator> <name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>scan_idx</name> <init>= <expr><name>SCAN_DIAG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scan_idx_c</name> <init>= <expr><name>SCAN_DIAG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cbf_chroma</name> <init>= <expr><name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cu_qp_delta_enabled_flag</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_qp_delta_coded</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>=</operator> <call><name>ff_hevc_cu_qp_delta_abs</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>ff_hevc_cu_qp_delta_sign_flag</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>=</operator> <operator>-</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_qp_delta_coded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><literal type="number">26</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator>
<name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">25</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"The cu_qp_delta %d is outside the valid range "</literal>
<literal type="string">"[%d, %d].\n"</literal></expr></argument>,
<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name></expr></argument>,
<argument><expr><operator>-</operator><operator>(</operator><literal type="number">26</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><literal type="number">25</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>qp_bd_offset</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_hevc_set_qPy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>cb_xBase</name></expr></argument>, <argument><expr><name>cb_yBase</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>cu_chroma_qp_offset_enabled_flag</name></name> <operator>&amp;&amp;</operator> <name>cbf_chroma</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>cu_transquant_bypass_flag</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_chroma_qp_offset_coded</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cu_chroma_qp_offset_flag</name> <init>= <expr><call><name>ff_hevc_cu_chroma_qp_offset_flag</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cu_chroma_qp_offset_flag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cu_chroma_qp_offset_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>chroma_qp_offset_list_len_minus1</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cu_chroma_qp_offset_idx</name> <operator>=</operator> <call><name>ff_hevc_cu_chroma_qp_offset_idx</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"cu_chroma_qp_offset_idx not yet tested.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cb</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cb_qp_offset_list</name><index>[<expr><name>cu_chroma_qp_offset_idx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cr</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cr_qp_offset_list</name><index>[<expr><name>cu_chroma_qp_offset_idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_offset_cr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_chroma_qp_offset_coded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name> <operator>&amp;&amp;</operator> <name>log2_trafo_size</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>&lt;=</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scan_idx</name> <operator>=</operator> <name>SCAN_VERT</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>&gt;=</operator> <literal type="number">22</literal> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>&lt;=</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scan_idx</name> <operator>=</operator> <name>SCAN_HORIZ</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>&lt;=</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scan_idx_c</name> <operator>=</operator> <name>SCAN_VERT</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>&gt;=</operator> <literal type="number">22</literal> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>&lt;=</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scan_idx_c</name> <operator>=</operator> <name>SCAN_HORIZ</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cbf_luma</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_residual_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_trafo_size</name></expr></argument>, <argument><expr><name>scan_idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_h</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size_c</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_v</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size_c</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cross_component_prediction_enabled_flag</name></name> <operator>&amp;&amp;</operator> <name>cbf_luma</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTER</name> <operator>||</operator>
<operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>chroma_mode_c</name></name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hls_cross_component_pred</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator></expr></argument>, <argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbf_cb</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_residual_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator></expr></argument>,
<argument><expr><name>log2_trafo_size_c</name></expr></argument>, <argument><expr><name>scan_idx_c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coeffs_y</name> <init>= <expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coeffs</name> <init>= <expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name>vshift</name><operator>)</operator> <operator>*</operator> <name>stride</name> <operator>+</operator>
<operator>(</operator><operator>(</operator><name>x0</name> <operator>&gt;&gt;</operator> <name>hshift</name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>size</name> <operator>*</operator> <name>size</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>res_scale_val</name></name> <operator>*</operator> <name><name>coeffs_y</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>add_residual</name><index>[<expr><name>log2_trafo_size_c</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>coeffs</name><operator>,</operator> <name>stride</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hls_cross_component_pred</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator></expr></argument>, <argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbf_cr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_residual_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator></expr></argument>,
<argument><expr><name>log2_trafo_size_c</name></expr></argument>, <argument><expr><name>scan_idx_c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cross_pf</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coeffs_y</name> <init>= <expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coeffs</name> <init>= <expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name>vshift</name><operator>)</operator> <operator>*</operator> <name>stride</name> <operator>+</operator>
<operator>(</operator><operator>(</operator><name>x0</name> <operator>&gt;&gt;</operator> <name>hshift</name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>size</name> <operator>*</operator> <name>size</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>res_scale_val</name></name> <operator>*</operator> <name><name>coeffs_y</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>add_residual</name><index>[<expr><name>log2_trafo_size_c</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>coeffs</name><operator>,</operator> <name>stride</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>&amp;&amp;</operator> <name>blk_idx</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_h</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_v</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr></argument>,
<argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbf_cb</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_residual_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr></argument>,
<argument><expr><name>log2_trafo_size</name></expr></argument>, <argument><expr><name>scan_idx_c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr></argument>,
<argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbf_cr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_residual_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr></argument>,
<argument><expr><name>log2_trafo_size</name></expr></argument>, <argument><expr><name>scan_idx_c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>&amp;&amp;</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>log2_trafo_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_h</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size_c</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_v</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size_c</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator></expr></argument>,
<argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size_c</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>x0</name><operator>,</operator> <name>y0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size_c</name><operator>)</operator><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>blk_idx</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_h</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trafo_size_v</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name></expr></argument>,
<argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name><operator>)</operator><operator>)</operator></expr></argument>,
<argument><expr><name>trafo_size_h</name></expr></argument>, <argument><expr><name>trafo_size_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name><operator>)</operator><operator>)</operator><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hpc</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>(</operator><name>s</name><operator>,</operator> <name>xBase</name><operator>,</operator> <name>yBase</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name><operator>)</operator><operator>)</operator><operator>,</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_deblocking_bypass</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log2_min_pu_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_end</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_end</name> <init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name>log2_min_pu_size</name><operator>)</operator></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>(</operator><name>y_end</name> <operator>&gt;&gt;</operator> <name>log2_min_pu_size</name><operator>)</operator></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>x0</name> <operator>&gt;&gt;</operator> <name>log2_min_pu_size</name><operator>)</operator></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>x_end</name> <operator>&gt;&gt;</operator> <name>log2_min_pu_size</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_pcm</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>min_pu_width</name></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_transform_tree</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>xBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb_xBase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb_yBase</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_trafo_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>trafo_depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blk_idx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>base_cbf_cb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>base_cbf_cr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>split_transform_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>cbf_cb</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>cbf_cr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>base_cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>base_cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>base_cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>base_cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>trafo_depth</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><name>blk_idx</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><name>blk_idx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>chroma_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>chroma_mode_c</name><index>[<expr><name>blk_idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>chroma_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>chroma_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>intra_pred_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>chroma_mode_c</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>chroma_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>log2_trafo_size</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_max_trafo_size</name></name> <operator>&amp;&amp;</operator>
<name>log2_trafo_size</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name> <operator>&amp;&amp;</operator>
<name>trafo_depth</name> <operator>&lt;</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>max_trafo_depth</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name> <operator>&amp;&amp;</operator> <name>trafo_depth</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>split_transform_flag</name> <operator>=</operator> <call><name>ff_hevc_split_transform_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>log2_trafo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>inter_split</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>max_transform_hierarchy_depth_inter</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTER</name> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>!=</operator> <name>PART_2Nx2N</name> <operator>&amp;&amp;</operator>
<name>trafo_depth</name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>split_transform_flag</name> <operator>=</operator> <name>log2_trafo_size</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_max_trafo_size</name></name> <operator>||</operator>
<operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name> <operator>&amp;&amp;</operator> <name>trafo_depth</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<name>inter_split</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>trafo_depth</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ff_hevc_cbf_cb_cr_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>trafo_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>split_transform_flag</name> <operator>||</operator> <name>log2_trafo_size</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ff_hevc_cbf_cb_cr_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>trafo_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>trafo_depth</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ff_hevc_cbf_cb_cr_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>trafo_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>split_transform_flag</name> <operator>||</operator> <name>log2_trafo_size</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ff_hevc_cbf_cb_cr_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>trafo_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>split_transform_flag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>trafo_size_split</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>log2_trafo_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x1</name> <init>= <expr><name>x0</name> <operator>+</operator> <name>trafo_size_split</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y1</name> <init>= <expr><name>y0</name> <operator>+</operator> <name>trafo_size_split</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBDIVIDE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ret = hls_transform_tree(s, x, y, x0, y0, cb_xBase, cb_yBase, log2_cb_size, log2_trafo_size - 1, trafo_depth + 1, idx, cbf_cb, cbf_cr); if (ret &lt; 0) return ret; } while (0)</cpp:value></cpp:define>








<expr_stmt><expr><call><name>SUBDIVIDE</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SUBDIVIDE</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SUBDIVIDE</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SUBDIVIDE</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUBDIVIDE</name></cpp:undef>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min_tu_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log2_min_tu_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_tu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_tb_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cbf_luma</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name> <operator>||</operator> <name>trafo_depth</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>cbf_cb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cbf_cb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>cbf_cr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cbf_luma</name> <operator>=</operator> <call><name>ff_hevc_cbf_luma_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>trafo_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hls_transform_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>xBase</name></expr></argument>, <argument><expr><name>yBase</name></expr></argument>, <argument><expr><name>cb_xBase</name></expr></argument>, <argument><expr><name>cb_yBase</name></expr></argument>,
<argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><name>log2_trafo_size</name></expr></argument>,
<argument><expr><name>blk_idx</name></expr></argument>, <argument><expr><name>cbf_luma</name></expr></argument>, <argument><expr><name>cbf_cb</name></expr></argument>, <argument><expr><name>cbf_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cbf_luma</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>min_tu_size</name></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_trafo_size</name><operator>)</operator></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <name>min_tu_size</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x_tu</name> <init>= <expr><operator>(</operator><name>x0</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>log2_min_tu_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_tu</name> <init>= <expr><operator>(</operator><name>y0</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>log2_min_tu_size</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cbf_luma</name><index>[<expr><name>y_tu</name> <operator>*</operator> <name>min_tu_width</name> <operator>+</operator> <name>x_tu</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>disable_deblocking_filter_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_deblocking_boundary_strengths</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_trafo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>transquant_bypass_enable_flag</name></name> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>cu_transquant_bypass_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_deblocking_bypass</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_trafo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_pcm_sample</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride0</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride1</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride2</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst0</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>y0</name> <operator>*</operator> <name>stride0</name> <operator>+</operator> <operator>(</operator><name>x0</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst1</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>stride1</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst2</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>stride2</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name>cb_size</name> <operator>*</operator> <name>cb_size</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>bit_depth</name></name> <operator>+</operator>
<operator>(</operator><operator>(</operator><operator>(</operator><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>+</operator>
<operator>(</operator><operator>(</operator><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>*</operator>
<name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>bit_depth_chroma</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>pcm</name> <init>= <expr><call><name>skip_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lc</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>length</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>disable_deblocking_filter_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_deblocking_boundary_strengths</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>init_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name>pcm</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_pcm</name></name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>stride0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>bit_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_pcm</name></name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>stride1</name></expr></argument>,
<argument><expr><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>bit_depth_chroma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_pcm</name></name><argument_list>(<argument><expr><name>dst2</name></expr></argument>, <argument><expr><name>stride2</name></expr></argument>,
<argument><expr><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>cb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>bit_depth_chroma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>void</name></type> <name>luma_mc_uni</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>dststride</name></decl></parameter>,
<parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mv</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y_off</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>block_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>luma_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>luma_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>srcstride</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><name><name>mv</name><operator>-&gt;</operator><name>x</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my</name> <init>= <expr><name><name>mv</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weight_flag</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_pred_flag</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_bipred_flag</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>ff_hevc_pel_weight</name><index>[<expr><name>block_w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>x_off</name> <operator>+=</operator> <name><name>mv</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>y_off</name> <operator>+=</operator> <name><name>mv</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <name>y_off</name> <operator>*</operator> <name>srcstride</name> <operator>+</operator> <operator>(</operator><name>x_off</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off</name> <operator>&lt;</operator> <name>QPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off</name> <operator>&lt;</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>srcstride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>, <argument><expr><name>src</name> <operator>-</operator> <name>offset</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>srcstride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>block_h</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>, <argument><expr><name>y_off</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name> <operator>+</operator> <name>buf_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcstride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weight_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_qpel_uni</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx</name></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src</name><operator>,</operator> <name>srcstride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>mx</name><operator>,</operator> <name>my</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_qpel_uni_w</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx</name></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src</name><operator>,</operator> <name>srcstride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name><operator>,</operator>
<name>luma_weight</name><operator>,</operator> <name>luma_offset</name><operator>,</operator> <name>mx</name><operator>,</operator> <name>my</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>void</name></type> <name>luma_mc_bi</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>dststride</name></decl></parameter>,
<parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>ref0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mv</name> <modifier>*</modifier></type><name>mv0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y_off</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>block_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_h</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>ref1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Mv</name> <modifier>*</modifier></type><name>mv1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MvField</name></name> <modifier>*</modifier></type><name>current_mv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>src0stride</name> <init>= <expr><name><name>ref0</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>src1stride</name> <init>= <expr><name><name>ref1</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mx0</name> <init>= <expr><name><name>mv0</name><operator>-&gt;</operator><name>x</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my0</name> <init>= <expr><name><name>mv0</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mx1</name> <init>= <expr><name><name>mv1</name><operator>-&gt;</operator><name>x</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my1</name> <init>= <expr><name><name>mv1</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weight_flag</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_pred_flag</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_bipred_flag</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_off0</name> <init>= <expr><name>x_off</name> <operator>+</operator> <operator>(</operator><name><name>mv0</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_off0</name> <init>= <expr><name>y_off</name> <operator>+</operator> <operator>(</operator><name><name>mv0</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_off1</name> <init>= <expr><name>x_off</name> <operator>+</operator> <operator>(</operator><name><name>mv1</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_off1</name> <init>= <expr><name>y_off</name> <operator>+</operator> <operator>(</operator><name><name>mv1</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>ff_hevc_pel_weight</name><index>[<expr><name>block_w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><name><name>ref0</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>y_off0</name> <operator>*</operator> <name>src0stride</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>x_off0</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name><name>ref1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>y_off1</name> <operator>*</operator> <name>src1stride</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>x_off1</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off0</name> <operator>&lt;</operator> <name>QPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off0</name> <operator>&lt;</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off0</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off0</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>src0stride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>, <argument><expr><name>src0</name> <operator>-</operator> <name>offset</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>src0stride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>block_h</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off0</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>, <argument><expr><name>y_off0</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src0</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name> <operator>+</operator> <name>buf_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src0stride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off1</name> <operator>&lt;</operator> <name>QPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off1</name> <operator>&lt;</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off1</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off1</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>QPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>src1stride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset</name> <init>= <expr><name>QPEL_EXTRA_BEFORE</name> <operator>*</operator> <name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><name>QPEL_EXTRA_BEFORE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name></expr></argument>, <argument><expr><name>src1</name> <operator>-</operator> <name>offset</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>src1stride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>block_h</name> <operator>+</operator> <name>QPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off1</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>, <argument><expr><name>y_off1</name> <operator>-</operator> <name>QPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name> <operator>+</operator> <name>buf_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src1stride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_qpel</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my0</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx0</name></expr>]</index></name><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator> <name>src0</name><operator>,</operator> <name>src0stride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>mx0</name><operator>,</operator> <name>my0</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weight_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_qpel_bi</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my1</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx1</name></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src1</name><operator>,</operator> <name>src1stride</name><operator>,</operator> <name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>mx1</name><operator>,</operator> <name>my1</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_qpel_bi_w</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my1</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx1</name></expr>]</index></name><operator>(</operator><name>dst</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src1</name><operator>,</operator> <name>src1stride</name><operator>,</operator> <name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_log2_weight_denom</name></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l0</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l1</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l0</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l1</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>,</operator>
<name>mx1</name><operator>,</operator> <name>my1</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>void</name></type> <name>chroma_mc_uni</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst0</name></decl></parameter>,
<parameter><decl><type><name>ptrdiff_t</name></type> <name>dststride</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src0</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>srcstride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reflist</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>x_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_h</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MvField</name></name> <modifier>*</modifier></type><name>current_mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chroma_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chroma_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Mv</name> <modifier>*</modifier></type><name>mv</name> <init>= <expr><operator>&amp;</operator><name><name>current_mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><name>reflist</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weight_flag</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_pred_flag</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_bipred_flag</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>ff_hevc_pel_weight</name><index>[<expr><name>block_w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>mx</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>hshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>my</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>vshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_mx</name> <init>= <expr><name>mx</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>hshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_my</name> <init>= <expr><name>my</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>vshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>x_off</name> <operator>+=</operator> <name><name>mv</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>hshift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>y_off</name> <operator>+=</operator> <name><name>mv</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>vshift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src0</name> <operator>+=</operator> <name>y_off</name> <operator>*</operator> <name>srcstride</name> <operator>+</operator> <operator>(</operator><name>x_off</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off</name> <operator>&lt;</operator> <name>EPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off</name> <operator>&lt;</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset0</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator> <operator>(</operator><name>srcstride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset0</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator>
<operator>(</operator><name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>, <argument><expr><name>src0</name> <operator>-</operator> <name>offset0</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>srcstride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>, <argument><expr><name>block_h</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>y_off</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>src0</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name> <operator>+</operator> <name>buf_offset0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcstride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weight_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_epel_uni</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx</name></expr>]</index></name><operator>(</operator><name>dst0</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src0</name><operator>,</operator> <name>srcstride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>_mx</name><operator>,</operator> <name>_my</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_epel_uni_w</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx</name></expr>]</index></name><operator>(</operator><name>dst0</name><operator>,</operator> <name>dststride</name><operator>,</operator> <name>src0</name><operator>,</operator> <name>srcstride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>,</operator>
<name>chroma_weight</name><operator>,</operator> <name>chroma_offset</name><operator>,</operator> <name>_mx</name><operator>,</operator> <name>_my</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>void</name></type> <name>chroma_mc_bi</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst0</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>dststride</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>ref0</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>ref1</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>x_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>block_h</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MvField</name></name> <modifier>*</modifier></type><name>current_mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name><name>ref0</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src2</name> <init>= <expr><name><name>ref1</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>src1stride</name> <init>= <expr><name><name>ref0</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>src2stride</name> <init>= <expr><name><name>ref1</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weight_flag</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_pred_flag</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>weighted_bipred_flag</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mv0</name> <init>= <expr><operator>&amp;</operator><name><name>current_mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mv1</name> <init>= <expr><operator>&amp;</operator><name><name>current_mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vshift</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>intptr_t</name></type> <name>mx0</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv0</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>hshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>my0</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv0</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>vshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>mx1</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>hshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>my1</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name><name>mv1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>vshift</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_mx0</name> <init>= <expr><name>mx0</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>hshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_my0</name> <init>= <expr><name>my0</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>vshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_mx1</name> <init>= <expr><name>mx1</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>hshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>_my1</name> <init>= <expr><name>my1</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>vshift</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x_off0</name> <init>= <expr><name>x_off</name> <operator>+</operator> <operator>(</operator><name><name>mv0</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>hshift</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_off0</name> <init>= <expr><name>y_off</name> <operator>+</operator> <operator>(</operator><name><name>mv0</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>vshift</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_off1</name> <init>= <expr><name>x_off</name> <operator>+</operator> <operator>(</operator><name><name>mv1</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>hshift</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_off1</name> <init>= <expr><name>y_off</name> <operator>+</operator> <operator>(</operator><name><name>mv1</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>vshift</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>ff_hevc_pel_weight</name><index>[<expr><name>block_w</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>src1</name> <operator>+=</operator> <name>y_off0</name> <operator>*</operator> <name>src1stride</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>x_off0</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src2</name> <operator>+=</operator> <name>y_off1</name> <operator>*</operator> <name>src2stride</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>x_off1</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off0</name> <operator>&lt;</operator> <name>EPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off0</name> <operator>&lt;</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off0</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off0</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset1</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator> <operator>(</operator><name>src1stride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset1</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator>
<operator>(</operator><name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>, <argument><expr><name>src1</name> <operator>-</operator> <name>offset1</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>src1stride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>, <argument><expr><name>block_h</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off0</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>y_off0</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>src1</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name> <operator>+</operator> <name>buf_offset1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src1stride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x_off1</name> <operator>&lt;</operator> <name>EPEL_EXTRA_BEFORE</name> <operator>||</operator> <name>y_off1</name> <operator>&lt;</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>x_off1</name> <operator>&gt;=</operator> <name>pic_width</name> <operator>-</operator> <name>block_w</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name> <operator>||</operator>
<name>y_off1</name> <operator>&gt;=</operator> <name>pic_height</name> <operator>-</operator> <name>block_h</name> <operator>-</operator> <name>EPEL_EXTRA_AFTER</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>edge_emu_stride</name> <init>= <expr><name>EDGE_EMU_BUFFER_STRIDE</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset1</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator> <operator>(</operator><name>src2stride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_offset1</name> <init>= <expr><name>EPEL_EXTRA_BEFORE</name> <operator>*</operator>
<operator>(</operator><name>edge_emu_stride</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pixel_shift</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name></expr></argument>, <argument><expr><name>src2</name> <operator>-</operator> <name>offset1</name></expr></argument>,
<argument><expr><name>edge_emu_stride</name></expr></argument>, <argument><expr><name>src2stride</name></expr></argument>,
<argument><expr><name>block_w</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>, <argument><expr><name>block_h</name> <operator>+</operator> <name>EPEL_EXTRA</name></expr></argument>,
<argument><expr><name>x_off1</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>y_off1</name> <operator>-</operator> <name>EPEL_EXTRA_BEFORE</name></expr></argument>,
<argument><expr><name>pic_width</name></expr></argument>, <argument><expr><name>pic_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>src2</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>edge_emu_buffer2</name></name> <operator>+</operator> <name>buf_offset1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src2stride</name> <operator>=</operator> <name>edge_emu_stride</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_epel</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my0</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx0</name></expr>]</index></name><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator> <name>src1</name><operator>,</operator> <name>src1stride</name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>_mx0</name><operator>,</operator> <name>_my0</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weight_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_epel_bi</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my1</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx1</name></expr>]</index></name><operator>(</operator><name>dst0</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>,</operator>
<name>src2</name><operator>,</operator> <name>src2stride</name><operator>,</operator> <name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator>
<name>block_h</name><operator>,</operator> <name>_mx1</name><operator>,</operator> <name>_my1</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hevcdsp</name><operator>.</operator><name>put_hevc_epel_bi_w</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>my1</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>mx1</name></expr>]</index></name><operator>(</operator><name>dst0</name><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>cidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>,</operator>
<name>src2</name><operator>,</operator> <name>src2stride</name><operator>,</operator> <name><name>lc</name><operator>-&gt;</operator><name>tmp</name></name><operator>,</operator>
<name>block_h</name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_log2_weight_denom</name></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><name>cidx</name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><name>cidx</name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><name>cidx</name></expr>]</index></name><operator>,</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name><name>current_mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><name>cidx</name></expr>]</index></name><operator>,</operator>
<name>_mx1</name><operator>,</operator> <name>_my1</name><operator>,</operator> <name>block_w</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hevc_await_progress</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>HEVCFrame</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Mv</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>==</operator> <name>FF_THREAD_FRAME</name></expr> )</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>mv</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>y0</name> <operator>+</operator> <name>height</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_thread_await_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hevc_luma_mv_mvp_mode</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_idx</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>merge_idx</name></decl></parameter>, <parameter><decl><type><name>MvField</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>InterPredIdc</name></name></type> <name>inter_pred_idc</name> <init>= <expr><name>PRED_L0</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mvp_flag</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>pred_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>inter_pred_idc</name> <operator>=</operator> <call><name>ff_hevc_inter_pred_idc_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inter_pred_idc</name> <operator>!=</operator> <name>PRED_L1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <call><name>ff_hevc_ref_idx_lx_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>pred_flag</name></name> <operator>=</operator> <name>PF_L0</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_hls_mvd_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mvp_flag</name> <operator>=</operator> <call><name>ff_hevc_mvp_lx_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_luma_mv_mvp_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>,
<argument><expr><name>part_idx</name></expr></argument>, <argument><expr><name>merge_idx</name></expr></argument>, <argument><expr><name>mv</name></expr></argument>, <argument><expr><name>mvp_flag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>+=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mvd</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>+=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mvd</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inter_pred_idc</name> <operator>!=</operator> <name>PRED_L0</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <call><name>ff_hevc_ref_idx_lx_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><name>L1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>mvd_l1_zero_flag</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>inter_pred_idc</name> <operator>==</operator> <name>PRED_BI</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AV_ZERO32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mvd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_mvd_coding</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>pred_flag</name></name> <operator>+=</operator> <name>PF_L1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mvp_flag</name> <operator>=</operator> <call><name>ff_hevc_mvp_lx_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_luma_mv_mvp_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>,
<argument><expr><name>part_idx</name></expr></argument>, <argument><expr><name>merge_idx</name></expr></argument>, <argument><expr><name>mv</name></expr></argument>, <argument><expr><name>mvp_flag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>+=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mvd</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>+=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mvd</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hls_prediction_unit</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POS</name><parameter_list>(<parameter><type><name>c_idx</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>&amp;s-&gt;frame-&gt;data[c_idx][((y) &gt;&gt; s-&gt;ps.sps-&gt;vshift[c_idx]) * s-&gt;frame-&gt;linesize[c_idx] + (((x) &gt;&gt; s-&gt;ps.sps-&gt;hshift[c_idx]) &lt;&lt; s-&gt;ps.sps-&gt;pixel_shift)]</cpp:value></cpp:define>


<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>merge_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MvField</name></name></type> <name>current_mv</name> <init>= <expr><block>{<expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCFrame</name> <modifier>*</modifier></type><name>ref0</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ref1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst0</name> <init>= <expr><call><name>POS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst1</name> <init>= <expr><call><name>POS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst2</name> <init>= <expr><call><name>POS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log2_min_cb_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_cb_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_cb_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_cb</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_cb</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_pu</name></decl>, <decl><type ref="prev"/><name>y_pu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>skip_flag</name> <init>= <expr><call><name>SAMPLE_CTB</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name></expr></argument>, <argument><expr><name>x_cb</name></expr></argument>, <argument><expr><name>y_cb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>merge_flag</name></name> <operator>=</operator> <call><name>ff_hevc_merge_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>skip_flag</name> <operator>||</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>merge_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>max_num_merge_cand</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>merge_idx</name> <operator>=</operator> <call><name>ff_hevc_merge_idx_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>merge_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>ff_hevc_luma_mv_merge_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>,
<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>merge_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>hevc_luma_mv_mvp_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>,
<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>merge_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>x_pu</name> <operator>=</operator> <name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>y_pu</name> <operator>=</operator> <name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>nPbH</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><name>nPbW</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab_mvf</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>current_mv</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>current_mv</name><operator>.</operator><name>pred_flag</name></name> <operator>&amp;</operator> <name>PF_L0</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ref0</name> <operator>=</operator> <name><name>refPicList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>ref</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref0</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hevc_await_progress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ref0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>current_mv</name><operator>.</operator><name>pred_flag</name></name> <operator>&amp;</operator> <name>PF_L1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ref1</name> <operator>=</operator> <name><name>refPicList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>ref</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref1</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hevc_await_progress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ref1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>current_mv</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_L0</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x0_c</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y0_c</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbW_c</name> <init>= <expr><name>nPbW</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbH_c</name> <init>= <expr><name>nPbH</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>luma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>chroma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>chroma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l0</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>current_mv</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_L1</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x0_c</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y0_c</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbW_c</name> <init>= <expr><name>nPbW</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbH_c</name> <init>= <expr><name>nPbH</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>luma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_weight_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>luma_offset_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>chroma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chroma_mc_uni</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_weight_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>chroma_offset_l1</name><index>[<expr><name><name>current_mv</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>current_mv</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_BI</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x0_c</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y0_c</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbW_c</name> <init>= <expr><name>nPbW</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>hshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPbH_c</name> <init>= <expr><name>nPbH</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>vshift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>luma_mc_bi</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>,
<argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current_mv</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>chroma_mc_bi</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>,
<argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chroma_mc_bi</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst2</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref0</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>, <argument><expr><name><name>ref1</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>,
<argument><expr><name>x0_c</name></expr></argument>, <argument><expr><name>y0_c</name></expr></argument>, <argument><expr><name>nPbW_c</name></expr></argument>, <argument><expr><name>nPbH_c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_mv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>luma_intra_pred_mode</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pu_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prev_intra_luma_pred_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_pu</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_pu</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size_in_pus</name> <init>= <expr><name>pu_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x0b</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y0b</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name>y0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cand_up</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_flag</name></name> <operator>||</operator> <name>y0b</name><operator>)</operator></expr> ?</condition><then>
<expr><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name></expr>]</index></name></expr> </then><else>: <expr><name>INTRA_DC</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cand_left</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>ctb_left_flag</name></name> <operator>||</operator> <name>x0b</name><operator>)</operator></expr> ?</condition><then>
<expr><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name><index>[<expr><name>y_pu</name> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>INTRA_DC</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>y_ctb</name> <init>= <expr><operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>intra_pred_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>candidate</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>y0</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>y_ctb</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cand_up</name> <operator>=</operator> <name>INTRA_DC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cand_left</name> <operator>==</operator> <name>cand_up</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cand_left</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_PLANAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_DC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_ANGULAR_26</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cand_left</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>cand_left</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>cand_left</name> <operator>-</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cand_left</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cand_up</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INTRA_PLANAR</name> <operator>&amp;&amp;</operator> <name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>INTRA_PLANAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_PLANAR</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INTRA_DC</name> <operator>&amp;&amp;</operator> <name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>INTRA_DC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_DC</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTRA_ANGULAR_26</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_intra_luma_pred_flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>intra_pred_mode</name> <operator>=</operator> <name><name>candidate</name><index>[<expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mpm_idx</name></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>candidate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>intra_pred_mode</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>rem_intra_luma_pred_mode</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>intra_pred_mode</name> <operator>&gt;=</operator> <name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>intra_pred_mode</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_in_pus</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size_in_pus</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size_in_pus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name></expr>]</index></name></expr></argument>,
<argument><expr><name>intra_pred_mode</name></expr></argument>, <argument><expr><name>size_in_pus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size_in_pus</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>tab_mvf</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>PF_INTRA</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>intra_pred_mode</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>set_ct_depth</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ct_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name><operator>)</operator> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_cb</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_cb</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ct_depth</name><index>[<expr><operator>(</operator><name>y_cb</name> <operator>+</operator> <name>y</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_cb_width</name></name> <operator>+</operator> <name>x_cb</name></expr>]</index></name></expr></argument>,
<argument><expr><name>ct_depth</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>tab_mode_idx</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>,
<expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>intra_prediction_unit</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>intra_chroma_table</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>prev_intra_luma_pred_flag</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>split</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_NxN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pb_size</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>split</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>side</name> <init>= <expr><name>split</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>prev_intra_luma_pred_flag</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>ff_hevc_prev_intra_luma_pred_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev_intra_luma_pred_flag</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>mpm_idx</name></name> <operator>=</operator> <call><name>ff_hevc_mpm_idx_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>rem_intra_luma_pred_mode</name></name> <operator>=</operator> <call><name>ff_hevc_rem_intra_luma_pred_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator>
<call><name>luma_intra_pred_mode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>pb_size</name> <operator>*</operator> <name>j</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>pb_size</name> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>pb_size</name></expr></argument>,
<argument><expr><name><name>prev_intra_luma_pred_flag</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>side</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>chroma_mode_c</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>chroma_mode</name> <operator>=</operator> <call><name>ff_hevc_intra_chroma_pred_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chroma_mode</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>==</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mode_idx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>chroma_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>chroma_mode</name> <operator>=</operator> <call><name>ff_hevc_intra_chroma_pred_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chroma_mode</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mode_idx</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mode_idx</name> <operator>=</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>mode_idx</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tab_mode_idx</name><index>[<expr><name>mode_idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>chroma_format_idc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>chroma_mode</name> <operator>=</operator> <call><name>ff_hevc_intra_chroma_pred_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chroma_mode</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>intra_chroma_table</name><index>[<expr><name>chroma_mode</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode_c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>intra_prediction_unit_default_value</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size_in_pus</name> <init>= <expr><name>pb_size</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_pu</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_pu</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size_in_pus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size_in_pus</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size_in_pus</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tab_ipm</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name></expr>]</index></name></expr></argument>, <argument><expr><name>INTRA_DC</name></expr></argument>, <argument><expr><name>size_in_pus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size_in_pus</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size_in_pus</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tab_mvf</name><index>[<expr><operator>(</operator><name>y_pu</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>min_pu_width</name> <operator>+</operator> <name>x_pu</name> <operator>+</operator> <name>k</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>PF_INTRA</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_coding_unit</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log2_min_cb_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name>cb_size</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_cb_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_cb_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_cb</name> <init>= <expr><name>x0</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_cb</name> <init>= <expr><name>y0</name> <operator>&gt;&gt;</operator> <name>log2_min_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>log2_cb_size</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>qp_block_mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>diff_cu_qp_delta_depth</name></name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>=</operator> <name>MODE_INTRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>=</operator> <name>PART_2Nx2N</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SAMPLE_CTB</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name></expr></argument>, <argument><expr><name>x_cb</name></expr></argument>, <argument><expr><name>y_cb</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>intra_pred_mode</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>transquant_bypass_enable_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>cu_transquant_bypass_flag</name></name> <operator>=</operator> <call><name>ff_hevc_cu_transquant_bypass_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>cu_transquant_bypass_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_deblocking_bypass</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>cu_transquant_bypass_flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>!=</operator> <name>HEVC_SLICE_I</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>skip_flag</name> <init>= <expr><call><name>ff_hevc_skip_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>x_cb</name></expr></argument>, <argument><expr><name>y_cb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name>y_cb</name> <operator>*</operator> <name>min_cb_width</name> <operator>+</operator> <name>x_cb</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><name>skip_flag</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>min_cb_width</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>=</operator> <ternary><condition><expr><name>skip_flag</name></expr> ?</condition><then> <expr><name>MODE_SKIP</name></expr> </then><else>: <expr><name>MODE_INTER</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>y_cb</name> <operator>*</operator> <name>min_cb_width</name> <operator>+</operator> <name>x_cb</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>min_cb_width</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SAMPLE_CTB</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>skip_flag</name></name></expr></argument>, <argument><expr><name>x_cb</name></expr></argument>, <argument><expr><name>y_cb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>intra_prediction_unit_default_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>disable_deblocking_filter_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_deblocking_boundary_strengths</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pcm_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>!=</operator> <name>HEVC_SLICE_I</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>=</operator> <call><name>ff_hevc_pred_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>!=</operator> <name>MODE_INTRA</name> <operator>||</operator>
<name>log2_cb_size</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>=</operator> <call><name>ff_hevc_part_mode_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_NxN</name> <operator>&amp;&amp;</operator>
<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_2Nx2N</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm_enabled_flag</name></name> <operator>&amp;&amp;</operator>
<name>log2_cb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>log2_min_pcm_cb_size</name></name> <operator>&amp;&amp;</operator>
<name>log2_cb_size</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>log2_max_pcm_cb_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pcm_flag</name> <operator>=</operator> <call><name>ff_hevc_pcm_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pcm_flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>intra_prediction_unit_default_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hls_pcm_sample</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>pcm</name><operator>.</operator><name>loop_filter_disable_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_deblocking_bypass</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>intra_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>intra_prediction_unit_default_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PART_2Nx2N</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_2NxN</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_Nx2N</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_2NxnU</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_2NxnD</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_nLx2N</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_nRx2N</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>cb_size</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PART_NxN</name></expr>:</case>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_prediction_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>cb_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pcm_flag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rqt_root_cbf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>!=</operator> <name>MODE_INTRA</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_2Nx2N</name> <operator>&amp;&amp;</operator> <name><name>lc</name><operator>-&gt;</operator><name>pu</name><operator>.</operator><name>merge_flag</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rqt_root_cbf</name> <operator>=</operator> <call><name>ff_hevc_no_residual_syntax_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rqt_root_cbf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>int</name></type> <name><name>cbf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>max_trafo_depth</name></name> <operator>=</operator> <ternary><condition><expr><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>pred_mode</name></name> <operator>==</operator> <name>MODE_INTRA</name></expr> ?</condition><then>
<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>max_transform_hierarchy_depth_intra</name></name> <operator>+</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>intra_split_flag</name></name></expr> </then><else>:
<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>max_transform_hierarchy_depth_inter</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hls_transform_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>,
<argument><expr><name>log2_cb_size</name></expr></argument>,
<argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cbf</name></expr></argument>, <argument><expr><name>cbf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>disable_deblocking_filter_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_deblocking_boundary_strengths</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cu_qp_delta_enabled_flag</name></name> <operator>&amp;&amp;</operator> <name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_qp_delta_coded</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_set_qPy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name>y_cb</name> <operator>*</operator> <name>min_cb_width</name> <operator>+</operator> <name>x_cb</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>qp_y_tab</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>qp_y</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>min_cb_width</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>x0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2_cb_size</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>qp_block_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>y0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2_cb_size</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>qp_block_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>qPy_pred</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>qp_y</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_ct_depth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>, <argument><expr><name><name>lc</name><operator>-&gt;</operator><name>ct_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_coding_quadtree</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>split_cu</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>ct_depth</name></name> <operator>=</operator> <name>cb_depth</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator>
<name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&amp;&amp;</operator>
<name>log2_cb_size</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>split_cu</name> <operator>=</operator> <call><name>ff_hevc_split_coding_unit_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>cb_depth</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>split_cu</name> <operator>=</operator> <operator>(</operator><name>log2_cb_size</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>cu_qp_delta_enabled_flag</name></name> <operator>&amp;&amp;</operator>
<name>log2_cb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>diff_cu_qp_delta_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_qp_delta_coded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>cu_qp_delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>cu_chroma_qp_offset_enabled_flag</name></name> <operator>&amp;&amp;</operator>
<name>log2_cb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>diff_cu_chroma_qp_offset_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>tu</name><operator>.</operator><name>is_cu_chroma_qp_offset_coded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>split_cu</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>qp_block_mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>diff_cu_qp_delta_depth</name></name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cb_size_split</name> <init>= <expr><name>cb_size</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x1</name> <init>= <expr><name>x0</name> <operator>+</operator> <name>cb_size_split</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y1</name> <init>= <expr><name>y0</name> <operator>+</operator> <name>cb_size_split</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>more_data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>cb_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>more_data</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&amp;&amp;</operator> <name>x1</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>cb_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>more_data</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&amp;&amp;</operator> <name>y1</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>log2_cb_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>cb_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>more_data</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&amp;&amp;</operator> <name>x1</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator>
<name>y1</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>log2_cb_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>cb_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>more_data</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>x0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2_cb_size</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>qp_block_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>y0</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2_cb_size</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>qp_block_mask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>qPy_pred</name></name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>qp_y</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>more_data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>x1</name> <operator>+</operator> <name>cb_size_split</name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>||</operator>
<operator>(</operator><name>y1</name> <operator>+</operator> <name>cb_size_split</name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hls_coding_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>x0</name> <operator>+</operator> <name>cb_size</name><operator>)</operator> <operator>%</operator>
<operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>x0</name> <operator>+</operator> <name>cb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>y0</name> <operator>+</operator> <name>cb_size</name><operator>)</operator> <operator>%</operator>
<operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>y0</name> <operator>+</operator> <name>cb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>end_of_slice_flag</name> <init>= <expr><call><name>ff_hevc_end_of_slice_flag_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>!</operator><name>end_of_slice_flag</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hls_decode_neighbour</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x_ctb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y_ctb</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ctb_addr_ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_rs</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_ts_to_rs</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_in_slice</name> <init>= <expr><name>ctb_addr_rs</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_addr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>entropy_coding_sync_enabled_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>x_ctb</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>y_ctb</name> <operator>&amp;</operator> <operator>(</operator><name>ctb_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>first_qp_group</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_x</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tiles_enabled_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctb_addr_ts</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idxX</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>col_idxX</name><index>[<expr><name>x_ctb</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_x</name></name> <operator>=</operator> <name>x_ctb</name> <operator>+</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>column_width</name><index>[<expr><name>idxX</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>first_qp_group</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_x</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_y</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>y_ctb</name> <operator>+</operator> <name>ctb_size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tiles_enabled_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>x_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name>ctb_addr_rs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_LEFT_TILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>x_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_LEFT_SLICE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>y_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name>ctb_addr_rs</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_UPPER_TILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>y_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_UPPER_SLICE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctb_addr_in_slice</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_LEFT_SLICE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ctb_addr_in_slice</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>|=</operator> <name>BOUNDARY_UPPER_SLICE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_left_flag</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ctb_addr_in_slice</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>&amp;</operator> <name>BOUNDARY_LEFT_TILE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_flag</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>y_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ctb_addr_in_slice</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>boundary_flags</name></name> <operator>&amp;</operator> <name>BOUNDARY_UPPER_TILE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_right_flag</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>y_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ctb_addr_in_slice</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name>ctb_addr_rs</name><operator>+</operator><literal type="number">1</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr>]</index></name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_left_flag</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>y_ctb</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ctb_addr_in_slice</name><operator>-</operator><literal type="number">1</literal> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tile_id</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name>ctb_addr_rs</name><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr>]</index></name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_decode_entry</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctxt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>isFilterThread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctxt</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_size</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>more_data</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x_ctb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_ctb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_ts</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_ctb_addr_rs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctb_addr_ts</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>dependent_slice_segment_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Impossible initial tile.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>dependent_slice_segment_flag</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>prev_rs</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_ts_to_rs</name><index>[<expr><name>ctb_addr_ts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>prev_rs</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Previous slice segment missing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>more_data</name> <operator>&amp;&amp;</operator> <name>ctb_addr_ts</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_rs</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_ts_to_rs</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>x_ctb</name> <operator>=</operator> <operator>(</operator><name>ctb_addr_rs</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <name>ctb_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>y_ctb</name> <operator>=</operator> <operator>(</operator><name>ctb_addr_rs</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <name>ctb_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hls_decode_neighbour</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_cabac_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hls_sao_param</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>, <argument><expr><name>y_ctb</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>deblock</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name><operator>.</operator><name>beta_offset</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>beta_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>deblock</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name><operator>.</operator><name>tc_offset</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>tc_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>filter_slice_edges</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_loop_filter_across_slices_enabled_flag</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>more_data</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ctb_addr_ts</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_save_states</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_hls_filters</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>x_ctb</name> <operator>+</operator> <name>ctb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator>
<name>y_ctb</name> <operator>+</operator> <name>ctb_size</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_filter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ctb_addr_ts</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_slice_data</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ret</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>hls_decode_entry</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ret</name></expr></argument> , <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ret</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_decode_entry_wpp</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctxt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>input_ctb_row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>job</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>self_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><name><name>avctxt</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_size</name> <init>= <expr><literal type="number">1</literal><operator>&lt;&lt;</operator> <name><name>s1</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>more_data</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ctb_row_p</name> <init>= <expr><name>input_ctb_row</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_row</name> <init>= <expr><name><name>ctb_row_p</name><index>[<expr><name>job</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_rs</name> <init>= <expr><name><name>s1</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_ctb_addr_rs</name></name> <operator>+</operator> <name>ctb_row</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>s1</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <name>ctb_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name><name>s1</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_ts</name> <init>= <expr><name><name>s1</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_rs_to_ts</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>thread</name> <init>= <expr><name>ctb_row</name> <operator>%</operator> <name><name>s1</name><operator>-&gt;</operator><name>threads_number</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s1</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>self_id</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ctb_row</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lc</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name><index>[<expr><name>ctb_row</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name><index>[<expr><name>ctb_row</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ff_init_cabac_decoder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lc</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name><index>[<expr><operator>(</operator><name>ctb_row</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name><index>[<expr><name>ctb_row</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while<condition>(<expr><name>more_data</name> <operator>&amp;&amp;</operator> <name>ctb_addr_ts</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x_ctb</name> <init>= <expr><operator>(</operator><name>ctb_addr_rs</name> <operator>%</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y_ctb</name> <init>= <expr><operator>(</operator><name>ctb_addr_rs</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hls_decode_neighbour</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_thread_await_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s1</name><operator>-&gt;</operator><name>wpp_err</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument> , <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_cabac_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hls_sao_param</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>, <argument><expr><name>y_ctb</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>more_data</name> <operator>=</operator> <call><name>hls_coding_quadtree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>more_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>more_data</name></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ctb_addr_ts</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_hevc_save_states</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ctb_addr_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_hls_filters</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>more_data</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>x_ctb</name><operator>+</operator><name>ctb_size</name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator> <name>ctb_row</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s1</name><operator>-&gt;</operator><name>wpp_err</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument> ,<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>x_ctb</name><operator>+</operator><name>ctb_size</name><operator>)</operator> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>y_ctb</name><operator>+</operator><name>ctb_size</name><operator>)</operator> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_hls_filter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x_ctb</name></expr></argument>, <argument><expr><name>y_ctb</name></expr></argument>, <argument><expr><name>ctb_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument> , <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ctb_addr_ts</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ctb_addr_rs</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>ctb_addr_ts_to_rs</name><index>[<expr><name>ctb_addr_ts</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x_ctb</name><operator>+=</operator><name>ctb_size</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>x_ctb</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument> ,<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name><index>[<expr><name>ctb_addr_rs</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s1</name><operator>-&gt;</operator><name>wpp_err</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_thread_report_progress2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>ctb_row</name></expr></argument> ,<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>SHIFT_CTB_WPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hls_slice_data_wpp</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>nal</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><name><name>nal</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>startheader</name></decl>, <decl><type ref="prev"/><name>cmpt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>||</operator> <operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_ctb_addr_rs</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"WPP ctb addresses are wrong (%d %d %d %d)\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_ctb_addr_rs</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_alloc_entries</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HEVCContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HEVCContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HEVCLocalContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>HEVClc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>index</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>cmpt</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>startheader</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes_pos</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes_pos</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <name>startheader</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>startheader</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cmpt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>cmpt</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>cmpt</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>startheader</name> <operator>=</operator> <name>offset</name>
<operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes_pos</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name><name>nal</name><operator>-&gt;</operator><name>skipped_bytes_pos</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <name>startheader</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>startheader</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cmpt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>cmpt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>cmpt</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"entry_point_offset table is corrupted\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>length</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>HEVClc</name><operator>-&gt;</operator><name>first_qp_group</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>HEVClc</name><operator>-&gt;</operator><name>qp_y</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>HEVClc</name><operator>-&gt;</operator><name>qp_y</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HEVCContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>HEVClc</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>wpp_err</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_reset_entries</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>entropy_coding_sync_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>execute2</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>hls_decode_entry_wpp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_side_data</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>frame</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>present</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>arrangement_type</name></name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>arrangement_type</name></name> <operator>&lt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>content_interpretation_type</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>content_interpretation_type</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVStereo3D</name> <modifier>*</modifier></type><name>stereo</name> <init>= <expr><call><name>av_stereo3d_create_side_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stereo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>arrangement_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>quincunx_subsampling</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AV_STEREO3D_SIDEBYSIDE_QUINCUNX</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AV_STEREO3D_SIDEBYSIDE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AV_STEREO3D_TOPBOTTOM</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AV_STEREO3D_FRAMESEQUENCE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>content_interpretation_type</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>AV_STEREO3D_FLAG_INVERT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>arrangement_type</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name><operator>.</operator><name>current_frame_is_frame0_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>view</name></name> <operator>=</operator> <name>AV_STEREO3D_VIEW_LEFT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stereo</name><operator>-&gt;</operator><name>view</name></name> <operator>=</operator> <name>AV_STEREO3D_VIEW_RIGHT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>present</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>anticlockwise_rotation</name></name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>hflip</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>vflip</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>angle</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>anticlockwise_rotation</name></name> <operator>*</operator> <literal type="number">360</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrameSideData</name> <modifier>*</modifier></type><name>rotation</name> <init>= <expr><call><name>av_frame_new_side_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>,
<argument><expr><name>AV_FRAME_DATA_DISPLAYMATRIX</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rotation</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_display_rotation_set</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>rotation</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_display_matrix_flip</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>rotation</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>hflip</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name><operator>.</operator><name>vflip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>present</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>no_rasl_output_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>present</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>present</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>mapping</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>chroma_den</name> <init>= <expr><literal type="number">50000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>luma_den</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVMasteringDisplayMetadata</name> <modifier>*</modifier></type><name>metadata</name> <init>=
<expr><call><name>av_mastering_display_metadata_create_side_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>metadata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><name><name>mapping</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>num</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>display_primaries</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>den</name> <operator>=</operator> <name>chroma_den</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>num</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>display_primaries</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>den</name> <operator>=</operator> <name>chroma_den</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>num</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>white_point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>den</name> <operator>=</operator> <name>chroma_den</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>num</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>white_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>den</name> <operator>=</operator> <name>chroma_den</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>max_luminance</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>max_luminance</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>max_luminance</name><operator>.</operator><name>den</name></name> <operator>=</operator> <name>luma_den</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>min_luminance</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name><operator>.</operator><name>min_luminance</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>min_luminance</name><operator>.</operator><name>den</name></name> <operator>=</operator> <name>luma_den</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>has_luminance</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>has_primaries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Mastering Display Metadata:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>,
<argument><expr><literal type="string">"r(%5.4f,%5.4f) g(%5.4f,%5.4f) b(%5.4f %5.4f) wp(%5.4f, %5.4f)\n"</literal></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>,
<argument><expr><literal type="string">"min_luminance=%f, max_luminance=%f\n"</literal></expr></argument>,
<argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>min_luminance</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>av_q2d</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>max_luminance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name><operator>.</operator><name>present</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>no_rasl_output_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name><operator>.</operator><name>present</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name><operator>.</operator><name>present</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVContentLightMetadata</name> <modifier>*</modifier></type><name>metadata</name> <init>=
<expr><call><name>av_content_light_metadata_create_side_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>metadata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxCLL</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name><operator>.</operator><name>max_content_light_level</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxFALL</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name><operator>.</operator><name>max_pic_average_light_level</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Content Light Level Metadata:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"MaxCLL=%d, MaxFALL=%d\n"</literal></expr></argument>,
<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxCLL</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxFALL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEVCSEIA53Caption</name> <modifier>*</modifier></type><name>a53</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrameSideData</name> <modifier>*</modifier></type><name>sd</name> <init>= <expr><call><name>av_frame_new_side_data_from_buf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>AV_FRAME_DATA_A53_CC</name></expr></argument>, <argument><expr><name><name>a53</name><operator>-&gt;</operator><name>buf_ref</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a53</name><operator>-&gt;</operator><name>buf_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>a53</name><operator>-&gt;</operator><name>buf_ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>properties</name></name> <operator>|=</operator> <name>FF_CODEC_PROPERTY_CLOSED_CAPTIONS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hevc_frame_start</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pic_size_in_ctb</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_cb_size</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>horizontal_bs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>bs_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>vertical_bs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bs_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>bs_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cbf_luma</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_tb_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_tb_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>is_pcm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pic_size_in_ctb</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>tab_slice_address</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>first_nal_type</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>no_rasl_output_flag</name></name> <operator>=</operator> <call><name>IS_IDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BLA</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_CRA_NUT</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_eos</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>tiles_enabled_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_x</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>column_width</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_set_new_ref</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_frame_rps</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error constructing the frame RPS.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>key_frame</name></name> <operator>=</operator> <call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>set_side_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame</name><operator>-&gt;</operator><name>pict_type</name></name> <operator>=</operator> <literal type="number">3</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_bump_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_frame_unref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_output_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_thread_finish_setup</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_nal_unit</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>lc</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctb_addr_ts</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>gb</name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>gb</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>temporal_id</name></name> <operator>=</operator> <name><name>nal</name><operator>-&gt;</operator><name>temporal_id</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HEVC_NAL_VPS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_nal_vps</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_SPS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_nal_sps</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>apply_defdispwin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_PPS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_nal_pps</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_SEI_PREFIX</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_SEI_SUFFIX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_params</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>,
<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_nal_sei</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_TRAIL_R</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_TRAIL_N</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_TSA_N</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_TSA_R</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_STSA_N</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_STSA_R</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_BLA_W_LP</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_BLA_W_RADL</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_BLA_N_LP</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_IDR_W_RADL</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_IDR_N_LP</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_CRA_NUT</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_RADL_N</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_RADL_R</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_RASL_N</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_RASL_R</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hls_slice_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(
<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_BIDIR</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_NONINTRA</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>!=</operator> <name>HEVC_SLICE_I</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_NONKEY</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_IRAP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>first_slice_in_pic_flag</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_CRA_NUT</name> <operator>||</operator> <call><name>IS_BLA</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_IDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_RASL_R</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_RASL_N</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>==</operator> <name>HEVC_NAL_RASL_R</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>overlap</name></name> <operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_frame_start</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"First slice in a frame missing.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>first_nal_type</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Non-matching NAL types of the VCL NALUs: %d %d\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>first_nal_type</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>dependent_slice_segment_flag</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>!=</operator> <name>HEVC_SLICE_I</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_slice_rpl</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Error constructing the reference lists for the current slice.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>first_slice_in_pic_flag</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>start_frame</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>decode_slice</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_data</name></name></expr></argument>, <argument><expr><name><name>nal</name><operator>-&gt;</operator><name>raw_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>num_entry_point_offsets</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ctb_addr_ts</name> <operator>=</operator> <call><name>hls_slice_data_wpp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ctb_addr_ts</name> <operator>=</operator> <call><name>hls_slice_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ctb_addr_ts</name> <operator>&gt;=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_width</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>ctb_height</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ctb_addr_ts</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ctb_addr_ts</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_EOS_NUT</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_EOB_NUT</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HEVC_NAL_AUD</name></expr>:</case>
<case>case <expr><name>HEVC_NAL_FD_NUT</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"Skipping NAL unit %d\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nal_unit_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>fail</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_nal_units</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eos_at_start</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_eos</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>eos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>overlap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_h2645_packet_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>is_nalff</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error splitting the input into NAL units.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nb_nals</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>HEVC_NAL_EOB_NUT</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>HEVC_NAL_EOS_NUT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>eos_at_start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_eos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eos_at_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nb_nals</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>H2645NAL</name> <modifier>*</modifier></type><name>nal</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pkt</name><operator>.</operator><name>nals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_ALL</name> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>skip_frame</name></name> <operator>&gt;=</operator> <name>AVDISCARD_NONREF</name>
<operator>&amp;&amp;</operator> <call><name>ff_hevc_nal_is_nonref</name><argument_list>(<argument><expr><name><name>nal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name><name>nal</name><operator>-&gt;</operator><name>nuh_layer_id</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>decode_nal_unit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>overlap</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Error parsing NAL unit #%d.\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<label><name>fail</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>==</operator> <name>FF_THREAD_FRAME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_thread_report_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_md5</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log_ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name><name>md5</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log_ctx</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"%02"</literal><name>PRIx8</name></expr></argument>, <argument><expr><name><name>md5</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>verify_md5</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pixel_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pixel_shift</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Verifying checksum for frame with POC %d: "</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>pixel_shift</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>checksum_buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_fast_malloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>checksum_buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>checksum_buf_size</name></name></expr></argument>,
<argument><expr><call><name>FFMAX3</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>checksum_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>coded_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>coded_height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>width</name> <operator>&gt;&gt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_w</name></name><operator>)</operator></expr> </then><else>: <expr><name>width</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>height</name> <operator>&gt;&gt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name><operator>)</operator></expr> </then><else>: <expr><name>height</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>md5</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_md5_init</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>j</name> <operator>*</operator> <name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>pixel_shift</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>bdsp</name><operator>.</operator><name>bswap16_buf</name></name><argument_list>(<argument><expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator> <name><name>s</name><operator>-&gt;</operator><name>checksum_buf</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><operator>)</operator> <name>src</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>checksum_buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>av_md5_update</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>w</name> <operator>&lt;&lt;</operator> <name>pixel_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_md5_final</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name></expr></argument>, <argument><expr><name>md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>md5</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>picture_hash</name><operator>.</operator><name>md5</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"plane %d - correct "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_md5</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><name>md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatching checksum of plane %d - "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_md5</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><name>md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">" != "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_md5</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>picture_hash</name><operator>.</operator><name>md5</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hevc_decode_extradata</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_decode_extradata</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>is_nalff</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>apply_defdispwin</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>HEVCSPS</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>HEVCSPS</name><operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>export_stream_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hevc_decode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_output</name></decl></parameter>,
<parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_extradata_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>new_extradata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_hevc_output_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>got_output</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_extradata</name> <operator>=</operator> <call><name>av_packet_get_side_data</name><argument_list>(<argument><expr><name>avpkt</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_NEW_EXTRADATA</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>new_extradata_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_extradata</name> <operator>&amp;&amp;</operator> <name>new_extradata_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_decode_extradata</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>new_extradata</name></expr></argument>, <argument><expr><name>new_extradata_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>decode_nal_units</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ret</name> <operator>=</operator> <call><name><name>avctx</name><operator>-&gt;</operator><name>hwaccel</name><operator>-&gt;</operator><name>end_frame</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"hardware accelerator failed to decode picture\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_CRCCHECK</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>picture_hash</name><operator>.</operator><name>is_md5</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>verify_md5</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>err_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>picture_hash</name><operator>.</operator><name>is_md5</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Decoded frame with POC %d.\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_decoded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>output_frame</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_move_ref</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>got_output</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hevc_ref_frame</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>HEVCFrame</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>HEVCFrame</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_thread_ref_frame</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tab_mvf_buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>tab_mvf_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>tab_mvf_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tab_mvf</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>rpl_tab_buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>rpl_tab_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>rpl_tab_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>rpl_tab</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>rpl_tab</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>rpl_buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>rpl_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>rpl_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>poc</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>poc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>ctb_count</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ctb_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>sequence</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>hwaccel_picture_private</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>hwaccel_priv_buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>hwaccel_priv_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>hwaccel_priv_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>hwaccel_picture_private</name></name> <operator>=</operator> <name><name>dst</name><operator>-&gt;</operator><name>hwaccel_priv_buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>hevc_decode_free</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pic_arrays_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>cabac_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_h</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sao_pixel_buffer_v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>DPB</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>ff_hevc_ps_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>entry_point_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h2645_packet_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_hevc_reset_sei</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>hevc_init_context</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HEVCLocalContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>HEVClcList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cabac_state</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>HEVC_CONTEXTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>cabac_state</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>output_frame</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>DPB</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frame</name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frame</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tf</name><operator>.</operator><name>f</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frame</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name> <operator>=</operator> <call><name>av_md5_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>md5_ctx</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ff_bswapdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>bdsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>context_initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_hevc_reset_sei</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>hevc_decode_free</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_THREADS</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hevc_update_thread_context</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVCodecContext</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>dst</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s0</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>context_initialized</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_init_context</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>DPB</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_hevc_unref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>frame</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_ref_frame</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s0</name><operator>-&gt;</operator><name>DPB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>!=</operator> <name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>vps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name> <operator>!=</operator> <name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>set_sps</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s0</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>seq_decode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_output</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>seq_output</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pocTid0</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>pocTid0</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>max_ra</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>eos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>no_rasl_output_flag</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>no_rasl_output_flag</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_nalff</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>is_nalff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nal_length_size</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>nal_length_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>threads_number</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>threads_type</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>eos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>seq_decode</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>a53_caption</name><operator>.</operator><name>buf_ref</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>frame_packing</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>display_orientation</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>mastering_display</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>content_light</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>alternative_transfer</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>hevc_decode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>allocate_progress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_init_context</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>enable_parallel_tiles</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sei</name><operator>.</operator><name>picture_timing</name><operator>.</operator><name>picture_struct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>atomic_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>wpp_err</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_SLICE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_decode_extradata</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hevc_decode_free</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>active_thread_type</name></name> <operator>&amp;</operator> <name>FF_THREAD_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>=</operator> <name>FF_THREAD_FRAME</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>=</operator> <name>FF_THREAD_SLICE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_THREADS</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>hevc_init_thread_copy</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hevc_init_context</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hevc_decode_flush</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_hevc_flush_dpb</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_hevc_reset_sei</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_ra</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>eos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(HEVCContext, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAR</name></cpp:macro> <cpp:value>(AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"apply_defdispwin"</literal></expr>, <expr><literal type="string">"Apply default display window from VUI"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>apply_defdispwin</name></expr></argument>)</argument_list></call></expr>,
<expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>PAR</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"strict-displaywin"</literal></expr>, <expr><literal type="string">"stricly apply default display window size"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>apply_defdispwin</name></expr></argument>)</argument_list></call></expr>,
<expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>PAR</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>hevc_decoder_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"HEVC decoder"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_hevc_decoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"hevc"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"HEVC (High Efficiency Video Coding)"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_HEVC</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HEVCContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>hevc_decoder_class</name></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>hevc_decode_init</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>hevc_decode_free</name></expr>,
<expr><operator>.</operator><name>decode</name> <operator>=</operator> <name>hevc_decode_frame</name></expr>,
<expr><operator>.</operator><name>flush</name> <operator>=</operator> <name>hevc_decode_flush</name></expr>,
<expr><operator>.</operator><name>update_thread_context</name> <operator>=</operator> <call><name>ONLY_IF_THREADS_ENABLED</name><argument_list>(<argument><expr><name>hevc_update_thread_context</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>init_thread_copy</name> <operator>=</operator> <call><name>ONLY_IF_THREADS_ENABLED</name><argument_list>(<argument><expr><name>hevc_init_thread_copy</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_DR1</name> <operator>|</operator> <name>AV_CODEC_CAP_DELAY</name> <operator>|</operator>
<name>AV_CODEC_CAP_SLICE_THREADS</name> <operator>|</operator> <name>AV_CODEC_CAP_FRAME_THREADS</name></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name> <operator>|</operator> <name>FF_CODEC_CAP_EXPORTS_CROPPING</name></expr>,
<expr><operator>.</operator><name>profiles</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><name>ff_hevc_profiles</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>hw_configs</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>AVCodecHWConfigInternal</name><operator>*</operator><index>[]</index><operator>)</operator> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_DXVA2_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_DXVA2</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_D3D11VA_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_D3D11VA</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_D3D11VA2_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_D3D11VA2</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_NVDEC_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_NVDEC</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VAAPI_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VAAPI</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VDPAU_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VDPAU</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL</name></expr></cpp:if>
<expr><call><name>HWACCEL_VIDEOTOOLBOX</name><argument_list>(<argument><expr><name>hevc</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>NULL</name></expr>
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
