<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\diracdec.c">



























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"get_bits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytestream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"golomb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dirac_arith.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dirac_vlc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpeg12data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/mpegvideo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpegvideoencdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dirac_dwt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dirac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diractab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diracdsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"videodsp.h"</cpp:file></cpp:include>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REFERENCE_FRAMES</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DELAY</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FRAMES</name></cpp:macro> <cpp:value>(MAX_REFERENCE_FRAMES + MAX_DELAY + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_QUANT</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BLOCKSIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRAC_REF_MASK_REF1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRAC_REF_MASK_REF2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRAC_REF_MASK_GLOBAL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELAYED_PIC_REF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALC_PADDING</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((size + (1 &lt;&lt; depth) - 1) &gt;&gt; depth) &lt;&lt; depth)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIVRNDUP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a) + (b) - 1) / (b))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>avframe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>interpolated</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>hpel</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>hpel_base</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reference</name></decl>;</decl_stmt>
}</block></struct></type> <name>DiracFrame</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<union>union <block>{
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>mv</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>dc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>u</name></decl>;</union> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ref</name></decl>;</decl_stmt>
}</block></struct></type> <name>DiracBlock</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SubBand</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orientation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stride</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pshift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ibuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>SubBand</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>coeff_data</name></decl>;</decl_stmt>
}</block></struct></type> <name>SubBand</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Plane</name> <block>{
<decl_stmt><decl><type><name>DWTPlane</name></type> <name>idwt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stride</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint8_t</name></type> <name>xblen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>yblen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>xbsep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ybsep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>xoffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>yoffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SubBand</name></type> <name><name>band</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>Plane</name>;</typedef>


<typedef>typedef <type><struct>struct <name>DiracSlice</name> <block>{
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
}</block></struct></type> <name>DiracSlice</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DiracContext</name> <block>{
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MpegvideoEncDSPContext</name></type> <name>mpvencdsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VideoDSPContext</name></type> <name>vdsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracDSPContext</name></type> <name>diracdsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracVersionInfo</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVDiracSeqHeader</name></type> <name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>seen_sequence_header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>frame_number</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Plane</name></type> <name><name>plane</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_x_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_y_shift</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pshift</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>zero_res</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>is_arith</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>core_syntax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>low_delay</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>hq_picture</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ld_picture</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>dc_prediction</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>globalmc_flag</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>num_refs</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>unsigned</name></type> <name>wavelet_depth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>wavelet_idx</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>old_delta_quant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>codeblock_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>num_x</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>num_y</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>thread_buf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>threads_num_buf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>thread_buf_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>DiracSlice</name> <modifier>*</modifier></type><name>slice_params_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_params_num_buf</name></decl>;</decl_stmt>

<struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>height</name></decl>;</decl_stmt>
}</block> <decl><name><name>codeblock</name><index>[<expr><name>MAX_DWT_LEVELS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</struct>

<struct>struct <block>{
<decl_stmt><decl><type><name>AVRational</name></type> <name>bytes</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>quant</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block> <decl><name>lowdelay</name></decl>;</struct>

<struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>prefix_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>size_scaler</name></decl>;</decl_stmt>
}</block> <decl><name>highquality</name></decl>;</struct>

<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name><name>pan_tilt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>zrs</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>perspective</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>zrs_exp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>perspective_exp</name></decl>;</decl_stmt>
}</block> <decl><name><name>globalmc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</struct>


<decl_stmt><decl><type><name>uint8_t</name></type> <name>mv_precision</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>weight</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>weight_log2denom</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>blwidth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>blheight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sbwidth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sbheight</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sbsplit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>blmotion</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>edge_emu_buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>edge_emu_buffer_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>mctmp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>mcscratch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buffer_stride</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>MAX_BLOCKSIZE</name><operator>*</operator><name>MAX_BLOCKSIZE</name></expr>]</index></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>put_pixels_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>avg_pixels_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>add_obmc</name>)<parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yblen</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>dirac_weight_func</name></type> <name>weight_func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dirac_biweight_func</name></type> <name>biweight_func</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>current_picture</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name><name>ref_pics</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name><name>ref_frames</name><index>[<expr><name>MAX_REFERENCE_FRAMES</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name><name>delay_frames</name><index>[<expr><name>MAX_DELAY</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracFrame</name></type> <name><name>all_frames</name><index>[<expr><name>MAX_FRAMES</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>DiracContext</name>;</typedef>

<enum>enum <name>dirac_subband</name> <block>{
<decl><name>subband_ll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>subband_hl</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>subband_lh</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>subband_hh</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>subband_nb</name></decl>,
}</block>;</enum>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>divide3</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>x</name><operator>+</operator><literal type="number">1U</literal><operator>)</operator><operator>*</operator><literal type="number">21845</literal> <operator>+</operator> <literal type="number">10922</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DiracFrame</name> <modifier>*</modifier></type><name>remove_frame</name><parameter_list>(<parameter><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name><name>framelist</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>picnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>remove_pic</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>remove_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>==</operator> <name>picnum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>remove_pic</name> <operator>=</operator> <name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>remove_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>remove_pic</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>remove_idx</name></expr>;</init> <condition><expr><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>framelist</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

<return>return <expr><name>remove_pic</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_frame</name><parameter_list>(<parameter><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name><name>framelist</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxframes</name></decl></parameter>, <parameter><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxframes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>framelist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>frame</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt></block_content></block></for>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_sequence_buffers</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sbwidth</name> <init>= <expr><call><name>DIVRNDUP</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sbheight</name> <init>= <expr><call><name>DIVRNDUP</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>height</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>h</name></decl>, <decl><type ref="prev"/><name>top_padding</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>max_xblen</name> <init>= <expr><name>MAX_BLOCKSIZE</name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_yblen</name> <init>= <expr><name>MAX_BLOCKSIZE</name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>width</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>height</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>






<expr_stmt><expr><name>top_padding</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>MAX_DWT_LEVELS</name></expr></argument>, <argument><expr><name>max_yblen</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><call><name>CALC_PADDING</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>MAX_DWT_LEVELS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>h</name> <operator>=</operator> <name>top_padding</name> <operator>+</operator> <call><name>CALC_PADDING</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>MAX_DWT_LEVELS</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>max_yblen</name><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>buf_base</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><operator>(</operator><name>w</name><operator>+</operator><name>max_xblen</name><operator>)</operator></expr></argument>, <argument><expr><name>h</name> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>tmp</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><operator>(</operator><name>w</name><operator>+</operator><literal type="number">16</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>buf_base</name></name> <operator>+</operator> <operator>(</operator><name>top_padding</name><operator>*</operator><name>w</name><operator>)</operator><operator>*</operator><operator>(</operator><literal type="number">2</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>buf_base</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>tmp</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sbsplit</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>sbwidth</name></expr></argument>, <argument><expr><name>sbheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blmotion</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>sbwidth</name></expr></argument>, <argument><expr><name>sbheight</name> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>blmotion</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>sbsplit</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>blmotion</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_buffers</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>height</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>stride</name> <operator>&gt;=</operator> <name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stride</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>buffer_stride</name></name> <operator>&gt;=</operator> <name>stride</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_stride</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer_base</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>stride</name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><operator>(</operator><name>stride</name><operator>+</operator><name>MAX_BLOCKSIZE</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>h</name><operator>+</operator><name>MAX_BLOCKSIZE</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>stride</name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer_base</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_stride</name></name> <operator>=</operator> <name>stride</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_sequence_buffers</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_unref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interpolated</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interpolated</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hpel_base</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>buf_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>idwt</name><operator>.</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buffer_stride</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>sbsplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>blmotion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>AVOnce</name></type> <name>dirac_arith_init</name> <init>= <expr><name>AV_ONCE_INIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>dirac_decode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_num_buf</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf_size</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_diracdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_mpegvideoencdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mpvencdsp</name></name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_videodsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>vdsp</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name> <operator>=</operator> <call><name>av_frame_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_thread_once</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirac_arith_init</name></expr></argument>, <argument><expr><name>ff_dirac_init_arith_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dirac_decode_flush</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_sequence_buffers</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seen_sequence_header</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>dirac_decode_end</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dirac_decode_flush</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>slice_params_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>coeff_unpack_golomb</name><parameter_list>(<parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qfactor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coeff</name> <init>= <expr><call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>sign</name> <init>= <expr><call><name>FFSIGN</name><argument_list>(<argument><expr><name>coeff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>coeff</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>coeff</name> <operator>=</operator> <name>sign</name><operator>*</operator><operator>(</operator><operator>(</operator><name>sign</name> <operator>*</operator> <name>coeff</name> <operator>*</operator> <name>qfactor</name> <operator>+</operator> <name>qoffset</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>coeff</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGN_CTX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(CTX_SIGN_ZERO + ((x) &gt; 0) - ((x) &lt; 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNPACK_ARITH</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline void coeff_unpack_arith_##n(DiracArith *c, int qfactor, int qoffset, SubBand *b, type *buf, int x, int y) { int sign, sign_pred = 0, pred_ctx = CTX_ZPZN_F1; unsigned coeff; const int mstride = -(b-&gt;stride &gt;&gt; (1+b-&gt;pshift)); if (b-&gt;parent) { const type *pbuf = (type *)b-&gt;parent-&gt;ibuf; const int stride = b-&gt;parent-&gt;stride &gt;&gt; (1+b-&gt;parent-&gt;pshift); pred_ctx += !!pbuf[stride * (y&gt;&gt;1) + (x&gt;&gt;1)] &lt;&lt; 1; } if (b-&gt;orientation == subband_hl) sign_pred = buf[mstride]; if (x) { pred_ctx += !(buf[-1] | buf[mstride] | buf[-1 + mstride]); if (b-&gt;orientation == subband_lh) sign_pred = buf[-1]; } else { pred_ctx += !buf[mstride]; } coeff = dirac_get_arith_uint(c, pred_ctx, CTX_COEFF_DATA); if (coeff) { coeff = (coeff * qfactor + qoffset) &gt;&gt; 2; sign = dirac_get_arith_bit(c, SIGN_CTX(sign_pred)); coeff = (coeff ^ -sign) + sign; } *buf = coeff; }</cpp:value></cpp:define> 





























<macro><name>UNPACK_ARITH</name><argument_list>(<argument><literal type="number">8</literal></argument>, <argument>int16_t</argument>)</argument_list></macro>
<macro><name>UNPACK_ARITH</name><argument_list>(<argument><literal type="number">10</literal></argument>, <argument>int32_t</argument>)</argument_list></macro>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>codeblock</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>, <parameter><decl><type><name>DiracArith</name> <modifier>*</modifier></type><name>c</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bottom</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>blockcnt_one</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_arith</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>zero_block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>qoffset</name></decl>, <decl><type ref="prev"/><name>qfactor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>blockcnt_one</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_arith</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zero_block</name> <operator>=</operator> <call><name>dirac_get_arith_bit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CTX_ZERO_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>zero_block</name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>zero_block</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>codeblock_mode</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>old_delta_quant</name></name> <operator>&amp;&amp;</operator> <name>blockcnt_one</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>quant</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arith</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>dirac_get_arith_int</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>CTX_DELTA_Q_F</name></expr></argument>, <argument><expr><name>CTX_DELTA_Q_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>quant</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>+</operator> <name>quant</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid quant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>+=</operator> <name>quant</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>&gt;</operator> <operator>(</operator><name>DIRAC_MAX_QUANT_INDEX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported quant %d\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qfactor</name> <operator>=</operator> <name><name>ff_dirac_qscale_tab</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>qoffset</name> <operator>=</operator> <name><name>ff_dirac_qoffset_intra_tab</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>qoffset</name> <operator>=</operator> <name><name>ff_dirac_qoffset_inter_tab</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name>top</name> <operator>*</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arith</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>c</name><operator>-&gt;</operator><name>error</name></name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>coeff_unpack_arith_10</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>qfactor</name></expr></argument>, <argument><expr><name>qoffset</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name><operator>)</operator><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>coeff_unpack_arith_8</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>qfactor</name></expr></argument>, <argument><expr><name>qoffset</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name><operator>)</operator><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>coeff_unpack_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>qfactor</name></expr></argument>, <argument><expr><name>qoffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AV_WN32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>AV_WN16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>x</name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>b</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTRA_DC_PRED</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline void intra_dc_prediction_##n(SubBand *b) { type *buf = (type*)b-&gt;ibuf; int x, y; for (x = 1; x &lt; b-&gt;width; x++) buf[x] += buf[x-1]; buf += (b-&gt;stride &gt;&gt; (1+b-&gt;pshift)); for (y = 1; y &lt; b-&gt;height; y++) { buf[0] += buf[-(b-&gt;stride &gt;&gt; (1+b-&gt;pshift))]; for (x = 1; x &lt; b-&gt;width; x++) { int pred = buf[x - 1] + buf[x - (b-&gt;stride &gt;&gt; (1+b-&gt;pshift))] + buf[x - (b-&gt;stride &gt;&gt; (1+b-&gt;pshift))-1]; buf[x] += divide3(pred); } buf += (b-&gt;stride &gt;&gt; (1+b-&gt;pshift)); } }</cpp:value></cpp:define> 




















<macro><name>INTRA_DC_PRED</name><argument_list>(<argument><literal type="number">8</literal></argument>, <argument>int16_t</argument>)</argument_list></macro>
<macro><name>INTRA_DC_PRED</name><argument_list>(<argument><literal type="number">10</literal></argument>, <argument>uint32_t</argument>)</argument_list></macro>





<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>decode_subband_internal</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_arith</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cb_x</name></decl>, <decl><type ref="prev"/><name>cb_y</name></decl>, <decl><type ref="prev"/><name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>top</name></decl>, <decl><type ref="prev"/><name>bottom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracArith</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cb_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>codeblock</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>orientation</name></name> <operator>!=</operator> <name>subband_ll</name><operator>)</operator></expr>]</index></name><operator>.</operator><name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cb_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>codeblock</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>orientation</name></name> <operator>!=</operator> <name>subband_ll</name><operator>)</operator></expr>]</index></name><operator>.</operator><name>height</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>blockcnt_one</name> <init>= <expr><operator>(</operator><name>cb_width</name> <operator>+</operator> <name>cb_height</name><operator>)</operator> <operator>==</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>coeff_data</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_arith</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cb_y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cb_y</name> <operator>&lt;</operator> <name>cb_height</name></expr>;</condition> <incr><expr><name>cb_y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>bottom</name> <operator>=</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <operator>(</operator><name>cb_y</name><operator>+</operator><literal type="number">1LL</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>cb_height</name></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cb_x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cb_x</name> <operator>&lt;</operator> <name>cb_width</name></expr>;</condition> <incr><expr><name>cb_x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <operator>(</operator><name>cb_x</name><operator>+</operator><literal type="number">1LL</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>cb_width</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>codeblock</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>, <argument><expr><name>blockcnt_one</name></expr></argument>, <argument><expr><name>is_arith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>top</name> <operator>=</operator> <name>bottom</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>orientation</name></name> <operator>==</operator> <name>subband_ll</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>intra_dc_prediction_10</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>intra_dc_prediction_8</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_subband_arith</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>decode_subband_internal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_subband_golomb</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>decode_subband_internal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>*</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_component</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>comp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name><name>bands</name><index>[<expr><literal type="number">3</literal><operator>*</operator><name>MAX_DWT_LEVELS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>dirac_subband</name></name></type> <name>orientation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>, <decl><type ref="prev"/><name>num_bands</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ret</name><index>[<expr><literal type="number">3</literal><operator>*</operator><name>MAX_DWT_LEVELS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>damaged_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>comp</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>bands</name><index>[<expr><name>num_bands</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>&gt;</operator> <operator>(</operator><name>DIRAC_MAX_QUANT_INDEX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported quant %d\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>quant</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>coeff_data</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>damaged_count</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>length</name></name><operator>*</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_arith</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>decode_subband_arith</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>comp</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><operator>!</operator><operator>!</operator><name>level</name></expr>]</index></name></expr></argument>,
<argument><expr><name>ret</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>level</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>level</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>-</operator><operator>!</operator><operator>!</operator><name>level</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubBand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_arith</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>decode_subband_golomb</name></expr></argument>, <argument><expr><name>bands</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>num_bands</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubBand</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>damaged_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>damaged_count</name> <operator>&gt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_VALUES</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>gb</name></type></parameter>, <parameter><type><name>ebits</name></type></parameter>, <parameter><type><name>buf1</name></type></parameter>, <parameter><type><name>buf2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>type *buf = (type *)buf1; buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset); if (get_bits_count(gb) &gt;= ebits) return; if (buf2) { buf = (type *)buf2; buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset); if (get_bits_count(gb) &gt;= ebits) return; }</cpp:value></cpp:define> 











<function><type><specifier>static</specifier> <name>void</name></type> <name>decode_subband</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quant</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>slice_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slice_y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits_end</name></decl></parameter>,
<parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b1</name></decl></parameter>, <parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name>slice_x</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator><operator>(</operator><name>slice_x</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <name>slice_y</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator><operator>(</operator><name>slice_y</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qfactor</name></decl>, <decl><type ref="prev"/><name>qoffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf1</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name>top</name> <operator>*</operator> <name><name>b1</name><operator>-&gt;</operator><name>stride</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf2</name> <init>= <expr><ternary><condition><expr><name>b2</name></expr> ?</condition><then> <expr><name><name>b2</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name>top</name> <operator>*</operator> <name><name>b2</name><operator>-&gt;</operator><name>stride</name></name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>quant</name> <operator>&gt;</operator> <operator>(</operator><name>DIRAC_MAX_QUANT_INDEX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported quant %d\n"</literal></expr></argument>, <argument><expr><name>quant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>qfactor</name> <operator>=</operator> <name><name>ff_dirac_qscale_tab</name><index>[<expr><name>quant</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>qoffset</name> <operator>=</operator> <name><name>ff_dirac_qoffset_intra_tab</name><index>[<expr><name>quant</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>bits_end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PARSE_VALUES</name><argument_list>(<argument><expr><name>int32_t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>bits_end</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf1</name> <operator>+=</operator> <name><name>b1</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>b2</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>top</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PARSE_VALUES</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>bits_end</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf1</name> <operator>+=</operator> <name><name>b1</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>b2</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_lowdelay_slice</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>slice</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>dirac_subband</name></name></type> <name>orientation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>, <decl><type ref="prev"/><name>quant</name></decl>, <decl><type ref="prev"/><name>chroma_bits</name></decl>, <decl><type ref="prev"/><name>chroma_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>quant_base</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>length_bits</name> <init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><literal type="number">8</literal> <operator>*</operator> <name><name>slice</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>luma_bits</name> <init>= <expr><call><name>get_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>length_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>luma_end</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>luma_bits</name></expr></argument>, <argument><expr><call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>quant_base</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decode_subband</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>quant</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_x</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_y</name></name></expr></argument>, <argument><expr><name>luma_end</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>


<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>luma_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_bits</name> <operator>=</operator> <literal type="number">8</literal><operator>*</operator><name><name>slice</name><operator>-&gt;</operator><name>bytes</name></name> <operator>-</operator> <literal type="number">7</literal> <operator>-</operator> <name>length_bits</name> <operator>-</operator> <name>luma_bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>chroma_end</name> <operator>=</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>chroma_bits</name></expr></argument>, <argument><expr><call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>quant_base</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decode_subband</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>quant</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_x</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_y</name></name></expr></argument>, <argument><expr><name>chroma_end</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SliceCoeffs</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tot_h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tot_v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tot</name></decl>;</decl_stmt>
}</block></struct></type> <name>SliceCoeffs</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>subband_coeffs</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>,
<parameter><decl><type><name>SliceCoeffs</name></type> <name><name>c</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>, <decl><type ref="prev"/><name>coef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SliceCoeffs</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <name>y</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name>x</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>tot_h</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <operator>(</operator><name>x</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>)</operator> <operator>-</operator> <name><name>o</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>tot_v</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <operator>(</operator><name>y</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name><operator>)</operator> <operator>-</operator> <name><name>o</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>tot</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>tot_h</name></name><operator>*</operator><name><name>o</name><operator>-&gt;</operator><name>tot_v</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>coef</name> <operator>+=</operator> <name><name>o</name><operator>-&gt;</operator><name>tot</name></name> <operator>*</operator> <operator>(</operator><literal type="number">4</literal> <operator>-</operator> <operator>!</operator><operator>!</operator><name>level</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>coef</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_hq_slice</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tmp_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>orientation</name></decl>, <decl><type ref="prev"/><name>quant_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>qfactor</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>qoffset</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>slice</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceCoeffs</name></type> <name><name>coeffs_num</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">8</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>prefix_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>quant_idx</name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>quant_idx</name> <operator>&gt;</operator> <name>DIRAC_MAX_QUANT_INDEX</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid quantization index - %i\n"</literal></expr></argument>, <argument><expr><name>quant_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>quant</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>quant_idx</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>qfactor</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_qscale_tab</name><index>[<expr><name>quant</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>qoffset</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_qoffset_intra_tab</name><index>[<expr><name>quant</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coef_num</name></decl>, <decl><type ref="prev"/><name>coef_par</name></decl>, <decl><type ref="prev"/><name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>length</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>size_scaler</name></name><operator>*</operator><call><name>get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>bits_end</name> <init>= <expr><call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal><operator>*</operator><name>length</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>align_get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name><operator>*</operator><literal type="number">8</literal> <operator>&gt;</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"end too far away\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>coef_num</name> <operator>=</operator> <call><name>subband_coeffs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_x</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>slice_y</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>coeffs_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>coef_par</name> <operator>=</operator> <call><name>ff_dirac_golomb_read_32bit</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>coef_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>coef_par</name> <operator>=</operator> <call><name>ff_dirac_golomb_read_16bit</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>coef_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>coef_num</name> <operator>&gt;</operator> <name>coef_par</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>start_b</name> <init>= <expr><name>coef_par</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>end_b</name> <init>= <expr><name>coef_num</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp_buf</name><index>[<expr><name>start_b</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>end_b</name> <operator>-</operator> <name>start_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SliceCoeffs</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><name><name>coeffs_num</name><index>[<expr><name>level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SubBand</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>b1</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name><name>c</name><operator>-&gt;</operator><name>top</name></name> <operator>*</operator> <name><name>b1</name><operator>-&gt;</operator><name>stride</name></name> <operator>+</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>left</name></name> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>qfunc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>tot_h</name></name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>dequant_subband</name><index>[<expr><name>qfunc</name></expr>]</index></name><operator>(</operator><operator>&amp;</operator><name><name>tmp_buf</name><index>[<expr><name>off</name></expr>]</index></name><operator>,</operator> <name>buf</name><operator>,</operator> <name><name>b1</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator>
<name><name>qfactor</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name><operator>,</operator>
<name><name>qoffset</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name><operator>,</operator>
<name><name>c</name><operator>-&gt;</operator><name>tot_v</name></name><operator>,</operator> <name><name>c</name><operator>-&gt;</operator><name>tot_h</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>+=</operator> <name><name>c</name><operator>-&gt;</operator><name>tot</name></name> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>skip_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>bits_end</name> <operator>-</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_hq_slice_row</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobnr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>threadnr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracSlice</name> <modifier>*</modifier></type><name>slices</name> <init>= <expr><operator>(</operator><operator>(</operator><name>DiracSlice</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name>jobnr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>thread_buf</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf_size</name></name><operator>*</operator><name>threadnr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>decode_hq_slice</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>thread_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_lowdelay</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_x</name></decl>, <decl><type ref="prev"/><name>slice_y</name></decl>, <decl><type ref="prev"/><name>bufsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>coef_buf_size</name></decl>, <decl><type ref="prev"/><name>bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracSlice</name> <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SliceCoeffs</name></type> <name><name>tmp</name><index>[<expr><name>MAX_DWT_LEVELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slice_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>slice_params_num_buf</name></name> <operator>!=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_params_buf</name></name> <operator>=</operator> <call><name>av_realloc_f</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>slice_params_buf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DiracSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>slice_params_buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"slice params buffer allocation failure\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_params_num_buf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>slice_params_num_buf</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>slices</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>slice_params_buf</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name>coef_buf_size</name> <operator>=</operator> <call><name>subband_coeffs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>coef_buf_size</name> <operator>=</operator> <operator>(</operator><name>coef_buf_size</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">512</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_num_buf</name></name> <operator>!=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>thread_buf_size</name></name> <operator>!=</operator> <name>coef_buf_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>threads_num_buf</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf_size</name></name> <operator>=</operator> <name>coef_buf_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name></name> <operator>=</operator> <call><name>av_realloc_f</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>thread_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>thread_buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"thread buffer allocation failure\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <call><name>get_bits_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>hq_picture</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>slice_y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slice_y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>slice_y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>slice_x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slice_x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</condition> <incr><expr><name>slice_x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>bytes</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>prefix_bytes</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;=</operator> <name>bufsize</name><operator>/</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bytes</name> <operator>+=</operator> <name><name>buf</name><index>[<expr><name>bytes</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>size_scaler</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>||</operator> <name>bytes</name><operator>*</operator><literal type="number">8</literal> <operator>&gt;</operator> <name>bufsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many bytes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>bytes</name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>slice_x</name> <operator>=</operator> <name>slice_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>slice_y</name> <operator>=</operator> <name>slice_y</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>gb</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slice_num</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bufsize</name><operator>/</operator><literal type="number">8</literal> <operator>&gt;=</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bufsize</name> <operator>-=</operator> <name>bytes</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>!=</operator> <name>slice_num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few slices\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>execute2</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>decode_hq_slice_row</name></expr></argument>, <argument><expr><name>slices</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>slice_y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slice_y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name></expr>;</condition> <incr><expr><name>slice_y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>slice_x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slice_x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name></expr>;</condition> <incr><expr><name>slice_x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>slice_num</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>num</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>den</name></name>
<operator>-</operator> <name>slice_num</name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>num</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>den</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>||</operator> <name>bytes</name><operator>*</operator><literal type="number">8</literal> <operator>&gt;</operator> <name>bufsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many bytes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>bytes</name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>slice_x</name> <operator>=</operator> <name>slice_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>slice_y</name> <operator>=</operator> <name>slice_y</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slices</name><index>[<expr><name>slice_num</name></expr>]</index></name><operator>.</operator><name>gb</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slice_num</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bufsize</name><operator>/</operator><literal type="number">8</literal> <operator>&gt;=</operator> <name>bytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bufsize</name> <operator>-=</operator> <name>bytes</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>decode_lowdelay_slice</name></expr></argument>, <argument><expr><name>slices</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slice_num</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DiracSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>dc_prediction</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>intra_dc_prediction_10</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>intra_dc_prediction_10</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>intra_dc_prediction_10</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>intra_dc_prediction_8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>intra_dc_prediction_8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>intra_dc_prediction_8</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>band</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_planes</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>h</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>orientation</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>width</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>height</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>width</name></name> <operator>=</operator> <name>w</name> <operator>=</operator> <call><name>CALC_PADDING</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument> , <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>height</name></name> <operator>=</operator> <name>h</name> <operator>=</operator> <call><name>CALC_PADDING</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>level</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>level</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>orientation</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>orientation</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>orientation</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>band</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pshift</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pshift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stride</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name> <operator>-</operator> <name>level</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>orientation</name></name> <operator>=</operator> <name>orientation</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orientation</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+=</operator> <name>w</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">1</literal><operator>+</operator><name><name>b</name><operator>-&gt;</operator><name>pshift</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>orientation</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+=</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>stride</name></name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>band</name><index>[<expr><name>level</name><operator>-</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>orientation</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xoffset</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yoffset</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_unpack_prediction_parameters</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>default_blen</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">24</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>ref</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Block prediction index too high\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>=</operator> <name><name>default_blen</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name> <operator>=</operator> <name><name>default_blen</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name>idx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"invalid x/y block length (%d/%d) for x/y chroma shift (%d/%d)\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name><operator>/</operator><literal type="number">2</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Block separation too small\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Block separation greater than size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FFMAX</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xblen</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>yblen</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_BLOCKSIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported large block size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"MV precision finer than eighth-pel\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc_flag</name></name> <operator>=</operator> <call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>globalmc_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ref</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>ref</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>pan_tilt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>pan_tilt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>zrs_exp</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>zrs</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>perspective_exp</name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>perspective</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name><name>perspective</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>perspective_exp</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>zrs_exp</name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

</block_content>}</block></for>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown picture prediction mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"weight_log2denom unsupported or invalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_unpack_idwt_params</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>tmp</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKEDREAD</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>, <parameter><type><name>errmsg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tmp = get_interleaved_ue_golomb(gb); if (cond) { av_log(s-&gt;avctx, AV_LOG_ERROR, errmsg); return AVERROR_INVALIDDATA; }dst = tmp;</cpp:value></cpp:define>







<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>zero_res</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr> ?</condition><then> <expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>zero_res</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<macro><name>CHECKEDREAD</name><argument_list>(<argument>s-&gt;wavelet_idx</argument>, <argument>tmp &gt; <literal type="number">6</literal></argument>, <argument><literal type="string">"wavelet_idx is too big\n"</literal></argument>)</argument_list></macro>

<macro><name>CHECKEDREAD</name><argument_list>(<argument>s-&gt;wavelet_depth</argument>, <argument>tmp &gt; MAX_DWT_LEVELS || tmp &lt; <literal type="number">1</literal></argument>, <argument><literal type="string">"invalid number of DWT decompositions\n"</literal></argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>low_delay</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>CHECKEDREAD</name><argument_list>(<argument>s-&gt;codeblock[i].width</argument> , <argument>tmp &lt; <literal type="number">1</literal> || tmp &gt; (s-&gt;avctx-&gt;width &gt;&gt;s-&gt;wavelet_depth-i)</argument>, <argument><literal type="string">"codeblock width invalid\n"</literal></argument>)</argument_list></macro>
<macro><name>CHECKEDREAD</name><argument_list>(<argument>s-&gt;codeblock[i].height</argument>, <argument>tmp &lt; <literal type="number">1</literal> || tmp &gt; (s-&gt;avctx-&gt;height&gt;&gt;s-&gt;wavelet_depth-i)</argument>, <argument><literal type="string">"codeblock height invalid\n"</literal></argument>)</argument_list></macro>
</block_content>}</block></for>

<macro><name>CHECKEDREAD</name><argument_list>(<argument>s-&gt;codeblock_mode</argument>, <argument>tmp &gt; <literal type="number">1</literal></argument>, <argument><literal type="string">"unknown codeblock mode\n"</literal></argument>)</argument_list></macro>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>codeblock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>width</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>codeblock</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>height</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>height</name></name></expr>
)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_ERROR</name></expr></argument>,<argument><expr><literal type="string">"Invalid numx/y\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_x</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>num_y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ld_picture</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>den</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>bytes</name><operator>.</operator><name>den</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_ERROR</name></expr></argument>,<argument><expr><literal type="string">"Invalid lowdelay.bytes.den\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>hq_picture</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>prefix_bytes</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>size_scaler</name></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>highquality</name><operator>.</operator><name>prefix_bytes</name></name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_ERROR</name></expr></argument>,<argument><expr><literal type="string">"too many prefix bytes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_bits1</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"Low Delay: Has Custom Quantization Matrix!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>level</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_ERROR</name></expr></argument>,<argument><expr><literal type="string">"Mandatory custom low delay matrix missing for depth %d\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>level</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ff_dirac_default_qmat</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name></expr>]</index><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lowdelay</name><operator>.</operator><name>quant</name><index>[<expr><name>level</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <literal type="number">4</literal><operator>*</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>level</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>pred_sbsplit</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sbsplit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>avgsplit</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>x</name><operator>|</operator><name>y</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>sbsplit</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>sbsplit</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>avgsplit</name><index>[<expr><name><name>sbsplit</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>sbsplit</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name> <operator>+</operator> <name><name>sbsplit</name><index>[<expr><operator>-</operator><name>stride</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>pred_block_mode</name><parameter_list>(<parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refmask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pred</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>x</name><operator>|</operator><name>y</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>refmask</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>refmask</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pred</name> <operator>=</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>refmask</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>refmask</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>refmask</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>pred</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>refmask</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>pred_block_dc</name><parameter_list>(<parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>divide3</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>pred_mv</name><parameter_list>(<parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name><name>pred</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>refmask</name> <init>= <expr><name>ref</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><name>refmask</name> <operator>|</operator> <name>DIRAC_REF_MASK_GLOBAL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>==</operator> <name>refmask</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pred</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>block</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>==</operator> <name>refmask</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pred</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>block</name><index>[<expr><operator>-</operator><name>stride</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>block</name><index>[<expr><operator>-</operator><name>stride</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>==</operator> <name>refmask</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pred</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>block</name><index>[<expr><operator>-</operator><name>stride</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>pred</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>pred</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pred</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pred</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pred</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pred</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>global_mv</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ez</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>zrs_exp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ep</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>perspective_exp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><name>A</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>zrs</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>pan_tilt</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>globalmc</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>perspective</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int64_t</name></type> <name>m</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ep</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>+</operator> <name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>y</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>mx</name> <init>= <expr><name>m</name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>A</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>+</operator> <name><name>A</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>y</name><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1LL</literal><operator>&lt;&lt;</operator><name>ez</name><operator>)</operator> <operator>*</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>my</name> <init>= <expr><name>m</name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>A</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>+</operator> <name><name>A</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>y</name><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1LL</literal><operator>&lt;&lt;</operator><name>ez</name><operator>)</operator> <operator>*</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>mx</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ez</name><operator>+</operator><name>ep</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>ez</name><operator>+</operator><name>ep</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>my</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ez</name><operator>+</operator><name>ep</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>ez</name><operator>+</operator><name>ep</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>decode_block_params</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracArith</name></type> <name><name>arith</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <call><name>pred_block_mode</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>DIRAC_REF_MASK_REF1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>^=</operator> <call><name>dirac_get_arith_bit</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>CTX_PMODE_REF1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>|=</operator> <call><name>pred_block_mode</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>DIRAC_REF_MASK_REF2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>^=</operator> <call><name>dirac_get_arith_bit</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>CTX_PMODE_REF2</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>block</name><operator>-&gt;</operator><name>ref</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pred_block_dc</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>dirac_get_arith_int</name><argument_list>(<argument><expr><name>arith</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>CTX_DC_F1</name></expr></argument>, <argument><expr><name>CTX_DC_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>globalmc_flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>|=</operator> <call><name>pred_block_mode</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>DIRAC_REF_MASK_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>^=</operator> <call><name>dirac_get_arith_bit</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>CTX_GLOBAL_BLOCK</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>&amp;</operator> <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name> <operator>&amp;</operator> <name>DIRAC_REF_MASK_GLOBAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>global_mv</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pred_mv</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>dirac_get_arith_int</name><argument_list>(<argument><expr><name>arith</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>CTX_MV_F1</name></expr></argument>, <argument><expr><name>CTX_MV_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>dirac_get_arith_int</name><argument_list>(<argument><expr><name>arith</name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>CTX_MV_F1</name></expr></argument>, <argument><expr><name>CTX_MV_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>propagate_block_data</name><parameter_list>(<parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>block</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>block</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>stride</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>block</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_unpack_block_motion_data</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sbsplit</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>sbsplit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>q</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracArith</name></type> <name><name>arith</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>align_get_bits</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name> <operator>=</operator> <call><name>DIVRNDUP</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xbsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sbheight</name></name> <operator>=</operator> <call><name>DIVRNDUP</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>seq</name><operator>.</operator><name>height</name></name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ybsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blheight</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sbheight</name></name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbheight</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>split</name> <init>= <expr><call><name>dirac_get_arith_uint</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>CTX_SB_F1</name></expr></argument>, <argument><expr><name>CTX_SB_DATA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sbsplit</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>split</name> <operator>+</operator> <call><name>pred_sbsplit</name><argument_list>(<argument><expr><name>sbsplit</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>sbsplit</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><name>arith</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><name>arith</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><name>arith</name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_dirac_init_arith_decoder</name><argument_list>(<argument><expr><name>arith</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><call><name>get_interleaved_ue_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbheight</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>blkcnt</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbsplit</name><index>[<expr><name>y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name> <operator>+</operator> <name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">4</literal> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sbsplit</name><index>[<expr><name>y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>sbwidth</name></name> <operator>+</operator> <name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>q</name> <operator>&lt;</operator> <name>blkcnt</name></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>blkcnt</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bx</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name>x</name> <operator>+</operator> <name>p</name><operator>*</operator><name>step</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>by</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name>y</name> <operator>+</operator> <name>q</name><operator>*</operator><name>step</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>blmotion</name><index>[<expr><name>by</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name> <operator>+</operator> <name>bx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>decode_block_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>arith</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagate_block_data</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>
</block_content>}</block></for></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arith</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>arith</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>weight</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLLOFF</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offset == 1 ? ((i) ? 5 : 3) : (1 + (6*(i) + offset - 1) / (2*offset - 1))</cpp:value></cpp:define>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ROLLOFF</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>blen</name><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ROLLOFF</name><argument_list>(<argument><expr><name>blen</name><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_obmc_weight_row</name><parameter_list>(<parameter><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>obmc_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>left</name> <operator>&amp;&amp;</operator> <name><name>x</name> <argument_list type="generic">&lt; <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>obmc_weight</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>wy</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init>;</init> <condition><expr><name><name>x</name> <argument_list type="generic">&lt; <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <name>right</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>obmc_weight</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>wy</name><operator>*</operator><call><name>weight</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xoffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>obmc_weight</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>wy</name><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>stride</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>obmc_weight</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_obmc_weight</name><parameter_list>(<parameter><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>obmc_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bottom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>top</name> <operator>&amp;&amp;</operator> <name><name>y</name> <argument_list type="generic">&lt; <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>init_obmc_weight_row</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obmc_weight</name> <operator>+=</operator> <name>stride</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name><name>y</name> <argument_list type="generic">&lt; <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <name>bottom</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wy</name> <init>= <expr><call><name>weight</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yoffset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_obmc_weight_row</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>wy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obmc_weight</name> <operator>+=</operator> <name>stride</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>init_obmc_weight_row</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>, <argument><expr><name>stride</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obmc_weight</name> <operator>+=</operator> <name>stride</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_obmc_weights</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>by</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><operator>!</operator><name>by</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><name>by</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>blheight</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>top</name> <operator>||</operator> <name>bottom</name> <operator>||</operator> <name>by</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>init_obmc_weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_obmc_weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_obmc_weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>epel_weights</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr><block>{ <expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">12</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr>,
<expr><block>{<expr><block>{ <expr><literal type="number">12</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">9</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr> }</block></expr>}</block></expr>,
<expr><block>{<expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr> }</block></expr>}</block></expr>,
<expr><block>{<expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">3</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">9</literal></expr> }</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>









<function><type><specifier>static</specifier> <name>int</name></type> <name>mc_subpel</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ref_hpel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>ref</name></expr>]</index></name><operator>-&gt;</operator><name><name>hpel</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>motion_x</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>motion_y</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>mv</name><index>[<expr><name>ref</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mx</name></decl>, <decl><type ref="prev"/><name>my</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>epel</name></decl>, <decl><type ref="prev"/><name>nplanes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>plane</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>motion_x</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>motion_y</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mx</name> <operator>=</operator> <name>motion_x</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>-</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>my</name> <operator>=</operator> <name>motion_y</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>-</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>motion_x</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>motion_y</name> <operator>&gt;&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>mx</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>my</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>motion_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>+=</operator> <name>motion_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>epel</name> <operator>=</operator> <operator>(</operator><name>mx</name><operator>|</operator><name>my</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>mx</name><operator>|</operator><name>my</name><operator>)</operator><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nplanes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ref_hpel</name><index>[<expr><operator>(</operator><name>my</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><operator>(</operator><name>mx</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator></expr>]</index></name> <operator>+</operator> <name>y</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name> <operator>+</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>nplanes</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ref_hpel</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>y</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name> <operator>+</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>



<if_stmt><if>if <condition>(<expr><name>mx</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>my</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>epel</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mx</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>src</name><index>[<expr><operator>!</operator><name>mx</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <operator>!</operator><operator>!</operator><name>mx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nplanes</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>my</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>my</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><operator>(</operator><name>my</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nplanes</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mx</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>my</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>epel_weights</name><index>[<expr><name>my</name><operator>&amp;</operator><literal type="number">3</literal></expr>]</index><index>[<expr><name>mx</name><operator>&amp;</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>x</name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>xblen</name></name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator><name>EDGE_WIDTH</name><operator>/</operator><literal type="number">2</literal> <operator>||</operator>
<name>y</name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name><operator>+</operator><name>EDGE_WIDTH</name><operator>/</operator><literal type="number">2</literal> <operator>||</operator>
<name>x</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplanes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>vdsp</name><operator>.</operator><name>emulated_edge_mc</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name><operator>+</operator><name>EDGE_WIDTH</name><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name><operator>+</operator><name>EDGE_WIDTH</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>nplanes</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>epel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_dc</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stride</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>obmc_weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xblen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yblen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dc</name> <operator>+=</operator> <literal type="number">128</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>yblen</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>xblen</name></expr>;</condition> <incr><expr><name>x</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>x</name></expr> ]</index></name> <operator>+=</operator> <name>dc</name> <operator>*</operator> <name><name>obmc_weight</name><index>[<expr><name>x</name></expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>dc</name> <operator>*</operator> <name><name>obmc_weight</name><index>[<expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>stride</name></expr>;</expr_stmt>
<expr_stmt><expr><name>obmc_weight</name> <operator>+=</operator> <name>MAX_BLOCKSIZE</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>block_mc</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>,
<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>mctmp</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>obmc_weight</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dstx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dsty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>ref</name></name><operator>&amp;</operator><literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> 
<expr_stmt><expr><call><name>add_dc</name><argument_list>(<argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dc</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>mc_subpel</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dstx</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>, <argument><expr><operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>ref</name></name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>put_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name><operator>,</operator> <name>src</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>weight_func</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>weight_func</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>mc_subpel</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dstx</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>put_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name><operator>,</operator> <name>src</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>mc_subpel</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dstx</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>biweight_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>put_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name> <operator>+</operator> <literal type="number">32</literal><operator>,</operator> <name>src</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>biweight_func</name></name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name><operator>+</operator><literal type="number">32</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avg_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name><operator>,</operator> <name>src</name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>yblen</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>add_obmc</name></name><argument_list>(<argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mcscratch</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name>obmc_weight</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mc_row</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>mctmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dsty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>dstx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>xoffset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>block_mc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>plane</name></expr></argument>, <argument><expr><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>xoffset</name></name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mctmp</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>block_mc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>plane</name></expr></argument>, <argument><expr><name>dstx</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dstx</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mctmp</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>xbsep</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>block_mc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>obmc_weight</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>plane</name></expr></argument>, <argument><expr><name>dstx</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>select_dsp_funcs</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xblen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yblen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xblen</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xblen</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>put_pixels_tab</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>put_dirac_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>put_pixels_tab</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avg_pixels_tab</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>avg_dirac_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avg_pixels_tab</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>add_obmc</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>add_dirac_obmc</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>weight_log2denom</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>weight</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight_func</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>weight_dirac_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>biweight_func</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>biweight_dirac_pixels_tab</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>weight_func</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>biweight_func</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>interpolate_refplane</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>edge</name> <init>= <expr><name>EDGE_WIDTH</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>mpvencdsp</name><operator>.</operator><name>draw_edges</name></name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>EDGE_TOP</name> <operator>|</operator> <name>EDGE_BOTTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>mv_precision</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>hpel_base</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel_base</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>height</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>edge</name><operator>)</operator> <operator>*</operator> <name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>hpel_base</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>hpel_base</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>edge</name><operator>*</operator><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>interpolated</name><index>[<expr><name>plane</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>dirac_hpel_filter</name></name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>mpvencdsp</name><operator>.</operator><name>draw_edges</name></name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>EDGE_TOP</name> <operator>|</operator> <name>EDGE_BOTTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>mpvencdsp</name><operator>.</operator><name>draw_edges</name></name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>EDGE_TOP</name> <operator>|</operator> <name>EDGE_BOTTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>mpvencdsp</name><operator>.</operator><name>draw_edges</name></name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>hpel</name><index>[<expr><name>plane</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>EDGE_TOP</name> <operator>|</operator> <name>EDGE_BOTTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>interpolated</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_decode_frame_internal</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DWTContext</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>comp</name></decl>, <decl><type ref="prev"/><name>dsty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>low_delay</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>hq_picture</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>comp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>comp</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>comp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>comp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>zero_res</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>decode_lowdelay</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>comp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>comp</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>comp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>comp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>comp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>edge_emu_buffer_base</name></name> <operator>+</operator> <name>i</name><operator>*</operator><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>zero_res</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>low_delay</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>decode_component</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_spatial_idwt_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>idwt</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_idx</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>wavelet_depth</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>bit_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>)</condition> <block>{<block_content> 
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bit_depth</name></name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_spatial_idwt_slice2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>put_signed_rect_clamped</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name>frame</name> <operator>+</operator> <name>y</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator>
<name><name>p</name><operator>-&gt;</operator><name>stride</name></name><operator>,</operator>
<name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>y</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name><operator>,</operator>
<name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>width</name></name><operator>,</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>rowheight</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>select_dsp_funcs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>xblen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yblen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>interpolate_refplane</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>yoffset</name></name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dsty</name> <operator>=</operator> <operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>yoffset</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>blheight</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><type ref="prev"/><name>start</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>dsty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>mctmp</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mctmp</name></name> <operator>+</operator> <name>y</name><operator>*</operator><name>rowheight</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracBlock</name> <modifier>*</modifier></type><name>blocks</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>blmotion</name></name> <operator>+</operator> <name>y</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>blwidth</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_obmc_weights</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>blheight</name></name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>start</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>-</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name> <operator>-</operator> <operator>(</operator><name>start</name> <operator>-</operator> <name>dsty</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mctmp</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>yoffset</name></name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>rowheight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mc_row</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name>dsty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mctmp</name> <operator>+=</operator> <operator>(</operator><name>start</name> <operator>-</operator> <name>dsty</name><operator>)</operator><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>xoffset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_spatial_idwt_slice2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>diracdsp</name><operator>.</operator><name>add_rect_clamped</name></name><argument_list>(<argument><expr><name>frame</name> <operator>+</operator> <name>start</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>, <argument><expr><name>mctmp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stride</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>buf</name></name><operator>)</operator> <operator>+</operator> <name>start</name><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>idwt</name><operator>.</operator><name>stride</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dsty</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>ybsep</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_buffer_with_edge</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma_x_shift</name></decl>, <decl><type ref="prev"/><name>chroma_y_shift</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_pix_fmt_get_chroma_sub_sample</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chroma_x_shift</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>chroma_y_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>EDGE_WIDTH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>EDGE_WIDTH</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_get_buffer</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>f</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>EDGE_WIDTH</name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name>chroma_y_shift</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator>
<name><name>f</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_decode_picture_header</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>retire</name></decl>, <decl><type ref="prev"/><name>picnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>refdist</name></decl>, <decl><type ref="prev"/><name>refnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetBitContext</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>picnum</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>=</operator> <call><name>get_bits_long</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,<argument><expr><name>AV_LOG_DEBUG</name></expr></argument>,<argument><expr><literal type="string">"PICTURE_NUM: %d\n"</literal></expr></argument>,<argument><expr><name>picnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>=</operator> <name>picnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>refnum</name> <operator>=</operator> <operator>(</operator><name>picnum</name> <operator>+</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>refdist</name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MAX_REFERENCE_FRAMES</name> <operator>&amp;&amp;</operator> <name>refdist</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name><index>[<expr><name>j</name></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>FFABS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>-</operator> <name>refnum</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>refdist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ref_frames</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>refdist</name> <operator>=</operator> <call><name>FFABS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>-</operator> <name>refnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name>refdist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Reference not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_buffer_with_edge</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>avframe</name></expr></argument>, <argument><expr><name>AV_GET_BUFFER_FLAG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ref_pics</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reference could not be allocated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>reference</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retire</name> <operator>=</operator> <operator>(</operator><name>picnum</name> <operator>+</operator> <call><name>dirac_get_se_golomb</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>retire</name> <operator>!=</operator> <name>picnum</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>retire_pic</name> <init>= <expr><call><name>remove_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name></expr></argument>, <argument><expr><name>retire</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>retire_pic</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>retire_pic</name><operator>-&gt;</operator><name>reference</name></name> <operator>&amp;=</operator> <name>DELAYED_PIC_REF</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Frame to retire not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><call><name>add_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name></expr></argument>, <argument><expr><name>MAX_REFERENCE_FRAMES</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reference frame overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reference</name> <operator>&amp;=</operator> <name>DELAYED_PIC_REF</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_unpack_prediction_parameters</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_unpack_block_motion_data</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_unpack_idwt_params</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>init_planes</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_delayed_pic</name><parameter_list>(<parameter><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>picture</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>out_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>out_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>out_idx</name></expr>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>reference</name></name> <operator>^=</operator> <name>DELAYED_PIC_REF</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>av_frame_ref</name><argument_list>(<argument><expr><name>picture</name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>avframe</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATA_UNIT_HEADER_SIZE</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_decode_data_unit</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>pic</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVDiracSeqHeader</name> <modifier>*</modifier></type><name>dsh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>parse_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>DATA_UNIT_HEADER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>parse_code</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal><operator>*</operator><operator>(</operator><name>size</name> <operator>-</operator> <name>DATA_UNIT_HEADER_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>parse_code</name> <operator>==</operator> <name>DIRAC_PCODE_SEQ_HEADER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>seen_sequence_header</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_dirac_parse_sequence_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsh</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>DATA_UNIT_HEADER_SIZE</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>DATA_UNIT_HEADER_SIZE</name></expr></argument>, <argument><expr><name>avctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error parsing sequence header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CALC_PADDING</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>dsh</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name>MAX_DWT_LEVELS</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>CALC_PADDING</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>dsh</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><name>MAX_DWT_LEVELS</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">5LL</literal> <operator>&gt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>max_pixels</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_set_dimensions</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>dsh</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>dsh</name><operator>-&gt;</operator><name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_set_sar</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>dsh</name><operator>-&gt;</operator><name>sample_aspect_ratio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_range</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>color_range</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>color_trc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>color_primaries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>colorspace</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>colorspace</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>profile</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>profile</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>framerate</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>framerate</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bit_depth</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>bit_depth</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>version</name><operator>.</operator><name>major</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>version</name><operator>.</operator><name>major</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>version</name><operator>.</operator><name>minor</name></name> <operator>=</operator> <name><name>dsh</name><operator>-&gt;</operator><name>version</name><operator>.</operator><name>minor</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <operator>*</operator><name>dsh</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pshift</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>bit_depth</name></name> <operator>&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_pix_fmt_get_chroma_sub_sample</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_x_shift</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_y_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>alloc_sequence_buffers</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seen_sequence_header</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>parse_code</name> <operator>==</operator> <name>DIRAC_PCODE_END_SEQ</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>free_sequence_buffers</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>seen_sequence_header</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>parse_code</name> <operator>==</operator> <name>DIRAC_PCODE_AUX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name><name>ver</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"Schroedinger %d.%d.%d"</literal></expr></argument>, <argument><expr><name>ver</name></expr></argument>, <argument><expr><name>ver</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ver</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>ver</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ver</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ver</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>old_delta_quant</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>seen_sequence_header</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Dropping frame without sequence header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pic</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"framelist full\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_frame_unref</name><argument_list>(<argument><expr><name><name>pic</name><operator>-&gt;</operator><name>avframe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x03</literal></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"num_refs of 3\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_arith</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x48</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x08</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>low_delay</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x88</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x88</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>core_syntax</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x88</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x08</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ld_picture</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0xF8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xC8</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hq_picture</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0xF8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xE8</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dc_prediction</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x28</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x08</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>pic</name><operator>-&gt;</operator><name>reference</name></name> <operator>=</operator> <operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x0C</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x0C</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>pic</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>key_frame</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>pic</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>pict_type</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>num_refs</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>version</name><operator>.</operator><name>minor</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>parse_code</name> <operator>==</operator> <literal type="number">0x88</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ld_picture</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>low_delay</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ld_picture</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>hq_picture</name></name><operator>)</operator></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid low delay flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>get_buffer_with_edge</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>pic</name><operator>-&gt;</operator><name>avframe</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>parse_code</name> <operator>&amp;</operator> <literal type="number">0x0C</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x0C</literal></expr> ?</condition><then> <expr><name>AV_GET_BUFFER_FLAG_REF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name> <operator>=</operator> <name>pic</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stride</name> <operator>=</operator> <name><name>pic</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stride</name> <operator>=</operator> <name><name>pic</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>stride</name> <operator>=</operator> <name><name>pic</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>alloc_buffers</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>FFMAX3</name><argument_list>(<argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stride</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>stride</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>stride</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_decode_picture_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_decode_frame_internal</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dirac_decode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DiracContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>picture</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buf_size</name> <init>= <expr><name><name>pkt</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>buf_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>data_unit_size</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FRAMES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>avframe</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reference</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_unref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>avframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interpolated</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>all_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interpolated</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>buf_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get_delayed_pic</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>AVFrame</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>got_frame</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>



<for>for <control>(<init>;</init> <condition><expr><name>buf_idx</name> <operator>+</operator> <name>DATA_UNIT_HEADER_SIZE</name> <operator>&lt;</operator> <name>buf_size</name></expr>;</condition> <incr><expr><name>buf_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>buf_idx</name></expr> ]</index></name> <operator>==</operator> <literal type="char">'B'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>buf_idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal> <operator>&amp;&amp;</operator>
<name><name>buf</name><index>[<expr><name>buf_idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'C'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>buf_idx</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>buf_idx</name> <operator>+</operator> <name>DATA_UNIT_HEADER_SIZE</name> <operator>&gt;=</operator> <name>buf_size</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data_unit_size</name> <operator>=</operator> <call><name>AV_RB32</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>buf_idx</name><operator>+</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>data_unit_size</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>buf_idx</name> <operator>||</operator> <operator>!</operator><name>data_unit_size</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>data_unit_size</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>buf_idx</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Data unit with size %d is larger than input buffer, discarding\n"</literal></expr></argument>,
<argument><expr><name>data_unit_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf_idx</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dirac_decode_data_unit</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>buf</name><operator>+</operator><name>buf_idx</name></expr></argument>, <argument><expr><name>data_unit_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,<argument><expr><literal type="string">"Error in dirac_decode_data_unit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf_idx</name> <operator>+=</operator> <name>data_unit_size</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>buf_size</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DiracFrame</name> <modifier>*</modifier></type><name>delayed_frame</name> <init>= <expr><call><name>remove_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>reference</name></name> <operator>|=</operator> <name>DELAYED_PIC_REF</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>add_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>, <argument><expr><name>MAX_DELAY</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min_num</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Delay frame overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>&lt;</operator> <name>min_num</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min_num</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>delay_frames</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>delayed_frame</name> <operator>=</operator> <call><name>remove_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>, <argument><expr><name>min_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_frame</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>delay_frames</name></name></expr></argument>, <argument><expr><name>MAX_DELAY</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>delayed_frame</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>delayed_frame</name><operator>-&gt;</operator><name>reference</name></name> <operator>^=</operator> <name>DELAYED_PIC_REF</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>ret</name><operator>=</operator><call><name>av_frame_ref</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>delayed_frame</name><operator>-&gt;</operator><name>avframe</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>avframe</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>ret</name><operator>=</operator><call><name>av_frame_ref</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>avframe</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>got_frame</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>=</operator> <name><name>picture</name><operator>-&gt;</operator><name>display_picture_number</name></name> <operator>+</operator> <literal type="number">1LL</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>buf_idx</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_dirac_decoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"dirac"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"BBC Dirac VC-2"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_DIRAC</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DiracContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>dirac_decode_init</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>dirac_decode_end</name></expr>,
<expr><operator>.</operator><name>decode</name> <operator>=</operator> <name>dirac_decode_frame</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_DELAY</name> <operator>|</operator> <name>AV_CODEC_CAP_SLICE_THREADS</name> <operator>|</operator> <name>AV_CODEC_CAP_DR1</name></expr>,
<expr><operator>.</operator><name>caps_internal</name> <operator>=</operator> <name>FF_CODEC_CAP_INIT_THREADSAFE</name></expr>,
<expr><operator>.</operator><name>flush</name> <operator>=</operator> <name>dirac_decode_flush</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
