<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\tests\checkasm\vp9dsp.c">



















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkasm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/vp9data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/vp9.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mathematics.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>pixel_mask</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xffffffff</literal></expr>, <expr><literal type="number">0x03ff03ff</literal></expr>, <expr><literal type="number">0x0fff0fff</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_PIXEL</name></cpp:macro> <cpp:value>((bit_depth + 7) / 8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>randomize_buffers</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { uint32_t mask = pixel_mask[(bit_depth - 8) &gt;&gt; 1]; int k; for (k = -4; k &lt; SIZEOF_PIXEL * FFMAX(8, size); k += 4) { uint32_t r = rnd() &amp; mask; AV_WN32A(a + k, r); } for (k = 0; k &lt; size * SIZEOF_PIXEL; k += 4) { uint32_t r = rnd() &amp; mask; AV_WN32A(l + k, r); } } while (0)</cpp:value></cpp:define>













<function><type><specifier>static</specifier> <name>void</name></type> <name>check_ipred</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>a_buf</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>a_buf</name><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>VP9DSPContext</name></type> <name>dsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tx</name></decl>, <decl><type ref="prev"/><name>mode</name></decl>, <decl><type ref="prev"/><name>bit_depth</name></decl>;</decl_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>ptrdiff_t stride</argument>,
<argument>const uint8_t *left</argument>, <argument>const uint8_t *top</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>mode_names</name><index>[<expr><name>N_INTRA_PRED_MODES</name></expr>]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>VERT_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"vert"</literal></expr>,
<expr><index>[<expr><name>HOR_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"hor"</literal></expr>,
<expr><index>[<expr><name>DC_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc"</literal></expr>,
<expr><index>[<expr><name>DIAG_DOWN_LEFT_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"diag_downleft"</literal></expr>,
<expr><index>[<expr><name>DIAG_DOWN_RIGHT_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"diag_downright"</literal></expr>,
<expr><index>[<expr><name>VERT_RIGHT_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"vert_right"</literal></expr>,
<expr><index>[<expr><name>HOR_DOWN_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"hor_down"</literal></expr>,
<expr><index>[<expr><name>VERT_LEFT_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"vert_left"</literal></expr>,
<expr><index>[<expr><name>HOR_UP_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"hor_up"</literal></expr>,
<expr><index>[<expr><name>TM_VP8_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"tm"</literal></expr>,
<expr><index>[<expr><name>LEFT_DC_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc_left"</literal></expr>,
<expr><index>[<expr><name>TOP_DC_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc_top"</literal></expr>,
<expr><index>[<expr><name>DC_128_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc_128"</literal></expr>,
<expr><index>[<expr><name>DC_127_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc_127"</literal></expr>,
<expr><index>[<expr><name>DC_129_PRED</name></expr>]</index> <operator>=</operator> <literal type="string">"dc_129"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>bit_depth</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_vp9dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsp</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>tx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>tx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">4</literal> <operator>&lt;&lt;</operator> <name>tx</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mode</name> <operator>&lt;</operator> <name>N_INTRA_PRED_MODES</name></expr>;</condition> <incr><expr><name>mode</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>intra_pred</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>mode</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"vp9_%s_%dx%d_%dbpp"</literal></expr></argument>,
<argument><expr><name><name>mode_names</name><index>[<expr><name>mode</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"ipred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>randomize_buffers</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>randomize_buffers</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { uint32_t mask = pixel_mask[(bit_depth - 8) &gt;&gt; 1]; for (y = 0; y &lt; sz; y++) { for (x = 0; x &lt; sz * SIZEOF_PIXEL; x += 4) { uint32_t r = rnd() &amp; mask; AV_WN32A(dst + y * sz * SIZEOF_PIXEL + x, r); AV_WN32A(src + y * sz * SIZEOF_PIXEL + x, rnd() &amp; mask); } for (x = 0; x &lt; sz; x++) { if (bit_depth == 8) { coef[y * sz + x] = src[y * sz + x] - dst[y * sz + x]; } else { ((int32_t *) coef)[y * sz + x] = ((uint16_t *) src)[y * sz + x] - ((uint16_t *) dst)[y * sz + x]; } } } } while(0)</cpp:value></cpp:define>





















<function><type><specifier>static</specifier> <name>void</name></type> <name>fwht_1d</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>t0</name> <init>= <expr><name><name>in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>t3</name> <init>= <expr><name><name>in</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>in</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>t4</name> <init>= <expr><call><name>trunc</name><argument_list>(<argument><expr><operator>(</operator><name>t0</name> <operator>-</operator> <name>t3</name><operator>)</operator> <operator>*</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>t1</name> <init>= <expr><name>t4</name> <operator>-</operator> <name><name>in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>t2</name> <init>= <expr><name>t4</name> <operator>-</operator> <name><name>in</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t0</name> <operator>-</operator> <name>t2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t3</name> <operator>+</operator> <name>t1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>t1</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fdct_1d</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <call><name>cos</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>k</name> <operator>/</operator> <operator>(</operator><name>sz</name> <operator>*</operator> <literal type="number">2.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*=</operator> <name>M_SQRT1_2</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>fadst4_1d</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>sz</name> <operator>*</operator> <literal type="number">2.0</literal> <operator>+</operator> <literal type="number">1.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>fadst_1d</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>sz</name> <operator>*</operator> <literal type="number">4.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>ftx1d_fn</name>)<parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ftx_2d</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>TxfmMode</name></name></type> <name>tx</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>TxfmType</name></name></type> <name>txtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name><name>scaling_factors</name><index>[<expr><literal type="number">5</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="number">4.0</literal></expr>, <expr><literal type="number">16.0</literal> <operator>*</operator> <name>M_SQRT1_2</name> <operator>/</operator> <literal type="number">3.0</literal></expr>, <expr><literal type="number">16.0</literal> <operator>*</operator> <name>M_SQRT1_2</name> <operator>/</operator> <literal type="number">3.0</literal></expr>, <expr><literal type="number">32.0</literal> <operator>/</operator> <literal type="number">9.0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">2.0</literal></expr>, <expr><literal type="number">2.0</literal></expr>, <expr><literal type="number">2.0</literal></expr>, <expr><literal type="number">2.0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0.25</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">4.0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ftx1d_fn</name></type> <name><name>ftx1d_tbl</name><index>[<expr><literal type="number">5</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst4_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fadst4_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst4_1d</name></expr>, <expr><name>fadst4_1d</name></expr> }</block></expr>,
}</block></expr>, <expr><block>{
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fadst_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst_1d</name></expr>, <expr><name>fadst_1d</name></expr> }</block></expr>,
}</block></expr>, <expr><block>{
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fadst_1d</name></expr> }</block></expr>,
<expr><block>{ <expr><name>fadst_1d</name></expr>, <expr><name>fadst_1d</name></expr> }</block></expr>,
}</block></expr>, <expr><block>{
<expr><block>{ <expr><name>fdct_1d</name></expr>, <expr><name>fdct_1d</name></expr> }</block></expr>,
}</block></expr>, <expr><block>{
<expr><block>{ <expr><name>fwht_1d</name></expr>, <expr><name>fwht_1d</name></expr> }</block></expr>,
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>temp</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>scaling_factor</name> <init>= <expr><name><name>scaling_factors</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>txtp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name><name>temp_out</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ftx1d_tbl</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>txtp</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>(</operator><name>temp_out</name><operator>,</operator> <operator>&amp;</operator><name><name>in</name><index>[<expr><name>i</name> <operator>*</operator> <name>sz</name></expr>]</index></name><operator>,</operator> <name>sz</name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>temp</name><index>[<expr><name>j</name> <operator>*</operator> <name>sz</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>temp_out</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>scaling_factor</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ftx1d_tbl</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>txtp</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>(</operator><operator>&amp;</operator><name><name>out</name><index>[<expr><name>i</name> <operator>*</operator> <name>sz</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>temp</name><index>[<expr><name>i</name> <operator>*</operator> <name>sz</name></expr>]</index></name><operator>,</operator> <name>sz</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ftx</name><parameter_list>(<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>TxfmMode</name></name></type> <name>tx</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>TxfmType</name></name></type> <name>txtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bit_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name><name>ind</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>outd</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>emms_c</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ind</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ind</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ftx_2d</name><argument_list>(<argument><expr><name>outd</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>txtp</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>lrint</name><argument_list>(<argument><expr><name><name>outd</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <call><name>lrint</name><argument_list>(<argument><expr><name><name>outd</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>copy_subcoefs</name><parameter_list>(<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>TxfmMode</name></name></type> <name>tx</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>TxfmType</name></name></type> <name>txtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sub</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bit_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>







<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><name><name>ff_vp9_scans</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>txtp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eob</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>scan</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>rcx</name> <init>= <expr><name>rc</name> <operator>%</operator> <name>sz</name></expr></init></decl>, <decl><type ref="prev"/><name>rcy</name> <init>= <expr><name>rc</name> <operator>/</operator> <name>sz</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>rcx</name> <operator>&gt;=</operator> <name>sub</name> <operator>||</operator> <name>rcy</name> <operator>&gt;=</operator> <name>sub</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>rc</name></expr>]</index></name> <operator>=</operator> <name><name>in</name><index>[<expr><name>rc</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><index>[<expr><name>rc</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in</name><index>[<expr><name>rc</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>eob</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>scan</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>rc</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>AV_ZERO32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><index>[<expr><name>rc</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>eob</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>iszero</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>sz</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>AV_RN32A</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_COEF</name></cpp:macro> <cpp:value>(2 * ((bit_depth + 7) / 8))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_itxfm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>ptrdiff_t stride</argument>, <argument>int16_t *block</argument>, <argument>int eob</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>VP9DSPContext</name></type> <name>dsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>tx</name></decl>, <decl><type ref="prev"/><name>txtp</name></decl>, <decl><type ref="prev"/><name>bit_depth</name></decl>, <decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>txtp_types</name><index>[<expr><name>N_TXFM_TYPES</name></expr>]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>DCT_DCT</name></expr>]</index> <operator>=</operator> <literal type="string">"dct_dct"</literal></expr>, <expr><index>[<expr><name>DCT_ADST</name></expr>]</index> <operator>=</operator> <literal type="string">"adst_dct"</literal></expr>,
<expr><index>[<expr><name>ADST_DCT</name></expr>]</index> <operator>=</operator> <literal type="string">"dct_adst"</literal></expr>, <expr><index>[<expr><name>ADST_ADST</name></expr>]</index> <operator>=</operator> <literal type="string">"adst_adst"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>bit_depth</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_vp9dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsp</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>tx</name> <operator>=</operator> <name>TX_4X4</name></expr>;</init> <condition><expr><name>tx</name> <operator>&lt;=</operator> <name>N_TXFM_SIZES</name></expr> ;</condition> <incr><expr><name>tx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">4</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>tx</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_txtps</name> <init>= <expr><ternary><condition><expr><name>tx</name> <operator>&lt;</operator> <name>TX_32X32</name></expr> ?</condition><then> <expr><name>N_TXFM_TYPES</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>txtp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>txtp</name> <operator>&lt;</operator> <name>n_txtps</name></expr>;</condition> <incr><expr><name>txtp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>





<for>for <control>(<init><expr><name>sub</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>txtp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tx</name> <operator>&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</init> <condition><expr><name>sub</name> <operator>&lt;=</operator> <name>sz</name></expr>;</condition>
<incr><expr><ternary><condition><expr><name>sub</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><operator>(</operator><name>sub</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>sub</name> <operator>+=</operator> <literal type="number">4</literal><operator>)</operator></expr></else></ternary></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>itxfm_add</name><index>[<expr><name>tx</name></expr>]</index><index>[<expr><name>txtp</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"vp9_inv_%s_%dx%d_sub%d_add_%d"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>tx</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="string">"wht_wht"</literal></expr> </then><else>: <expr><name><name>txtp_types</name><index>[<expr><name>txtp</name></expr>]</index></name></expr></else></ternary></expr></argument>,
<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>eob</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ftx</name><argument_list>(<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>txtp</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&lt;</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eob</name> <operator>=</operator> <call><name>copy_subcoefs</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><name>tx</name></expr></argument>, <argument><expr><name>txtp</name></expr></argument>,
<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eob</name> <operator>=</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>iszero</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>iszero</name><argument_list>(<argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><name>eob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"itxfm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>randomize_buffers</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setpx</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (SIZEOF_PIXEL == 1) { buf0[(a) + (b) * jstride] = av_clip_uint8(c); } else { ((uint16_t *)buf0)[(a) + (b) * jstride] = av_clip_uintp2(c, bit_depth); } } while (0)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setdx</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>setpx(a,b,c-(d)+(rnd()%((d)*2+1)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setsx</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>setdx(a,b,c,(d) &lt;&lt; (bit_depth - 8))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randomize_loopfilter_buffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bidx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineoff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>str</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>bit_depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>H</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>I</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf0</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bit_depth</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>lineoff</name></expr> </then><else>: <expr><name>lineoff</name> <operator>*</operator> <literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>istride</name> <init>= <expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jstride</name> <init>= <expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>str</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>off</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></init></decl>, <decl><type ref="prev"/><name>p0</name></decl>, <decl><type ref="prev"/><name>q0</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>q0</name> <operator>=</operator> <call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>p0</name> <operator>=</operator> <name>q0</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><name>bidx</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><name>p0</name></expr></argument>, <argument><expr><name><name>F</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>q0</name></expr></argument>, <argument><expr><name><name>F</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>off</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></init></decl>, <decl><type ref="prev"/><name>p0</name></decl>, <decl><type ref="prev"/><name>q0</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>q0</name> <operator>=</operator> <call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>p0</name> <operator>=</operator> <name>q0</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><name>bidx</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><name>p0</name></expr></argument>, <argument><expr><name><name>F</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>q0</name></expr></argument>, <argument><expr><name><name>F</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>off</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></init></decl>, <decl><type ref="prev"/><name>p2</name></decl>, <decl><type ref="prev"/><name>p1</name></decl>, <decl><type ref="prev"/><name>p0</name></decl>, <decl><type ref="prev"/><name>q0</name></decl>, <decl><type ref="prev"/><name>q1</name></decl>, <decl><type ref="prev"/><name>q2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>q0</name> <operator>=</operator> <call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>q1</name> <operator>=</operator> <name>q0</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>q2</name> <operator>=</operator> <name>q1</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>q2</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>p0</name> <operator>=</operator> <name>q0</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><name>bidx</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>p1</name> <operator>=</operator> <name>p0</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>p2</name> <operator>=</operator> <name>p1</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><name>bidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">6</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>off</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setpx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>randomize_buffers</name><parameter_list>(<parameter><type><name>bidx</name></type></parameter>, <parameter><type><name>lineoff</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>randomize_loopfilter_buffers(bidx, lineoff, str, bit_depth, dir, E, F, H, I, buf0, buf1)</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>void</name></type> <name>check_loopfilter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>base0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>+</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>base1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>+</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>VP9DSPContext</name></type> <name>dsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>, <decl><type ref="prev"/><name>wd</name></decl>, <decl><type ref="prev"/><name>wd2</name></decl>, <decl><type ref="prev"/><name>bit_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>dir_name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"h"</literal></expr>, <expr><literal type="string">"v"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>E</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">20</literal></expr>, <expr><literal type="number">28</literal></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name><name>I</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">10</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>H</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">7</literal></expr>, <expr><literal type="number">11</literal></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name><name>F</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>ptrdiff_t stride</argument>, <argument>int E</argument>, <argument>int I</argument>, <argument>int H</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>bit_depth</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_vp9dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsp</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>dir</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dir</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>dir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>midoff</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>midoff_aligned</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf0</name> <init>= <expr><name>base0</name> <operator>+</operator> <name>midoff_aligned</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf1</name> <init>= <expr><name>base1</name> <operator>+</operator> <name>midoff_aligned</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>wd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wd</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>wd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>loop_filter_8</name><index>[<expr><name>wd</name></expr>]</index><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"vp9_loop_filter_%s_%d_8_%dbpp"</literal></expr></argument>,
<argument><expr><name><name>dir_name</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>&lt;&lt;</operator> <name>wd</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>,
<argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>buf0</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name> <operator>&gt;&gt;</operator> <name>dir</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name> <operator>&gt;&gt;</operator> <name>dir</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name> <operator>&gt;&gt;</operator> <name>dir</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>midoff</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>midoff_aligned</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf0</name> <operator>=</operator> <name>base0</name> <operator>+</operator> <name>midoff_aligned</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf1</name> <operator>=</operator> <name>base1</name> <operator>+</operator> <name>midoff_aligned</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>loop_filter_16</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"vp9_loop_filter_%s_16_16_%dbpp"</literal></expr></argument>,
<argument><expr><name><name>dir_name</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>buf0</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name><name>E</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>I</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>H</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>wd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wd</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>wd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>wd2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wd2</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>wd2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>loop_filter_mix2</name><index>[<expr><name>wd</name></expr>]</index><index>[<expr><name>wd2</name></expr>]</index><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"vp9_loop_filter_mix2_%s_%d%d_16_%dbpp"</literal></expr></argument>,
<argument><expr><name><name>dir_name</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>&lt;&lt;</operator> <name>wd</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>&lt;&lt;</operator> <name>wd2</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)[1] &lt;&lt; 8) | (a)[0])</cpp:value></cpp:define>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>buf0</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>H</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>H</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf0</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><name>buf1</name> <operator>-</operator> <name>midoff</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>M</name><argument_list>(<argument><expr><name>H</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>M</name></cpp:undef>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"loopfilter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>setsx</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>setpx</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>setdx</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>randomize_buffers</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DST_BUF_SIZE</name></cpp:macro> <cpp:value>(size * size * SIZEOF_PIXEL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRC_BUF_STRIDE</name></cpp:macro> <cpp:value>72</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRC_BUF_SIZE</name></cpp:macro> <cpp:value>((size + 7) * SRC_BUF_STRIDE * SIZEOF_PIXEL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>src</name></cpp:macro> <cpp:value>(buf + 3 * SIZEOF_PIXEL * (SRC_BUF_STRIDE + 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>randomize_buffers</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { uint32_t mask = pixel_mask[(bit_depth - 8) &gt;&gt; 1]; int k; for (k = 0; k &lt; SRC_BUF_SIZE; k += 4) { uint32_t r = rnd() &amp; mask; AV_WN32A(buf + k, r); } if (op == 1) { for (k = 0; k &lt; DST_BUF_SIZE; k += 4) { uint32_t r = rnd() &amp; mask; AV_WN32A(dst0 + k, r); AV_WN32A(dst1 + k, r); } } } while (0)</cpp:value></cpp:define>
















<function><type><specifier>static</specifier> <name>void</name></type> <name>check_mc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">72</literal> <operator>*</operator> <literal type="number">72</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">64</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">64</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>VP9DSPContext</name></type> <name>dsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>hsize</name></decl>, <decl><type ref="prev"/><name>bit_depth</name></decl>, <decl><type ref="prev"/><name>filter</name></decl>, <decl><type ref="prev"/><name>dx</name></decl>, <decl><type ref="prev"/><name>dy</name></decl>;</decl_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>ptrdiff_t dst_stride</argument>,
<argument>const uint8_t *ref</argument>, <argument>ptrdiff_t ref_stride</argument>,
<argument>int h</argument>, <argument>int mx</argument>, <argument>int my</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>filter_names</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="string">"8tap_smooth"</literal></expr>, <expr><literal type="string">"8tap_regular"</literal></expr>, <expr><literal type="string">"8tap_sharp"</literal></expr>, <expr><literal type="string">"bilin"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>subpel_names</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><block>{ <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"h"</literal></expr> }</block></expr>, <expr><block>{ <expr><literal type="string">"v"</literal></expr>, <expr><literal type="string">"hv"</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>op_names</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"put"</literal></expr>, <expr><literal type="string">"avg"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>op</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>op</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>bit_depth</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_vp9dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsp</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>hsize</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>hsize</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">64</literal> <operator>&gt;&gt;</operator> <name>hsize</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>filter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>filter</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>filter</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>dx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dx</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>dx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>dy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dy</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>dy</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dx</name> <operator>||</operator> <name>dy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s_%s_%d%s"</literal></expr></argument>, <argument><expr><name><name>op_names</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>filter_names</name><index>[<expr><name>filter</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><name><name>subpel_names</name><index>[<expr><name>dy</name></expr>]</index><index>[<expr><name>dx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name><name>op_names</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name><name>dsp</name><operator>.</operator><name>mc</name><index>[<expr><name>hsize</name></expr>]</index><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>op</name></expr>]</index><index>[<expr><name>dx</name></expr>]</index><index>[<expr><name>dy</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"vp9_%s_%dbpp"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mx</name> <init>= <expr><ternary><condition><expr><name>dx</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><call><name>rnd</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">14</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>my</name> <init>= <expr><ternary><condition><expr><name>dy</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><call><name>rnd</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">14</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>src</name></expr></argument>, <argument><expr><name>SRC_BUF_STRIDE</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>src</name></expr></argument>, <argument><expr><name>SRC_BUF_STRIDE</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>DST_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>filter</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>filter</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">12</literal> <operator>&amp;&amp;</operator> <name>filter</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>src</name></expr></argument>, <argument><expr><name>SRC_BUF_STRIDE</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"mc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>checkasm_check_vp9dsp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_ipred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_itxfm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_loopfilter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_mc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
