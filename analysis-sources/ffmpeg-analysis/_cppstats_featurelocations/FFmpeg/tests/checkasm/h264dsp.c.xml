<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\tests\checkasm\h264dsp.c">



















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"checkasm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/avcodec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/h264dsp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/h264data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>pixel_mask</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xffffffff</literal></expr>, <expr><literal type="number">0x01ff01ff</literal></expr>, <expr><literal type="number">0x03ff03ff</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>pixel_mask_lf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xff0fff0f</literal></expr>, <expr><literal type="number">0x01ff000f</literal></expr>, <expr><literal type="number">0x03ff000f</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_PIXEL</name></cpp:macro> <cpp:value>((bit_depth + 7) / 8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_COEF</name></cpp:macro> <cpp:value>(2 * ((bit_depth + 7) / 8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIXEL_STRIDE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>randomize_buffers</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { int x, y; uint32_t mask = pixel_mask[bit_depth - 8]; for (y = 0; y &lt; sz; y++) { for (x = 0; x &lt; PIXEL_STRIDE; x += 4) { AV_WN32A(src + y * PIXEL_STRIDE + x, rnd() &amp; mask); AV_WN32A(dst + y * PIXEL_STRIDE + x, rnd() &amp; mask); } for (x = 0; x &lt; sz; x++) { if (bit_depth == 8) { coef[y * sz + x] = src[y * PIXEL_STRIDE + x] - dst[y * PIXEL_STRIDE + x]; } else { ((int32_t *)coef)[y * sz + x] = ((uint16_t *)src)[y * (PIXEL_STRIDE/2) + x] - ((uint16_t *)dst)[y * (PIXEL_STRIDE/2) + x]; } } } } while (0)</cpp:value></cpp:define>





















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dct4x4_impl</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>dctcoef</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void dct4x4_##size(dctcoef *coef) { int i, y, x; dctcoef tmp[16]; for (i = 0; i &lt; 4; i++) { const int z0 = coef[i*4 + 0] + coef[i*4 + 3]; const int z1 = coef[i*4 + 1] + coef[i*4 + 2]; const int z2 = coef[i*4 + 0] - coef[i*4 + 3]; const int z3 = coef[i*4 + 1] - coef[i*4 + 2]; tmp[i + 4*0] = z0 + z1; tmp[i + 4*1] = 2*z2 + z3; tmp[i + 4*2] = z0 - z1; tmp[i + 4*3] = z2 - 2*z3; } for (i = 0; i &lt; 4; i++) { const int z0 = tmp[i*4 + 0] + tmp[i*4 + 3]; const int z1 = tmp[i*4 + 1] + tmp[i*4 + 2]; const int z2 = tmp[i*4 + 0] - tmp[i*4 + 3]; const int z3 = tmp[i*4 + 1] - tmp[i*4 + 2]; coef[i*4 + 0] = z0 + z1; coef[i*4 + 1] = 2*z2 + z3; coef[i*4 + 2] = z0 - z1; coef[i*4 + 3] = z2 - 2*z3; } for (y = 0; y &lt; 4; y++) { for (x = 0; x &lt; 4; x++) { static const int scale[] = { 13107 * 10, 8066 * 13, 5243 * 16 }; const int idx = (y &amp; 1) + (x &amp; 1); coef[y*4 + x] = (coef[y*4 + x] * scale[idx] + (1 &lt;&lt; 14)) &gt;&gt; 15; } } }</cpp:value></cpp:define>

































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCT8_1D</name><parameter_list>(<parameter><type><name>src</name></type></parameter>, <parameter><type><name>srcstride</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>, <parameter><type><name>dststride</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const int a0 = (src)[srcstride * 0] + (src)[srcstride * 7]; const int a1 = (src)[srcstride * 0] - (src)[srcstride * 7]; const int a2 = (src)[srcstride * 1] + (src)[srcstride * 6]; const int a3 = (src)[srcstride * 1] - (src)[srcstride * 6]; const int a4 = (src)[srcstride * 2] + (src)[srcstride * 5]; const int a5 = (src)[srcstride * 2] - (src)[srcstride * 5]; const int a6 = (src)[srcstride * 3] + (src)[srcstride * 4]; const int a7 = (src)[srcstride * 3] - (src)[srcstride * 4]; const int b0 = a0 + a6; const int b1 = a2 + a4; const int b2 = a0 - a6; const int b3 = a2 - a4; const int b4 = a3 + a5 + (a1 + (a1 &gt;&gt; 1)); const int b5 = a1 - a7 - (a5 + (a5 &gt;&gt; 1)); const int b6 = a1 + a7 - (a3 + (a3 &gt;&gt; 1)); const int b7 = a3 - a5 + (a7 + (a7 &gt;&gt; 1)); (dst)[dststride * 0] = b0 + b1; (dst)[dststride * 1] = b4 + (b7 &gt;&gt; 2); (dst)[dststride * 2] = b2 + (b3 &gt;&gt; 1); (dst)[dststride * 3] = b5 + (b6 &gt;&gt; 2); (dst)[dststride * 4] = b0 - b1; (dst)[dststride * 5] = b6 - (b5 &gt;&gt; 2); (dst)[dststride * 6] = (b2 &gt;&gt; 1) - b3; (dst)[dststride * 7] = (b4 &gt;&gt; 2) - b7; } while (0)</cpp:value></cpp:define>


























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dct8x8_impl</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>dctcoef</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void dct8x8_##size(dctcoef *coef) { int i, x, y; dctcoef tmp[64]; for (i = 0; i &lt; 8; i++) DCT8_1D(coef + i, 8, tmp + i, 8); for (i = 0; i &lt; 8; i++) DCT8_1D(tmp + 8*i, 1, coef + i, 8); for (y = 0; y &lt; 8; y++) { for (x = 0; x &lt; 8; x++) { static const int scale[] = { 13107 * 20, 11428 * 18, 20972 * 32, 12222 * 19, 16777 * 25, 15481 * 24, }; static const int idxmap[] = { 0, 3, 4, 3, 3, 1, 5, 1, 4, 5, 2, 5, 3, 1, 5, 1, }; const int idx = idxmap[(y &amp; 3) * 4 + (x &amp; 3)]; coef[y*8 + x] = ((int64_t)coef[y*8 + x] * scale[idx] + (1 &lt;&lt; 17)) &gt;&gt; 18; } } }</cpp:value></cpp:define>





























<macro><name>dct4x4_impl</name><argument_list>(<argument><literal type="number">16</literal></argument>, <argument>int16_t</argument>)</argument_list></macro>
<macro><name>dct4x4_impl</name><argument_list>(<argument><literal type="number">32</literal></argument>, <argument>int32_t</argument>)</argument_list></macro>

<macro><name>dct8x8_impl</name><argument_list>(<argument><literal type="number">16</literal></argument>, <argument>int16_t</argument>)</argument_list></macro>
<macro><name>dct8x8_impl</name><argument_list>(<argument><literal type="number">32</literal></argument>, <argument>int32_t</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dct4x4</name><parameter_list>(<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coef</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bit_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct4x4_16</name><argument_list>(<argument><expr><name>coef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct4x4_32</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <name>coef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dct8x8</name><parameter_list>(<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>coef</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bit_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dct8x8_16</name><argument_list>(<argument><expr><name>coef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dct8x8_32</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator> <name>coef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>check_idct</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1_base</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">32</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>H264DSPContext</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>, <decl><type ref="prev"/><name>align</name></decl>, <decl><type ref="prev"/><name>dc</name></decl>;</decl_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>int16_t *block</argument>, <argument>int stride</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>bit_depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sz</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>sz</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>sz</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct4x4</name><argument_list>(<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct8x8</name><argument_list>(<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>dc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>dc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>idct</name>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<switch>switch <condition>(<expr><operator>(</operator><name>sz</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <name>dc</name></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>(</operator><literal type="number">4</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct_add</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><operator>(</operator><literal type="number">4</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct_dc_add</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><operator>(</operator><literal type="number">8</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct8_add</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><operator>(</operator><literal type="number">8</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct8_dc_add</name></name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name>idct</name></expr></argument>, <argument><expr><literal type="string">"h264_idct%d_add%s_%dbpp"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dc</name></expr> ?</condition><then> <expr><literal type="string">"_dc"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>align</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>align</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>align</name> <operator>+=</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst1</name> <init>= <expr><name>dst1_base</name> <operator>+</operator> <name>align</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>coef</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>PIXEL_STRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>PIXEL_STRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>PIXEL_STRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>PIXEL_STRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>PIXEL_STRIDE</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>subcoef0</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>sz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>subcoef1</name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_idct_multiple</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst_full</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>coef_full</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>coef0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>coef1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>nnzc</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>H264DSPContext</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>func</name></decl>;</decl_stmt>
<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX</argument>, <argument>void</argument>, <argument>uint8_t *dst</argument>, <argument>const int *block_offset</argument>, <argument>int16_t *block</argument>, <argument>int stride</argument>, <argument>const uint8_t nnzc[<literal type="number">15</literal>*<literal type="number">8</literal>]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>bit_depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>func</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>func</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>func</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>idct</name>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>uint8_t</name><index>[]</index></name></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>, <decl><type ref="prev"/><name>intra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>block_offset</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>func</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct_add16</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"h264_idct_add16"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct_add16intra</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"h264_idct_add16intra"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>intra</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>idct</name> <operator>=</operator> <name><name>h</name><operator>.</operator><name>h264_idct8_add4</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"h264_idct8_add4"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nnzc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">15</literal> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>coef_full</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>src</name><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>dst</name><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>coef</name><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>i</name> <operator>/</operator> <name>sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_y</name> <init>= <expr><operator>(</operator><name>index</name> <operator>/</operator> <literal type="number">16</literal><operator>)</operator> <operator>*</operator> <name>sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_x</name> <init>= <expr><name>index</name> <operator>%</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>block_y</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <name>block_x</name><operator>)</operator> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nnz</name> <init>= <expr><call><name>rnd</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>randomize_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct4x4</name><argument_list>(<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dct8x8</name><argument_list>(<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_full</name><index>[<expr><name>offset</name> <operator>+</operator> <name>y</name> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>dst</name><index>[<expr><name>PIXEL_STRIDE</name> <operator>*</operator> <name>y</name></expr>]</index></name></expr></argument>, <argument><expr><name>sz</name> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>nnz</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nnz</name> <operator>=</operator> <name>sz</name> <operator>*</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>coef_full</name><index>[<expr><name>i</name> <operator>*</operator> <name>SIZEOF_COEF</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>coef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>,
<argument><expr><name>coef</name></expr></argument>, <argument><expr><name>nnz</name> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>intra</name> <operator>&amp;&amp;</operator> <name>nnz</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nnz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>nnzc</name><index>[<expr><name><name>scan8</name><index>[<expr><name>i</name> <operator>/</operator> <literal type="number">16</literal></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>nnz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block_offset</name><index>[<expr><name>i</name> <operator>/</operator> <literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>check_func</name><argument_list>(<argument><expr><name>idct</name></expr></argument>, <argument><expr><literal type="string">"%s_%dbpp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>coef0</name></expr></argument>, <argument><expr><name>coef_full</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>coef1</name></expr></argument>, <argument><expr><name>coef_full</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst_full</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>dst_full</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_ref</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>block_offset</name></expr></argument>, <argument><expr><name>coef0</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>nnzc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>call_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>block_offset</name></expr></argument>, <argument><expr><name>coef1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>nnzc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>dst0</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>coef0</name></expr></argument>, <argument><expr><name>coef1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_COEF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bench_new</name><argument_list>(<argument><expr><name>dst1</name></expr></argument>, <argument><expr><name>block_offset</name></expr></argument>, <argument><expr><name>coef1</name></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>*</operator> <name>SIZEOF_PIXEL</name></expr></argument>, <argument><expr><name>nnzc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>check_loop_filter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>H264DSPContext</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>alphas</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>betas</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name></type> <name><name>tc0</name><index>[<expr><literal type="number">36</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX</argument>, <argument>void</argument>, <argument>uint8_t *pix</argument>, <argument>ptrdiff_t stride</argument>,
<argument>int alpha</argument>, <argument>int beta</argument>, <argument>int8_t *tc0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>bit_depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>a</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mask</name> <init>= <expr><name><name>pixel_mask_lf</name><index>[<expr><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">35</literal></expr><operator>,</operator> <expr><name>a</name> <operator>=</operator> <literal type="number">255</literal></expr><operator>,</operator> <expr><name>c</name> <operator>=</operator> <literal type="number">250</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>alphas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>a</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>betas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tc0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tc0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tc0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">15</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tc0</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">9</literal><operator>)</operator> <operator>/</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>*</operator><literal type="number">9</literal><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">9</literal><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_LOOP_FILTER</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>align</name></type></parameter>, <parameter><type><name>idc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (check_func(h.name, #name #idc "_%dbpp", bit_depth)) { for (j = 0; j &lt; 36; j++) { intptr_t off = 8 * 32 + (j &amp; 15) * 4 * !align; for (i = 0; i &lt; 1024; i+=4) { AV_WN32A(dst + i, rnd() &amp; mask); } memcpy(dst0, dst, 32 * 16 * 2); memcpy(dst1, dst, 32 * 16 * 2); call_ref(dst0 + off, 32, alphas[j], betas[j], tc0[j]); call_new(dst1 + off, 32, alphas[j], betas[j], tc0[j]); if (memcmp(dst0, dst1, 32 * 16 * SIZEOF_PIXEL)) { fprintf(stderr, #name #idc ": j:%d, alpha:%d beta:%d " "tc0:{%d,%d,%d,%d}\n", j, alphas[j], betas[j], tc0[j][0], tc0[j][1], tc0[j][2], tc0[j][3]); fail(); } bench_new(dst1, 32, alphas[j], betas[j], tc0[j]); } } } while (0)</cpp:value></cpp:define>























<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_v_loop_filter_luma</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_luma</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_luma_mbaff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_v_loop_filter_chroma</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_mbaff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">422</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_mbaff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">422</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_LOOP_FILTER</name></cpp:undef>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_loop_filter_intra</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst0</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOCAL_ALIGNED_16</name><argument_list>(<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>dst1</name></expr></argument>, <argument><expr><index>[<expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>H264DSPContext</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>alphas</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>betas</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></decl>;</decl_stmt>

<macro><name>declare_func_emms</name><argument_list>(<argument>AV_CPU_FLAG_MMX</argument>, <argument>void</argument>, <argument>uint8_t *pix</argument>, <argument>ptrdiff_t stride</argument>,
<argument>int alpha</argument>, <argument>int beta</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>bit_depth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bit_depth</name> <operator>&lt;=</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>bit_depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mask</name> <init>= <expr><name><name>pixel_mask_lf</name><index>[<expr><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">35</literal></expr><operator>,</operator> <expr><name>a</name> <operator>=</operator> <literal type="number">255</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>alphas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>a</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>betas</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>bit_depth</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>*</operator><literal type="number">9</literal><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_LOOP_FILTER</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>align</name></type></parameter>, <parameter><type><name>idc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (check_func(h.name, #name #idc "_%dbpp", bit_depth)) { for (j = 0; j &lt; 36; j++) { intptr_t off = 8 * 32 + (j &amp; 15) * 4 * !align; for (i = 0; i &lt; 1024; i+=4) { AV_WN32A(dst + i, rnd() &amp; mask); } memcpy(dst0, dst, 32 * 16 * 2); memcpy(dst1, dst, 32 * 16 * 2); call_ref(dst0 + off, 32, alphas[j], betas[j]); call_new(dst1 + off, 32, alphas[j], betas[j]); if (memcmp(dst0, dst1, 32 * 16 * SIZEOF_PIXEL)) { fprintf(stderr, #name #idc ": j:%d, alpha:%d beta:%d\n", j, alphas[j], betas[j]); fail(); } bench_new(dst1, 32, alphas[j], betas[j]); } } } while (0)</cpp:value></cpp:define>






















<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_v_loop_filter_luma_intra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_luma_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_luma_mbaff_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_v_loop_filter_chroma_intra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_mbaff_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_h264dsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name>bit_depth</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">422</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LOOP_FILTER</name><argument_list>(<argument><expr><name>h264_h_loop_filter_chroma_mbaff_intra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">422</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_LOOP_FILTER</name></cpp:undef>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>checkasm_check_h264dsp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_idct</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_idct_multiple</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"idct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_loop_filter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"loop_filter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_loop_filter_intra</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><literal type="string">"loop_filter_intra"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
