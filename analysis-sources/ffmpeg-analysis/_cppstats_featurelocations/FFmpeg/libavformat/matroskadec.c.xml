<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavformat\matroskadec.c">





























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intfloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/lzo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mastering_display_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mathematics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/time_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/spherical.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/bytestream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/flac.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/mpeg4audio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avio_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"isom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"matroska.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oggdec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"riff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rmsipr.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_BZLIB</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_ZLIB</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qtpalette.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EBML_UNKNOWN_LENGTH</name></cpp:macro> <cpp:value>UINT64_MAX</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEEDS_CHECKING</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVEL_ENDED</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_THRESHOLD</name></cpp:macro> <cpp:value>1024 * 1024</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNKNOWN_EQUIV</name></cpp:macro> <cpp:value>50 * 1024</cpp:value></cpp:define> 



<typedef>typedef <type><enum>enum <block>{
<decl><name>EBML_NONE</name></decl>,
<decl><name>EBML_UINT</name></decl>,
<decl><name>EBML_SINT</name></decl>,
<decl><name>EBML_FLOAT</name></decl>,
<decl><name>EBML_STR</name></decl>,
<decl><name>EBML_UTF8</name></decl>,
<decl><name>EBML_BIN</name></decl>,
<decl><name>EBML_NEST</name></decl>,
<decl><name>EBML_LEVEL1</name></decl>,
<decl><name>EBML_STOP</name></decl>,
<decl><name>EBML_TYPE_COUNT</name></decl>
}</block></enum></type> <name>EbmlType</name>;</typedef>

<typedef>typedef <type><struct><specifier>const</specifier> struct <name>EbmlSyntax</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>list_elem_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>data_offset</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>EbmlSyntax</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
}</block> <decl><name>def</name></decl>;</union>
}</block></struct></type> <name>EbmlSyntax</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EbmlList</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>nb_elem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>alloc_elem_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
}</block></struct></type> <name>EbmlList</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EbmlBin</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>EbmlBin</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Ebml</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>max_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>id_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>doctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>doctype_version</name></decl>;</decl_stmt>
}</block></struct></type> <name>Ebml</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackCompression</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>algo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>settings</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackCompression</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackEncryption</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>algo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>key_id</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackEncryption</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackEncoding</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackCompression</name></type> <name>compression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackEncryption</name></type> <name>encryption</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackEncoding</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaMasteringMeta</name> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>r_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>r_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>g_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>g_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>b_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>b_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>white_x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>white_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>max_luminance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>min_luminance</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaMasteringMeta</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackVideoColor</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>matrix_coefficients</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>bits_per_channel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>chroma_sub_horz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>chroma_sub_vert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cb_sub_horz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cb_sub_vert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>chroma_siting_horz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>chroma_siting_vert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>transfer_characteristics</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>primaries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>max_cll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>max_fall</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaMasteringMeta</name></type> <name>mastering_meta</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackVideoColor</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackVideoProjection</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>private</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>yaw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>pitch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>roll</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackVideoProjection</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackVideo</name> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>frame_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>display_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>display_height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pixel_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pixel_height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>color_space</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>display_unit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>interlaced</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>field_order</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>stereo_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>alpha_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackVideoProjection</name></type> <name>projection</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackVideo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackAudio</name> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>samplerate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>out_samplerate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>bitdepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>channels</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>coded_framesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sub_packet_h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>frame_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sub_packet_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sub_packet_cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pkt_cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>buf_timecode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackAudio</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackPlane</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackPlane</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrackOperation</name> <block>{
<decl_stmt><decl><type><name>EbmlList</name></type> <name>combine_planes</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrackOperation</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTrack</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>codec_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>codec_priv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>language</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>time_scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>default_duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flag_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flag_forced</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>seek_preroll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackVideo</name></type> <name>video</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackAudio</name></type> <name>audio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackOperation</name></type> <name>operation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>encodings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>codec_delay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>codec_delay_in_track_tb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end_timecode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ms_compat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>max_block_additional_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>palette</name><index>[<expr><name>AVPALETTE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_palette</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaAttachment</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>bin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>stream</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaAttachment</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaChapter</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVChapter</name> <modifier>*</modifier></type><name>chapter</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaChapter</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaIndexPos</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>track</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaIndexPos</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaIndex</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaIndex</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTag</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>def</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>sub</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTag</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTagTarget</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>typevalue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>trackuid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>chapteruid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>attachuid</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTagTarget</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaTags</name> <block>{
<decl_stmt><decl><type><name>MatroskaTagTarget</name></type> <name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>tag</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaTags</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaSeekhead</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaSeekhead</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaLevel</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>length</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaLevel</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaBlock</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>reference</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>non_simple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>additional_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>additional</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>discard_padding</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaBlock</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaCluster</name> <block>{
<decl_stmt><decl><type><name>MatroskaBlock</name></type> <name>block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>timecode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaCluster</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaLevel1Element</name> <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parsed</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaLevel1Element</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MatroskaDemuxContext</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>MatroskaLevel</name></type> <name><name>levels</name><index>[<expr><name>EBML_MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_levels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>current_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>resync_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unknown_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>time_scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>muxingapp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlBin</name></type> <name>date_utc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>tracks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>attachments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>chapters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>tags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name></type> <name>seekhead</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>segment_start</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>AVPacketList</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVPacketList</name> <modifier>*</modifier></type><name>queue_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>skip_to_keyframe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>skip_to_timecode</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>cues_parsing_deferred</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>MatroskaLevel1Element</name></type> <name><name>level1_elems</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_level1_elems</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MatroskaCluster</name></type> <name>current_cluster</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>is_live</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>bandwidth</name></decl>;</decl_stmt>
}</block></struct></type> <name>MatroskaDemuxContext</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHILD_OF</name><parameter_list>(<parameter><type><name>parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ .def = { .n = parent } }</cpp:value></cpp:define>





<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>ebml_syntax</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_segment</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_track_video_color</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_track_video</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>matroska_track</name><index>[<expr><literal type="number">27</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_track_encoding</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_track_encodings</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>matroska_track_combine_planes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_track_operation</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_tracks</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>matroska_attachments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_chapter_entry</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_chapter</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_chapters</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>matroska_index_entry</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_index</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_tag</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_seekhead</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>,
<decl><type ref="prev"/><name><name>matroska_blockadditions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_blockgroup</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>matroska_cluster_parsing</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>ebml_header</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>EBML_ID_EBMLREADVERSION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Ebml</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>EBML_VERSION</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_EBMLMAXSIZELENGTH</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Ebml</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">8</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_EBMLMAXIDLENGTH</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Ebml</name></expr></argument>, <argument><expr><name>id_length</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">4</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_DOCTYPE</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Ebml</name></expr></argument>, <argument><expr><name>doctype</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>s</name> <operator>=</operator> <literal type="string">"(none)"</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_DOCTYPEREADVERSION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Ebml</name></expr></argument>, <argument><expr><name>doctype_version</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_EBMLVERSION</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>EBML_ID_DOCTYPEVERSION</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>ebml_syntax</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>ebml_syntax</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>EBML_ID_HEADER</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>ebml_header</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SEGMENT</name></expr>, <expr><name>EBML_STOP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_info</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TIMECODESCALE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>time_scale</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1000000</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_DURATION</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaDemuxContext</argument>, <argument>duration</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TITLE</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaDemuxContext</argument>, <argument>title</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_WRITINGAPP</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_MUXINGAPP</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaDemuxContext</argument>, <argument>muxingapp</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_DATEUTC</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaDemuxContext</argument>, <argument>date_utc</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SEGMENTUID</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_mastering_meta</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_RX</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>r_x</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_RY</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>r_y</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_GX</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>g_x</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_GY</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>g_y</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_BX</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>b_x</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_BY</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>b_y</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_WHITEX</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>white_x</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_WHITEY</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>white_y</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_LUMINANCEMIN</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>min_luminance</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR_LUMINANCEMAX</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaMasteringMeta</name></expr></argument>, <argument><expr><name>max_luminance</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_video_color</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_video_color</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORMATRIXCOEFF</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>matrix_coefficients</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AVCOL_SPC_UNSPECIFIED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORBITSPERCHANNEL</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>bits_per_channel</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCHROMASUBHORZ</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>chroma_sub_horz</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCHROMASUBVERT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>chroma_sub_vert</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCBSUBHORZ</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>cb_sub_horz</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCBSUBVERT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>cb_sub_vert</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>chroma_siting_horz</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_COLOUR_CHROMASITINGHORZ_UNDETERMINED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>chroma_siting_vert</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_COLOUR_CHROMASITINGVERT_UNDETERMINED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORRANGE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AVCOL_RANGE_UNSPECIFIED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORTRANSFERCHARACTERISTICS</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>transfer_characteristics</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORPRIMARIES</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>primaries</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AVCOL_PRI_UNSPECIFIED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORMAXCLL</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>max_cll</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORMAXFALL</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>max_fall</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORMASTERINGMETA</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>, <argument><expr><name>mastering_meta</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_mastering_meta</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_video</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_video_projection</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTIONTYPE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoProjection</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_VIDEO_PROJECTION_TYPE_RECTANGULAR</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTIONPRIVATE</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideoProjection</argument>, <argument>private</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTIONPOSEYAW</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoProjection</name></expr></argument>, <argument><expr><name>yaw</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><literal type="number">0.0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTIONPOSEPITCH</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoProjection</name></expr></argument>, <argument><expr><name>pitch</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><literal type="number">0.0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTIONPOSEROLL</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideoProjection</name></expr></argument>, <argument><expr><name>roll</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name><operator>=</operator><literal type="number">0.0</literal></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_video</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_video</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOFRAMERATE</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideo</argument>, <argument>frame_rate</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEODISPLAYWIDTH</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>display_width</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEODISPLAYHEIGHT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>display_height</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELWIDTH</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideo</argument>, <argument>pixel_width</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELHEIGHT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideo</argument>, <argument>pixel_height</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLORSPACE</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideo</argument>, <argument>color_space</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOALPHAMODE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackVideo</argument>, <argument>alpha_mode</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOCOLOR</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTrackVideoColor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_video_color</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPROJECTION</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>projection</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_video_projection</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELCROPB</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELCROPT</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELCROPL</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOPIXELCROPR</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEODISPLAYUNIT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>display_unit</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name><operator>=</operator> <name>MATROSKA_VIDEO_DISPLAYUNIT_PIXELS</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOFLAGINTERLACED</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>interlaced</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_VIDEO_INTERLACE_FLAG_UNDETERMINED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOFIELDORDER</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>field_order</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_VIDEO_FIELDORDER_UNDETERMINED</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOSTEREOMODE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackVideo</name></expr></argument>, <argument><expr><name>stereo_mode</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>MATROSKA_VIDEO_STEREOMODE_TYPE_NB</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_VIDEOASPECTRATIO</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_audio</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_AUDIOSAMPLINGFREQ</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackAudio</name></expr></argument>, <argument><expr><name>samplerate</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name> <operator>=</operator> <literal type="number">8000.0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_AUDIOOUTSAMPLINGFREQ</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackAudio</argument>, <argument>out_samplerate</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_AUDIOBITDEPTH</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackAudio</argument>, <argument>bitdepth</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_AUDIOCHANNELS</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackAudio</name></expr></argument>, <argument><expr><name>channels</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_encoding_compression</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGCOMPALGO</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackCompression</name></expr></argument>, <argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGCOMPSETTINGS</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackCompression</argument>, <argument>settings</argument>)</argument_list></macro> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_encoding</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_encoding_encryption</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGENCALGO</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackEncryption</name></expr></argument>,<argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr>, <expr><block>{<expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGENCKEYID</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackEncryption</argument>,<argument>key_id</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGENCAESSETTINGS</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGSIGALGO</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGSIGHASHALGO</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGSIGKEYID</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGSIGNATURE</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_encoding</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_encoding</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGSCOPE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackEncoding</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGTYPE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackEncoding</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGCOMPRESSION</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackEncoding</name></expr></argument>, <argument><expr><name>compression</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_encoding_compression</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGENCRYPTION</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackEncoding</name></expr></argument>, <argument><expr><name>encryption</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_encoding_encryption</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ENCODINGORDER</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_encodings</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_encodings</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKCONTENTENCODING</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTrackEncoding</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>encodings</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_encoding</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_plane</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKPLANEUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackPlane</argument>,<argument>uid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKPLANETYPE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrackPlane</argument>,<argument>type</argument>)</argument_list></macro> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_combine_planes</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_combine_planes</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKPLANE</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTrackPlane</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrackOperation</name></expr></argument>,<argument><expr><name>combine_planes</name></expr></argument>)</argument_list></call></expr>, <expr><block>{<expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_plane</name></expr>}</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track_operation</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track_operation</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKCOMBINEPLANES</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{<expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_combine_planes</name></expr>}</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_track</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_track</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKNUMBER</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>num</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKNAME</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>name</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>uid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKTYPE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>type</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECID</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>codec_id</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECPRIVATE</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>codec_priv</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECDELAY</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>codec_delay</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKLANGUAGE</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>language</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>s</name> <operator>=</operator> <literal type="string">"eng"</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKDEFAULTDURATION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>default_duration</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKTIMECODESCALE</name></expr>, <expr><name>EBML_FLOAT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>time_scale</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>f</name> <operator>=</operator> <literal type="number">1.0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKFLAGDEFAULT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>flag_default</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKFLAGFORCED</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>flag_forced</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKVIDEO</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>video</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_video</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKAUDIO</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>audio</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_audio</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKOPERATION</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_operation</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKCONTENTENCODINGS</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track_encodings</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKMAXBLKADDID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>max_block_additional_id</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SEEKPREROLL</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTrack</argument>, <argument>seek_preroll</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKFLAGENABLED</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKFLAGLACING</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECNAME</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECDECODEALL</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECINFOURL</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECDOWNLOADURL</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKMINCACHE</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKMAXCACHE</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_tracks</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_tracks</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TRACKENTRY</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTrack</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>tracks</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_track</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_attachment</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_FILEUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaAttachment</argument>, <argument>uid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_FILENAME</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaAttachment</argument>, <argument>filename</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_FILEMIMETYPE</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaAttachment</argument>, <argument>mime</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_FILEDATA</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaAttachment</argument>, <argument>bin</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_FILEDESC</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_attachments</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_attachments</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_ATTACHEDFILE</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaAttachment</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>attachments</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_attachment</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_chapter_display</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CHAPSTRING</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaChapter</argument>, <argument>title</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPLANG</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPCOUNTRY</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_chapter_entry</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_chapter_entry</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERTIMESTART</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaChapter</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERTIMEEND</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaChapter</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaChapter</argument>, <argument>uid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERDISPLAY</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_chapter_display</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERFLAGHIDDEN</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERFLAGENABLED</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERPHYSEQUIV</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERATOM</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_chapter</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_chapter</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERATOM</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaChapter</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>chapters</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_chapter_entry</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_EDITIONUID</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_EDITIONFLAGHIDDEN</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_EDITIONFLAGDEFAULT</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_EDITIONFLAGORDERED</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_chapters</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_chapters</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_EDITIONENTRY</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_chapter</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_index_pos</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CUETRACK</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaIndexPos</argument>, <argument>track</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUECLUSTERPOSITION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaIndexPos</argument>, <argument>pos</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUERELATIVEPOSITION</name></expr>,<expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUEDURATION</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUEBLOCKNUMBER</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_index_entry</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_index_entry</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CUETIME</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaIndex</argument>, <argument>time</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUETRACKPOSITION</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaIndexPos</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaIndex</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_index_pos</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_index</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_index</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_POINTENTRY</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaIndex</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_index_entry</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_simpletag</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TAGNAME</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTag</argument>, <argument>name</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGSTRING</name></expr>, <expr><name>EBML_UTF8</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTag</argument>, <argument>string</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGLANG</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTag</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>s</name> <operator>=</operator> <literal type="string">"und"</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGDEFAULT</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTag</argument>, <argument>def</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGDEFAULT_BUG</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTag</argument>, <argument>def</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SIMPLETAG</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTag</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTag</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_simpletag</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_tag</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_tagtargets</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS_TYPE</name></expr>, <expr><name>EBML_STR</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTagTarget</argument>, <argument>type</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS_TYPEVALUE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTagTarget</name></expr></argument>, <argument><expr><name>typevalue</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">50</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS_TRACKUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTagTarget</argument>, <argument>trackuid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS_CHAPTERUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTagTarget</argument>, <argument>chapteruid</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS_ATTACHUID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaTagTarget</argument>, <argument>attachuid</argument>)</argument_list></macro> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_tag</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_tag</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_SIMPLETAG</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTag</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTags</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_simpletag</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGTARGETS</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaTags</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_tagtargets</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_tags</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_tags</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_TAG</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaTags</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_tag</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_seekhead_entry</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_SEEKID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaSeekhead</argument>, <argument>id</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SEEKPOSITION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaSeekhead</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_seekhead</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_seekhead</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_SEEKENTRY</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaSeekhead</name></expr></argument>)</argument_list></sizeof></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>, <argument><expr><name>seekhead</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_seekhead_entry</name></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_segment</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CLUSTER</name></expr>, <expr><name>EBML_STOP</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_INFO</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_info</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TRACKS</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_tracks</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_ATTACHMENTS</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_attachments</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CHAPTERS</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_chapters</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CUES</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_index</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_TAGS</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_tags</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SEEKHEAD</name></expr>, <expr><name>EBML_LEVEL1</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_seekhead</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr> 
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_segments</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_SEGMENT</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_segment</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_blockmore</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKADDID</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaBlock</name></expr></argument>,<argument><expr><name>additional_id</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKADDITIONAL</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaBlock</argument>,<argument>additional</argument>)</argument_list></macro> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_blockadditions</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_blockadditions</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKMORE</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{<expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_blockmore</name></expr>}</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_blockgroup</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_blockgroup</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_BLOCK</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaBlock</argument>, <argument>bin</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKADDITIONS</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_blockadditions</name></expr>}</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKDURATION</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaBlock</argument>, <argument>duration</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_DISCARDPADDING</name></expr>, <expr><name>EBML_SINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaBlock</argument>, <argument>discard_padding</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKREFERENCE</name></expr>, <expr><name>EBML_SINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaBlock</name></expr></argument>, <argument><expr><name>reference</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>i</name> <operator>=</operator> <name>INT64_MIN</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CODECSTATE</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MatroskaBlock</name></expr></argument>, <argument><expr><name>non_simple</name></expr></argument>)</argument_list></call></expr>, <expr><block>{ <expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_cluster_parsing</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_cluster_parsing</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_SIMPLEBLOCK</name></expr>, <expr><name>EBML_BIN</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaBlock</argument>, <argument>bin</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKGROUP</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <name>matroska_blockgroup</name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CLUSTERTIMECODE</name></expr>, <expr><name>EBML_UINT</name></expr>, <expr><literal type="number">0</literal></expr>, <macro><name>offsetof</name><argument_list>(<argument>MatroskaCluster</argument>, <argument>timecode</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_SIMPLEBLOCK</name></expr>, <expr><name>EBML_STOP</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_BLOCKGROUP</name></expr>, <expr><name>EBML_STOP</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CLUSTERPOSITION</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><name>MATROSKA_ID_CLUSTERPREVSIZE</name></expr>, <expr><name>EBML_NONE</name></expr> }</block></expr>,
<macro><name>CHILD_OF</name><argument_list>(<argument>matroska_segment</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EbmlSyntax</name></type> <name><name>matroska_cluster_enter</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>MATROSKA_ID_CLUSTER</name></expr>, <expr><name>EBML_NEST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{ <expr><operator>.</operator><name>n</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska_cluster_parsing</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> }</block></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHILD_OF</name></cpp:undef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>matroska_doctypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"matroska"</literal></expr>, <expr><literal type="string">"webm"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>matroska_read_close</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_reset_status</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>position</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>position</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>err</name> <init>= <expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>position</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>unknown_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>-=</operator> <operator>(</operator><call><name>av_log2</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_resync</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>last_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>last_pos</name> <operator>&lt;</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>avio_seek</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>last_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Seek to desired resync point failed. Seeking to "</literal>
<literal type="string">"earliest point available instead.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><call><name>FFMAX</name><argument_list>(<argument><expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name><name>pb</name><operator>-&gt;</operator><name>buffer</name></name> <operator>-</operator> <name><name>pb</name><operator>-&gt;</operator><name>buf_ptr</name></name><operator>)</operator></expr></argument>,
<argument><expr><name>last_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>MATROSKA_ID_INFO</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>MATROSKA_ID_TRACKS</name> <operator>||</operator>
<name>id</name> <operator>==</operator> <name>MATROSKA_ID_CUES</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>MATROSKA_ID_TAGS</name> <operator>||</operator>
<name>id</name> <operator>==</operator> <name>MATROSKA_ID_SEEKHEAD</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>MATROSKA_ID_ATTACHMENTS</name> <operator>||</operator>
<name>id</name> <operator>==</operator> <name>MATROSKA_ID_CLUSTER</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>MATROSKA_ID_CHAPTERS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>id</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr> ?</condition><then> <expr><name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr> </then><else>: <expr><name>AVERROR_EOF</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_num</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>max_size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eof_forbidden</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>read</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name></decl>;</decl_stmt>


<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name>read</name> <operator>=</operator> <literal type="number">8</literal> <operator>-</operator> <name><name>ff_log2_tab</name><index>[<expr><name>total</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>total</name> <operator>||</operator> <name>read</name> <operator>&gt;</operator> <name>max_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>total</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"0x00 at pos %"</literal><name>PRId64</name><literal type="string">" (0x%"</literal><name>PRIx64</name><literal type="string">") invalid as first byte "</literal>
<literal type="string">"of an EBML number\n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Length %d indicated by an EBML number's first byte 0x%02x "</literal>
<literal type="string">"at pos %"</literal><name>PRId64</name><literal type="string">" (0x%"</literal><name>PRIx64</name><literal type="string">") exceeds max length %d.\n"</literal></expr></argument>,
<argument><expr><name>read</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name>total</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>total</name> <operator>^=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ff_log2_tab</name><index>[<expr><name>total</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name><operator>++</operator> <operator>&lt;</operator> <name>read</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>total</name> <operator>=</operator> <operator>(</operator><name>total</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eof_forbidden</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>number</name> <operator>=</operator> <name>total</name></expr>;</expr_stmt>

<return>return <expr><name>read</name></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Read error at pos. %"</literal><name>PRIu64</name><literal type="string">" (0x%"</literal><name>PRIx64</name><literal type="string">")\n"</literal></expr></argument>,
<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eof_forbidden</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"File ended prematurely "</literal>
<literal type="string">"at pos. %"</literal><name>PRIu64</name><literal type="string">" (0x%"</literal><name>PRIx64</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EIO</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>AVERROR_EOF</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_length</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>number</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>*</operator> <name>res</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>number</name> <operator>=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_uint</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name><operator>++</operator> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>num</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>NEEDS_CHECKING</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_sint</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>sign_extend</name><argument_list>(<argument><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><name>n</name><operator>++</operator> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>*</operator><name>num</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>NEEDS_CHECKING</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_float</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>av_int2float</name><argument_list>(<argument><expr><call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>av_int2double</name><argument_list>(<argument><expr><call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></else></if_stmt>

<return>return <expr><name>NEEDS_CHECKING</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_ascii</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>res</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ret</name></expr> </then><else>: <expr><name>NEEDS_CHECKING</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>res</name><operator>)</operator><index>[<expr><name>size</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_binary</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>EbmlBin</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_buffer_realloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>length</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>length</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ret</name></expr> </then><else>: <expr><name>NEEDS_CHECKING</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_read_master</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaLevel</name> <modifier>*</modifier></type><name>level</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>&gt;=</operator> <name>EBML_MAX_DEPTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"File moves beyond max. allowed depth (%d)\n"</literal></expr></argument>, <argument><expr><name>EBML_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOSYS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>level</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>level</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>level</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_ebmlnum_sint</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>unum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>unum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <name>unum</name> <operator>-</operator> <operator>(</operator><operator>(</operator><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>*</operator> <name>res</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ebml_parse</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>EbmlSyntax</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>EbmlSyntax</name> <modifier>*</modifier></type><name>ebml_parse_id</name><parameter_list>(<parameter><decl><type><name>EbmlSyntax</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><operator>&amp;</operator><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_parse_nest</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>EbmlSyntax</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<switch>switch <condition>(<expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EBML_UINT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_offset</name><operator>)</operator> <operator>=</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_SINT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_offset</name><operator>)</operator> <operator>=</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_FLOAT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_offset</name><operator>)</operator> <operator>=</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_STR</name></expr>:</case>
<case>case <expr><name>EBML_UTF8</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>s</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>dst</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <call><name>av_strdup</name><argument_list>(<argument><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>syntax</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>;</do>

<return>return <expr><ternary><condition><expr><name>res</name> <operator>==</operator> <name>LEVEL_ENDED</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>res</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_ebml_id_valid</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bits</name> <init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>id</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bits</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal> <operator>==</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>bits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>MatroskaLevel1Element</name> <modifier>*</modifier></type><name>matroska_find_level1_elem</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaLevel1Element</name> <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ebml_id_valid</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>MATROSKA_ID_CLUSTER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <name>MATROSKA_ID_SEEKHEAD</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>num_level1_elems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>level1_elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>level1_elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_level1_elems</name></name> <operator>&gt;=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>level1_elems</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too many level1 elements or circular seekheads.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>level1_elems</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_level1_elems</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>elem</name> <operator>=</operator> <operator>(</operator><name>MatroskaLevel1Element</name><operator>)</operator><block>{<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>id</name></expr>}</block></expr>;</expr_stmt>

<return>return <expr><name>elem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ebml_parse</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>EbmlSyntax</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>max_lengths</name><index>[<expr><name>EBML_TYPE_COUNT</name></expr>]</index></name> <init>= <expr><block>{

<expr><index>[<expr><name>EBML_NONE</name></expr>]</index> <operator>=</operator> <name>EBML_UNKNOWN_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>EBML_UINT</name></expr>]</index> <operator>=</operator> <literal type="number">8</literal></expr>,
<expr><index>[<expr><name>EBML_SINT</name></expr>]</index> <operator>=</operator> <literal type="number">8</literal></expr>,
<expr><index>[<expr><name>EBML_FLOAT</name></expr>]</index> <operator>=</operator> <literal type="number">8</literal></expr>,

<expr><index>[<expr><name>EBML_STR</name></expr>]</index> <operator>=</operator> <literal type="number">0x1000000</literal></expr>,
<expr><index>[<expr><name>EBML_UTF8</name></expr>]</index> <operator>=</operator> <literal type="number">0x1000000</literal></expr>,

<expr><index>[<expr><name>EBML_BIN</name></expr>]</index> <operator>=</operator> <literal type="number">0x10000000</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>pos_alt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>update_pos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>level_check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaLevel1Element</name> <modifier>*</modifier></type><name>level1_elem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaLevel</name> <modifier>*</modifier></type><name>level</name> <init>= <expr><ternary><condition><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>&amp;&amp;</operator> <name>res</name> <operator>==</operator> <name>AVERROR_EOF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>is_live</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>==</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>level</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>LEVEL_ENDED</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"File ended prematurely "</literal>
<literal type="string">"at pos. %"</literal><name>PRIu64</name><literal type="string">" (0x%"</literal><name>PRIx64</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name> <operator>=</operator> <name>id</name> <operator>|</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">7</literal> <operator>*</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos_alt</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <name>res</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pos_alt</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>-=</operator> <operator>(</operator><call><name>av_log2</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>syntax</name> <operator>=</operator> <call><name>ebml_parse_id</name><argument_list>(<argument><expr><name>syntax</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>syntax</name><operator>-&gt;</operator><name>id</name></name> <operator>&amp;&amp;</operator> <name>id</name> <operator>!=</operator> <name>EBML_ID_VOID</name> <operator>&amp;&amp;</operator> <name>id</name> <operator>!=</operator> <name>EBML_ID_CRC32</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&amp;&amp;</operator> <name><name>level</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>


<while>while <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>def</name><operator>.</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>syntax</name> <operator>=</operator> <call><name>ebml_parse_id</name><argument_list>(<argument><expr><name><name>syntax</name><operator>-&gt;</operator><name>def</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>LEVEL_ENDED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Unknown entry 0x%"</literal><name>PRIX32</name><literal type="string">" at pos. "</literal>
<literal type="string">"%"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>update_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><operator>-&gt;</operator><name>data_offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>list_elem_size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>newelem</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>UINT_MAX</name> <operator>/</operator> <name><name>syntax</name><operator>-&gt;</operator><name>list_elem_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newelem</name> <operator>=</operator> <call><name>av_fast_realloc</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>alloc_elem_size</name></name></expr></argument>,
<argument><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>syntax</name><operator>-&gt;</operator><name>list_elem_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newelem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <name>newelem</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>list</name><operator>-&gt;</operator><name>elem</name></name> <operator>+</operator> <name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>*</operator> <name><name>syntax</name><operator>-&gt;</operator><name>list_elem_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>syntax</name><operator>-&gt;</operator><name>list_elem_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EBML_STOP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>ebml_read_length</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos_alt</name> <operator>+=</operator> <name>res</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name> <operator>&amp;&amp;</operator>
<name><name>level</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>elem_end</name> <init>= <expr><name>pos_alt</name> <operator>+</operator> <name>length</name></expr></init></decl>,
<decl><type ref="prev"/><name>level_end</name> <init>= <expr><name><name>level</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>level</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elem_end</name> <operator>&lt;</operator> <name>level_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level_check</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>elem_end</name> <operator>==</operator> <name>level_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level_check</name> <operator>=</operator> <name>LEVEL_ENDED</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Element at 0x%"</literal><name>PRIx64</name><literal type="string">" ending at 0x%"</literal><name>PRIx64</name><literal type="string">" exceeds "</literal>
<literal type="string">"containing master element ending at 0x%"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>elem_end</name></expr></argument>, <argument><expr><name>level_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>length</name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level_check</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>level</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown-sized element "</literal>
<literal type="string">"at 0x%"</literal><name>PRIx64</name><literal type="string">" inside parent with finite size\n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>level_check</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <name>MATROSKA_ID_CLUSTER</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EBML_LEVEL1</name>
<operator>||</operator> <name><name>syntax</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EBML_NEST</name><operator>)</operator></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Found unknown-length element 0x%"</literal><name>PRIX32</name><literal type="string">" other than "</literal>
<literal type="string">"a cluster at 0x%"</literal><name>PRIx64</name><literal type="string">". Spec-incompliant, but "</literal>
<literal type="string">"parsing will nevertheless be attempted.\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>update_pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>level_check</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>max_lengths</name><index>[<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <name><name>max_lengths</name><index>[<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid length 0x%"</literal><name>PRIx64</name><literal type="string">" &gt; 0x%"</literal><name>PRIx64</name><literal type="string">" for element "</literal>
<literal type="string">"with ID 0x%"</literal><name>PRIX32</name><literal type="string">" at 0x%"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>max_lengths</name><index>[<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>EBML_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Element with ID 0x%"</literal><name>PRIX32</name><literal type="string">" at pos. 0x%"</literal><name>PRIx64</name><literal type="string">" has "</literal>
<literal type="string">"unknown length, yet the length of an element of its "</literal>
<literal type="string">"type must be known.\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Found unknown-length element with ID 0x%"</literal><name>PRIX32</name><literal type="string">" at "</literal>
<literal type="string">"pos. 0x%"</literal><name>PRIx64</name><literal type="string">" for which no syntax for parsing is "</literal>
<literal type="string">"available.\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pb</name><operator>-&gt;</operator><name>seekable</name></name> <operator>&amp;</operator> <name>AVIO_SEEKABLE_NORMAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>





















<if_stmt><if>if <condition>(<expr><name>update_pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>unknown_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>dist</name> <init>= <expr><name>length</name> <operator>+</operator> <name>UNKNOWN_EQUIV</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>unknown_count</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>unknown_count</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dist</name> <operator>+=</operator> <name>pos_alt</name> <operator>-</operator> <name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dist</name> <operator>&gt;</operator> <name>SKIP_THRESHOLD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Unknown element %"</literal><name>PRIX32</name><literal type="string">" at pos. 0x%"</literal><name>PRIx64</name><literal type="string">" with "</literal>
<literal type="string">"length 0x%"</literal><name>PRIx64</name><literal type="string">" considered as invalid data. Last "</literal>
<literal type="string">"known good position 0x%"</literal><name>PRIx64</name><literal type="string">", %d unknown elements"</literal>
<literal type="string">" in a row\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name></expr></argument>,
<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>unknown_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>update_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>!=</operator> <name>EBML_UNKNOWN_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>skip</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EBML_UINT</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_uint</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_SINT</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_sint</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_FLOAT</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_float</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_STR</name></expr>:</case>
<case>case <expr><name>EBML_UTF8</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_ascii</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_BIN</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_read_binary</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>pos_alt</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_LEVEL1</name></expr>:</case>
<case>case <expr><name>EBML_NEST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>ebml_read_master</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>pos_alt</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>MATROSKA_ID_SEGMENT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name> <operator>=</operator> <name>pos_alt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>MATROSKA_ID_CUES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>syntax</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>EBML_LEVEL1</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>level1_elem</name> <operator>=</operator> <call><name>matroska_find_level1_elem</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>syntax</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>level1_elem</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>level1_elem</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>level1_elem</name><operator>-&gt;</operator><name>pos</name></name> <operator>!=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Duplicate element\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>level1_elem</name><operator>-&gt;</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>=</operator> <call><name>ebml_parse_nest</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>syntax</name><operator>-&gt;</operator><name>def</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>EBML_STOP</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>skip</name>:</label>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>length</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>res2</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ffio_limit</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>length</name></expr>)</condition> <block>{<block_content>


<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EIO</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res2</name> <operator>=</operator> <call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NEEDS_CHECKING</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NEEDS_CHECKING</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pb</name><operator>-&gt;</operator><name>error</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>AVERROR_EOF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<goto>goto <name>level_check</name>;</goto></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AVERROR_INVALIDDATA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid element\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>EIO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>AVERROR_EOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"File ended prematurely\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>EIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<label><name>level_check</name>:</label>
<if_stmt><if>if <condition>(<expr><name>level_check</name> <operator>==</operator> <name>LEVEL_ENDED</name> <operator>&amp;&amp;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<while>while <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>==</operator> <name><name>level</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>level</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>level_check</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ebml_free</name><parameter_list>(<parameter><decl><type><name>EbmlSyntax</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data_off</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data_offset</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EBML_STR</name></expr>:</case>
<case>case <expr><name>EBML_UTF8</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>data_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_BIN</name></expr>:</case>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>EbmlBin</name> <operator>*</operator><operator>)</operator> <name>data_off</name><operator>)</operator><operator>-&gt;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EBML_LEVEL1</name></expr>:</case>
<case>case <expr><name>EBML_NEST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>list_elem_size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>data_off</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition>
<incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name> <operator>+=</operator> <name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>list_elem_size</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>alloc_elem_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name><name>syntax</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>def</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>data_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_probe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AVProbeData</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len_mask</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>AV_RB32</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EBML_ID_HEADER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>total</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>total</name> <operator>&amp;</operator> <name>len_mask</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len_mask</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>total</name> <operator>&amp;=</operator> <operator>(</operator><name>len_mask</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>total</name> <operator>=</operator> <operator>(</operator><name>total</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>n</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>total</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>*</operator> <name>size</name><operator>)</operator></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>total</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>-</operator> <literal type="number">4</literal> <operator>-</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>+</operator> <name>size</name> <operator>+</operator> <name>total</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>matroska_doctypes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>probelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>matroska_doctypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>total</name> <operator>&lt;</operator> <name>probelen</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <name>size</name></expr>;</init> <condition><expr><name>n</name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>+</operator> <name>size</name> <operator>+</operator> <name>total</name> <operator>-</operator> <name>probelen</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name><name>matroska_doctypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>probelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVPROBE_SCORE_MAX</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></for>


<return>return <expr><name>AVPROBE_SCORE_EXTENSION</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MatroskaTrack</name> <modifier>*</modifier></type><name>matroska_find_track_by_num</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>num</name> <operator>==</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid track number %"</literal><name>PRIu64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_decode_buffer</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>buf_size</name></decl></parameter>,
<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrackEncoding</name> <modifier>*</modifier></type><name>encodings</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>encodings</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>*</operator><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>isize</name> <init>= <expr><operator>*</operator><name>buf_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pkt_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <name>av_unused</name> <modifier>*</modifier></type><name>newpktdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pkt_size</name> <init>= <expr><name>isize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>olen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pkt_size</name> <operator>&gt;=</operator> <literal type="number">10000000U</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>algo</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>header_size</name> <init>= <expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>settings</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>settings</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>header_size</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>header</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Compression size but no data in headerstrip\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>header_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pkt_size</name> <operator>=</operator> <name>isize</name> <operator>+</operator> <name>header_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>pkt_size</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pkt_data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pkt_data</name> <operator>+</operator> <name>header_size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>isize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_LZO</name></expr></cpp:if>
<case>case <expr><name>MATROSKA_TRACK_ENCODING_COMP_LZO</name></expr>:</case>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>insize</name> <init>= <expr><name>isize</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>olen</name> <operator>=</operator> <name>pkt_size</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>newpktdata</name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name>pkt_size</name> <operator>+</operator> <name>AV_LZO_OUTPUT_PADDING</name>
<operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newpktdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <name>newpktdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>av_lzo1x_decode</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>result</name> <operator>==</operator> <name>AV_LZO_OUTPUT_FULL</name> <operator>&amp;&amp;</operator> <name>pkt_size</name> <operator>&lt;</operator> <literal type="number">10000000</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pkt_size</name> <operator>-=</operator> <name>olen</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_ZLIB</name></expr></cpp:if>
<case>case <expr><name>MATROSKA_TRACK_ENCODING_COMP_ZLIB</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>z_stream</name></type> <name>zstream</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>inflateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstream</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zstream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>isize</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>pkt_size</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>newpktdata</name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name>pkt_size</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newpktdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <name>newpktdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>pkt_size</name> <operator>-</operator> <name><name>zstream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>pkt_data</name> <operator>+</operator> <name><name>zstream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstream</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>result</name> <operator>==</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name>pkt_size</name> <operator>&lt;</operator> <literal type="number">10000000</literal></expr>)</condition>;</do>
<expr_stmt><expr><name>pkt_size</name> <operator>=</operator> <name><name>zstream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Z_MEM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_BZLIB</name></expr></cpp:if>
<case>case <expr><name>MATROSKA_TRACK_ENCODING_COMP_BZLIB</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>bz_stream</name></type> <name>bzstream</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bzstream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>bzstream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzstream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>isize</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>pkt_size</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>newpktdata</name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name>pkt_size</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newpktdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bzstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <name>newpktdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzstream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>pkt_size</name> <operator>-</operator> <name><name>bzstream</name><operator>.</operator><name>total_out_lo32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bzstream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>pkt_data</name> <operator>+</operator> <name><name>bzstream</name><operator>.</operator><name>total_out_lo32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bzstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>result</name> <operator>==</operator> <name>BZ_OK</name> <operator>&amp;&amp;</operator> <name>pkt_size</name> <operator>&lt;</operator> <literal type="number">10000000</literal></expr>)</condition>;</do>
<expr_stmt><expr><name>pkt_size</name> <operator>=</operator> <name><name>bzstream</name><operator>.</operator><name>total_out_lo32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bzstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BZ_STREAM_END</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BZ_MEM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>failed</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pkt_data</name> <operator>+</operator> <name>pkt_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>pkt_data</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buf_size</name> <operator>=</operator> <name>pkt_size</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>failed</name>:</label>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_convert_tag</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
<parameter><decl><type><name>AVDictionary</name> <modifier>*</modifier><modifier>*</modifier></type><name>metadata</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTag</name> <modifier>*</modifier></type><name>tags</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lang</name> <init>= <expr><ternary><condition><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lang</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lang</name></expr></argument>, <argument><expr><literal type="string">"und"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lang</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Skipping invalid tag with no TagName.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_strlcpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>def</name> <operator>||</operator> <operator>!</operator><name>lang</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>sub</name><operator>.</operator><name>nb_elem</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sub</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lang</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_strlcat</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_strlcat</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>sub</name><operator>.</operator><name>nb_elem</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sub</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ff_metadata_conv</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ff_mkv_metadata_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_convert_tags</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTags</name> <modifier>*</modifier></type><name>tags</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tags</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tags</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>attachuid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaAttachment</name> <modifier>*</modifier></type><name>attachment</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>attachments</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>attachments</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>attachment</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>==</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>attachuid</name></name> <operator>&amp;&amp;</operator>
<name><name>attachment</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>stream</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>attachment</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>stream</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"The tags at index %d refer to a "</literal>
<literal type="string">"non-existent attachment %"</literal><name>PRId64</name><literal type="string">".\n"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>attachuid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>chapteruid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaChapter</name> <modifier>*</modifier></type><name>chapter</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>chapters</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>chapters</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>chapter</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>==</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>chapteruid</name></name> <operator>&amp;&amp;</operator>
<name><name>chapter</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>chapter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>chapter</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>chapter</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"The tags at index %d refer to a non-existent chapter "</literal>
<literal type="string">"%"</literal><name>PRId64</name><literal type="string">".\n"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>chapteruid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>trackuid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>==</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>trackuid</name></name> <operator>&amp;&amp;</operator>
<name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>stream</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>stream</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"The tags at index %d refer to a non-existent track "</literal>
<literal type="string">"%"</literal><name>PRId64</name><literal type="string">".\n"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>trackuid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>matroska_convert_tag</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>,
<argument><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>target</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_seekhead_entry</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>saved_id</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>before_pos</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pos</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>==</operator> <name>EBML_MAX_DEPTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"Max EBML element depth (%d) reached, "</literal>
<literal type="string">"cannot parse further.\n"</literal></expr></argument>, <argument><expr><name>EBML_MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>levels</name><index>[<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>MatroskaLevel</name><operator>)</operator> <block>{ <expr><literal type="number">0</literal></expr>, <expr><name>EBML_UNKNOWN_LENGTH</name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_segment</name></expr></argument>, <argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>LEVEL_ENDED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_EOF</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>saved_id</name></expr></argument>, <argument><expr><name>before_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_execute_seekhead</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>seekhead_list</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>seekhead</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name><operator>-&gt;</operator><name>seekable</name></name> <operator>&amp;</operator> <name>AVIO_SEEKABLE_NORMAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seekhead_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaSeekhead</name> <modifier>*</modifier></type><name>seekheads</name> <init>= <expr><name><name>seekhead_list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name> <init>= <expr><name><name>seekheads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name> <init>= <expr><name><name>seekheads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>+</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MatroskaLevel1Element</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>matroska_find_level1_elem</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elem</name> <operator>||</operator> <name><name>elem</name><operator>-&gt;</operator><name>parsed</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>MATROSKA_ID_CUES</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>matroska_parse_seekhead_entry</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_add_index_entries</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>index_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaIndex</name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>index_scale</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AVFMT_FLAG_IGNIDX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>index_list</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>index_list</name><operator>-&gt;</operator><name>elem</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>index_list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>index</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>time</name> <operator>&gt;</operator> <literal type="number">1E14</literal> <operator>/</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Dropping apparently-broken index.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>pos_list</name> <init>= <expr><operator>&amp;</operator><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaIndexPos</name> <modifier>*</modifier></type><name>pos</name> <init>= <expr><name><name>pos_list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pos_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><call><name>matroska_find_track_by_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>,
<argument><expr><name><name>pos</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>track</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>track</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>stream</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_add_index_entry</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>,
<argument><expr><name><name>pos</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>+</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr></argument>,
<argument><expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>/</operator> <name>index_scale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>AVINDEX_KEYFRAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_parse_cues</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AVFMT_FLAG_IGNIDX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>num_level1_elems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaLevel1Element</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>level1_elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>MATROSKA_ID_CUES</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>elem</name><operator>-&gt;</operator><name>parsed</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>matroska_parse_seekhead_entry</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>matroska_add_index_entries</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_aac_profile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>codec_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>aac_profiles</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"MAIN"</literal></expr>, <expr><literal type="string">"LC"</literal></expr>, <expr><literal type="string">"SSR"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>profile</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>profile</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>profile</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>aac_profiles</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>profile</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>codec_id</name></expr></argument>, <argument><expr><name><name>aac_profiles</name><index>[<expr><name>profile</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>profile</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_aac_sri</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>samplerate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sri</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>sri</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sri</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>avpriv_mpeg4audio_sample_rates</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sri</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>avpriv_mpeg4audio_sample_rates</name><index>[<expr><name>sri</name></expr>]</index></name> <operator>==</operator> <name>samplerate</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>sri</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_metadata_creation_time</name><parameter_list>(<parameter><decl><type><name>AVDictionary</name> <modifier>*</modifier><modifier>*</modifier></type><name>metadata</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>date_utc</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>avpriv_dict_set_timestamp</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"creation_time"</literal></expr></argument>, <argument><expr><name>date_utc</name> <operator>/</operator> <literal type="number">1000</literal> <operator>+</operator> <literal type="number">978307200000000LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_flac</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>stream</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">8</literal> <operator>+</operator> <name>FLAC_STREAMINFO_SIZE</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Invalid FLAC private data\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name>FLAC_STREAMINFO_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>block_last</name></decl>, <decl><type ref="prev"/><name>block_type</name></decl>, <decl><type ref="prev"/><name>block_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>flac_parse_block_header</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block_last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_size</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>block_type</name> <operator>==</operator> <name>FLAC_METADATA_TYPE_VORBIS_COMMENT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVDictionary</name> <modifier>*</modifier></type><name>dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVDictionaryEntry</name> <modifier>*</modifier></type><name>chmask</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_vorbis_comment</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dict</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>block_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>chmask</name> <operator>=</operator> <call><name>av_dict_get</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"WAVEFORMATEXTENSIBLE_CHANNEL_MASK"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chmask</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>mask</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name><name>chmask</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mask</name> <operator>||</operator> <name>mask</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3ffffULL</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid value of WAVEFORMATEXTENSIBLE_CHANNEL_MASK\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channel_layout</name></name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>block_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>block_size</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mkv_field_order</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>field_order</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>major</name></decl>, <decl><type ref="prev"/><name>minor</name></decl>, <decl><type ref="prev"/><name>micro</name></decl>, <decl><type ref="prev"/><name>bttb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>muxingapp</name></name> <operator>&amp;&amp;</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>muxingapp</name></name></expr></argument>, <argument><expr><literal type="string">"Lavf%d.%d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>major</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>micro</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bttb</name> <operator>=</operator> <operator>(</operator><name>major</name> <operator>==</operator> <literal type="number">57</literal> <operator>&amp;&amp;</operator> <name>minor</name> <operator>&gt;=</operator> <literal type="number">36</literal> <operator>&amp;&amp;</operator> <name>minor</name> <operator>&lt;=</operator> <literal type="number">51</literal> <operator>&amp;&amp;</operator> <name>micro</name> <operator>&gt;=</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>field_order</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_PROGRESSIVE</name></expr>:</case>
<return>return <expr><name>AV_FIELD_PROGRESSIVE</name></expr>;</return>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_UNDETERMINED</name></expr>:</case>
<return>return <expr><name>AV_FIELD_UNKNOWN</name></expr>;</return>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_TT</name></expr>:</case>
<return>return <expr><name>AV_FIELD_TT</name></expr>;</return>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_BB</name></expr>:</case>
<return>return <expr><name>AV_FIELD_BB</name></expr>;</return>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_BT</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>bttb</name></expr> ?</condition><then> <expr><name>AV_FIELD_TB</name></expr> </then><else>: <expr><name>AV_FIELD_BT</name></expr></else></ternary></expr>;</return>
<case>case <expr><name>MATROSKA_VIDEO_FIELDORDER_TB</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>bttb</name></expr> ?</condition><then> <expr><name>AV_FIELD_BT</name></expr> </then><else>: <expr><name>AV_FIELD_TB</name></expr></else></ternary></expr>;</return>
<default>default:</default>
<return>return <expr><name>AV_FIELD_UNKNOWN</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mkv_stereo_mode_display_mul</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stereo_mode</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>h_width</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>h_height</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>stereo_mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_MONO</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_CHECKERBOARD_RL</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_CHECKERBOARD_LR</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_BOTH_EYES_BLOCK_RL</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_BOTH_EYES_BLOCK_LR</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_RIGHT_LEFT</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_LEFT_RIGHT</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_COL_INTERLEAVED_RL</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_COL_INTERLEAVED_LR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>h_width</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_BOTTOM_TOP</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_TOP_BOTTOM</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_ROW_INTERLEAVED_RL</name></expr>:</case>
<case>case <expr><name>MATROSKA_VIDEO_STEREOMODE_TYPE_ROW_INTERLEAVED_LR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>h_height</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mkv_parse_video_color</name><parameter_list>(<parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>MatroskaTrackVideoColor</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>color</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MatroskaMasteringMeta</name> <modifier>*</modifier></type><name>mastering_meta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_mastering_primaries</name></decl>, <decl><type ref="prev"/><name>has_mastering_luminance</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>color</name><operator>.</operator><name>nb_elem</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mastering_meta</name> <operator>=</operator> <operator>&amp;</operator><name><name>color</name><operator>-&gt;</operator><name>mastering_meta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>has_mastering_primaries</name> <operator>=</operator>
<name><name>mastering_meta</name><operator>-&gt;</operator><name>r_x</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mastering_meta</name><operator>-&gt;</operator><name>r_y</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>mastering_meta</name><operator>-&gt;</operator><name>g_x</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mastering_meta</name><operator>-&gt;</operator><name>g_y</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>mastering_meta</name><operator>-&gt;</operator><name>b_x</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mastering_meta</name><operator>-&gt;</operator><name>b_y</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>mastering_meta</name><operator>-&gt;</operator><name>white_x</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mastering_meta</name><operator>-&gt;</operator><name>white_y</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>has_mastering_luminance</name> <operator>=</operator> <name><name>mastering_meta</name><operator>-&gt;</operator><name>max_luminance</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>matrix_coefficients</name></name> <operator>!=</operator> <name>AVCOL_SPC_RESERVED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>color_space</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>matrix_coefficients</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>primaries</name></name> <operator>!=</operator> <name>AVCOL_PRI_RESERVED</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>primaries</name></name> <operator>!=</operator> <name>AVCOL_PRI_RESERVED0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>color_primaries</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>primaries</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>transfer_characteristics</name></name> <operator>!=</operator> <name>AVCOL_TRC_RESERVED</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>transfer_characteristics</name></name> <operator>!=</operator> <name>AVCOL_TRC_RESERVED0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>transfer_characteristics</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>range</name></name> <operator>!=</operator> <name>AVCOL_RANGE_UNSPECIFIED</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>range</name></name> <operator>&lt;=</operator> <name>AVCOL_RANGE_JPEG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>color_range</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>range</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>chroma_siting_horz</name></name> <operator>!=</operator> <name>MATROSKA_COLOUR_CHROMASITINGHORZ_UNDETERMINED</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>chroma_siting_vert</name></name> <operator>!=</operator> <name>MATROSKA_COLOUR_CHROMASITINGVERT_UNDETERMINED</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>chroma_siting_horz</name></name> <operator>&lt;</operator> <name>MATROSKA_COLOUR_CHROMASITINGHORZ_NB</name> <operator>&amp;&amp;</operator>
<name><name>color</name><operator>-&gt;</operator><name>chroma_siting_vert</name></name> <operator>&lt;</operator> <name>MATROSKA_COLOUR_CHROMASITINGVERT_NB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>chroma_location</name></name> <operator>=</operator>
<call><name>avcodec_chroma_pos_to_enum</name><argument_list>(<argument><expr><operator>(</operator><name><name>color</name><operator>-&gt;</operator><name>chroma_siting_horz</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr></argument>,
<argument><expr><operator>(</operator><name><name>color</name><operator>-&gt;</operator><name>chroma_siting_vert</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>max_cll</name></name> <operator>&amp;&amp;</operator> <name><name>color</name><operator>-&gt;</operator><name>max_fall</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVContentLightMetadata</name> <modifier>*</modifier></type><name>metadata</name> <init>= <expr><call><name>av_content_light_metadata_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>metadata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_stream_add_side_data</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_CONTENT_LIGHT_LEVEL</name></expr></argument>,
<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>metadata</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxCLL</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>max_cll</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>MaxFALL</name></name> <operator>=</operator> <name><name>color</name><operator>-&gt;</operator><name>max_fall</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mastering_primaries</name> <operator>||</operator> <name>has_mastering_luminance</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVMasteringDisplayMetadata</name> <modifier>*</modifier></type><name>metadata</name> <init>=
<expr><operator>(</operator><name>AVMasteringDisplayMetadata</name><operator>*</operator><operator>)</operator> <call><name>av_stream_new_side_data</name><argument_list>(
<argument><expr><name>st</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_MASTERING_DISPLAY_METADATA</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AVMasteringDisplayMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>metadata</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AVMasteringDisplayMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mastering_primaries</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>r_x</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>r_y</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>g_x</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>g_y</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>b_x</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>display_primaries</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>b_y</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>white_x</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>white_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>white_y</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>has_primaries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mastering_luminance</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>max_luminance</name></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>max_luminance</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>min_luminance</name></name> <operator>=</operator> <call><name>av_d2q</name><argument_list>(<argument><expr><name><name>mastering_meta</name><operator>-&gt;</operator><name>min_luminance</name></name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>has_luminance</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mkv_parse_video_projection</name><parameter_list>(<parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>AVSphericalMapping</name> <modifier>*</modifier></type><name>spherical</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>AVSphericalProjection</name></name></type> <name>projection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>spherical_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GetByteContext</name></type> <name>gb</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bytestream2_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unknown spherical metadata\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MATROSKA_VIDEO_PROJECTION_TYPE_EQUIRECTANGULAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;=</operator> <name>UINT_MAX</name> <operator>-</operator> <name>t</name> <operator>||</operator> <name>r</name> <operator>&gt;=</operator> <name>UINT_MAX</name> <operator>-</operator> <name>l</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Invalid bounding rectangle coordinates "</literal>
<literal type="string">"%"</literal><name>PRIu32</name><literal type="string">",%"</literal><name>PRIu32</name><literal type="string">",%"</literal><name>PRIu32</name><literal type="string">",%"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>l</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown spherical metadata\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>||</operator> <name>t</name> <operator>||</operator> <name>r</name> <operator>||</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>projection</name> <operator>=</operator> <name>AV_SPHERICAL_EQUIRECTANGULAR_TILE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>projection</name> <operator>=</operator> <name>AV_SPHERICAL_EQUIRECTANGULAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>MATROSKA_VIDEO_PROJECTION_TYPE_CUBEMAP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing projection private properties\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>private</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>layout</name> <init>= <expr><call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>layout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Unknown spherical cubemap layout %"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>projection</name> <operator>=</operator> <name>AV_SPHERICAL_CUBEMAP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>padding</name> <operator>=</operator> <call><name>bytestream2_get_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown spherical metadata\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>MATROSKA_VIDEO_PROJECTION_TYPE_RECTANGULAR</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Unknown spherical metadata type %"</literal><name>PRIu64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name>spherical</name> <operator>=</operator> <call><name>av_spherical_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spherical_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>spherical</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>projection</name></name> <operator>=</operator> <name>projection</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>yaw</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>yaw</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>pitch</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>pitch</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>roll</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>projection</name><operator>.</operator><name>roll</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>padding</name></name> <operator>=</operator> <name>padding</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>bound_left</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>bound_top</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>bound_right</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spherical</name><operator>-&gt;</operator><name>bound_bottom</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_stream_add_side_data</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_SPHERICAL</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>spherical</name></expr></argument>,
<argument><expr><name>spherical_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spherical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_qt_codec</name><parameter_list>(<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>fourcc</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>AVCodecID</name></name> <modifier>*</modifier></type><name>codec_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVCodecTag</name> <modifier>*</modifier></type><name>codec_tags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>codec_tags</name> <operator>=</operator> <ternary><condition><expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_VIDEO</name></expr> ?</condition><then>
<expr><name>ff_codec_movvideo_tags</name></expr> </then><else>: <expr><name>ff_codec_movaudio_tags</name></expr></else></ternary></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>codec_tags</name></expr></argument>, <argument><expr><call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>av_buffer_realloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>fourcc</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>codec_tags</name></expr></argument>, <argument><expr><operator>*</operator><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_tracks</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><operator>&amp;</operator><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>AVCodecID</name></name></type> <name>codec_id</name> <init>= <expr><name>AV_CODEC_ID_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>encodings_list</name> <init>= <expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>encodings</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrackEncoding</name> <modifier>*</modifier></type><name>encodings</name> <init>= <expr><name><name>encodings_list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>extradata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extradata_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extradata_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>fourcc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVIOContext</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>key_id_base64</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit_depth</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_TYPE_VIDEO</name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_TYPE_AUDIO</name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_TYPE_SUBTITLE</name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_TYPE_METADATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"Unknown or unsupported track type %"</literal><name>PRIu64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
<call><name>isnan</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid sample rate %f, defaulting to 8000 instead.\n"</literal></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name> <operator>=</operator> <literal type="number">8000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_VIDEO</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>default_duration</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>frame_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>default_duration</name> <init>= <expr><literal type="number">1000000000</literal> <operator>/</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>frame_rate</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>default_duration</name> <operator>&gt;</operator> <name>UINT64_MAX</name> <operator>||</operator> <name>default_duration</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid frame rate %e. Cannot calculate default duration.\n"</literal></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>frame_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>default_duration</name></name> <operator>=</operator> <name>default_duration</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_width</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_width</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>pixel_width</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_height</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_height</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>pixel_height</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>color_space</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>color_space</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_AUDIO</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>encodings_list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Multiple combined encodings not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>encodings_list</name><operator>-&gt;</operator><name>nb_elem</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>encryption</name><operator>.</operator><name>key_id</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b64_size</name> <init>= <expr><call><name>AV_BASE64_SIZE</name><argument_list>(<argument><expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>encryption</name><operator>.</operator><name>key_id</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>key_id_base64</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>b64_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>key_id_base64</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_base64_encode</name><argument_list>(<argument><expr><name>key_id_base64</name></expr></argument>, <argument><expr><name>b64_size</name></expr></argument>,
<argument><expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>encryption</name><operator>.</operator><name>key_id</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>encryption</name><operator>.</operator><name>key_id</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>scope</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_ZLIB</name></expr></cpp:if>
<expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>algo</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_ENCODING_COMP_ZLIB</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_BZLIB</name></expr></cpp:if>
<name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>algo</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_ENCODING_COMP_BZLIB</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_LZO</name></expr></cpp:if>
<name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>algo</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_ENCODING_COMP_LZO</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>compression</name><operator>.</operator><name>algo</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>scope</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported encoding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>encodings</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>scope</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>codec_priv</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>matroska_decode_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name>track</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Failed to decode codec private data\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>codec_priv</name> <operator>!=</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_buffer_unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>av_buffer_create</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ff_mkv_codec_tags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ff_mkv_codec_tags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ff_mkv_codec_tags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name><name>ff_mkv_codec_tags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>st</name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>stream</name></name> <operator>=</operator> <call><name>avformat_new_stream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>key_id_base64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>key_id_base64</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"enc_key_id"</literal></expr></argument>, <argument><expr><name>key_id_base64</name></expr></argument>,
<argument><expr><name>AV_DICT_DONT_STRDUP_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"V_MS/VFW/FOURCC"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">40</literal> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>ms_compat</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bit_depth</name> <operator>=</operator> <call><name>AV_RL16</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>ff_codec_bmp_tags</name></expr></argument>,
<argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>codec_id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>ff_codec_movvideo_tags</name></expr></argument>,
<argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>extradata_offset</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"A_MS/ACM"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">14</literal> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ffio_init_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_get_wav_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata_offset</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"A_QUICKTIME"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">32</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>sample_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>get_qt_codec</name><argument_list>(<argument><expr><name>track</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fourcc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>codec_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sample_size</name> <operator>=</operator> <call><name>AV_RB16</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fourcc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sample_size</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>,<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'w'</literal></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>ff_codec_movaudio_tags</name></expr></argument>, <argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sample_size</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>,<argument><expr><literal type="char">'w'</literal></expr></argument>,<argument><expr><literal type="char">'o'</literal></expr></argument>,<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>ff_codec_movaudio_tags</name></expr></argument>, <argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fourcc</name> <operator>==</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>,<argument><expr><literal type="char">'w'</literal></expr></argument>,<argument><expr><literal type="char">'o'</literal></expr></argument>,<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<name>fourcc</name> <operator>==</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>,<argument><expr><literal type="char">'o'</literal></expr></argument>,<argument><expr><literal type="char">'w'</literal></expr></argument>,<argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<name>sample_size</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S8</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"V_QUICKTIME"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">21</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>get_qt_codec</name><argument_list>(<argument><expr><name>track</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fourcc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>codec_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name> <operator>&amp;&amp;</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><literal type="string">"SMI "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>,<argument><expr><literal type="char">'V'</literal></expr></argument>,<argument><expr><literal type="char">'Q'</literal></expr></argument>,<argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <call><name>ff_codec_get_id</name><argument_list>(<argument><expr><name>ff_codec_movvideo_tags</name></expr></argument>, <argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"mov FourCC not found %s.\n"</literal></expr></argument>, <argument><expr><call><name>av_fourcc2str</name><argument_list>(<argument><expr><name>fourcc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">86</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bit_depth</name> <operator>=</operator> <call><name>AV_RB16</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">82</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ffio_init_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_get_qtpalette</name><argument_list>(<argument><expr><name>codec_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>palette</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bit_depth</name> <operator>&amp;=</operator> <literal type="number">0x1F</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>has_palette</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_PCM_S16BE</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_U8</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">24</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S24BE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S32BE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_PCM_S16LE</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_U8</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">24</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S24LE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S32LE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_PCM_F32LE</name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>codec_id</name> <operator>=</operator> <name>AV_CODEC_ID_PCM_F64LE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_AAC</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>profile</name> <init>= <expr><call><name>matroska_aac_profile</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sri</name> <init>= <expr><call><name>matroska_aac_sri</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>extradata</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><literal type="number">5</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extradata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>extradata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>profile</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>sri</name> <operator>&amp;</operator> <literal type="number">0x0E</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extradata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sri</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"SBR"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sri</name> <operator>=</operator> <call><name>matroska_aac_sri</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extradata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x56</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extradata</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xE5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extradata</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>sri</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata_size</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>extradata_size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_ALAC</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name>INT_MAX</name> <operator>-</operator> <literal type="number">12</literal> <operator>-</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>extradata_size</name> <operator>=</operator> <literal type="number">12</literal> <operator>+</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name>extradata_size</name> <operator>+</operator>
<name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extradata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name>extradata</name></expr></argument>, <argument><expr><name>extradata_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extradata</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"alac"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extradata</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extradata</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_TTA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name> <operator>&gt;</operator> <name>UINT16_MAX</name> <operator>||</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Too large audio channel number %"</literal><name>PRIu64</name>
<literal type="string">" or bitdepth %"</literal><name>PRIu64</name><literal type="string">". Skipping track.\n"</literal></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>error_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>extradata_size</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><name>extradata_size</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extradata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>extradata</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_be32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><literal type="string">"TTA1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bytestream_put_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><call><name>av_rescale</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name></expr></argument>,
<argument><expr><name>AV_TIME_BASE</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RV10</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RV20</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RV30</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RV40</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extradata_offset</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RA_144</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name> <operator>=</operator> <literal type="number">8000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RA_288</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_COOK</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_ATRAC3</name> <operator>||</operator>
<name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_SIPR</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flavor</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ffio_init_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flavor</name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>coded_framesize</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_h</name></name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>frame_size</name></name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flavor</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>coded_framesize</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_h</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>frame_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codec_id</name> <operator>!=</operator> <name>AV_CODEC_ID_SIPR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_h</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>frame_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_RA_288</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>block_align</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>coded_framesize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_SIPR</name> <operator>&amp;&amp;</operator> <name>flavor</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>sipr_bit_rate</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">6504</literal></expr>, <expr><literal type="number">8496</literal></expr>, <expr><literal type="number">5000</literal></expr>, <expr><literal type="number">16000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name> <operator>=</operator> <name><name>ff_sipr_subpk_size</name><index>[<expr><name>flavor</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>=</operator> <name><name>sipr_bit_rate</name><index>[<expr><name>flavor</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>block_align</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata_offset</name> <operator>=</operator> <literal type="number">78</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_FLAC</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>matroska_parse_flac</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>track</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extradata_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_WAVPACK</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Assuming WavPack version 4.10 "</literal>
<literal type="string">"in absence of valid CodecPrivate.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata_size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>extradata</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extradata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>AV_WL16</name><argument_list>(<argument><expr><name>extradata</name></expr></argument>, <argument><expr><literal type="number">0x410</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_PRORES</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fourcc</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_VP9</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_AV1</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>extradata_offset</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>-=</operator> <name>extradata_offset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"Unknown/unsupported AVCodecID %s.\n"</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>&lt;</operator> <literal type="number">0.01</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>avpriv_set_pts_info</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>*</operator> <name><name>track</name><operator>-&gt;</operator><name>time_scale</name></name></expr></argument>,
<argument><expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>codec_delay_in_track_tb</name></name> <operator>=</operator> <macro><name>av_rescale_q</name><argument_list>(<argument>track-&gt;codec_delay</argument>,
<argument>(AVRational){ <literal type="number">1</literal></argument>, <argument><literal type="number">1000000000</literal> }</argument>,
<argument>st-&gt;time_base</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>codec_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="string">"und"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"language"</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>flag_default</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>flag_forced</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_FORCED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>extradata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name> <operator>=</operator> <name>extradata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>=</operator> <name>extradata_size</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ff_alloc_extradata</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>extradata_offset</name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_priv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_VIDEO</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrackPlane</name> <modifier>*</modifier></type><name>planes</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>operation</name><operator>.</operator><name>combine_planes</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>display_width_mul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>display_height_mul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <name>fourcc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bit_depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name> <operator>=</operator> <name>bit_depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>pixel_width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>pixel_height</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>interlaced</name></name> <operator>==</operator> <name>MATROSKA_VIDEO_INTERLACE_FLAG_INTERLACED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <call><name>mkv_field_order</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>field_order</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>interlaced</name></name> <operator>==</operator> <name>MATROSKA_VIDEO_INTERLACE_FLAG_PROGRESSIVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_PROGRESSIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>&lt;</operator> <name>MATROSKA_VIDEO_STEREOMODE_TYPE_NB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mkv_stereo_mode_display_mul</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>display_width_mul</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>display_height_mul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_unit</name></name> <operator>&lt;</operator> <name>MATROSKA_VIDEO_DISPLAYUNIT_UNKNOWN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_reduce</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>sample_aspect_ratio</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>sample_aspect_ratio</name><operator>.</operator><name>den</name></name></expr></argument>,
<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>height</name></name> <operator>*</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_width</name></name> <operator>*</operator> <name>display_width_mul</name></expr></argument>,
<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>display_height</name></name> <operator>*</operator> <name>display_height_mul</name></expr></argument>,
<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>!=</operator> <name>AV_CODEC_ID_HEVC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_HEADERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>default_duration</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_reduce</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>den</name></name></expr></argument>,
<argument><expr><literal type="number">1000000000</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>default_duration</name></name></expr></argument>, <argument><expr><literal type="number">30000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_R_FRAME_RATE</name></expr></cpp:if>
<if_stmt><if>if <condition>( <expr><name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>num</name></name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>den</name></name> <operator>*</operator> <literal type="number">1000LL</literal>
<operator>&amp;&amp;</operator> <name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>num</name></name> <operator>&gt;</operator> <name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name><operator>.</operator><name>den</name></name> <operator>*</operator> <literal type="number">5LL</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>r_frame_rate</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>avg_frame_rate</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>&lt;</operator> <name>MATROSKA_VIDEO_STEREOMODE_TYPE_NB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"stereo_mode"</literal></expr></argument>, <argument><expr><name><name>ff_matroska_video_stereo_mode</name><index>[<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>alpha_mode</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"alpha_mode"</literal></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>track</name><operator>-&gt;</operator><name>operation</name><operator>.</operator><name>combine_planes</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>planes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>&gt;=</operator> <name>MATROSKA_VIDEO_STEREO_PLANE_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>,
<argument><expr><name><name>ff_matroska_video_stereo_plane</name><index>[<expr><name><name>planes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>planes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>==</operator> <name><name>tracks</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>&amp;&amp;</operator> <name><name>tracks</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>stream</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tracks</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>stream</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>,
<argument><expr><literal type="string">"stereo_mode"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>&lt;</operator> <name>MATROSKA_VIDEO_STEREOMODE_TYPE_NB</name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>!=</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name> <operator>!=</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>ff_mkv_stereo3d_conv</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>video</name><operator>.</operator><name>stereo_mode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mkv_parse_video_color</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>track</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mkv_parse_video_projection</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>track</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_AUDIO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <name>fourcc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>out_samplerate</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>channels</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>bitdepth</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_MP3</name> <operator>||</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_MLP</name> <operator>||</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_TRUEHD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_FULL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>!=</operator> <name>AV_CODEC_ID_AAC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_HEADERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>codec_delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>initial_padding</name></name> <operator>=</operator> <macro><name>av_rescale_q</name><argument_list>(<argument>track-&gt;codec_delay</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument><literal type="number">1000000000</literal>}</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument>st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_OPUS ?
<literal type="number">48000</literal> : st-&gt;codecpar-&gt;sample_rate}</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>seek_preroll</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>seek_preroll</name></name> <operator>=</operator> <macro><name>av_rescale_q</name><argument_list>(<argument>track-&gt;seek_preroll</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument><literal type="number">1000000000</literal>}</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument>st-&gt;codecpar-&gt;sample_rate}</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>codec_id</name> <operator>==</operator> <name>AV_CODEC_ID_WEBVTT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_SUBTITLE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"D_WEBVTT/CAPTIONS"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_CAPTIONS</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"D_WEBVTT/DESCRIPTIONS"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_DESCRIPTIONS</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>, <argument><expr><literal type="string">"D_WEBVTT/METADATA"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_METADATA</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_SUBTITLE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_SUBTITLE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_read_header</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>attachments_list</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>attachments</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>chapters_list</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>chapters</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaAttachment</name> <modifier>*</modifier></type><name>attachments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaChapter</name> <modifier>*</modifier></type><name>chapters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>max_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Ebml</name></type> <name>ebml</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>ebml_syntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebml</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>ebml</name><operator>.</operator><name>doctype</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"EBML header parsing failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>ebml_syntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ebml</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <name>EBML_VERSION</name> <operator>||</operator>
<name><name>ebml</name><operator>.</operator><name>max_size</name></name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<name><name>ebml</name><operator>.</operator><name>id_length</name></name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<name><name>ebml</name><operator>.</operator><name>doctype_version</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,
<argument><expr><literal type="string">"EBML version %"</literal><name>PRIu64</name><literal type="string">", doctype %s, doc version %"</literal><name>PRIu64</name></expr></argument>,
<argument><expr><name><name>ebml</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>ebml</name><operator>.</operator><name>doctype</name></name></expr></argument>, <argument><expr><name><name>ebml</name><operator>.</operator><name>doctype_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>ebml_syntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ebml</name><operator>.</operator><name>doctype_version</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"EBML header using unsupported features\n"</literal>
<literal type="string">"(EBML version %"</literal><name>PRIu64</name><literal type="string">", doctype %s, doc version %"</literal><name>PRIu64</name><literal type="string">")\n"</literal></expr></argument>,
<argument><expr><name><name>ebml</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>ebml</name><operator>.</operator><name>doctype</name></name></expr></argument>, <argument><expr><name><name>ebml</name><operator>.</operator><name>doctype_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>matroska_doctypes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ebml</name><operator>.</operator><name>doctype</name></name></expr></argument>, <argument><expr><name><name>matroska_doctypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>matroska_doctypes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unknown EBML doctype '%s'\n"</literal></expr></argument>, <argument><expr><name><name>ebml</name><operator>.</operator><name>doctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>error_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>ebml_syntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>ebml_syntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_segments</name></expr></argument>, <argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_resync</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_segment</name></expr></argument>, <argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name> <operator>==</operator> <name>MATROSKA_ID_CLUSTER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>data_offset</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>matroska_execute_seekhead</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>*</operator>
<literal type="number">1000</literal> <operator>/</operator> <name>AV_TIME_BASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"encoder"</literal></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>muxingapp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>date_utc</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>matroska_metadata_creation_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><call><name>AV_RB64</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>date_utc</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_tracks</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>attachments</name> <operator>=</operator> <name><name>attachments_list</name><operator>-&gt;</operator><name>elem</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>attachments_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>filename</name> <operator>&amp;&amp;</operator> <name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mime</name> <operator>&amp;&amp;</operator>
<name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>data</name></name> <operator>&amp;&amp;</operator> <name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete attachment\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>avformat_new_stream</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"mimetype"</literal></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ff_mkv_image_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ff_mkv_image_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mime</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ff_mkv_image_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name><name>ff_mkv_image_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>stream</name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>attached_pic</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>disposition</name></name> <operator>|=</operator> <name>AV_DISPOSITION_ATTACHED_PIC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_init_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pkt</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>AV_PKT_FLAG_KEY</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_ATTACHMENT</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ff_alloc_extradata</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ff_mkv_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ff_mkv_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>, <argument><expr><name><name>attachments</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>mime</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ff_mkv_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name><name>ff_mkv_mime_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>chapters</name> <operator>=</operator> <name><name>chapters_list</name><operator>-&gt;</operator><name>elem</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chapters_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name> <operator>&amp;&amp;</operator> <name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>uid</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>max_start</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name> <operator>&gt;</operator> <name>max_start</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>chapter</name> <operator>=</operator>
<macro><name>avpriv_new_chapter</name><argument_list>(<argument>s</argument>, <argument>chapters[i].uid</argument>,
<argument>(AVRational) { <literal type="number">1</literal></argument>, <argument><literal type="number">1000000000</literal> }</argument>,
<argument>chapters[i].start</argument>, <argument>chapters[i].end</argument>,
<argument>chapters[i].title</argument>)</argument_list></macro></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>chapter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chapter</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>,
<argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>title</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>max_start</name> <operator>=</operator> <name><name>chapters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>matroska_add_index_entries</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>matroska_convert_tags</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>matroska_read_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_deliver_packet</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_packet_list_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue_end</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>track</name> <operator>=</operator> <operator>&amp;</operator><name><name>tracks</name><index>[<expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>has_palette</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pal</name> <init>= <expr><call><name>av_packet_new_side_data</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>AV_PKT_DATA_PALETTE</name></expr></argument>, <argument><expr><name>AVPALETTE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pal</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot append palette to packet\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pal</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>palette</name></name></expr></argument>, <argument><expr><name>AVPALETTE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>has_palette</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>matroska_clear_queue</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ff_packet_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_laces</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name><name>lace_size</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>laces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>*</operator><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>laces</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lace_size</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>laces</name> <operator>=</operator> <operator>*</operator><name>data</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x1</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>*</operator><name>laces</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>total</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>*</operator><name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name> <operator>+=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>total</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>total</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="number">0x2</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>%</operator> <operator>(</operator><operator>*</operator><name>laces</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>*</operator><name>laces</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>size</name> <operator>/</operator> <operator>*</operator><name>laces</name></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>

<case>case <expr><literal type="number">0x3</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>total</name> <operator>=</operator> <name><name>lace_size</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <operator>*</operator><name>laces</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>snum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>matroska_ebmlnum_sint</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>snum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lace_size</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>snum</name> <operator>&gt;</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>lace_size</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>snum</name></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>total</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lace_size</name><index>[<expr><operator>*</operator><name>laces</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>total</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_rm_audio</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>timecode</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>block_align</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sps</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cfs</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>coded_framesize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_h</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_cnt</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>frame_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>pkt_cnt</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_cnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf_timecode</name></name> <operator>=</operator> <name>timecode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_RA_288</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>cfs</name> <operator>*</operator> <name>h</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Corrupt int4 RM-style audio packet size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>h</name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>x</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name>w</name> <operator>+</operator> <name>y</name> <operator>*</operator> <name>cfs</name></expr></argument>,
<argument><expr><name>data</name> <operator>+</operator> <name>x</name> <operator>*</operator> <name>cfs</name></expr></argument>, <argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_SIPR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>w</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Corrupt sipr RM-style audio packet size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>y</name> <operator>*</operator> <name>w</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>sps</name> <operator>*</operator> <name>w</name> <operator>/</operator> <name>sps</name> <operator>||</operator> <name>h</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>w</name><operator>%</operator><name>sps</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Corrupt generic RM-style audio packet size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>w</name> <operator>/</operator> <name>sps</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name> <operator>+</operator>
<name>sps</name> <operator>*</operator> <operator>(</operator><name>h</name> <operator>*</operator> <name>x</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>h</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>y</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>y</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>,
<argument><expr><name>data</name> <operator>+</operator> <name>x</name> <operator>*</operator> <name>sps</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_cnt</name></name> <operator>&gt;=</operator> <name>h</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_SIPR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_rm_reorder_sipr_data</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>pkt_cnt</name></name> <operator>=</operator> <name>h</name> <operator>*</operator> <name>w</name> <operator>/</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>pkt_cnt</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVPacket</name></type> <name>pktl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pkt</name> <init>= <expr><operator>&amp;</operator><name>pktl</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_new_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>a</name> <operator>*</operator> <operator>(</operator><name>h</name> <operator>*</operator> <name>w</name> <operator>/</operator> <name>a</name> <operator>-</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>pkt_cnt</name></name><operator>--</operator><operator>)</operator></expr></argument>,
<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf_timecode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>buf_timecode</name></name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_packet_list_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue_end</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_wavpack</name><parameter_list>(<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pdst</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dstlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>srclen</name> <init>= <expr><operator>*</operator><name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>samples</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>ver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ver</name> <operator>=</operator> <call><name>AV_RL16</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>samples</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>srclen</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>srclen</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>multiblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>blocksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name> <init>= <expr><call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>crc</name> <init>= <expr><call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>srclen</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>multiblock</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0x1800</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x1800</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>multiblock</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>blocksize</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>srclen</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>blocksize</name> <operator>=</operator> <name>srclen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>blocksize</name> <operator>&gt;</operator> <name>srclen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstlen</name> <operator>+</operator> <name>blocksize</name> <operator>+</operator> <literal type="number">32</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dstlen</name> <operator>+=</operator> <name>blocksize</name> <operator>+</operator> <literal type="number">32</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>blocksize</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL16</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>ver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL16</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>, <argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>blocksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>src</name> <operator>+=</operator> <name>blocksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srclen</name> <operator>-=</operator> <name>blocksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>blocksize</name> <operator>+</operator> <literal type="number">32</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>dstlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pdst</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>dstlen</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_prores</name><parameter_list>(<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pdst</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dstlen</name> <init>= <expr><operator>*</operator><name>size</name> <operator>+</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>dstlen</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name>MKBETAG</name><argument_list>(<argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dstlen</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>dstlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pdst</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>dstlen</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_webvtt</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>,
<parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_len</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>timecode</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>duration</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVPacket</name></type> <name>pktl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pkt</name> <init>= <expr><operator>&amp;</operator><name>pktl</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>settings</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>text</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id_len</name></decl>, <decl><type ref="prev"/><name>settings_len</name></decl>, <decl><type ref="prev"/><name>text_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>data</name> <operator>+</operator> <name>data_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>id_len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>q</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>id_len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>q</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>settings</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>settings_len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>q</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>settings_len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>settings</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>q</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>text</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>text_len</name> <operator>=</operator> <name>q</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>text_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>text_len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>c</name> <init>= <expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>text_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>text_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>av_new_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>text_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>text_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>id_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>av_packet_new_side_data</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>,
<argument><expr><name>AV_PKT_DATA_WEBVTT_IDENTIFIER</name></expr></argument>,
<argument><expr><name>id_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>id_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>settings_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>av_packet_new_side_data</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>,
<argument><expr><name>AV_PKT_DATA_WEBVTT_SETTINGS</name></expr></argument>,
<argument><expr><name>settings_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>settings</name></expr></argument>, <argument><expr><name>settings_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name>timecode</name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name>duration</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>ff_packet_list_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue_end</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_frame</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>,
<parameter><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
<parameter><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pkt_size</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>timecode</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>lace_duration</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_keyframe</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>additional</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>additional_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>additional_size</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>discard_padding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaTrackEncoding</name> <modifier>*</modifier></type><name>encodings</name> <init>= <expr><name><name>track</name><operator>-&gt;</operator><name>encodings</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pkt_data</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVPacket</name></type> <name>pktl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pkt</name> <init>= <expr><operator>&amp;</operator><name>pktl</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encodings</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>encodings</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator> <name><name>encodings</name><operator>-&gt;</operator><name>scope</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_decode_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pkt_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkt_size</name></expr></argument>, <argument><expr><name>track</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_WAVPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>wv_data</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_wavpack</name><argument_list>(<argument><expr><name>track</name></expr></argument>, <argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wv_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error parsing a wavpack block.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pkt_data</name> <operator>!=</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pkt_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <name>wv_data</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_PRORES</name> <operator>&amp;&amp;</operator>
<call><name>AV_RB32</name><argument_list>(<argument><expr><name>pkt_data</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MKBETAG</name><argument_list>(<argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pr_data</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_prores</name><argument_list>(<argument><expr><name>track</name></expr></argument>, <argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pr_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Error parsing a prores block.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pkt_data</name> <operator>!=</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pkt_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pkt_data</name> <operator>=</operator> <name>pr_data</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_init_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pkt_data</name> <operator>!=</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>av_buffer_create</name><argument_list>(<argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name>pkt_size</name> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>av_buffer_ref</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pkt</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>pkt_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>pkt_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>is_keyframe</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>additional_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>side_data</name> <init>= <expr><call><name>av_packet_new_side_data</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>,
<argument><expr><name>AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL</name></expr></argument>,
<argument><expr><name>additional_size</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>side_data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>AV_WB64</name><argument_list>(<argument><expr><name>side_data</name></expr></argument>, <argument><expr><name>additional_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>side_data</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>additional</name></expr></argument>, <argument><expr><name>additional_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>discard_padding</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>side_data</name> <init>= <expr><call><name>av_packet_new_side_data</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>,
<argument><expr><name>AV_PKT_DATA_SKIP_SAMPLES</name></expr></argument>,
<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>side_data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>discard_padding</name> <operator>=</operator> <macro><name>av_rescale_q</name><argument_list>(<argument>discard_padding</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument><literal type="number">1000000000</literal>}</argument>,
<argument>(AVRational){<literal type="number">1</literal></argument>, <argument>st-&gt;codecpar-&gt;sample_rate}</argument>)</argument_list></macro></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>discard_padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>side_data</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>discard_padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name>side_data</name></expr></argument>, <argument><expr><operator>-</operator><name>discard_padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>ms_compat</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>dts</name></name> <operator>=</operator> <name>timecode</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name>timecode</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name>lace_duration</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FF_API_CONVERGENCE_DURATION</name></expr></cpp:if>
<macro><name>FF_DISABLE_DEPRECATION_WARNINGS</name></macro>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_SUBRIP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>convergence_duration</name></name> <operator>=</operator> <name>lace_duration</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>FF_ENABLE_DEPRECATION_WARNINGS</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>res</name> <init>= <expr><call><name>ff_packet_list_put</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue_end</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_packet_unref</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<if_stmt><if>if <condition>(<expr><name>pkt_data</name> <operator>!=</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pkt_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_block</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>, <parameter><decl><type><name>AVBufferRef</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>cluster_time</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>block_duration</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_keyframe</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>additional</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>additional_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>additional_size</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>cluster_pos</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>discard_padding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>timecode</name> <init>= <expr><name>AV_NOPTS_VALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVIOContext</name></type> <name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name>block_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>lace_size</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>, <decl><type ref="prev"/><name>laces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trust_default_duration</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ffio_init_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>track</name> <operator>=</operator> <call><name>matroska_find_track_by_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>track</name> <operator>||</operator> <operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>stream</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,
<argument><expr><literal type="string">"Invalid stream %"</literal><name>PRIu64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>st</name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>stream</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>discard</name></name> <operator>&gt;=</operator> <name>AVDISCARD_ALL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>block_duration</name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block_time</name> <operator>=</operator> <call><name>sign_extend</name><argument_list>(<argument><expr><call><name>AV_RB16</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_keyframe</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>is_keyframe</name> <operator>=</operator> <ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> ?</condition><then> <expr><name>AV_PKT_FLAG_KEY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cluster_time</name> <operator>!=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>block_time</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>cluster_time</name> <operator>&gt;=</operator> <operator>-</operator><name>block_time</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>timecode</name> <operator>=</operator> <name>cluster_time</name> <operator>+</operator> <name>block_time</name> <operator>-</operator> <name><name>track</name><operator>-&gt;</operator><name>codec_delay_in_track_tb</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_SUBTITLE</name> <operator>&amp;&amp;</operator>
<name>timecode</name> <operator>&lt;</operator> <name><name>track</name><operator>-&gt;</operator><name>end_timecode</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>is_keyframe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>is_keyframe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ff_reduce_index</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_add_index_entry</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>cluster_pos</name></expr></argument>, <argument><expr><name>timecode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>AVINDEX_KEYFRAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>&amp;&amp;</operator>
<name><name>track</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MATROSKA_TRACK_TYPE_SUBTITLE</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>timecode</name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_timecode</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_keyframe</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"File is broken, keyframes not correctly marked!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_laces</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0x06</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><name>lace_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>laces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error parsing frame sizes.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name> <operator>==</operator> <literal type="number">8000</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_AC3</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>samplerate</name></name> <operator>!=</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>||</operator> <operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>frame_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>trust_default_duration</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block_duration</name> <operator>&amp;&amp;</operator> <name>trust_default_duration</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>block_duration</name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>default_duration</name></name> <operator>*</operator> <name>laces</name> <operator>/</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cluster_time</name> <operator>!=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>block_time</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>cluster_time</name> <operator>&gt;=</operator> <operator>-</operator><name>block_time</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>end_timecode</name></name> <operator>=</operator>
<call><name>FFMAX</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>end_timecode</name></name></expr></argument>, <argument><expr><name>timecode</name> <operator>+</operator> <name>block_duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>laces</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lace_duration</name> <init>= <expr><name>block_duration</name><operator>*</operator><operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>laces</name> <operator>-</operator> <name>block_duration</name><operator>*</operator><name>n</name> <operator>/</operator> <name>laces</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_RA_288</name> <operator>||</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_COOK</name> <operator>||</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_SIPR</name> <operator>||</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_ATRAC3</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>block_align</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>audio</name><operator>.</operator><name>sub_packet_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_rm_audio</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>track</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
<argument><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
<argument><expr><name>timecode</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_WEBVTT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_webvtt</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>track</name></expr></argument>, <argument><expr><name>st</name></expr></argument>,
<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
<argument><expr><name>timecode</name></expr></argument>, <argument><expr><name>lace_duration</name></expr></argument>,
<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_frame</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>track</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
<argument><expr><name>timecode</name></expr></argument>, <argument><expr><name>lace_duration</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>!</operator><name>n</name></expr> ?</condition><then> <expr><name>is_keyframe</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>additional</name></expr></argument>, <argument><expr><name>additional_id</name></expr></argument>, <argument><expr><name>additional_size</name></expr></argument>,
<argument><expr><name>discard_padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>timecode</name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>timecode</name> <operator>=</operator> <ternary><condition><expr><name>lace_duration</name></expr> ?</condition><then> <expr><name>timecode</name> <operator>+</operator> <name>lace_duration</name></expr> </then><else>: <expr><name>AV_NOPTS_VALUE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <name><name>lace_size</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_parse_cluster</name><parameter_list>(<parameter><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaCluster</name> <modifier>*</modifier></type><name>cluster</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>current_cluster</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>block</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_segment</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_cluster_enter</name></expr></argument>, <argument><expr><name>cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ebml_parse</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>matroska_cluster_parsing</name></expr></argument>, <argument><expr><name>cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>block</name><operator>-&gt;</operator><name>bin</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_keyframe</name> <init>= <expr><ternary><condition><expr><name><name>block</name><operator>-&gt;</operator><name>non_simple</name></name></expr> ?</condition><then> <expr><name><name>block</name><operator>-&gt;</operator><name>reference</name></name> <operator>==</operator> <name>INT64_MIN</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name><modifier>*</modifier></type> <name>additional</name> <init>= <expr><ternary><condition><expr><name><name>block</name><operator>-&gt;</operator><name>additional</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
<expr><name><name>block</name><operator>-&gt;</operator><name>additional</name><operator>.</operator><name>data</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>matroska_parse_block</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>bin</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>bin</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>block</name><operator>-&gt;</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>bin</name><operator>.</operator><name>pos</name></name></expr></argument>,
<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>timecode</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>,
<argument><expr><name>is_keyframe</name></expr></argument>, <argument><expr><name>additional</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>additional_id</name></name></expr></argument>,
<argument><expr><name><name>block</name><operator>-&gt;</operator><name>additional</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
<argument><expr><name><name>block</name><operator>-&gt;</operator><name>discard_padding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>matroska_blockgroup</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>num_levels</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"File extends beyond "</literal>
<literal type="string">"end of segment.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_EOF</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_read_packet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><call><name>matroska_deliver_packet</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ret</name></expr> </then><else>: <expr><name>AVERROR_EOF</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>matroska_parse_cluster</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>matroska_resync</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_read_seek</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stream_index</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>stream_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>matroska_parse_cues</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>index</name> <operator>=</operator> <call><name>av_index_search_timestamp</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>==</operator> <name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>index</name> <operator>=</operator> <call><name>av_index_search_timestamp</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>==</operator> <name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_clear_queue</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>matroska_parse_cluster</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>matroska_clear_queue</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>matroska</name><operator>-&gt;</operator><name>cues_parsing_deferred</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>==</operator> <name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tracks</name> <operator>=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>audio</name><operator>.</operator><name>pkt_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>audio</name><operator>.</operator><name>sub_packet_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>audio</name><operator>.</operator><name>buf_timecode</name></name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tracks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end_timecode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>AVSEEK_FLAG_ANY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_timecode</name></name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_timecode</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>timestamp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_update_cur_dts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>err</name>:</label>


<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>resync_pos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>matroska_clear_queue</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator>
<name><name>matroska</name><operator>-&gt;</operator><name>skip_to_keyframe</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matroska</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>matroska_read_close</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>matroska_clear_queue</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>tracks</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>MATROSKA_TRACK_TYPE_AUDIO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tracks</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>audio</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ebml_free</name><argument_list>(<argument><expr><name>matroska_segment</name></expr></argument>, <argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>start_time_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end_time_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>start_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end_offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>CueDesc</name>;</typedef>





<function><type><specifier>static</specifier> <name>CueDesc</name></type> <name>get_cue_desc</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>cues_start</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CueDesc</name></type> <name>cue_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_index_entries</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVIndexEntry</name> <modifier>*</modifier></type><name>index_entries</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>index_entries</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&gt;=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>CueDesc</name><operator>)</operator> <block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nb_index_entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>index_entries</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>&lt;=</operator> <name>ts</name> <operator>&amp;&amp;</operator>
<name><name>index_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>&gt;</operator> <name>ts</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>start_time_ns</name></name> <operator>=</operator> <name><name>index_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>start_offset</name></name> <operator>=</operator> <name><name>index_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>-</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>nb_index_entries</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>end_time_ns</name></name> <operator>=</operator> <name><name>index_entries</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>end_offset</name></name> <operator>=</operator> <name><name>index_entries</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pos</name> <operator>-</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>end_time_ns</name></name> <operator>=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>cue_desc</name><operator>.</operator><name>end_offset</name></name> <operator>=</operator> <name>cues_start</name> <operator>-</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>cue_desc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>webm_clusters_start_with_keyframe</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name> <init>= <expr><name><name>matroska</name><operator>-&gt;</operator><name>current_id</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>cluster_pos</name></decl>, <decl><type ref="prev"/><name>before_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>rv</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>av_index_search_timestamp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cluster_pos</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>index_entries</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>before_pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cluster_id</name></decl>, <decl><type ref="prev"/><name>cluster_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>cluster_pos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>ebml_read_num</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cluster_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>read</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cluster_id</name> <operator>!=</operator> <literal type="number">0xF43B675</literal></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>ebml_read_length</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cluster_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>read</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cluster_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>matroska_clear_queue</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>matroska_parse_cluster</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>queue</name><operator>-&gt;</operator><name>pkt</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cluster_pos</name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <name>read</name> <operator>+</operator> <name>cluster_length</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PKT_FLAG_KEY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>


<expr_stmt><expr><call><name>matroska_reset_status</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>before_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>buffer_size_after_time_downloaded</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>time_ns</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>search_sec</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>bps</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>min_buffer</name></decl></parameter>, <parameter><decl><type><name>double</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>,
<parameter><decl><type><name>double</name><modifier>*</modifier></type> <name>sec_to_download</name></decl></parameter>, <parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>cues_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>nano_seconds_per_second</name> <init>= <expr><literal type="number">1000000000.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>time_sec</name> <init>= <expr><name>time_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>time_to_search_ns</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>search_sec</name> <operator>*</operator> <name>nano_seconds_per_second</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end_time_ns</name> <init>= <expr><name>time_ns</name> <operator>+</operator> <name>time_to_search_ns</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>sec_downloaded</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CueDesc</name></type> <name>desc_curr</name> <init>= <expr><call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>time_ns</name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>desc_curr</name><operator>.</operator><name>start_time_ns</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sec_to_download</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>time_ns</name> <operator>&gt;</operator> <name><name>desc_curr</name><operator>.</operator><name>start_time_ns</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>cue_nano</name> <init>= <expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name>time_ns</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>percent</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>cue_nano</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name><name>desc_curr</name><operator>.</operator><name>start_time_ns</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>cueBytes</name> <init>= <expr><operator>(</operator><name><name>desc_curr</name><operator>.</operator><name>end_offset</name></name> <operator>-</operator> <name><name>desc_curr</name><operator>.</operator><name>start_offset</name></name><operator>)</operator> <operator>*</operator> <name>percent</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>timeToDownload</name> <init>= <expr><operator>(</operator><name>cueBytes</name> <operator>*</operator> <literal type="number">8.0</literal><operator>)</operator> <operator>/</operator> <name>bps</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sec_downloaded</name> <operator>+=</operator> <operator>(</operator><name>cue_nano</name> <operator>/</operator> <name>nano_seconds_per_second</name><operator>)</operator> <operator>-</operator> <name>timeToDownload</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sec_to_download</name> <operator>+=</operator> <name>timeToDownload</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>&gt;=</operator> <name>end_time_ns</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>desc_end_time_sec</name> <init>= <expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>percent_to_sub</name> <init>= <expr><name>search_sec</name> <operator>/</operator> <operator>(</operator><name>desc_end_time_sec</name> <operator>-</operator> <name>time_sec</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sec_downloaded</name> <operator>=</operator> <name>percent_to_sub</name> <operator>*</operator> <name>sec_downloaded</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sec_to_download</name> <operator>=</operator> <name>percent_to_sub</name> <operator>*</operator> <operator>*</operator><name>sec_to_download</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sec_downloaded</name> <operator>+</operator> <operator>*</operator><name>buffer</name><operator>)</operator> <operator>&lt;=</operator> <name>min_buffer</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>desc_curr</name> <operator>=</operator> <call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name><name>desc_curr</name><operator>.</operator><name>start_time_ns</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>desc_bytes</name> <init>= <expr><name><name>desc_curr</name><operator>.</operator><name>end_offset</name></name> <operator>-</operator> <name><name>desc_curr</name><operator>.</operator><name>start_offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>desc_ns</name> <init>= <expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name><name>desc_curr</name><operator>.</operator><name>start_time_ns</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>desc_sec</name> <init>= <expr><name>desc_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>bits</name> <init>= <expr><operator>(</operator><name>desc_bytes</name> <operator>*</operator> <literal type="number">8.0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>time_to_download</name> <init>= <expr><name>bits</name> <operator>/</operator> <name>bps</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sec_downloaded</name> <operator>+=</operator> <name>desc_sec</name> <operator>-</operator> <name>time_to_download</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sec_to_download</name> <operator>+=</operator> <name>time_to_download</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>&gt;=</operator> <name>end_time_ns</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>desc_end_time_sec</name> <init>= <expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>percent_to_sub</name> <init>= <expr><name>search_sec</name> <operator>/</operator> <operator>(</operator><name>desc_end_time_sec</name> <operator>-</operator> <name>time_sec</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sec_downloaded</name> <operator>=</operator> <name>percent_to_sub</name> <operator>*</operator> <name>sec_downloaded</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sec_to_download</name> <operator>=</operator> <name>percent_to_sub</name> <operator>*</operator> <operator>*</operator><name>sec_to_download</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sec_downloaded</name> <operator>+</operator> <operator>*</operator><name>buffer</name><operator>)</operator> <operator>&lt;=</operator> <name>min_buffer</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sec_downloaded</name> <operator>+</operator> <operator>*</operator><name>buffer</name><operator>)</operator> <operator>&lt;=</operator> <name>min_buffer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>desc_curr</name> <operator>=</operator> <call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>desc_curr</name><operator>.</operator><name>end_time_ns</name></name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <operator>*</operator><name>buffer</name> <operator>+</operator> <name>sec_downloaded</name></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>webm_dash_manifest_compute_bandwidth</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>cues_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>bandwidth</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>prebuffer_ns</name> <init>= <expr><literal type="number">1000000000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>time_ns</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>index_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>nano_seconds_per_second</name> <init>= <expr><literal type="number">1000000000.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>prebuffered_ns</name> <init>= <expr><name>time_ns</name> <operator>+</operator> <name>prebuffer_ns</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>prebuffer_bytes</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>temp_prebuffer_ns</name> <init>= <expr><name>prebuffer_ns</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pre_bytes</name></decl>, <decl><type ref="prev"/><name>pre_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>pre_sec</name></decl>, <decl><type ref="prev"/><name>prebuffer</name></decl>, <decl><type ref="prev"/><name>bits_per_second</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CueDesc</name></type> <name>desc_beg</name> <init>= <expr><call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>time_ns</name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CueDesc</name></type> <name>desc_end</name> <init>= <expr><name>desc_beg</name></expr></init></decl>;</decl_stmt>



<while>while <condition>(<expr><name><name>desc_end</name><operator>.</operator><name>start_time_ns</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name> <operator>&lt;</operator> <name>prebuffered_ns</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prebuffer_bytes</name> <operator>+=</operator> <name><name>desc_end</name><operator>.</operator><name>end_offset</name></name> <operator>-</operator> <name><name>desc_end</name><operator>.</operator><name>start_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_prebuffer_ns</name> <operator>-=</operator> <name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name><name>desc_end</name><operator>.</operator><name>start_time_ns</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>desc_end</name> <operator>=</operator> <call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>desc_end</name><operator>.</operator><name>start_time_ns</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name> <operator>&gt;=</operator> <name>prebuffered_ns</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bits_per_second</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>pre_bytes</name> <operator>=</operator> <name><name>desc_end</name><operator>.</operator><name>end_offset</name></name> <operator>-</operator> <name><name>desc_end</name><operator>.</operator><name>start_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pre_ns</name> <operator>=</operator> <name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name><name>desc_end</name><operator>.</operator><name>start_time_ns</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pre_sec</name> <operator>=</operator> <name>pre_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prebuffer_bytes</name> <operator>+=</operator>
<name>pre_bytes</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>temp_prebuffer_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name><operator>)</operator> <operator>/</operator> <name>pre_sec</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>prebuffer</name> <operator>=</operator> <name>prebuffer_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name></expr>;</expr_stmt>


<expr_stmt><expr><name>bits_per_second</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>desc_bytes</name> <init>= <expr><name><name>desc_end</name><operator>.</operator><name>end_offset</name></name> <operator>-</operator> <name><name>desc_beg</name><operator>.</operator><name>start_offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>desc_ns</name> <init>= <expr><name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name> <operator>-</operator> <name><name>desc_beg</name><operator>.</operator><name>start_time_ns</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>desc_sec</name> <init>= <expr><name>desc_ns</name> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>calc_bits_per_second</name> <init>= <expr><operator>(</operator><name>desc_bytes</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator> <operator>/</operator> <name>desc_sec</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>double</name></type> <name>percent</name> <init>= <expr><operator>(</operator><name>desc_bytes</name> <operator>-</operator> <name>prebuffer_bytes</name><operator>)</operator> <operator>/</operator> <name>desc_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>mod_bits_per_second</name> <init>= <expr><name>calc_bits_per_second</name> <operator>*</operator> <name>percent</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prebuffer</name> <operator>&lt;</operator> <name>desc_sec</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>search_sec</name> <init>=
<expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name> <operator>*</operator> <name><name>matroska</name><operator>-&gt;</operator><name>time_scale</name></name><operator>)</operator> <operator>/</operator> <name>nano_seconds_per_second</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int64_t</name></type> <name>bps</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>mod_bits_per_second</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>min_buffer</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>buffer</name> <init>= <expr><name>prebuffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>sec_to_download</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>buffer_size_after_time_downloaded</name><argument_list>(<argument><expr><name>prebuffered_ns</name></expr></argument>, <argument><expr><name>search_sec</name></expr></argument>, <argument><expr><name>bps</name></expr></argument>,
<argument><expr><name>min_buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_to_download</name></expr></argument>,
<argument><expr><name>s</name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bits_per_second</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>bps</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>desc_end</name> <operator>=</operator> <call><name>get_cue_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>desc_end</name><operator>.</operator><name>end_time_ns</name></name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>desc_end</name><operator>.</operator><name>start_time_ns</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bandwidth</name> <operator>&lt;</operator> <name>bits_per_second</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bandwidth</name> <operator>=</operator> <name>bits_per_second</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>bandwidth</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>webm_dash_manifest_cues</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>init_range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EbmlList</name> <modifier>*</modifier></type><name>seekhead_list</name> <init>= <expr><operator>&amp;</operator><name><name>matroska</name><operator>-&gt;</operator><name>seekhead</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaSeekhead</name> <modifier>*</modifier></type><name>seekhead</name> <init>= <expr><name><name>seekhead_list</name><operator>-&gt;</operator><name>elem</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>cues_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>cues_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>before_pos</name></decl>, <decl><type ref="prev"/><name>bandwidth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seekhead_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>seekhead</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>MATROSKA_ID_CUES</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>seekhead_list</name><operator>-&gt;</operator><name>nb_elem</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>before_pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cues_start</name> <operator>=</operator> <name><name>seekhead</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>+</operator> <name><name>matroska</name><operator>-&gt;</operator><name>segment_start</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cues_start</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>cues_length</name></decl>, <decl><type ref="prev"/><name>cues_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes_read</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_read</name> <operator>=</operator> <call><name>ebml_read_num</name> <argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cues_id</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cues_id</name> <operator>!=</operator> <operator>(</operator><name>MATROSKA_ID_CUES</name> <operator>&amp;</operator> <literal type="number">0xfffffff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>bytes_read</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>bytes_read</name></expr> </then><else>: <expr><name>AVERROR_INVALIDDATA</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bytes_read</name> <operator>=</operator> <call><name>ebml_read_length</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cues_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>bytes_read</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cues_end</name> <operator>=</operator> <name>cues_start</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <name>bytes_read</name> <operator>+</operator> <name>cues_length</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>before_pos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cues_start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>cues_end</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>matroska_parse_cues</name><argument_list>(<argument><expr><name>matroska</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>CUES_START</name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>CUES_END</name></expr></argument>, <argument><expr><name>cues_end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>cues_start</name> <operator>&lt;=</operator> <name>init_range</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>INITIALIZATION_RANGE</name></expr></argument>, <argument><expr><name>cues_start</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>bandwidth</name> <operator>=</operator> <call><name>webm_dash_manifest_compute_bandwidth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>cues_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bandwidth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>BANDWIDTH</name></expr></argument>, <argument><expr><name>bandwidth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>CLUSTER_KEYFRAME</name></expr></argument>, <argument><expr><call><name>webm_clusters_start_with_keyframe</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>end</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>,
<argument><expr><literal type="string">"%"</literal> <name>PRId64</name><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>index_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timestamp</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>i</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name> <operator>-</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ret</name> <operator>==</operator> <literal type="number">20</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nb_index_entries</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"timestamp too long.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>CUE_TIMESTAMPS</name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>AV_DICT_DONT_STRDUP_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>webm_dash_manifest_read_header</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>matroska_read_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>init_range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaTrack</name> <modifier>*</modifier></type><name>tracks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatroskaDemuxContext</name> <modifier>*</modifier></type><name>matroska</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to read file headers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>matroska_read_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"No streams found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>is_live</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>av_asprintf</name><argument_list>(<argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>DURATION</name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>AV_DICT_DONT_STRDUP_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>init_range</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>INITIALIZATION_RANGE</name></expr></argument>, <argument><expr><name>init_range</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>url</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>FILENAME</name></expr></argument>, <argument><expr><ternary><condition><expr><name>buf</name></expr> ?</condition><then> <expr><operator>++</operator><name>buf</name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>url</name></name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>tracks</name> <operator>=</operator> <name><name>matroska</name><operator>-&gt;</operator><name>tracks</name><operator>.</operator><name>elem</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>TRACK_NUMBER</name></expr></argument>, <argument><expr><name><name>tracks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>matroska</name><operator>-&gt;</operator><name>is_live</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>webm_dash_manifest_cues</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>init_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error parsing Cues\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>matroska</name><operator>-&gt;</operator><name>bandwidth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>metadata</name></expr></argument>, <argument><expr><name>BANDWIDTH</name></expr></argument>,
<argument><expr><name><name>matroska</name><operator>-&gt;</operator><name>bandwidth</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>webm_dash_manifest_read_packet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>AVERROR_EOF</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(MatroskaDemuxContext, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"live"</literal></expr>, <expr><literal type="string">"flag indicating that the input is a live file that only has the headers."</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>is_live</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bandwidth"</literal></expr>, <expr><literal type="string">"bandwidth of this stream to be specified in the DASH manifest."</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>bandwidth</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>webm_dash_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"WebM DASH Manifest demuxer"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVInputFormat</name></type> <name>ff_matroska_demuxer</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"matroska,webm"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Matroska / WebM"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>extensions</name> <operator>=</operator> <literal type="string">"mkv,mk3d,mka,mks"</literal></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>read_probe</name> <operator>=</operator> <name>matroska_probe</name></expr>,
<expr><operator>.</operator><name>read_header</name> <operator>=</operator> <name>matroska_read_header</name></expr>,
<expr><operator>.</operator><name>read_packet</name> <operator>=</operator> <name>matroska_read_packet</name></expr>,
<expr><operator>.</operator><name>read_close</name> <operator>=</operator> <name>matroska_read_close</name></expr>,
<expr><operator>.</operator><name>read_seek</name> <operator>=</operator> <name>matroska_read_seek</name></expr>,
<expr><operator>.</operator><name>mime_type</name> <operator>=</operator> <literal type="string">"audio/webm,audio/x-matroska,video/webm,video/x-matroska"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVInputFormat</name></type> <name>ff_webm_dash_manifest_demuxer</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"webm_dash_manifest"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"WebM DASH Manifest"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MatroskaDemuxContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>read_header</name> <operator>=</operator> <name>webm_dash_manifest_read_header</name></expr>,
<expr><operator>.</operator><name>read_packet</name> <operator>=</operator> <name>webm_dash_manifest_read_packet</name></expr>,
<expr><operator>.</operator><name>read_close</name> <operator>=</operator> <name>matroska_read_close</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>webm_dash_class</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
