<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavformat\mxfdec.c">












































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/aes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mathematics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavcodec/bytestream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/parseutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/timecode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mxf.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXF_MAX_CHUNK_SIZE</name></cpp:macro> <cpp:value>(32 &lt;&lt; 20)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{
<decl><name>Header</name></decl>,
<decl><name>BodyPartition</name></decl>,
<decl><name>Footer</name></decl>
}</block></enum></type> <name>MXFPartitionType</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
<decl><name>OP1a</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>OP1b</name></decl>,
<decl><name>OP1c</name></decl>,
<decl><name>OP2a</name></decl>,
<decl><name>OP2b</name></decl>,
<decl><name>OP2c</name></decl>,
<decl><name>OP3a</name></decl>,
<decl><name>OP3b</name></decl>,
<decl><name>OP3c</name></decl>,
<decl><name>OPAtom</name></decl>,
<decl><name>OPSONYOpt</name></decl>, 
}</block></enum></type> <name>MXFOP</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
<decl><name>UnknownWrapped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>FrameWrapped</name></decl>,
<decl><name>ClipWrapped</name></decl>,
}</block></enum></type> <name>MXFWrappingScheme</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFPartition</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>closed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>complete</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPartitionType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>previous_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>this_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>essence_offset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int64_t</name></type> <name>essence_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>kag_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>header_byte_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>index_byte_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pack_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pack_ofs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int64_t</name></type> <name>body_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>first_essence_klv</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFPartition</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFCryptoContext</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>source_container_ul</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFCryptoContext</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFStructuralComponent</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>source_package_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>source_package_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>data_definition_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>start_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>source_track_id</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFStructuralComponent</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFSequence</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>data_definition_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>structural_components_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>structural_components_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>origin</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFSequence</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFTimecodeComponent</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>drop_frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>start_frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>AVRational</name></name></type> <name>rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVTimecode</name></type> <name>tc</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFTimecodeComponent</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>input_segment_ref</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFPulldownComponent</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>structural_components_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>structural_components_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>duration</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFEssenceGroup</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFTaggedValue</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFSequence</name> <modifier>*</modifier></type><name>sequence</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UID</name></type> <name>sequence_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>track_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>track_number</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>edit_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>intra_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>sample_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>original_duration</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>index_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFWrappingScheme</name></type> <name>wrapping</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edit_units_per_packet</name></decl>;</decl_stmt> 
}</block></struct></type> <name>MXFTrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFDescriptor</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>essence_container_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>essence_codec_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>codec_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>sample_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>aspect_ratio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>frame_layout</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>video_line_map</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXF_FIELD_DOMINANCE_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXF_FIELD_DOMINANCE_FF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXF_FIELD_DOMINANCE_FL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>field_dominance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>channels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_per_sample</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>duration</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>component_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>horiz_subsampling</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vert_subsampling</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>sub_descriptors_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sub_descriptors_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linked_track_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>extradata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extradata_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>pix_fmt</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFDescriptor</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFIndexTableSegment</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edit_unit_byte_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>index_edit_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>index_start_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>index_duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>temporal_offset_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>flag_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>stream_offset_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_index_entries</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFIndexTableSegment</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFPackage</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>package_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>package_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>tracks_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tracks_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UID</name></type> <name>descriptor_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>comment_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>comment_count</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFPackage</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFEssenceContainerData</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>package_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>package_ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFEssenceContainerData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFMetadataSet</name> <block>{
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFMetadataSet</name>;</typedef>


<typedef>typedef <type><struct>struct <name>MXFIndexTable</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_ptses</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int64_t</name></type> <name>first_dts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>ptses</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>nb_segments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier><modifier>*</modifier></type><name>segments</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>AVIndexEntry</name> <modifier>*</modifier></type><name>fake_index</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>offsets</name></decl>;</decl_stmt> 
}</block></struct></type> <name>MXFIndexTable</name>;</typedef>

<typedef>typedef <type><struct>struct <name>MXFContext</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>partitions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>partitions_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFOP</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>packages_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>packages_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>essence_container_data_refs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>essence_container_data_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier><modifier>*</modifier></type><name>metadata_sets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>metadata_sets_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>AVAES</name></name> <modifier>*</modifier></type><name>aesc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>local_tags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>local_tags_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>footer_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>current_klv_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>run_in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>current_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parsing_backward</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>last_forward_tell</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_forward_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_index_tables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>index_tables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eia608_extract</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFContext</name>;</typedef>


<typedef>typedef <function_decl><type><name>int</name></type> <name>MXFMetadataReadFunc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>MXFMetadataReadTableEntry</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>UID</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFMetadataReadFunc</name> <modifier>*</modifier></type><name>read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctx_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>MXFMetadataReadTableEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_close</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_header_partition_pack_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_essence_element_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_avid_essence_element_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_canopus_essence_element_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_system_item_key_cp</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_system_item_key_gc</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x14</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_klv_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_crypto_source_container_ul</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_encrypted_triplet_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x07</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x7e</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_encrypted_essence_container</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x07</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0b</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_random_index_pack_key</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x11</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_sony_mpeg4_extradata</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_avid_project_name</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xa5</literal></expr>,<expr><literal type="number">0xfb</literal></expr>,<expr><literal type="number">0x7b</literal></expr>,<expr><literal type="number">0x25</literal></expr>,<expr><literal type="number">0xf6</literal></expr>,<expr><literal type="number">0x15</literal></expr>,<expr><literal type="number">0x94</literal></expr>,<expr><literal type="number">0xb9</literal></expr>,<expr><literal type="number">0x62</literal></expr>,<expr><literal type="number">0xfc</literal></expr>,<expr><literal type="number">0x37</literal></expr>,<expr><literal type="number">0x17</literal></expr>,<expr><literal type="number">0x49</literal></expr>,<expr><literal type="number">0x2d</literal></expr>,<expr><literal type="number">0x42</literal></expr>,<expr><literal type="number">0xbf</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_jp2k_rsiz</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_indirect_value_utf16le</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x4c</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x10</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>mxf_indirect_value_utf16be</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x42</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x10</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_KLV_KEY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!memcmp(x, y, sizeof(y)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mxf_free_metadataset</name><parameter_list>(<parameter><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier><modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freectx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Descriptor</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFDescriptor</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>extradata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MultipleDescriptor</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFDescriptor</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>sub_descriptors_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Sequence</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFSequence</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>structural_components_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EssenceGroup</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFEssenceGroup</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>structural_components_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SourcePackage</name></expr>:</case>
<case>case <expr><name>MaterialPackage</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFPackage</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>tracks_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFPackage</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFPackage</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>comment_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TaggedValue</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFTaggedValue</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFTaggedValue</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Track</name></expr>:</case>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFTrack</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>IndexTableSegment</name></expr>:</case>
<expr_stmt><expr><name>seg</name> <operator>=</operator> <operator>(</operator><name>MXFIndexTableSegment</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seg</name><operator>-&gt;</operator><name>temporal_offset_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seg</name><operator>-&gt;</operator><name>flag_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>seg</name><operator>-&gt;</operator><name>stream_offset_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>freectx</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>klv_decode_ber_length</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>size</name> <init>= <expr><call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>bytes_num</name> <init>= <expr><name>size</name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes_num</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>bytes_num</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_sync</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>b</name> <operator>!=</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>i</name> <operator>==</operator> <name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>klv_read_packet</name><parameter_list>(<parameter><decl><type><name>KLVPacket</name> <modifier>*</modifier></type><name>klv</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mxf_read_sync</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>mxf_klv_key</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>klv</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>klv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_klv_key</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>klv</name><operator>-&gt;</operator><name>key</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>length</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>klv</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name>INT64_MAX</name> <operator>-</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>klv</name><operator>-&gt;</operator><name>next_klv</name></name> <operator>=</operator> <name>pos</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_get_stream_index</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>KLVPacket</name> <modifier>*</modifier></type><name>klv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>body_sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>track</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>body_sid</name> <operator>||</operator> <operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>body_sid</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>klv</name><operator>-&gt;</operator><name>key</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mxf_essence_element_key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>track_number</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>track_number</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_body_sid_by_absolute_offset</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pack_ofs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>b</name> <operator>-</operator> <name>a</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>+</operator> <name>b</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_ofs</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>pack_ofs</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pack_ofs</name> <operator>&lt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>a</name></expr>]</index></name><operator>.</operator><name>body_sid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_get_eia608_packet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cdp_identifier</name></decl>, <decl><type ref="prev"/><name>cdp_length</name></decl>, <decl><type ref="prev"/><name>cdp_footer_id</name></decl>, <decl><type ref="prev"/><name>ccdata_id</name></decl>, <decl><type ref="prev"/><name>cc_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line_num</name></decl>, <decl><type ref="prev"/><name>sample_coding</name></decl>, <decl><type ref="prev"/><name>sample_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>did</name></decl>, <decl><type ref="prev"/><name>sdid</name></decl>, <decl><type ref="prev"/><name>data_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"unsupported multiple ANC packets (%d) per KLV packet\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error reading s436m packet %"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>line_num</name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>sample_coding</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_count</name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>-=</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <name>sample_count</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line_num</name> <operator>!=</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>line_num</name> <operator>!=</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sample_coding</name> <operator>==</operator> <literal type="number">7</literal> <operator>||</operator> <name>sample_coding</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>sample_coding</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"unsupported s436m 10 bit sample coding\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>avio_rb32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_rb32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>did</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sdid</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>did</name> <operator>!=</operator> <literal type="number">0x61</literal> <operator>||</operator> <name>sdid</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"unsupported did or sdid: %x %x\n"</literal></expr></argument>, <argument><expr><name>did</name></expr></argument>, <argument><expr><name>sdid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cdp_identifier</name> <operator>=</operator> <call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>cdp_identifier</name> <operator>!=</operator> <literal type="number">0x9669</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong cdp identifier %x\n"</literal></expr></argument>, <argument><expr><name>cdp_identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cdp_length</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>ccdata_id</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ccdata_id</name> <operator>!=</operator> <literal type="number">0x72</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong cdp data section %x\n"</literal></expr></argument>, <argument><expr><name>ccdata_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cc_count</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_get_packet</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>cc_count</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cdp_length</name> <operator>-</operator> <literal type="number">9</literal> <operator>-</operator> <literal type="number">4</literal> <operator>&lt;</operator> <name>cc_count</name> <operator>*</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong cdp size %d cc count %d\n"</literal></expr></argument>, <argument><expr><name>cdp_length</name></expr></argument>, <argument><expr><name>cc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>data_length</name> <operator>-</operator> <literal type="number">9</literal> <operator>-</operator> <literal type="number">4</literal> <operator>-</operator> <name>cc_count</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cdp_footer_id</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cdp_footer_id</name> <operator>!=</operator> <literal type="number">0x74</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong cdp footer section %x\n"</literal></expr></argument>, <argument><expr><name>cdp_footer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_get_d10_aes3_packet</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf_ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">61444</literal></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>av_get_packet</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>length</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data_ptr</name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_ptr</name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt> 
<for>for <control>(<init>;</init> <condition><expr><name>end_ptr</name> <operator>-</operator> <name>buf_ptr</name> <operator>&gt;=</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</condition> <incr/>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>sample</name> <init>= <expr><call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name> <operator>==</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bytestream_put_le24</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>sample</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bytestream_put_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>sample</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buf_ptr</name> <operator>+=</operator> <literal type="number">32</literal> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt> 
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_shrink_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>data_ptr</name> <operator>-</operator> <name><name>pkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_decrypt_triplet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>KLVPacket</name> <modifier>*</modifier></type><name>klv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>checkv</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x4b</literal></expr>, <expr><literal type="number">0x43</literal></expr>, <expr><literal type="number">0x48</literal></expr>, <expr><literal type="number">0x55</literal></expr>, <expr><literal type="number">0x4b</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>klv</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>orig_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>plaintext_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>ivec</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>tmpbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>key</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>keylen</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name> <operator>=</operator> <call><name>av_aes_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_aes_init</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>plaintext_size</name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>klv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>klv</name></expr></argument>, <argument><expr><name>mxf_essence_element_key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>body_sid</name> <operator>=</operator> <call><name>find_body_sid_by_absolute_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>klv</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>mxf_get_stream_index</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>klv</name></expr></argument>, <argument><expr><name>body_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orig_size</name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>orig_size</name> <operator>&lt;</operator> <name>plaintext_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>klv_decode_ber_length</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">32</literal> <operator>||</operator> <name>size</name> <operator>-</operator> <literal type="number">32</literal> <operator>&lt;</operator> <name>orig_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>ivec</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_aes_crypt</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr></argument>, <argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ivec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>checkv</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"probably incorrect decryption key\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>av_get_packet</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>size</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>plaintext_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>plaintext_size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_aes_crypt</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pkt</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plaintext_size</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>pkt</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plaintext_size</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>ivec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_shrink_packet</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>orig_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_primer_pack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>item_num</name> <init>= <expr><call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>item_len</name> <init>= <expr><call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item_len</name> <operator>!=</operator> <literal type="number">18</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"Primer pack item length %d"</literal></expr></argument>, <argument><expr><name>item_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>item_num</name> <operator>&gt;</operator> <literal type="number">65536</literal> <operator>||</operator> <name>item_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"item_num %d is too large\n"</literal></expr></argument>, <argument><expr><name>item_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Multiple primer packs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name>item_num</name></expr></argument>, <argument><expr><name>item_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags_count</name></name> <operator>=</operator> <name>item_num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name></expr></argument>, <argument><expr><name>item_num</name><operator>*</operator><name>item_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_partition_pack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>partition</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_part</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>footer_partition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nb_essence_containers</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmp_part</name> <operator>=</operator> <call><name>av_realloc_array</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_part</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <name>tmp_part</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name></expr>]</index></name></expr></argument>,
<argument><expr><operator>(</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name> <operator>-</operator> <name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>partition</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>partition</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>partition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>pack_length</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>klv_offset</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>pack_ofs</name></name> <operator>=</operator> <name>klv_offset</name></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name><name>uid</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>Header</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BodyPartition</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>Footer</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown partition type %i\n"</literal></expr></argument>, <argument><expr><name><name>uid</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></switch>


<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name><name>partition</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>Footer</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>uid</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>complete</name></name> <operator>=</operator> <name><name>uid</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>this_partition</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>footer_partition</name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>header_byte_count</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>index_byte_count</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>body_offset</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed reading UID\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nb_essence_containers</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>Header</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%08x.%08x.%08x.%08x"</literal></expr></argument>, <argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"operational_pattern_ul"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>this_partition</name></name> <operator>&amp;&amp;</operator>
<name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>==</operator> <name><name>partition</name><operator>-&gt;</operator><name>this_partition</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"PreviousPartition equal to ThisPartition %"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>prev</name> <init>=
<expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>last_forward_partition</name></name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>this_partition</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>==</operator> <name><name>partition</name><operator>-&gt;</operator><name>this_partition</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Overriding PreviousPartition with %"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>footer_partition</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>!=</operator> <name>footer_partition</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"inconsistent FooterPartition value: %"</literal><name>PRIu64</name><literal type="string">" != %"</literal><name>PRIu64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name></expr></argument>, <argument><expr><name>footer_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>=</operator> <name>footer_partition</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>,
<argument><expr><literal type="string">"PartitionPack: ThisPartition = 0x%"</literal><name>PRIX64</name>
<literal type="string">", PreviousPartition = 0x%"</literal><name>PRIX64</name><literal type="string">", "</literal>
<literal type="string">"FooterPartition = 0x%"</literal><name>PRIX64</name><literal type="string">", IndexSID = %i, BodySID = %i\n"</literal></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>this_partition</name></name></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name></expr></argument>, <argument><expr><name>footer_partition</name></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>, <argument><expr><name><name>partition</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>&amp;&amp;</operator>
<name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>&gt;=</operator> <name>klv_offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"PreviousPartition points to this partition or forward\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP1a</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP1b</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP1c</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP2a</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP2b</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP2c</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP3a</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP3b</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP3c</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">64</literal><operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OPSONYOpt</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x10</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>nb_essence_containers</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MXFOP</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>nb_essence_containers</name></expr> ?</condition><then> <expr><name>OP1a</name></expr> </then><else>: <expr><name>OPAtom</name></expr></else></ternary></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"\"OPAtom\" with %"</literal><name>PRIu32</name><literal type="string">" ECs - assuming %s\n"</literal></expr></argument>,
<argument><expr><name>nb_essence_containers</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>op</name> <operator>==</operator> <name>OP1a</name></expr> ?</condition><then> <expr><literal type="string">"OP1a"</literal></expr> </then><else>: <expr><literal type="string">"OPAtom"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OPAtom</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operational pattern: %02xh %02xh - guessing OP1a\n"</literal></expr></argument>, <argument><expr><name><name>op</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>op</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>OP1a</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"invalid KAGSize %"</literal><name>PRId32</name><literal type="string">" - guessing "</literal></expr></argument>,
<argument><expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>OPSONYOpt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRId32</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>partition</name><operator>-&gt;</operator><name>kag_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_add_metadata_set</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>metadata_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>av_realloc_array</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>]</index></name> <operator>=</operator> <name>metadata_set</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_cryptographic_context</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFCryptoContext</name> <modifier>*</modifier></type><name>cryptocontext</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>mxf_crypto_source_container_ul</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>cryptocontext</name><operator>-&gt;</operator><name>source_container_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_strong_ref_array</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>UID</name> <modifier>*</modifier><modifier>*</modifier></type><name>refs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>refs</name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><operator>*</operator><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>refs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>refs</name></expr></argument>, <argument><expr><operator>*</operator><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>mxf_read_utf16_string</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>be</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buf_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>size</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name><operator>/</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf_size</name> <operator>=</operator> <name>size</name> <operator>+</operator> <name>size</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>be</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>avio_get_str16be</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>avio_get_str16le</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STR16</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>big_endian</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int mxf_read_utf16 ##type ##_string(AVIOContext *pb, int size, char** str) { return mxf_read_utf16_string(pb, size, str, big_endian); }</cpp:value></cpp:define>




<macro><name>READ_STR16</name><argument_list>(<argument>be</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>READ_STR16</name><argument_list>(<argument>le</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>READ_STR16</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_content_storage</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x1901</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Multiple packages_refs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>packages_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x1902</literal></expr>:</case>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_refs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_source_clip</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>source_clip</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0202</literal></expr>:</case>
<expr_stmt><expr><name><name>source_clip</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1201</literal></expr>:</case>
<expr_stmt><expr><name><name>source_clip</name><operator>-&gt;</operator><name>start_position</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1101</literal></expr>:</case>

<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>source_clip</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>source_clip</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1102</literal></expr>:</case>
<expr_stmt><expr><name><name>source_clip</name><operator>-&gt;</operator><name>source_track_id</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_timecode_component</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTimecodeComponent</name> <modifier>*</modifier></type><name>mxf_timecode</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x1501</literal></expr>:</case>
<expr_stmt><expr><name><name>mxf_timecode</name><operator>-&gt;</operator><name>start_frame</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1502</literal></expr>:</case>
<expr_stmt><expr><name><name>mxf_timecode</name><operator>-&gt;</operator><name>rate</name></name> <operator>=</operator> <operator>(</operator><name>AVRational</name><operator>)</operator><block>{<expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1503</literal></expr>:</case>
<expr_stmt><expr><name><name>mxf_timecode</name><operator>-&gt;</operator><name>drop_frame</name></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_pulldown_component</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPulldownComponent</name> <modifier>*</modifier></type><name>mxf_pulldown</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0d01</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>mxf_pulldown</name><operator>-&gt;</operator><name>input_segment_ref</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_track</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x4801</literal></expr>:</case>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>track_id</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4804</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>track_number</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4802</literal></expr>:</case>
<expr_stmt><expr><call><name>mxf_read_utf16be_string</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4b01</literal></expr>:</case>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4803</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>sequence_ref</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_sequence</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFSequence</name> <modifier>*</modifier></type><name>sequence</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0202</literal></expr>:</case>
<expr_stmt><expr><name><name>sequence</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x0201</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4b02</literal></expr>:</case>
<expr_stmt><expr><name><name>sequence</name><operator>-&gt;</operator><name>origin</name></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1001</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_essence_group</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFEssenceGroup</name> <modifier>*</modifier></type><name>essence_group</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0202</literal></expr>:</case>
<expr_stmt><expr><name><name>essence_group</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x0501</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>essence_group</name><operator>-&gt;</operator><name>structural_components_refs</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>essence_group</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_package</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>package</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x4403</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>tracks_refs</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>tracks_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x4401</literal></expr>:</case>

<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_uid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4701</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>package</name><operator>-&gt;</operator><name>descriptor_ref</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x4402</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_utf16be_string</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x4406</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>comment_refs</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>comment_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_essence_container_data</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFEssenceContainerData</name> <modifier>*</modifier></type><name>essence_data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x2701</literal></expr>:</case>

<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>essence_data</name><operator>-&gt;</operator><name>package_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>essence_data</name><operator>-&gt;</operator><name>package_uid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3f06</literal></expr>:</case>
<expr_stmt><expr><name><name>essence_data</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3f07</literal></expr>:</case>
<expr_stmt><expr><name><name>essence_data</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_index_entry_array</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&lt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>segment</name><operator>-&gt;</operator><name>temporal_offset_entries</name></name><operator>=</operator><call><name>av_calloc</name><argument_list>(<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>segment</name><operator>-&gt;</operator><name>temporal_offset_entries</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>segment</name><operator>-&gt;</operator><name>flag_entries</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>segment</name><operator>-&gt;</operator><name>flag_entries</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>segment</name><operator>-&gt;</operator><name>stream_offset_entries</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>segment</name><operator>-&gt;</operator><name>stream_offset_entries</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segment</name><operator>-&gt;</operator><name>temporal_offset_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segment</name><operator>-&gt;</operator><name>flag_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>segment</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>avio_feof</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>temporal_offset_entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>flag_entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>stream_offset_entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_index_table_segment</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>segment</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x3F05</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"EditUnitByteCount %d\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3F06</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %d\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3F07</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"BodySID %d\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3F0A</literal></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"IndexEntryArray found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>mxf_read_index_entry_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x3F0B</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_edit_rate</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_edit_rate</name><operator>.</operator><name>den</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"IndexEditRate %d/%d\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>index_edit_rate</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>index_edit_rate</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3F0C</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"IndexStartPosition %"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>index_start_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3F0D</literal></expr>:</case>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"IndexDuration %"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>index_duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mxf_read_pixel_layout</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>, <decl><type ref="prev"/><name>value</name></decl>, <decl><type ref="prev"/><name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>layout</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> 

<do>do <block>{<block_content>
<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"pixel layout: code %#x\n"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>&lt;=</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>layout</name><index>[<expr><name>ofs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>layout</name><index>[<expr><name>ofs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt> 
</block_content>}</block> while <condition>(<expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do> 

<expr_stmt><expr><call><name>ff_mxf_decode_pixel_layout</name><argument_list>(<argument><expr><name>layout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_generic_descriptor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>entry_count</name></decl>, <decl><type ref="prev"/><name>entry_size</name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x3F01</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_strong_ref_array</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>sub_descriptors_refs</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>sub_descriptors_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x3002</literal></expr>:</case> 
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3004</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_container_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3005</literal></expr>:</case>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>codec_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3006</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>linked_track_id</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3201</literal></expr>:</case> 
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3203</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3202</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x320C</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>frame_layout</name></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x320D</literal></expr>:</case>
<expr_stmt><expr><name>entry_count</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entry_size</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>entry_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"VideoLineMap element size %d currently not supported\n"</literal></expr></argument>, <argument><expr><name>entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x320E</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>aspect_ratio</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>aspect_ratio</name><operator>.</operator><name>den</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3212</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name> <operator>=</operator> <call><name>avio_r8</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3301</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>component_depth</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3302</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>horiz_subsampling</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3308</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>vert_subsampling</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3D03</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>den</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3D06</literal></expr>:</case> 
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3D07</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3D01</literal></expr>:</case>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3401</literal></expr>:</case>
<expr_stmt><expr><call><name>mxf_read_pixel_layout</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>mxf_sony_mpeg4_extradata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Duplicate sony_mpeg4_extradata\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>mxf_jp2k_rsiz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>rsiz</name> <init>= <expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rsiz</name> <operator>==</operator> <name>FF_PROFILE_JPEG2000_DCINEMA_2K</name> <operator>||</operator>
<name>rsiz</name> <operator>==</operator> <name>FF_PROFILE_JPEG2000_DCINEMA_4K</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>AV_PIX_FMT_XYZ12</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_indirect_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTaggedValue</name> <modifier>*</modifier></type><name>tagged_value</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>key</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">17</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>mxf_indirect_value_utf16le</name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>mxf_read_utf16le_string</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tagged_value</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>mxf_indirect_value_utf16be</name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>mxf_read_utf16be_string</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tagged_value</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_tagged_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTaggedValue</name> <modifier>*</modifier></type><name>tagged_value</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0x5001</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_utf16be_string</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tagged_value</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0x5003</literal></expr>:</case>
<return>return <expr><call><name>mxf_read_indirect_value</name><argument_list>(<argument><expr><name>tagged_value</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_match_uid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UID</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>uid</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>mxf_get_codec_ul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>uls</name></decl></parameter>, <parameter><decl><type><name>UID</name> <modifier>*</modifier></type><name>uid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name><name>uls</name><operator>-&gt;</operator><name>uid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>mxf_match_uid</name><argument_list>(<argument><expr><name><name>uls</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><operator>*</operator><name>uid</name></expr></argument>, <argument><expr><name><name>uls</name><operator>-&gt;</operator><name>matching_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>uls</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>uls</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>mxf_resolve_strong_ref</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>UID</name> <modifier>*</modifier></type><name>strong_ref</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strong_ref</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>*</operator><name>strong_ref</name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>uid</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>type</name> <operator>==</operator> <name>AnyType</name> <operator>||</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_picture_essence_container_uls</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x07</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_JPEG2000</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x10</literal></expr>,<expr><literal type="number">0x60</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_H264</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x11</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_DNXHD</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_VC1</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x14</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_TIFF</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x15</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_DIRAC</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x1b</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_CFHD</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_PRORES</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x60</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_MPEG2VIDEO</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_MPEG2VIDEO</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>D10D11Wrap</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_DVVIDEO</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_RAWVIDEO</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>RawVWrap</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x20</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>AV_CODEC_ID_HQ_HQA</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x20</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">15</literal></expr>, <expr><name>AV_CODEC_ID_HQX</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x15</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x10</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>AV_CODEC_ID_HEVC</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x4b</literal></expr>,<expr><literal type="number">0x46</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x4d</literal></expr>,<expr><literal type="number">0x4f</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_RAWVIDEO</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_intra_only_essence_container_uls</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_MPEG2VIDEO</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_intra_only_picture_essence_coding_uls</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0A</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x32</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_H264</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x07</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_JPEG2000</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_intra_only_picture_coded_width</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0A</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x32</literal></expr>,<expr><literal type="number">0x21</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1440</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0A</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x32</literal></expr>,<expr><literal type="number">0x21</literal></expr>,<expr><literal type="number">0x02</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1440</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0A</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x32</literal></expr>,<expr><literal type="number">0x21</literal></expr>,<expr><literal type="number">0x03</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1440</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0A</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x32</literal></expr>,<expr><literal type="number">0x21</literal></expr>,<expr><literal type="number">0x04</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">1440</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_sound_essence_container_uls</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_PCM_S16LE</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>RawAWrap</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x40</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_MP2</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_PCM_S16LE</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">13</literal></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x4b</literal></expr>,<expr><literal type="number">0x46</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x41</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x4d</literal></expr>,<expr><literal type="number">0x4F</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_PCM_S16LE</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">14</literal></expr>, <expr><name>AV_CODEC_ID_AAC</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFCodecUL</name></type> <name><name>mxf_data_essence_container_uls</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr>, <expr><literal type="string">"vbi_smpte_436M"</literal></expr>, <expr><literal type="number">11</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr>, <expr><literal type="string">"vbi_vanc_smpte_436M"</literal></expr>, <expr><literal type="number">11</literal></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x13</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr> }</block></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>AV_CODEC_ID_TTML</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_CODEC_ID_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>MXFWrappingScheme</name></type> <name>mxf_get_wrapping_kind</name><parameter_list>(<parameter><decl><type><name>UID</name> <modifier>*</modifier></type><name>essence_container_ul</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>codec_ul</name></decl>;</decl_stmt>

<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_picture_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>uid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_sound_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>uid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_data_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>uid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>wrapping_indicator_pos</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>UnknownWrapped</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>essence_container_ul</name><operator>)</operator><index>[<expr><name><name>codec_ul</name><operator>-&gt;</operator><name>wrapping_indicator_pos</name></name></expr>]</index></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>codec_ul</name><operator>-&gt;</operator><name>wrapping_indicator_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RawVWrap</name></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>%</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RawAWrap</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0x03</literal> <operator>||</operator> <name>val</name> <operator>==</operator> <literal type="number">0x04</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>-=</operator> <literal type="number">0x02</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>D10D11Wrap</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0x02</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0x01</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FrameWrapped</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0x02</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ClipWrapped</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>UnknownWrapped</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_get_sorted_table_segments</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nb_sorted_segments</name></decl></parameter>, <parameter><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>sorted_segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nb_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier><modifier>*</modifier></type><name>unsorted_segments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_body_sid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>last_index_sid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>last_index_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>IndexTableSegment</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nb_segments</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nb_segments</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>unsorted_segments</name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name>nb_segments</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>unsorted_segments</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><operator>*</operator><name>sorted_segments</name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name>nb_segments</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>sorted_segments</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>sorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>unsorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nb_segments</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>IndexTableSegment</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>MXFIndexTableSegment</name><operator>*</operator><operator>)</operator><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>unsorted_segments</name><index>[<expr><name>nb_segments</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %i segment at %"</literal><name>PRId64</name><literal type="string">" missing EditUnitByteCount and IndexEntryArray\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nb_segments</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>sorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>unsorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>nb_sorted_segments</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nb_segments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>best</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>best_body_sid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>best_index_sid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>best_index_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>best_index_duration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nb_segments</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>unsorted_segments</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>&gt;</operator> <name>last_body_sid</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>last_body_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>&gt;</operator> <name>last_index_sid</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>last_body_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>==</operator> <name>last_index_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>&gt;</operator> <name>last_index_start</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>best</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>&lt;</operator> <name>best_body_sid</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>best_body_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>&lt;</operator> <name>best_index_sid</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>best_body_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>==</operator> <name>best_index_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>&lt;</operator> <name>best_index_start</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>best_body_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>==</operator> <name>best_index_sid</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>==</operator> <name>best_index_start</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>&gt;</operator> <name>best_index_duration</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_body_sid</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_index_sid</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_index_start</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_index_duration</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>best</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sorted_segments</name><operator>)</operator><index>[<expr><operator>(</operator><operator>*</operator><name>nb_sorted_segments</name><operator>)</operator><operator>++</operator></expr>]</index> <operator>=</operator> <name><name>unsorted_segments</name><index>[<expr><name>best</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_body_sid</name> <operator>=</operator> <name>best_body_sid</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_index_sid</name> <operator>=</operator> <name>best_index_sid</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_index_start</name> <operator>=</operator> <name>best_index_start</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>unsorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_absolute_bodysid_offset</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>body_sid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset_out</name></decl></parameter>, <parameter><decl><type><name>MXFPartition</name> <modifier>*</modifier><modifier>*</modifier></type><name>partition_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>last_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>m0</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>b</name> <operator>-</operator> <name>a</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m0</name> <operator>=</operator> <name>m</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>+</operator> <name>b</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>m</name> <operator>&lt;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>body_sid</name> <operator>!=</operator> <name>body_sid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&lt;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>body_offset</name> <operator>&lt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>m0</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>a</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last_p</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>last_p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>||</operator> <name><name>last_p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>&gt;</operator> <operator>(</operator><name>offset</name> <operator>-</operator> <name><name>last_p</name><operator>-&gt;</operator><name>body_offset</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>offset_out</name> <operator>=</operator> <name><name>last_p</name><operator>-&gt;</operator><name>essence_offset</name></name> <operator>+</operator> <operator>(</operator><name>offset</name> <operator>-</operator> <name><name>last_p</name><operator>-&gt;</operator><name>body_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>partition_out</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>partition_out</name> <operator>=</operator> <name>last_p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"failed to find absolute offset of %"</literal><name>PRIX64</name><literal type="string">" in BodySID %i - partial file?\n"</literal></expr></argument>,
<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>body_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>mxf_essence_container_end</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>body_sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>x</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>x</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>!=</operator> <name>body_sid</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>essence_offset</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name></expr>;</return>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_edit_unit_absolute_offset</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>index_table</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>edit_unit</name></decl></parameter>, <parameter><decl><type><name>AVRational</name></type> <name>edit_rate</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>edit_unit_out</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset_out</name></decl></parameter>, <parameter><decl><type><name>MXFPartition</name> <modifier>*</modifier><modifier>*</modifier></type><name>partition_out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset_temp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>edit_unit</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>segments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>index_edit_rate</name></expr></argument>, <argument><expr><name>edit_rate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_segments</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>index_table</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>edit_unit</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>edit_unit</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>index</name> <init>= <expr><name>edit_unit</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset_temp</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name> <operator>*</operator> <name>index</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>index</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %i segment at %"</literal><name>PRId64</name><literal type="string">" IndexEntryArray too small\n"</literal></expr></argument>,
<argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_start_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset_temp</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>stream_offset_entries</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>edit_unit_out</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>edit_unit_out</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name>edit_rate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_edit_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>mxf_absolute_bodysid_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>, <argument><expr><name>offset_temp</name></expr></argument>, <argument><expr><name>offset_out</name></expr></argument>, <argument><expr><name>partition_out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>offset_temp</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to map EditUnit %"</literal><name>PRId64</name><literal type="string">" in IndexSID %i to an offset\n"</literal></expr></argument>, <argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_compute_ptses_fake_index</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>index_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name></type> <name>max_temporal_offset</name> <init>= <expr><operator>-</operator><literal type="number">128</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>flags</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_segments</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>index_table</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>-</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"ignoring IndexSID %d, duration is too large\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>index_table</name><operator>-&gt;</operator><name>fake_index</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AVIndexEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>index_table</name><operator>-&gt;</operator><name>offsets</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index_table</name><operator>-&gt;</operator><name>fake_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index_table</name><operator>-&gt;</operator><name>offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>;</expr_stmt></block_content></block></for>




























<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_segments</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>index_table</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index_delta</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index_delta</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <name>index_delta</name></expr><operator>,</operator> <expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>temporal_offset_entries</name><index>[<expr><name>j</name></expr>]</index></name> <operator>/</operator> <name>index_delta</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>x</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"x &gt;= nb_ptses - IndexEntryCount %i &lt; IndexDuration %"</literal><name>PRId64</name><literal type="string">"?\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nb_index_entries</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>index_duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>flags</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flag_entries</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x30</literal><operator>)</operator></expr> ?</condition><then> <expr><name>AVINDEX_KEYFRAME</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"index entry %i + TemporalOffset %i = %i, which is out of bounds\n"</literal></expr></argument>,
<argument><expr><name>x</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_temporal_offset</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>max_temporal_offset</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>index_table</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>fake_index</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>timestamp</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><name>x</name></expr>]</index></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>fake_index</name><index>[<expr><name><name>index_table</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><name>x</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>flags</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>index_table</name><operator>-&gt;</operator><name>first_dts</name></name> <operator>=</operator> <operator>-</operator><name>max_temporal_offset</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_compute_index_tables</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>nb_sorted_segments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted_segments</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_get_sorted_table_segments</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nb_sorted_segments</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sorted_segments</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<name>nb_sorted_segments</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"broken or empty index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nb_sorted_segments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name> <operator>!=</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>sorted_segments</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>body_sid</name> <operator>!=</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>body_sid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"found inconsistent BodySID\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>finish_decoding_index</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate index tables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finish_decoding_index</name>;</goto>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nb_sorted_segments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name> <operator>!=</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nb_segments</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>nb_segments</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>mxf_track</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>nb_segments</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>t</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>segments</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate IndexTableSegment"</literal>
<literal type="string">" pointer array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finish_decoding_index</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_start_position</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %i starts at EditUnit %"</literal><name>PRId64</name><literal type="string">" - seeking may not work as expected\n"</literal></expr></argument>,
<argument><expr><name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name></expr></argument>, <argument><expr><name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_start_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>nb_segments</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MXFIndexTableSegment</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index_sid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <name><name>sorted_segments</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>body_sid</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_compute_ptses_fake_index</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish_decoding_index</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>track</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mxf_track</name> <operator>=</operator> <name>track</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>nb_segments</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name><name>index_edit_rate</name><operator>.</operator><name>num</name></name> <operator>||</operator> <operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name><name>index_edit_rate</name><operator>.</operator><name>den</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %i segment %i has invalid IndexEditRate\n"</literal></expr></argument>,
<argument><expr><name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mxf_track</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>index_edit_rate</name> <operator>=</operator> <name><name>mxf_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>index_duration</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>nb_segments</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"IndexSID %i segment %i has zero IndexDuration and there's more than one segment\n"</literal></expr></argument>,
<argument><expr><name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mxf_track</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"no streams?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>index_duration</name> <operator>=</operator> <name><name>mxf_track</name><operator>-&gt;</operator><name>original_duration</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>finish_decoding_index</name>:</label>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>sorted_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_is_intra_only</name><parameter_list>(<parameter><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_intra_only_essence_container_uls</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_container_ul</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>id</name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name> <operator>||</operator>
<call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_intra_only_picture_essence_coding_uls</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>id</name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_uid_to_str</name><parameter_list>(<parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>str</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%.2x"</literal></expr></argument>, <argument><expr><name><name>uid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">3</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">7</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_umid_to_str</name><parameter_list>(<parameter><decl><type><name>UID</name></type> <name>ul</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>str</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%.2X"</literal></expr></argument>, <argument><expr><name><name>ul</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%.2X"</literal></expr></argument>, <argument><expr><name><name>uid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_add_umid_metadata</name><parameter_list>(<parameter><decl><type><name>AVDictionary</name> <modifier>*</modifier><modifier>*</modifier></type><name>pm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>MXFPackage</name><modifier>*</modifier></type> <name>package</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>package</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_umid_to_str</name><argument_list>(<argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_ul</name></name></expr></argument>, <argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_uid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><name>pm</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>AV_DICT_DONT_STRDUP_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_add_timecode_metadata</name><parameter_list>(<parameter><decl><type><name>AVDictionary</name> <modifier>*</modifier><modifier>*</modifier></type><name>pm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>AVTimecode</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>AV_TIMECODE_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><name>pm</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>av_timecode_make_string</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFTimecodeComponent</name><modifier>*</modifier></type> <name>mxf_resolve_timecode_component</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>UID</name> <modifier>*</modifier></type><name>strong_ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPulldownComponent</name> <modifier>*</modifier></type><name>pulldown</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>strong_ref</name></expr></argument>, <argument><expr><name>AnyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>component</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TimecodeComponent</name></expr>:</case>
<return>return <expr><operator>(</operator><name>MXFTimecodeComponent</name><operator>*</operator><operator>)</operator><name>component</name></expr>;</return>
<case>case <expr><name>PulldownComponent</name></expr>:</case> 
<expr_stmt><expr><name>pulldown</name> <operator>=</operator> <operator>(</operator><name>MXFPulldownComponent</name><operator>*</operator><operator>)</operator><name>component</name></expr>;</expr_stmt>
<return>return <expr><call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pulldown</name><operator>-&gt;</operator><name>input_segment_ref</name></name></expr></argument>, <argument><expr><name>TimecodeComponent</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFPackage</name><modifier>*</modifier></type> <name>mxf_resolve_source_package</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>package_ul</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>package_uid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>package</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>packages_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>package</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SourcePackage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>package</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_ul</name></name></expr></argument>, <argument><expr><name>package_ul</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>package</name><operator>-&gt;</operator><name>package_uid</name></name></expr></argument>, <argument><expr><name>package_uid</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>package</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFDescriptor</name><modifier>*</modifier></type> <name>mxf_resolve_multidescriptor</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>track_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>sub_descriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descriptor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>MultipleDescriptor</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>sub_descriptors_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sub_descriptor</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>sub_descriptors_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>Descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub_descriptor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve sub descriptor strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sub_descriptor</name><operator>-&gt;</operator><name>linked_track_id</name></name> <operator>==</operator> <name>track_id</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>sub_descriptor</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>Descriptor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>descriptor</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFStructuralComponent</name><modifier>*</modifier></type> <name>mxf_resolve_essence_group_choice</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFEssenceGroup</name> <modifier>*</modifier></type><name>essence_group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>package</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>essence_group</name> <operator>||</operator> <operator>!</operator><name><name>essence_group</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>essence_group</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>essence_group</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SourceClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>package</name> <operator>=</operator> <call><name>mxf_resolve_source_package</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>descriptor_ref</name></name></expr></argument>, <argument><expr><name>Descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>descriptor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>component</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFStructuralComponent</name><modifier>*</modifier></type> <name>mxf_resolve_sourceclip</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>UID</name> <modifier>*</modifier></type><name>strong_ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>strong_ref</name></expr></argument>, <argument><expr><name>AnyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>component</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SourceClip</name></expr>:</case>
<return>return <expr><name>component</name></expr>;</return>
<case>case <expr><name>EssenceGroup</name></expr>:</case>
<return>return <expr><call><name>mxf_resolve_essence_group_choice</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>(</operator><name>MXFEssenceGroup</name><operator>*</operator><operator>)</operator> <name>component</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_package_comments</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVDictionary</name> <modifier>*</modifier><modifier>*</modifier></type><name>pm</name></decl></parameter>, <parameter><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>package</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTaggedValue</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>package</name><operator>-&gt;</operator><name>comment_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>package</name><operator>-&gt;</operator><name>comment_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>TaggedValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tag</name> <operator>||</operator> <operator>!</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name></name> <operator>||</operator> <operator>!</operator><name><name>tag</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>av_asprintf</name><argument_list>(<argument><expr><literal type="string">"comment_%s"</literal></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>key</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><name>pm</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>AV_DICT_DONT_STRDUP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_physical_source_package</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>source_track</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>physical_package</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>physical_track</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>sourceclip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTimecodeComponent</name> <modifier>*</modifier></type><name>mxf_tc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVTimecode</name></type> <name>tc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>start_position</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sourceclip</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SourceClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sourceclip</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>physical_package</name> <operator>=</operator> <call><name>mxf_resolve_source_package</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>sourceclip</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><name><name>sourceclip</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mxf_add_umid_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"reel_umid"</literal></expr></argument>, <argument><expr><name>physical_package</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>physical_package</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>physical_package</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"reel_name"</literal></expr></argument>, <argument><expr><name><name>physical_package</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>physical_package</name><operator>-&gt;</operator><name>tracks_count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>physical_track</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>physical_package</name><operator>-&gt;</operator><name>tracks_refs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>Track</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve source track strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>physical_track</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>physical_track</name><operator>-&gt;</operator><name>sequence_ref</name></name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve source track sequence strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid edit rate (%d/%d) found on structural"</literal>
<literal type="string">" component #%d, defaulting to 25/1\n"</literal></expr></argument>,
<argument><expr><name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name></name> <operator>=</operator> <operator>(</operator><name>AVRational</name><operator>)</operator><block>{<expr><literal type="number">25</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>physical_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mxf_tc</name> <operator>=</operator> <call><name>mxf_resolve_timecode_component</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>physical_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <ternary><condition><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>drop_frame</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>AV_TIMECODE_FLAG_DROPFRAME</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>start_position</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name><name>sourceclip</name><operator>-&gt;</operator><name>start_position</name></name></expr></argument>,
<argument><expr><name><name>physical_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>,
<argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>av_timecode_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>, <argument><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>rate</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>start_position</name> <operator>+</operator> <name><name>mxf_tc</name><operator>-&gt;</operator><name>start_frame</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mxf_add_timecode_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"timecode"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_add_metadata_stream</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>codec_ul</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPackage</name></type> <name>tmp_package</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_sourceclip</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>avformat_new_stream</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not allocate metadata stream\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_DATA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>track_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp_package</name><operator>.</operator><name>package_ul</name></name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp_package</name><operator>.</operator><name>package_uid</name></name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mxf_add_umid_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"file_package_umid"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_package</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"track_name"</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_data_definition_uls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"data_type"</literal></expr></argument>, <argument><expr><call><name>av_get_media_type_string</name><argument_list>(<argument><expr><name><name>codec_ul</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_structural_metadata</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>material_package</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"metadata sets count %d\n"</literal></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>packages_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>material_package</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MaterialPackage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>material_package</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>material_package</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"no material package found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mxf_add_umid_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"material_package_umid"</literal></expr></argument>, <argument><expr><name>material_package</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>material_package</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>material_package</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"material_package_name"</literal></expr></argument>, <argument><expr><name><name>material_package</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>mxf_parse_package_comments</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>material_package</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>material_package</name><operator>-&gt;</operator><name>tracks_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFPackage</name> <modifier>*</modifier></type><name>source_package</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>material_track</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>source_track</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>temp_track</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFDescriptor</name> <modifier>*</modifier></type><name>descriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFStructuralComponent</name> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTimecodeComponent</name> <modifier>*</modifier></type><name>mxf_tc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name> <modifier>*</modifier></type><name>essence_container_ul</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>codec_ul</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>container_ul</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFCodecUL</name> <modifier>*</modifier></type><name>pix_fmt_ul</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVTimecode</name></type> <name>tc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>material_track</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>material_package</name><operator>-&gt;</operator><name>tracks_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>Track</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve material track strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>component</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>material_track</name><operator>-&gt;</operator><name>sequence_ref</name></name></expr></argument>, <argument><expr><name>TimecodeComponent</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mxf_tc</name> <operator>=</operator> <operator>(</operator><name>MXFTimecodeComponent</name><operator>*</operator><operator>)</operator><name>component</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <ternary><condition><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>drop_frame</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>AV_TIMECODE_FLAG_DROPFRAME</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_timecode_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>, <argument><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>rate</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>start_frame</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mxf_add_timecode_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"timecode"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>material_track</name><operator>-&gt;</operator><name>sequence_ref</name></name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve material track sequence strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>TimecodeComponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mxf_tc</name> <operator>=</operator> <operator>(</operator><name>MXFTimecodeComponent</name><operator>*</operator><operator>)</operator><name>component</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <ternary><condition><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>drop_frame</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>AV_TIMECODE_FLAG_DROPFRAME</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_timecode_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>, <argument><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>rate</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>mxf_tc</name><operator>-&gt;</operator><name>start_frame</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mxf_add_timecode_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"timecode"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if<condition>(<expr><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"material track %d: has %d components\n"</literal></expr></argument>,
<argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_count</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>mxf_resolve_sourceclip</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>structural_components_refs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>component</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>source_package</name> <operator>=</operator> <call><name>mxf_resolve_source_package</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>source_package</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"material track %d: no corresponding source package found\n"</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>source_package</name><operator>-&gt;</operator><name>tracks_count</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>temp_track</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>source_package</name><operator>-&gt;</operator><name>tracks_refs</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>Track</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve source track strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>temp_track</name><operator>-&gt;</operator><name>track_id</name></name> <operator>==</operator> <name><name>component</name><operator>-&gt;</operator><name>source_track_id</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>source_track</name> <operator>=</operator> <name>temp_track</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>source_track</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"material track %d: no corresponding source track found\n"</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_count</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFEssenceContainerData</name> <modifier>*</modifier></type><name>essence_data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>essence_data</name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_refs</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>EssenceContainerData</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"could not resolve essence container data strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_ul</name></name></expr></argument>, <argument><expr><name><name>essence_data</name><operator>-&gt;</operator><name>package_ul</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>component</name><operator>-&gt;</operator><name>source_package_uid</name></name></expr></argument>, <argument><expr><name><name>essence_data</name><operator>-&gt;</operator><name>package_uid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <name><name>essence_data</name><operator>-&gt;</operator><name>body_sid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <name><name>essence_data</name><operator>-&gt;</operator><name>index_sid</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>source_track</name> <operator>&amp;&amp;</operator> <name>component</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>source_track</name> <operator>||</operator> <operator>!</operator><name>component</name> <operator>||</operator> <operator>!</operator><name>source_package</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_add_metadata_stream</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>material_track</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail_and_free</name>;</goto></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>source_track</name><operator>-&gt;</operator><name>sequence_ref</name></name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not resolve source track sequence strong ref\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"material track %d: DataDefinition mismatch\n"</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>avformat_new_stream</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not allocate stream\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>material_track</name><operator>-&gt;</operator><name>track_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name> <operator>=</operator> <name>source_track</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>source_package</name><operator>-&gt;</operator><name>descriptor</name></name> <operator>=</operator> <call><name>mxf_resolve_strong_ref</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>source_package</name><operator>-&gt;</operator><name>descriptor_ref</name></name></expr></argument>, <argument><expr><name>AnyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>mxf_resolve_multidescriptor</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>source_package</name><operator>-&gt;</operator><name>descriptor</name></name></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>descriptor</name> <operator>&amp;&amp;</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>duration</name></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>original_duration</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>, <argument><expr><name><name>component</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>original_duration</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name><name>component</name><operator>-&gt;</operator><name>duration</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>start_time</name></name> <operator>=</operator> <name><name>component</name><operator>-&gt;</operator><name>start_position</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid edit rate (%d/%d) found on stream #%d, "</literal>
<literal type="string">"defaulting to 25/1\n"</literal></expr></argument>,
<argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name></expr></argument>,
<argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name></name> <operator>=</operator> <operator>(</operator><name>AVRational</name><operator>)</operator><block>{<expr><literal type="number">25</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avpriv_set_pts_info</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>edit_rate</name></name> <operator>=</operator> <name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><literal type="string">"data definition ul"</literal></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_data_definition_uls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>data_definition_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name><name>codec_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>descriptor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"source track %d: stream %d, no descriptor found\n"</literal></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>track_id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><literal type="string">"essence codec ul"</literal></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><literal type="string">"essence container ul"</literal></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_container_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>essence_container_ul</name> <operator>=</operator> <operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_container_ul</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>OPAtom</name><operator>)</operator></expr> ?</condition><then> <expr><name>ClipWrapped</name></expr> </then><else>: <expr><call><name>mxf_get_wrapping_kind</name><argument_list>(<argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>source_track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"wrapping of stream %d is unknown\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>essence_container_ul</name></expr></argument>, <argument><expr><name>mxf_encrypted_essence_container</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"broken encrypted mxf file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier></type><name>metadata</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CryptoContext</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>essence_container_ul</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>MXFCryptoContext</name> <operator>*</operator><operator>)</operator><name>metadata</name><operator>)</operator><operator>-&gt;</operator><name>source_container_ul</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_codec_uls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <operator>(</operator>enum <name>AVCodecID</name><operator>)</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>codec_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_codec_uls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>codec_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <operator>(</operator>enum <name>AVCodecID</name><operator>)</operator><name><name>codec_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"%s: Universal Label: "</literal></expr></argument>,
<argument><expr><call><name>avcodec_get_name</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"%.2x"</literal></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>k</name><operator>+</operator><literal type="number">1</literal> <operator>&amp;</operator> <literal type="number">19</literal><operator>)</operator> <operator>||</operator> <name>k</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mxf_add_umid_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"file_package_umid"</literal></expr></argument>, <argument><expr><name>source_package</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>source_package</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>source_package</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"file_package_name"</literal></expr></argument>, <argument><expr><name><name>source_package</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>material_track</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>material_track</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"track_name"</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mxf_parse_physical_source_package</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>source_track</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>source_track</name><operator>-&gt;</operator><name>intra_only</name></name> <operator>=</operator> <call><name>mxf_is_intra_only</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>container_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_picture_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name><name>container_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt> 
<switch>switch <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>frame_layout</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>FullFrame</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_PROGRESSIVE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OneField</name></expr>:</case>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"OneField frame layout isn't currently supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break> 


<case>case <expr><name>MixedFields</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>SegmentedFrame</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_PROGRESSIVE</name></expr>;</expr_stmt>
<case>case <expr><name>SeparateFields</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"video_line_map: (%d, %d), field_dominance: %d\n"</literal></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>video_line_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MXF_FIELD_DOMINANCE_DEFAULT</name></expr>:</case>
<case>case <expr><name>MXF_FIELD_DOMINANCE_FF</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_TT</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MXF_FIELD_DOMINANCE_FL</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_TB</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>,
<argument><expr><literal type="string">"Field dominance %d support"</literal></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MXF_FIELD_DOMINANCE_DEFAULT</name></expr>:</case>
<case>case <expr><name>MXF_FIELD_DOMINANCE_FF</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_BB</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MXF_FIELD_DOMINANCE_FL</name></expr>:</case>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>field_order</name></name> <operator>=</operator> <name>AV_FIELD_BT</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>,
<argument><expr><literal type="string">"Field dominance %d support"</literal></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>field_dominance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>height</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Unknown frame layout type: %d\n"</literal></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>frame_layout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_PRORES</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'c'</literal></expr></argument>,<argument><expr><literal type="char">'o'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'c'</literal></expr></argument>,<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'c'</literal></expr></argument>,<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'c'</literal></expr></argument>,<argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'4'</literal></expr></argument>,<argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>,<argument><expr><literal type="char">'p'</literal></expr></argument>,<argument><expr><literal type="char">'4'</literal></expr></argument>,<argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_RAWVIDEO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>AV_PIX_FMT_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pix_fmt_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_pixel_format_uls</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <operator>(</operator>enum <name>AVPixelFormat</name><operator>)</operator><name><name>pix_fmt_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>format</name></name><operator>==</operator> <name>AV_PIX_FMT_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>ff_mxf_codec_tag_uls</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_tag</name></name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>horiz_subsampling</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<name><name>descriptor</name><operator>-&gt;</operator><name>vert_subsampling</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>descriptor</name><operator>-&gt;</operator><name>component_depth</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>AV_PIX_FMT_UYVY422</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_HEADERS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>origin</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"material_track_origin"</literal></expr></argument>, <argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>origin</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_dict_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"source_track_origin"</literal></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>origin</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>aspect_ratio</name><operator>.</operator><name>num</name></name> <operator>&amp;&amp;</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>aspect_ratio</name><operator>.</operator><name>den</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>display_aspect_ratio</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>aspect_ratio</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>container_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_sound_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name> <operator>||</operator> <operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_PCM_ALAW</name> <operator>&amp;&amp;</operator> <operator>(</operator>enum <name>AVCodecID</name><operator>)</operator><name><name>container_ul</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>AV_CODEC_ID_NONE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <operator>(</operator>enum <name>AVCodecID</name><operator>)</operator><name><name>container_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>channels</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>den</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>num</name></name> <operator>/</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>den</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_set_pts_info</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>den</name></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"invalid sample rate (%d/%d) "</literal>
<literal type="string">"found for stream #%d, time base forced to 1/48000\n"</literal></expr></argument>,
<argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>sample_rate</name><operator>.</operator><name>den</name></name></expr></argument>,
<argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_set_pts_info</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">48000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>,
<argument><expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>material_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_PCM_S16LE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>&gt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>&lt;=</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S24LE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S32LE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_PCM_S16BE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>&gt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>&lt;=</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S24BE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>bits_per_sample</name></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_PCM_S32BE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_MP2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_FULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name> <operator>=</operator> <call><name>av_get_bits_per_sample</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>AVMediaType</name></name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>container_ul</name> <operator>=</operator> <call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_data_essence_container_uls</name></expr></argument>, <argument><expr><name>essence_container_ul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name><name>container_ul</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>avcodec_get_type</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AVMEDIA_TYPE_SUBTITLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>container_ul</name><operator>-&gt;</operator><name>desc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><literal type="string">"data_type"</literal></expr></argument>, <argument><expr><name><name>container_ul</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>eia608_extract</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>container_ul</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"vbi_vanc_smpte_436M"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_SUBTITLE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_EIA_608</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ff_alloc_extradata</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata_size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata</name></name></expr></argument>, <argument><expr><name><name>descriptor</name><operator>-&gt;</operator><name>extradata_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_H264</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coded_width</name> <init>= <expr><call><name>mxf_get_codec_ul</name><argument_list>(<argument><expr><name>mxf_intra_only_picture_coded_width</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>essence_codec_ul</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>id</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>coded_width</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>coded_width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_generate_avci_extradata</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>!=</operator> <name>AVMEDIA_TYPE_DATA</name> <operator>&amp;&amp;</operator> <name><name>source_track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name>FrameWrapped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_TIMESTAMPS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track1</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>track1</name> <operator>&amp;&amp;</operator> <name><name>track1</name><operator>-&gt;</operator><name>body_sid</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track2</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>track2</name> <operator>&amp;&amp;</operator> <name><name>track1</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name><name>track2</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>&amp;&amp;</operator> <name><name>track1</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name><name>track2</name><operator>-&gt;</operator><name>wrapping</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>track1</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track1</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>=</operator> <name><name>track2</name><operator>-&gt;</operator><name>wrapping</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>track2</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track2</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>=</operator> <name><name>track1</name><operator>-&gt;</operator><name>wrapping</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"stream %d and stream %d have the same BodySID (%d) "</literal>
<literal type="string">"with different wrapping\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>track1</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>fail_and_free</name>:</label>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>mxf_timestamp_to_int64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>time</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>msecs</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>-</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">40</literal> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>msecs</name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name><name>time</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name><name>time</name><operator>.</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name><name>time</name><operator>.</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name><name>time</name><operator>.</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">59</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name><name>time</name><operator>.</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">59</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msecs</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>msecs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>av_timegm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000000</literal> <operator>+</operator> <name>msecs</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_STR_METADATA</name><parameter_list>(<parameter><type><name>pb</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((ret = mxf_read_utf16be_string(pb, size, &amp;str)) &lt; 0) return ret; av_dict_set(&amp;s-&gt;metadata, name, str, AV_DICT_DONT_STRDUP_VAL); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_UID_METADATA</name><parameter_list>(<parameter><type><name>pb</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>var</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { avio_read(pb, var, 16); if ((ret = mxf_uid_to_str(var, &amp;str)) &lt; 0) return ret; av_dict_set(&amp;s-&gt;metadata, name, str, AV_DICT_DONT_STRDUP_VAL); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TS_METADATA</name><parameter_list>(<parameter><type><name>pb</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>var</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { var = avio_rb64(pb); if (var &amp;&amp; (ret = avpriv_dict_set_timestamp(&amp;s-&gt;metadata, name, mxf_timestamp_to_int64(var))) &lt; 0) return ret; } while (0)</cpp:value></cpp:define>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_identification_metadata</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>_uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ts</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x3C01</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_STR_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"company_name"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C02</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_STR_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"product_name"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C04</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_STR_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"product_version"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C05</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_UID_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"product_uid"</literal></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C06</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_TS_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"modification_date"</literal></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C08</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_STR_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"application_platform"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C09</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_UID_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"generation_uid"</literal></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x3C0A</literal></expr>:</case>
<expr_stmt><expr><call><name>SET_UID_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"uid"</literal></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_preface_metadata</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>UID</name></type> <name>uid</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>klv_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>&gt;=</operator> <literal type="number">0x8000</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name>mxf_avid_project_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_STR_METADATA</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="string">"project_name"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MXFMetadataReadTableEntry</name></type> <name><name>mxf_metadata_read_table</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_primer_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_partition_pack</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x2f</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_preface_metadata</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x30</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_identification_metadata</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x18</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_content_storage</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AnyType</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x37</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_package</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFPackage</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>SourcePackage</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x36</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_package</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFPackage</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>MaterialPackage</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_sequence</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFSequence</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Sequence</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0E</literal></expr>,<expr><literal type="number">0x2B</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0D</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_essence_group</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFEssenceGroup</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>EssenceGroup</name></expr>}</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x11</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_source_clip</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFStructuralComponent</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>SourceClip</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x3f</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_tagged_value</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFTaggedValue</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>TaggedValue</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x44</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>MultipleDescriptor</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x42</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x28</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x29</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x48</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x47</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x51</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x5b</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x5c</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x5e</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x64</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_generic_descriptor</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFDescriptor</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Descriptor</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x3A</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_track</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFTrack</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Track</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x3B</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_track</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFTrack</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Track</name></expr> }</block></expr>, 
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x14</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_timecode_component</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFTimecodeComponent</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>TimecodeComponent</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_pulldown_component</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFPulldownComponent</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>PulldownComponent</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_cryptographic_context</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFCryptoContext</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>CryptoContext</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x10</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_index_table_segment</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFIndexTableSegment</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>IndexTableSegment</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x2b</literal></expr>,<expr><literal type="number">0x34</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x53</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x23</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>mxf_read_essence_container_data</name></expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MXFEssenceContainerData</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>EssenceContainerData</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr> }</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AnyType</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_metadataset_init</name><parameter_list>(<parameter><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>MultipleDescriptor</name></expr>:</case>
<case>case <expr><name>Descriptor</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MXFDescriptor</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>pix_fmt</name> <operator>=</operator> <name>AV_PIX_FMT_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MXFDescriptor</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator><operator>-&gt;</operator><name>duration</name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_local_tags</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>KLVPacket</name> <modifier>*</modifier></type><name>klv</name></decl></parameter>, <parameter><decl><type><name>MXFMetadataReadFunc</name> <modifier>*</modifier></type><name>read_child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctx_size</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFMetadataSet</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><ternary><condition><expr><name>ctx_size</name></expr> ?</condition><then> <expr><call><name>av_mallocz</name><argument_list>(<argument><expr><name>ctx_size</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>mxf</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>klv_end</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>klv</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>mxf_metadataset_init</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;</operator> <name>klv_end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tag</name> <init>= <expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>avio_rb16</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint64_t</name></type> <name>next</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UID</name></type> <name>uid</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"local tag %#04x size %d\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"local tag %#04x with 0 size\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>&gt;</operator> <literal type="number">0x7FFF</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>local_tags_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>local_tag</name> <init>= <expr><call><name>AV_RB16</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">18</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>local_tag</name> <operator>==</operator> <name>tag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">18</literal><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"local tag %#04x\n"</literal></expr></argument>, <argument><expr><name>local_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><literal type="string">"uid"</literal></expr></argument>, <argument><expr><name>uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ctx_size</name> <operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <literal type="number">0x3C0A</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>avio_read</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>read_child</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctx_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mxf_free_metadataset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>klv_end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctx_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mxf_free_metadataset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"local tag %#04x extends past end of local set @ %#"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>klv</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ctx_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>ctx_size</name></expr> ?</condition><then> <expr><call><name>mxf_add_metadata_set</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_is_partition_pack_key</name><parameter_list>(<parameter><decl><type><name>UID</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>mxf_header_partition_pack_key</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>key</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>key</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_klv</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>KLVPacket</name></type> <name>klv</name></decl></parameter>, <parameter><decl><type><name>MXFMetadataReadFunc</name> <modifier>*</modifier></type><name>read</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ctx_size</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>MXFMetadataSetType</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>klv</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x53</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mxf_read_local_tags</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name>read</name></expr></argument>, <argument><expr><name>ctx_size</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>next</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>klv</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"read past end of KLV @ %#"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error reading header metadata\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_seek_to_previous_partition</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>klv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>current_partition_ofs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name> <operator>||</operator>
<name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name><operator>-&gt;</operator><name>previous_partition</name></name> <operator>&lt;=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>last_forward_tell</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 


<expr_stmt><expr><name>current_partition_ofs</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name><operator>-&gt;</operator><name>pack_ofs</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name><operator>-&gt;</operator><name>previous_partition</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"seeking to previous partition\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>klv_read_packet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to read PartitionPack KLV\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mxf_is_partition_pack_key</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"PreviousPartition @ %"</literal> <name>PRIx64</name> <literal type="string">" isn't a PartitionPack\n"</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>klv</name><operator>.</operator><name>offset</name></name> <operator>&gt;=</operator> <name>current_partition_ofs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"PreviousPartition for PartitionPack @ %"</literal>
<name>PRIx64</name> <literal type="string">" indirectly points to itself\n"</literal></expr></argument>, <argument><expr><name>current_partition_ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_parse_klv</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>klv</name></expr></argument>, <argument><expr><name>mxf_read_partition_pack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_handle_essence</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>mxf_seek_to_previous_partition</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"no FooterPartition\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"seeking to FooterPartition\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_tell</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pb</name><operator>-&gt;</operator><name>seekable</name></name> <operator>&amp;</operator> <name>AVIO_SEEKABLE_NORMAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"file is not seekable - not parsing FooterPartition\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>avio_seek</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"failed to seek to FooterPartition @ 0x%"</literal> <name>PRIx64</name>
<literal type="string">" (%"</literal><name>PRId64</name><literal type="string">") - partial file?\n"</literal></expr></argument>,
<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_parse_handle_partition_or_eof</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name></expr> ?</condition><then> <expr><call><name>mxf_seek_to_previous_partition</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFWrappingScheme</name></type> <name>mxf_get_wrapping_by_body_sid</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>body_sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>track</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name>body_sid</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>UnknownWrapped</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>mxf_compute_essence_containers</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFWrappingScheme</name></type> <name>wrapping</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>body_sid</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 





<expr_stmt><expr><name>wrapping</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>OPAtom</name><operator>)</operator></expr> ?</condition><then> <expr><name>ClipWrapped</name></expr> </then><else>: <expr><call><name>mxf_get_wrapping_by_body_sid</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wrapping</name> <operator>==</operator> <name>ClipWrapped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>essence_offset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>essence_offset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>this_partition</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>essence_offset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>essence_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"partition %i: bad ThisPartition = %"</literal><name>PRIX64</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>this_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_pcm</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>AVCodecID</name></name></type> <name>codec_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><name>codec_id</name> <operator>&gt;=</operator> <name>AV_CODEC_ID_PCM_S16LE</name> <operator>&amp;&amp;</operator> <name>codec_id</name> <operator>&lt;</operator> <name>AV_CODEC_ID_PCM_S24DAUD</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MXFIndexTable</name> <modifier>*</modifier></type><name>mxf_find_index_table</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index_sid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index_sid</name> <operator>==</operator> <name>index_sid</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>mxf_compute_edit_units_per_packet</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>track</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>edit_units_per_packet</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name>ClipWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>mxf_find_index_table</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>!=</operator> <name>AVMEDIA_TYPE_AUDIO</name> <operator>||</operator>
<operator>!</operator><call><name>is_pcm</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><name>t</name> <operator>||</operator>
<name><name>t</name><operator>-&gt;</operator><name>nb_segments</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
<name><name>t</name><operator>-&gt;</operator><name>segments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>edit_unit_byte_count</name> <operator>&gt;=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>edit_units_per_packet</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>num</name></name> <operator>/</operator> <name><name>track</name><operator>-&gt;</operator><name>edit_rate</name><operator>.</operator><name>den</name></name> <operator>/</operator> <literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_handle_missing_index_segment</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>segment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>essence_partition_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edit_unit_byte_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>track</name> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name>ClipWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>IndexTableSegment</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>MXFIndexTableSegment</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>MXFIndexTableSegment</name><operator>*</operator><operator>)</operator><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>==</operator> <name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>partitions_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>body_sid</name> <operator>!=</operator> <name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>essence_partition_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>essence_partition_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_AUDIO</name> <operator>&amp;&amp;</operator> <call><name>is_pcm</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>edit_unit_byte_count</name> <operator>=</operator> <operator>(</operator><call><name>av_get_bits_per_sample</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>length</name></name> <operator>%</operator> <name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>edit_unit_byte_count</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>length</name></name> <operator>/</operator> <name><name>st</name><operator>-&gt;</operator><name>duration</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>edit_unit_byte_count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"guessing index for stream %d using edit unit byte count %d\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>edit_unit_byte_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>segment</name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_add_metadata_set</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mxf_free_metadataset</name><argument_list>(<argument><expr><operator>(</operator><name>MXFMetadataSet</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>segment</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>body_sid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>IndexTableSegment</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>edit_unit_byte_count</name></name> <operator>=</operator> <name>edit_unit_byte_count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_start_position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_duration</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>duration</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_edit_rate</name></name> <operator>=</operator> <call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>body_sid</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body_sid</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mxf_read_random_index_pack</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>file_size</name></decl>, <decl><type ref="prev"/><name>max_rip_length</name></decl>, <decl><type ref="prev"/><name>min_rip_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>klv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pb</name><operator>-&gt;</operator><name>seekable</name></name> <operator>&amp;</operator> <name>AVIO_SEEKABLE_NORMAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>file_size</name> <operator>=</operator> <call><name>avio_size</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>max_rip_length</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>file_size</name> <operator>-</operator> <name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name><operator>)</operator> <operator>/</operator> <literal type="number">105</literal><operator>)</operator> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">28</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max_rip_length</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>max_rip_length</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><name>min_rip_length</name> <operator>=</operator> <literal type="number">16</literal><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">24</literal><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>file_size</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>avio_rb32</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><expr><name>min_rip_length</name> <operator>||</operator> <name>length</name></expr></argument> &gt;</argument_list></name> <name>max_rip_length</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>file_size</name> <operator>-</operator> <name>length</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>klv_read_packet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>!</operator><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_random_index_pack_key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>!=</operator> <name>file_size</name> <operator>||</operator> <name><name>klv</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>||</operator> <operator>(</operator><name><name>klv</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator> <operator>%</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Invalid RIP KLV length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>=</operator> <call><name>avio_rb64</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>+</operator> <name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>&gt;=</operator> <name>file_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"bad FooterPartition in RIP - ignoring\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>footer_partition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_header</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>klv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>essence_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>last_forward_tell</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mxf_read_sync</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>mxf_header_partition_pack_key</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find header partition pack key\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">14</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>run_in</name></name> <operator>=</operator> <call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mxf_read_random_index_pack</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>avio_feof</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>MXFMetadataReadTableEntry</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>klv_read_packet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>mxf_parse_handle_partition_or_eof</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"read header"</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"size %"</literal><name>PRIu64</name><literal type="string">" offset %#"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_encrypted_triplet_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_essence_element_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_canopus_essence_element_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_avid_essence_element_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_system_item_key_cp</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_system_item_key_gc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"found essence prior to first PartitionPack\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name><operator>-&gt;</operator><name>first_essence_klv</name><operator>.</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name><operator>-&gt;</operator><name>first_essence_klv</name></name> <operator>=</operator> <name>klv</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>essence_offset</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>essence_offset</name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>mxf_parse_handle_essence</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>mxf_is_partition_pack_key</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_partition</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>mxf_parse_handle_partition_or_eof</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>parsing_backward</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>metadata</name> <operator>=</operator> <name>mxf_metadata_read_table</name></expr>;</init> <condition><expr><name><name>metadata</name><operator>-&gt;</operator><name>read</name></name></expr>;</condition> <incr><expr><name>metadata</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_parse_klv</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>klv</name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>read</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>ctx_size</name></name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>metadata</name><operator>-&gt;</operator><name>read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Dark key "</literal> <name>PRIxUID</name> <literal type="string">"\n"</literal></expr></argument>,
<argument><expr><call><name>UID_ARG</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>essence_offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"no essence\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>essence_offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_parse_structural_metadata</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mxf_handle_missing_index_segment</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_compute_index_tables</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"got %i index tables - only the first one (IndexSID %i) will be used\n"</literal></expr></argument>,
<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name></expr></argument>, <argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>index_sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>OPAtom</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>error_recognition</name></name> <operator>&amp;</operator> <name>AV_EF_EXPLODE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot demux OPAtom without an index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mxf_compute_essence_containers</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mxf_compute_edit_units_per_packet</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>mxf_read_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_get_next_track_edit_unit</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>current_offset</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>edit_unit_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>mxf_find_index_table</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>original_duration</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>original_duration</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>b</name> <operator>-</operator> <name>a</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>+</operator> <name>b</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>mxf_edit_unit_absolute_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>current_offset</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>edit_unit_out</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>mxf_compute_sample_count</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>edit_unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>time_base</name> <init>= <expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVRational</name></type> <name>sample_rate</name> <init>= <expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>!=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>edit_unit</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sample_rate</name><operator>.</operator><name>num</name></name> <operator>/</operator> <name><name>sample_rate</name><operator>.</operator><name>den</name></name><operator>)</operator> <operator>==</operator> <literal type="number">48000</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>av_rescale_q</name><argument_list>(<argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>remainder</name> <init>= <expr><operator>(</operator><name><name>sample_rate</name><operator>.</operator><name>num</name></name> <operator>*</operator> <name><name>time_base</name><operator>.</operator><name>num</name></name><operator>)</operator> <operator>%</operator>
<operator>(</operator><name><name>time_base</name><operator>.</operator><name>den</name></name> <operator>*</operator> <name><name>sample_rate</name><operator>.</operator><name>den</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>remainder</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"seeking detected on stream #%d with time base (%d/%d) and "</literal>
<literal type="string">"sample rate (%d/%d), audio pts won't be accurate.\n"</literal></expr></argument>,
<argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>time_base</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>time_base</name><operator>.</operator><name>den</name></name></expr></argument>,
<argument><expr><name><name>sample_rate</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>sample_rate</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>av_rescale_q</name><argument_list>(<argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>mxf_set_current_edit_unit</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>current_offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>resync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>next_ofs</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>edit_unit</name> <init>= <expr><call><name>av_rescale_q</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>, <argument><expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>new_edit_unit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>mxf_find_index_table</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name> <operator>||</operator> <name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mxf_edit_unit_absolute_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>edit_unit</name> <operator>+</operator> <name><name>track</name><operator>-&gt;</operator><name>edit_units_per_packet</name></name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_ofs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>next_ofs</name> <operator>=</operator> <call><name>mxf_essence_container_end</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>body_sid</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to compute the size of the last packet\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>next_ofs</name> <operator>&gt;</operator> <name>current_offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>next_ofs</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resync</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot find current edit unit for stream %d, invalid index?\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mxf_get_next_track_edit_unit</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>track</name></expr></argument>, <argument><expr><name>current_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_edit_unit</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>new_edit_unit</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find next track edit unit in stream %d\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_edit_unit</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>=</operator> <call><name>mxf_compute_sample_count</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>new_edit_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"edit unit sync lost on stream %d, jumping from %"</literal><name>PRId64</name><literal type="string">" to %"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>edit_unit</name></expr></argument>, <argument><expr><name>new_edit_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>mxf_set_current_edit_unit</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>current_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_set_audio_pts</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVCodecParameters</name> <modifier>*</modifier></type><name>par</name></decl></parameter>,
<parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>bits_per_sample</name> <init>= <expr><name><name>par</name><operator>-&gt;</operator><name>bits_per_coded_sample</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bits_per_sample</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bits_per_sample</name> <operator>=</operator> <call><name>av_get_bits_per_sample</name><argument_list>(<argument><expr><name><name>par</name><operator>-&gt;</operator><name>codec_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><name><name>par</name><operator>-&gt;</operator><name>channels</name></name> <operator>&lt;=</operator> <literal type="number">0</literal>
<operator>||</operator> <name>bits_per_sample</name> <operator>&lt;=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>par</name><operator>-&gt;</operator><name>channels</name></name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>bits_per_sample</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>=</operator> <call><name>mxf_compute_sample_count</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><call><name>av_rescale_q</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>, <argument><expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>+=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <operator>(</operator><name><name>par</name><operator>-&gt;</operator><name>channels</name></name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>bits_per_sample</name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_set_pts</name><parameter_list>(<parameter><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name></decl></parameter>, <parameter><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVCodecParameters</name> <modifier>*</modifier></type><name>par</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>par</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>mxf_find_index_table</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>track</name><operator>-&gt;</operator><name>index_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&amp;&amp;</operator> <name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>dts</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>+</operator> <name><name>t</name><operator>-&gt;</operator><name>first_dts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>intra_only</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>par</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>mxf_set_audio_pts</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>par</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>track</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>dts</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>track</name><operator>-&gt;</operator><name>sample_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_packet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>klv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>max_data_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pos</name> <init>= <expr><call><name>avio_tell</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name><operator>.</operator><name>length</name></name> <operator>||</operator> <name>pos</name> <operator>&gt;=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name><operator>.</operator><name>next_klv</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>klv_read_packet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>max_data_size</name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name><name>klv</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINT_KEY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"read packet"</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_TRACE</name></expr></argument>, <argument><expr><literal type="string">"size %"</literal><name>PRIu64</name><literal type="string">" offset %#"</literal><name>PRIx64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_encrypted_triplet_key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mxf_decrypt_triplet</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid encoded triplet\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>klv</name> <operator>=</operator> <name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_data_size</name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_essence_element_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_canopus_essence_element_key</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>IS_KLV_KEY</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name>mxf_avid_essence_element_key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>body_sid</name> <init>= <expr><call><name>find_body_sid_by_absolute_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>mxf_get_stream_index</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klv</name></expr></argument>, <argument><expr><name>body_sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>next_ofs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"error getting stream index %"</literal><name>PRIu32</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><call><name>AV_RB32</name><argument_list>(<argument><expr><name><name>klv</name><operator>.</operator><name>key</name></name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>skip</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>st</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>track</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>discard</name> <operator>==</operator> <name>AVDISCARD_ALL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>skip</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next_ofs</name> <operator>=</operator> <call><name>mxf_set_current_edit_unit</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>!=</operator> <name>FrameWrapped</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>next_ofs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name><name>klv</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name>pos</name> <operator>&amp;&amp;</operator> <name>max_data_size</name> <operator>&gt;</operator> <name>MXF_MAX_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>need_parsing</name></name> <operator>=</operator> <name>AVSTREAM_PARSE_FULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_request_sample</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"Huge KLV without proper index in non-frame wrapped essence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>max_data_size</name></expr></argument>, <argument><expr><name>MXF_MAX_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>=</operator> <name>next_ofs</name> <operator>-</operator> <name>pos</name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad size: %"</literal><name>PRId64</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>max_data_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>max_data_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <name>klv</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>klv</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>klv</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>klv</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>klv</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x06</literal> <operator>&amp;&amp;</operator> <name><name>klv</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x01</literal> <operator>&amp;&amp;</operator> <name><name>klv</name><operator>.</operator><name>key</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x10</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mxf_get_d10_aes3_packet</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"error reading D-10 aes3 frame\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>eia608_extract</name></name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_EIA_608</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mxf_get_eia608_packet</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_get_packet</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>stream_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>klv</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mxf_set_pts</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>klv</name><operator>.</operator><name>next_klv</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<label><name>skip</name>:</label>
<expr_stmt><expr><call><name>avio_skip</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>max_data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><ternary><condition><expr><call><name>avio_feof</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>AVERROR_EOF</name></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_close</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MXFContext</name> <modifier>*</modifier></type><name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>packages_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>essence_container_data_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>mxf_free_metadataset</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>metadata_sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>aesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>local_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fake_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_probe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AVProbeData</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>bufp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>buf_size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>end</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>bufp</name> <operator>&lt;</operator> <name>end</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>bufp</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF2</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>AV_RN32</name><argument_list>(<argument><expr><name>bufp</name></expr></argument> )</argument_list></call> <operator>==</operator> <call><name>AV_RN32</name><argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name></expr></argument> )</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>AV_RN32</name><argument_list>(<argument><expr><name>bufp</name><operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>AV_RN32</name><argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name><operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>AV_RN32</name><argument_list>(<argument><expr><name>bufp</name><operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>AV_RN32</name><argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name><operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>AV_RN16</name><argument_list>(<argument><expr><name>bufp</name><operator>+</operator><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>AV_RN16</name><argument_list>(<argument><expr><name>mxf_header_partition_pack_key</name><operator>+</operator><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVPROBE_SCORE_MAX</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bufp</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bufp</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>mxf_read_seek</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stream_index</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>sample_time</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>stream_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>seconds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFContext</name><modifier>*</modifier></type> <name>mxf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>seekpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFIndexTable</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>source_track</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>source_track</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>==</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>,
<argument><expr><call><name>av_inv_q</name><argument_list>(<argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mxf</name><operator>-&gt;</operator><name>nb_index_tables</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sample_time</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>seconds</name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>time_base</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bit_rate</name></name> <operator>*</operator> <name>seconds</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>seekpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>seekpos</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ff_update_cur_dts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>sample_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>MXFPartition</name> <modifier>*</modifier></type><name>partition</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name><name>mxf</name><operator>-&gt;</operator><name>index_tables</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>!=</operator> <name><name>source_track</name><operator>-&gt;</operator><name>index_sid</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>new_source_track</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>priv_data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_source_track</name> <operator>&amp;&amp;</operator> <name><name>new_source_track</name><operator>-&gt;</operator><name>index_sid</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>index_sid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name><name>new_source_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>source_track</name> <operator>=</operator> <name>new_source_track</name></expr>;</expr_stmt>
<expr_stmt><expr><name>st</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>sample_time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>fake_index</name></name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>AVSEEK_FLAG_ANY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>AVSEEK_FLAG_BACKWARD</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>t</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name> <operator>&amp;&amp;</operator>
<name>sample_time</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>fake_index</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>AVINDEX_KEYFRAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>ptses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sample_time</name> <operator>=</operator> <call><name>ff_index_search_timestamp</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>fake_index</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>nb_ptses</name></name></expr></argument>, <argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>sample_time</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sample_time</name> <operator>+=</operator> <name><name>t</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>sample_time</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>sample_time</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>original_duration</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>source_track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>UnknownWrapped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"attempted seek in an UnknownWrapped essence\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>mxf_edit_unit_absolute_offset</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>sample_time</name></expr></argument>, <argument><expr><name><name>source_track</name><operator>-&gt;</operator><name>edit_rate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sample_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seekpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partition</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ff_update_cur_dts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>sample_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>source_track</name><operator>-&gt;</operator><name>wrapping</name></name> <operator>==</operator> <name>ClipWrapped</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>KLVPacket</name></type> <name>klv</name> <init>= <expr><name><name>partition</name><operator>-&gt;</operator><name>first_essence_klv</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>seekpos</name> <operator>&lt;</operator> <name><name>klv</name><operator>.</operator><name>next_klv</name></name> <operator>-</operator> <name><name>klv</name><operator>.</operator><name>length</name></name> <operator>||</operator> <name>seekpos</name> <operator>&gt;=</operator> <name><name>klv</name><operator>.</operator><name>next_klv</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>mxf</name><operator>-&gt;</operator><name>fc</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted seek out of clip wrapped KLV\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <name>klv</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>mxf</name><operator>-&gt;</operator><name>current_klv_data</name></name> <operator>=</operator> <operator>(</operator><name>KLVPacket</name><operator>)</operator><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>avio_seek</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>cur_st</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>streams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MXFTrack</name> <modifier>*</modifier></type><name>cur_track</name> <init>= <expr><name><name>cur_st</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_track</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>track_edit_unit</name> <init>= <expr><name>sample_time</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>st</name> <operator>!=</operator> <name>cur_st</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mxf_get_next_track_edit_unit</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>cur_track</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>track_edit_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cur_track</name><operator>-&gt;</operator><name>sample_count</name></name> <operator>=</operator> <call><name>mxf_compute_sample_count</name><argument_list>(<argument><expr><name>mxf</name></expr></argument>, <argument><expr><name>cur_st</name></expr></argument>, <argument><expr><name>track_edit_unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"eia608_extract"</literal></expr>, <expr><literal type="string">"extract eia 608 captions from s436m track"</literal></expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MXFContext</name></expr></argument>, <argument><expr><name>eia608_extract</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>demuxer_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"mxf"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
<expr><operator>.</operator><name>category</name> <operator>=</operator> <name>AV_CLASS_CATEGORY_DEMUXER</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVInputFormat</name></type> <name>ff_mxf_demuxer</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"mxf"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"MXF (Material eXchange Format)"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFMT_SEEK_TO_PTS</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MXFContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>read_probe</name> <operator>=</operator> <name>mxf_probe</name></expr>,
<expr><operator>.</operator><name>read_header</name> <operator>=</operator> <name>mxf_read_header</name></expr>,
<expr><operator>.</operator><name>read_packet</name> <operator>=</operator> <name>mxf_read_packet</name></expr>,
<expr><operator>.</operator><name>read_close</name> <operator>=</operator> <name>mxf_read_close</name></expr>,
<expr><operator>.</operator><name>read_seek</name> <operator>=</operator> <name>mxf_read_seek</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>demuxer_class</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
