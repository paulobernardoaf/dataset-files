<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavformat\sbgdec.c">




















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/time_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SBG_SCALE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAY</name></cpp:macro> <cpp:value>(24 * 60 * 60)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAY_TS</name></cpp:macro> <cpp:value>((int64_t)DAY * AV_TIME_BASE)</cpp:value></cpp:define>

<struct>struct <name>sbg_demuxer</name> <block>{
<decl_stmt><decl><type><name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sample_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>frame_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_file_size</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>sbg_string</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
}</block>;</struct>

<enum>enum <name>sbg_fade_type</name> <block>{
<decl><name>SBG_FADE_SILENCE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>SBG_FADE_SAME</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>SBG_FADE_ADAPT</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
}</block>;</enum>

<struct>struct <name>sbg_fade</name> <block>{
<decl_stmt><decl><type><name>int8_t</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>, <decl><type ref="prev"/><name>slide</name></decl>;</decl_stmt>
}</block>;</struct>

<enum>enum <name>sbg_synth_type</name> <block>{
<decl><name>SBG_TYPE_NONE</name></decl>,
<decl><name>SBG_TYPE_SINE</name></decl>,
<decl><name>SBG_TYPE_NOISE</name></decl>,
<decl><name>SBG_TYPE_BELL</name></decl>,
<decl><name>SBG_TYPE_MIX</name></decl>,
<decl><name>SBG_TYPE_SPIN</name></decl>,
}</block>;</enum>



<struct>struct <name>sbg_timestamp</name> <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt> 
}</block>;</struct>

<struct>struct <name>sbg_script_definition</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elements</name></decl>, <decl><type ref="prev"/><name>nb_elements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt> 
}</block>;</struct>

<struct>struct <name>sbg_script_synth</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>carrier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>beat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>sbg_synth_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
}</block> <decl><name>ref</name></decl>;</struct>
}</block>;</struct>

<struct>struct <name>sbg_script_tseq</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_timestamp</name></name></type> <name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_fade</name></name></type> <name>fade</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>sbg_script_event</name> <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts_int</name></decl>, <decl><type ref="prev"/><name>ts_trans</name></decl>, <decl><type ref="prev"/><name>ts_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elements</name></decl>, <decl><type ref="prev"/><name>nb_elements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_fade</name></name></type> <name>fade</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>sbg_script</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_definition</name></name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_tseq</name></name> <modifier>*</modifier></type><name>tseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_tseq</name></name> <modifier>*</modifier></type><name>block_tseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_event</name></name> <modifier>*</modifier></type><name>events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_def</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_tseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_synth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>start_ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>end_ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>opt_fade_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>opt_duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt_mix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sample_rate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>opt_start_at_first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>opt_end_at_last</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>sbg_parser</name> <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>script</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script</name></name></type> <name>scs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_timestamp</name></name></type> <name>current_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_block_tseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_def_max</name></decl>, <decl><type ref="prev"/><name>nb_synth_max</name></decl>, <decl><type ref="prev"/><name>nb_tseq_max</name></decl>, <decl><type ref="prev"/><name>nb_block_tseq_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line_no</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>err_msg</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<enum>enum <name>ws_interval_type</name> <block>{
<decl><name>WS_SINE</name> <init>= <expr><call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>,<argument><expr><literal type="char">'I'</literal></expr></argument>,<argument><expr><literal type="char">'N'</literal></expr></argument>,<argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr></init></decl>,
<decl><name>WS_NOISE</name> <init>= <expr><call><name>MKTAG</name><argument_list>(<argument><expr><literal type="char">'N'</literal></expr></argument>,<argument><expr><literal type="char">'O'</literal></expr></argument>,<argument><expr><literal type="char">'I'</literal></expr></argument>,<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr></init></decl>,
}</block>;</enum>

<struct>struct <name>ws_interval</name> <block>{
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts1</name></decl>, <decl><type ref="prev"/><name>ts2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ws_interval_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>channels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>f1</name></decl>, <decl><type ref="prev"/><name>f2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>phi</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>ws_intervals</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>ws_interval</name></name> <modifier>*</modifier></type><name>inter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_inter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_inter</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>alloc_array_elem</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elsize</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>size</name> <operator>==</operator> <operator>*</operator><name>max_size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><operator>*</operator><name>max_size</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>size</name> <operator>&gt;=</operator> <name>m</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>array</name> <operator>=</operator> <call><name>av_realloc_f</name><argument_list>(<argument><expr><operator>*</operator><name>array</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>elsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>array</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>max_size</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>array</name> <operator>+</operator> <name>elsize</name> <operator>*</operator> <operator>*</operator><name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>elsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>size</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>str_to_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>rtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hours</name></decl>, <decl><type ref="prev"/><name>minutes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>seconds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>cur</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>cur</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hours</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>cur</name> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator> <name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minutes</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>cur</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>seconds</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>rtime</name> <operator>=</operator> <operator>(</operator><name>hours</name> <operator>*</operator> <literal type="number">3600LL</literal> <operator>+</operator> <name>minutes</name> <operator>*</operator> <literal type="number">60LL</literal> <operator>+</operator> <name>seconds</name><operator>)</operator> <operator>*</operator> <name>AV_TIME_BASE</name></expr>;</expr_stmt>
<return>return <expr><name>cur</name> <operator>-</operator> <name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>is_space</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>scale_double</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>*=</operator> <name>d</name> <operator>*</operator> <name>SBG_SCALE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&lt;</operator> <name>INT_MIN</name> <operator>||</operator> <name>m</name> <operator>&gt;=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"%g is too large\n"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EDOM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_space</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&gt;</operator> <name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_char</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <name>c</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_double</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>||</operator> <call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_fixed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&lt;</operator> <name>l</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_line_end</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name><operator>++</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>line_no</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_wsword</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_string</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>c</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_string</name></name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>c</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>*</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rs</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_time</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>rt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>str_to_time</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
<return>return <expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORWARD_ERROR</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int errcode = c; if (errcode &lt;= 0) return errcode ? errcode : AVERROR_INVALIDDATA; } while (0)</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_immediate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"immediate sequences not yet implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_preprogrammed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"preprogrammed sequences not yet implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_optarg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_string</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_wsword</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"option '%c' requires an argument"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_string</name></name></type> <name>ostr</name></decl>, <decl><type ref="prev"/><name>oarg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>||</operator> <operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lex_wsword</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ostr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name><name>ostr</name><operator>.</operator><name>s</name></name> <operator>&lt;</operator> <name><name>ostr</name><operator>.</operator><name>e</name></name></expr>;</condition> <incr><expr><name><name>ostr</name><operator>.</operator><name>s</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>opt</name> <init>= <expr><operator>*</operator><name><name>ostr</name><operator>.</operator><name>s</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_start_at_first</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'E'</literal></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_end_at_last</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name>tptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"syntax error for option -F"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_fade_time</name></name> <operator>=</operator> <name>v</name> <operator>*</operator> <name>AV_TIME_BASE</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'L'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>str_to_time</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name><name>oarg</name><operator>.</operator><name>s</name></name> <operator>+</operator> <name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"syntax error for option -L"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'T'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>str_to_time</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>start_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name><name>oarg</name><operator>.</operator><name>s</name></name> <operator>+</operator> <name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"syntax error for option -T"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tptr</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>oarg</name><operator>.</operator><name>s</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tptr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tptr</name><index>[<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>oarg</name><operator>.</operator><name>s</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_mix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>opt_mix</name></name> <operator>=</operator> <name>tptr</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name>tptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"syntax error for option -q"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"speed factor other than 1 not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_optarg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>oarg</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oarg</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name>tptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"syntax error for option -r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"invalid sample rate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>sample_rate</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"unknown option: '%c'"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>ostr</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></while>
<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<return>return <expr><call><name>parse_immediate</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<return>return <expr><call><name>parse_preprogrammed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>AVERROR_BUG</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_timestamp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_timestamp</name></name> <modifier>*</modifier></type><name>rts</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>rrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>abs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"NOW"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lex_time</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_time</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rel</name> <operator>+=</operator> <name>dt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>rts</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rts</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>abs</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rrel</name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_fade</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_fade</name></name> <modifier>*</modifier></type><name>fr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_fade</name></name></type> <name>f</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>SBG_FADE_SILENCE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>SBG_FADE_SAME</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>SBG_FADE_ADAPT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>SBG_FADE_SILENCE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>SBG_FADE_SAME</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>f</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>SBG_FADE_ADAPT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>fr</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_time_sequence</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_timestamp</name></name></type> <name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>rel_ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_fade</name></name></type> <name>fade</name> <init>= <expr><block>{ <expr><name>SBG_FADE_SAME</name></expr>, <expr><name>SBG_FADE_SAME</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_string</name></name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_tseq</name></name> <modifier>*</modifier></type><name>tseq</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_timestamp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>inblock</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>current_time</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>current_time</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><operator>!</operator><name>inblock</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>current_time</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"relative time without previous absolute time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>current_time</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>current_time</name><operator>.</operator><name>t</name></name> <operator>+</operator> <name>rel_ts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_fade</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"-&gt;"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fade</name><operator>.</operator><name>slide</name></name> <operator>=</operator> <name>SBG_FADE_ADAPT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tseq</name> <operator>=</operator> <ternary><condition><expr><name>inblock</name></expr> ?</condition><then>
<expr><call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>block_tseq</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tseq</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nb_block_tseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nb_block_tseq_max</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>tseq</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tseq</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_tseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nb_tseq_max</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tseq</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tseq</name><operator>-&gt;</operator><name>ts</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tseq</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>name</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tseq</name><operator>-&gt;</operator><name>name_len</name></name> <operator>=</operator> <name><name>name</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>name</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tseq</name><operator>-&gt;</operator><name>fade</name></name> <operator>=</operator> <name>fade</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_wave_def</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wavenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"waveform definitions not yet implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_block_def</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_definition</name></name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>tseq</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tseq</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nb_block_tseq</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_time_sequence</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>tseq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>nb_elements</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nb_block_tseq</name></name> <operator>-</operator> <name>tseq</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>def</name><operator>-&gt;</operator><name>nb_elements</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_volume</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>vol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0.01</literal></expr></argument>, <argument><expr><name>vol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel_sine</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>carrierf</name></decl>, <decl><type ref="prev"/><name>beatf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>carrier</name></decl>, <decl><type ref="prev"/><name>beat</name></decl>, <decl><type ref="prev"/><name>vol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrierf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beatf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>beatf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_volume</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>carrierf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>beatf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>beat</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EDOM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SBG_TYPE_SINE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>carrier</name></name> <operator>=</operator> <name>carrier</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>beat</name></name> <operator>=</operator> <name>beat</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>vol</name></name> <operator>=</operator> <name>vol</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel_pink</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>vol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"pink"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_volume</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SBG_TYPE_NOISE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>vol</name></name> <operator>=</operator> <name>vol</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel_bell</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>carrierf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>carrier</name></decl>, <decl><type ref="prev"/><name>vol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"bell"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrierf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_volume</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>carrierf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EDOM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SBG_TYPE_BELL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>carrier</name></name> <operator>=</operator> <name>carrier</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>vol</name></name> <operator>=</operator> <name>vol</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel_mix</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>vol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"mix"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_volume</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SBG_TYPE_MIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>vol</name></name> <operator>=</operator> <name>vol</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel_spin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>carrierf</name></decl>, <decl><type ref="prev"/><name>beatf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>carrier</name></decl>, <decl><type ref="prev"/><name>beat</name></decl>, <decl><type ref="prev"/><name>vol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_fixed</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"spin:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrierf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beatf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FORWARD_ERROR</name><argument_list>(<argument><expr><call><name>parse_volume</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>carrierf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>scale_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>log</name></name></expr></argument>, <argument><expr><name>beatf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>beat</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EDOM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SBG_TYPE_SPIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>carrier</name></name> <operator>=</operator> <name>carrier</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>beat</name></name> <operator>=</operator> <name>beat</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>synth</name><operator>-&gt;</operator><name>vol</name></name> <operator>=</operator> <name>vol</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_channel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>synth</name></decl>;</decl_stmt>

<expr_stmt><expr><name>synth</name> <operator>=</operator> <call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>synth</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>synth</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_synth</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nb_synth_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>synth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel_pink</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel_bell</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel_mix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel_spin</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel_sine</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>synth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_synth</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_synth_def</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_definition</name></name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>synth</name></decl>;</decl_stmt>

<expr_stmt><expr><name>synth</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_synth</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_synth_channel</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name> <operator>||</operator> <operator>!</operator><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>synth</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_synth</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>synth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>nb_elements</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_synth</name></name> <operator>-</operator> <name>synth</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_named_def</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_parser</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor_save</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_string</name></name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_definition</name></name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>lex_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>cursor_save</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>name</name><operator>.</operator><name>s</name></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><literal type="string">"wave"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
<name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wavenum</name> <init>= <expr><operator>(</operator><name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>name</name><operator>.</operator><name>s</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>parse_wave_def</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>wavenum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>def</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>def</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>scs</name><operator>.</operator><name>nb_def</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nb_def_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>def</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>name</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>name_len</name></name> <operator>=</operator> <name><name>name</name><operator>.</operator><name>e</name></name> <operator>-</operator> <name><name>name</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lex_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>parse_block_def</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>parse_synth_def</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_script</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block_tseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>opt_mix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_script</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>script_len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>rscript</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_parser</name></name></type> <name>sp</name> <init>= <expr><block>{
<expr><operator>.</operator><name>log</name> <operator>=</operator> <name>log</name></expr>,
<expr><operator>.</operator><name>script</name> <operator>=</operator> <name>script</name></expr>,
<expr><operator>.</operator><name>end</name> <operator>=</operator> <name>script</name> <operator>+</operator> <name>script_len</name></expr>,
<expr><operator>.</operator><name>cursor</name> <operator>=</operator> <name>script</name></expr>,
<expr><operator>.</operator><name>line_no</name> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><operator>.</operator><name>err_msg</name> <operator>=</operator> <literal type="string">""</literal></expr>,
<expr><operator>.</operator><name>scs</name> <operator>=</operator> <block>{

<expr><operator>.</operator><name>start_ts</name> <operator>=</operator> <name>AV_NOPTS_VALUE</name></expr>,
<expr><operator>.</operator><name>sample_rate</name> <operator>=</operator> <literal type="number">44100</literal></expr>,
<expr><operator>.</operator><name>opt_fade_time</name> <operator>=</operator> <literal type="number">60</literal> <operator>*</operator> <name>AV_TIME_BASE</name></expr>,
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lex_space</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>sp</name><operator>.</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>lex_line_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name><name>sp</name><operator>.</operator><name>cursor</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_named_def</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_time_sequence</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <ternary><condition><expr><call><name>lex_line_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>AVERROR_INVALIDDATA</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>rscript</name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>scs</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>free_script</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>.</operator><name>scs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>sp</name><operator>.</operator><name>err_msg</name></name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>AVERROR_INVALIDDATA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sp</name><operator>.</operator><name>err_msg</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sp</name><operator>.</operator><name>err_msg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>log</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>sp</name><operator>.</operator><name>err_msg</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>sp</name><operator>.</operator><name>cursor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ectx</name> <init>= <expr><call><name>av_x_if_null</name><argument_list>(<argument><expr><call><name>memchr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name><name>sp</name><operator>.</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sp</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lctx</name> <init>= <expr><name>ectx</name> <operator>-</operator> <name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quote</name> <init>= <expr><literal type="string">"\""</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lctx</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><index>[<expr><name>lctx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lctx</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lctx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctx</name> <operator>=</operator> <literal type="string">"the end of line"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>lctx</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error line %d: %s near %s%.*s%s.\n"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>quote</name></expr></argument>, <argument><expr><name>lctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_whole_file</name><parameter_list>(<parameter><decl><type><name>AVIOContext</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_size</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>rbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bufsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>-</operator> <name>size</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>bufsize</name></expr></argument>, <argument><expr><literal type="number">8192</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>-</operator> <name>size</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>EFBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>av_realloc_f</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>avio_read</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name> <operator>-</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>AVERROR_EOF</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>size</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rbuf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>expand_timestamps</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nb_rel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>now</name></decl>, <decl><type ref="prev"/><name>cur_ts</name></decl>, <decl><type ref="prev"/><name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_tseq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>nb_rel</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>nb_rel</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_tseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>now</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Start time ignored in a purely relative script.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nb_rel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name> <operator>||</operator>
<name><name>s</name><operator>-&gt;</operator><name>opt_start_at_first</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>==</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>now</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>time_t</name></type> <name>now0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>, <decl><type ref="prev"/><name>tmpbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Scripts with mixed absolute and relative timestamps can give "</literal>
<literal type="string">"unexpected results (pause, seeking, time zone change).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>time</name></cpp:undef>
<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>now</name> <operator>=</operator> <ternary><condition><expr><name>tm</name></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <literal type="number">3600</literal> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>*</operator> <literal type="number">60</literal> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr> </then><else>:
<expr><name>now0</name> <operator>%</operator> <name>DAY</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Using %02d:%02d:%02d as NOW.\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>now</name> <operator>/</operator> <literal type="number">3600</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>now</name> <operator>/</operator> <literal type="number">60</literal><operator>)</operator> <operator>%</operator> <literal type="number">60</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>now</name> <operator>%</operator> <literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>now</name> <operator>*=</operator> <name>AV_TIME_BASE</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_tseq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>type</name></name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>t</name></name> <operator>+=</operator> <name>now</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>==</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>opt_start_at_first</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>tseq</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>t</name></name></expr> </then><else>: <expr><name>now</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>end_ts</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>opt_duration</name></name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>start_ts</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>opt_duration</name></name></expr> </then><else>:
<expr><name>AV_NOPTS_VALUE</name></expr></else></ternary></expr>;</expr_stmt> 
<expr_stmt><expr><name>cur_ts</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_tseq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>t</name></name> <operator>+</operator> <name>delta</name> <operator>&lt;</operator> <name>cur_ts</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>delta</name> <operator>+=</operator> <name>DAY_TS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cur_ts</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ts</name><operator>.</operator><name>t</name></name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expand_tseq</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nb_ev_max</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>t0</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script_tseq</name></name> <modifier>*</modifier></type><name>tseq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_definition</name></name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_tseq</name></name> <modifier>*</modifier></type><name>be</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tseq</name><operator>-&gt;</operator><name>lock</name></name><operator>++</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Recursion loop on \"%.*s\"\n"</literal></expr></argument>,
<argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name_len</name></name></expr></argument>, <argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>t0</name> <operator>+=</operator> <name><name>tseq</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_def</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>def</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name_len</name> <operator>==</operator> <name><name>tseq</name><operator>-&gt;</operator><name>name_len</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>def</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_def</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Tone-set \"%.*s\" not defined\n"</literal></expr></argument>,
<argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name_len</name></name></expr></argument>, <argument><expr><name><name>tseq</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>def</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>def</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'B'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>be</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>block_tseq</name></name> <operator>+</operator> <name><name>def</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>def</name><operator>-&gt;</operator><name>nb_elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_tseq</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>nb_ev_max</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>be</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ev</name> <operator>=</operator> <call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ev</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr></argument>, <argument><expr><name>nb_ev_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ev</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ev</name><operator>-&gt;</operator><name>ts</name></name> <operator>=</operator> <name><name>tseq</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><operator>-&gt;</operator><name>nb_elements</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>nb_elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><operator>-&gt;</operator><name>fade</name></name> <operator>=</operator> <name><name>tseq</name><operator>-&gt;</operator><name>fade</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tseq</name><operator>-&gt;</operator><name>lock</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expand_script</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>nb_events_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expand_timestamps</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_tseq</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_tseq</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nb_events_max</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>tseq</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"No events in script\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>opt_end_at_last</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>end_ts</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_interval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>ws_interval_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>channels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>ts1</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>f1</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>a1</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>ts2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>f2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>a2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ws_interval</name></name> <modifier>*</modifier></type><name>i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ri</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ri</name> <operator>=</operator> <operator>&amp;</operator><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>ref</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name> <operator>&amp;&amp;</operator> <name><name>ri</name><operator>-&gt;</operator><name>channels</name></name> <operator>==</operator> <name>channels</name> <operator>&amp;&amp;</operator>
<name><name>ri</name><operator>-&gt;</operator><name>f1</name></name> <operator>==</operator> <name><name>ri</name><operator>-&gt;</operator><name>f2</name></name> <operator>&amp;&amp;</operator> <name><name>ri</name><operator>-&gt;</operator><name>f2</name></name> <operator>==</operator> <name>f1</name> <operator>&amp;&amp;</operator> <name>f1</name> <operator>==</operator> <name>f2</name> <operator>&amp;&amp;</operator>
<name><name>ri</name><operator>-&gt;</operator><name>a1</name></name> <operator>==</operator> <name><name>ri</name><operator>-&gt;</operator><name>a2</name></name> <operator>&amp;&amp;</operator> <name><name>ri</name><operator>-&gt;</operator><name>a2</name></name> <operator>==</operator> <name>a1</name> <operator>&amp;&amp;</operator> <name>a1</name> <operator>==</operator> <name>a2</name> <operator>&amp;&amp;</operator>
<name><name>ri</name><operator>-&gt;</operator><name>ts2</name></name> <operator>==</operator> <name>ts1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>ts2</name></name> <operator>=</operator> <name>ts2</name></expr>;</expr_stmt>
<return>return <expr><name>ref</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>alloc_array_elem</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>inter</name><operator>-&gt;</operator><name>inter</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>inter</name><operator>-&gt;</operator><name>nb_inter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>inter</name><operator>-&gt;</operator><name>max_inter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>ts1</name></name> <operator>=</operator> <name>ts1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>ts2</name></name> <operator>=</operator> <name>ts2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <name>channels</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>f1</name></name> <operator>=</operator> <name>f1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>f2</name></name> <operator>=</operator> <name>f2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>a1</name></name> <operator>=</operator> <name>a1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>a2</name></name> <operator>=</operator> <name>a2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>phi</name></name> <operator>=</operator> <ternary><condition><expr><name>ref</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ref</name> <operator>|</operator> <literal type="number">0x80000000</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>i</name> <operator>-</operator> <name><name>inter</name><operator>-&gt;</operator><name>inter</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_bell</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>ts1</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>ts2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<decl_stmt><decl><type><name>int32_t</name></type> <name><name>cpoints</name><index>[]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><name>a</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><name>a</name> <operator>-</operator> <name>a</name> <operator>/</operator> <literal type="number">4</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><name>a</name> <operator>/</operator> <literal type="number">2</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">16</literal></expr>, <expr><name>a</name> <operator>/</operator> <literal type="number">4</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">25</literal></expr>, <expr><name>a</name> <operator>/</operator> <literal type="number">10</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">50</literal></expr>, <expr><name>a</name> <operator>/</operator> <literal type="number">80</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">75</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>dt</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>/</operator> <literal type="number">20</literal></expr></init></decl>, <decl><type ref="prev"/><name>ts3</name> <init>= <expr><name>ts1</name></expr></init></decl>, <decl><type ref="prev"/><name>ts4</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>cpoints</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ts4</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>ts1</name> <operator>+</operator> <name><name>cpoints</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_interval</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>WS_SINE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>ts3</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>ts4</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>cpoints</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ts3</name> <operator>=</operator> <name>ts4</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>cpoints</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>generate_interval</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>ts1</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>ts2</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>s1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>s2</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>transition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ts2</name> <operator>&lt;=</operator> <name>ts1</name> <operator>||</operator> <operator>(</operator><name><name>s1</name><operator>-&gt;</operator><name>vol</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s2</name><operator>-&gt;</operator><name>vol</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SBG_TYPE_NONE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>SBG_TYPE_SINE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>s1</name><operator>-&gt;</operator><name>beat</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s2</name><operator>-&gt;</operator><name>beat</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_interval</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>WS_SINE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>carrier</name></name></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>,
<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>carrier</name></name></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name> <operator>=</operator> <name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_interval</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>WS_SINE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>carrier</name></name> <operator>+</operator> <name><name>s1</name><operator>-&gt;</operator><name>beat</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>,
<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>carrier</name></name> <operator>+</operator> <name><name>s2</name><operator>-&gt;</operator><name>beat</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_interval</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>WS_SINE</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>r</name></name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>carrier</name></name> <operator>-</operator> <name><name>s1</name><operator>-&gt;</operator><name>beat</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>,
<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>carrier</name></name> <operator>-</operator> <name><name>s2</name><operator>-&gt;</operator><name>beat</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>SBG_TYPE_BELL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>transition</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_bell</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>carrier</name></name></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>vol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SBG_TYPE_SPIN</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Spinning noise not implemented, "</literal>
<literal type="string">"using pink noise instead.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>SBG_TYPE_NOISE</name></expr>:</case>










<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>add_interval</name><argument_list>(<argument><expr><name>inter</name></expr></argument>, <argument><expr><name>WS_NOISE</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>vol</name></name> <operator>-</operator> <name><name>s1</name><operator>-&gt;</operator><name>vol</name></name> <operator>/</operator> <literal type="number">4</literal></expr></argument>,
<argument><expr><name>ts2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s2</name><operator>-&gt;</operator><name>vol</name></name> <operator>-</operator> <name><name>s2</name><operator>-&gt;</operator><name>vol</name></name> <operator>/</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>l</name></name> <operator>=</operator> <name><name>s2</name><operator>-&gt;</operator><name>ref</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SBG_TYPE_MIX</name></expr>:</case>

<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Type %d is not implemented\n"</literal></expr></argument>, <argument><expr><name><name>s1</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>generate_plateau</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_event</name></name> <modifier>*</modifier></type><name>ev1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts1</name> <init>= <expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_int</name></name></expr></init></decl>, <decl><type ref="prev"/><name>ts2</name> <init>= <expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ev1</name><operator>-&gt;</operator><name>nb_elements</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name><index>[<expr><name><name>ev1</name><operator>-&gt;</operator><name>elements</name></name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_interval</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>generate_transition</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_event</name></name> <modifier>*</modifier></type><name>ev1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sbg_script_event</name></name> <modifier>*</modifier></type><name>ev2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts1</name> <init>= <expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name></expr></init></decl>, <decl><type ref="prev"/><name>ts2</name> <init>= <expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int64_t</name></type> <name>tsmid</name> <init>= <expr><operator>(</operator><name>ts1</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>ts2</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>ts1</name> <operator>&amp;</operator> <name>ts2</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>sbg_fade_type</name></name></type> <name>type</name> <init>= <expr><name><name>ev1</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>slide</name></name> <operator>|</operator> <operator>(</operator><name><name>ev1</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>out</name></name> <operator>&amp;</operator> <name><name>ev2</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>in</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nb_elements</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>nb_elements</name></name></expr></argument>, <argument><expr><name><name>ev2</name><operator>-&gt;</operator><name>nb_elements</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_synth</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>, <decl><type ref="prev"/><name>s1mod</name></decl>, <decl><type ref="prev"/><name>s2mod</name></decl>, <decl><type ref="prev"/><name>smid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pass</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>







<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nb_elements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ev1</name><operator>-&gt;</operator><name>nb_elements</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name><index>[<expr><name><name>ev1</name><operator>-&gt;</operator><name>elements</name></name> <operator>+</operator> <name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name>s1mod</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ev2</name><operator>-&gt;</operator><name>nb_elements</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>synth</name><index>[<expr><name><name>ev2</name><operator>-&gt;</operator><name>elements</name></name> <operator>+</operator> <name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name>s2mod</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>s1mod</name> <operator>=</operator> <ternary><condition><expr><name>s1</name> <operator>!=</operator> <operator>&amp;</operator><name>s1mod</name></expr> ?</condition><then> <expr><operator>*</operator><name>s1</name></expr> </then><else>: <expr><operator>(</operator>struct <name>sbg_script_synth</name><operator>)</operator><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>s2mod</name> <operator>=</operator> <ternary><condition><expr><name>s2</name> <operator>!=</operator> <operator>&amp;</operator><name>s2mod</name></expr> ?</condition><then> <expr><operator>*</operator><name>s2</name></expr> </then><else>: <expr><operator>(</operator>struct <name>sbg_script_synth</name><operator>)</operator><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev1</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>slide</name></name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>s1mod</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SBG_TYPE_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s1mod</name> <operator>=</operator> <name>s2mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1mod</name><operator>.</operator><name>vol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s2mod</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SBG_TYPE_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s2mod</name> <operator>=</operator> <name>s1mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2mod</name><operator>.</operator><name>vol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s1mod</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>s2mod</name><operator>.</operator><name>type</name></name> <operator>&amp;&amp;</operator>
<name><name>s1mod</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>SBG_TYPE_BELL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>type</name> <operator>==</operator> <name>SBG_FADE_ADAPT</name> <operator>||</operator>
<operator>(</operator><name><name>s1mod</name><operator>.</operator><name>carrier</name></name> <operator>==</operator> <name><name>s2mod</name><operator>.</operator><name>carrier</name></name> <operator>&amp;&amp;</operator>
<name><name>s1mod</name><operator>.</operator><name>beat</name></name> <operator>==</operator> <name><name>s2mod</name><operator>.</operator><name>beat</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_interval</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s1mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s2mod</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name><name>s2mod</name><operator>.</operator><name>ref</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>smid</name> <operator>=</operator> <name>s1mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smid</name><operator>.</operator><name>vol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_interval</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>,
<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>tsmid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s1mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>smid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>smid</name> <operator>=</operator> <name>s2mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smid</name><operator>.</operator><name>vol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_interval</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>,
<argument><expr><name>tsmid</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>smid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s2mod</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name><name>s2mod</name><operator>.</operator><name>ref</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>generate_intervals</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sample_rate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>trans_time</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>opt_fade_time</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script_event</name></name></type> <name>ev0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>period</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>




<expr_stmt><expr><name>period</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>period</name> <operator>=</operator> <operator>(</operator><name>period</name> <operator>+</operator> <operator>(</operator><name>DAY_TS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>DAY_TS</name> <operator>*</operator> <name>DAY_TS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>period</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>DAY_TS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_int</name></name> <operator>=</operator> <name><name>ev1</name><operator>-&gt;</operator><name>ts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ev1</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>slide</name></name></expr> ?</condition><then> <expr><name><name>ev1</name><operator>-&gt;</operator><name>ts</name></name></expr>
</then><else>: <expr><name><name>ev2</name><operator>-&gt;</operator><name>ts</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>ev1</name> <operator>&lt;</operator> <name>ev2</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>period</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ev1</name><operator>-&gt;</operator><name>fade</name><operator>.</operator><name>slide</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_int</name></name></expr></argument>, <argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name> <operator>-</operator> <name>trans_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev2</name><operator>-&gt;</operator><name>ts_int</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>ev2</name><operator>-&gt;</operator><name>ts_trans</name></name></expr></argument>, <argument><expr><name><name>ev2</name><operator>-&gt;</operator><name>ts_int</name></name> <operator>+</operator> <name>trans_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_next</name></name> <operator>=</operator> <name><name>ev2</name><operator>-&gt;</operator><name>ts_int</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>ev1</name> <operator>&lt;</operator> <name>ev2</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>period</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>ev0</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev0</name><operator>.</operator><name>ts_int</name></name> <operator>-=</operator> <name>period</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev0</name><operator>.</operator><name>ts_trans</name></name> <operator>-=</operator> <name>period</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev0</name><operator>.</operator><name>ts_next</name></name> <operator>-=</operator> <name>period</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name>ev0</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_int</name></name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_int</name></name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>, <argument><expr><name>AV_TIME_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_trans</name></name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>, <argument><expr><name>AV_TIME_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_next</name></name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name><name>ev1</name><operator>-&gt;</operator><name>ts_next</name></name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>, <argument><expr><name>AV_TIME_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_synth</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>synth</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ref</name><operator>.</operator><name>l</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>synth</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ref</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name>ev0</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>events</name><index>[<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_events</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_plateau</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_transition</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><name>ev1</name></expr></argument>, <argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inter</name><operator>-&gt;</operator><name>nb_inter</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Completely silent script.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_intervals</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sbg_script</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVCodecParameters</name> <modifier>*</modifier></type><name>par</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ws_intervals</name></name> <modifier>*</modifier></type><name>inter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>edata_size</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>inter</name><operator>-&gt;</operator><name>nb_inter</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>edata_size</name> <operator>+=</operator> <ternary><condition><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>WS_SINE</name></expr> ?</condition><then> <expr><literal type="number">44</literal></expr> </then><else>:
<expr><ternary><condition><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>WS_NOISE</name></expr> ?</condition><then> <expr><literal type="number">32</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>edata_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_alloc_extradata</name><argument_list>(<argument><expr><name>par</name></expr></argument>, <argument><expr><name>edata_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>edata</name> <operator>=</operator> <name><name>par</name><operator>-&gt;</operator><name>extradata</name></name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_EDATA32</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { AV_WL32(edata, (v)); edata += 4; } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_EDATA64</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { AV_WL64(edata, (v)); edata += 8; } while(0)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>nb_inter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>inter</name><operator>-&gt;</operator><name>nb_inter</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ADD_EDATA64</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ts1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA64</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ts2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>channels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>WS_SINE</name></expr>:</case>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>phi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>WS_NOISE</name></expr>:</case>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_EDATA32</name><argument_list>(<argument><expr><name><name>inter</name><operator>-&gt;</operator><name>inter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>edata</name> <operator>!=</operator> <name><name>par</name><operator>-&gt;</operator><name>extradata</name></name> <operator>+</operator> <name>edata_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_BUG</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>sbg_read_probe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AVProbeData</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script</name></name></type> <name>script</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_script</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf_size</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <ternary><condition><expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>script</name><operator>.</operator><name>nb_def</name></name> <operator>||</operator> <operator>!</operator><name><name>script</name><operator>.</operator><name>nb_tseq</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
<expr><name>AVPROBE_SCORE_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_script</name><argument_list>(<argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>sbg_read_header</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>avf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_demuxer</name></name> <modifier>*</modifier></type><name>sbg</name> <init>= <expr><name><name>avf</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sbg_script</name></name></type> <name>script</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVStream</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ws_intervals</name></name></type> <name>inter</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read_whole_file</name><argument_list>(<argument><expr><name><name>avf</name><operator>-&gt;</operator><name>pb</name></name></expr></argument>, <argument><expr><name><name>sbg</name><operator>-&gt;</operator><name>max_file_size</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>parse_script</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>script</name><operator>.</operator><name>sample_rate</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>script</name><operator>.</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sbg</name><operator>-&gt;</operator><name>frame_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sbg</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>script</name><operator>.</operator><name>opt_mix</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Mix feature not implemented: "</literal>
<literal type="string">"-m is ignored and mix channels will be silent.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>expand_script</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>generate_intervals</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>, <argument><expr><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>avformat_new_stream</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_type</name></name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>=</operator> <name>AV_CODEC_ID_FFWAVESYNTH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>channel_layout</name></name> <operator>=</operator> <name>AV_CH_LAYOUT_STEREO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>sample_rate</name></name> <operator>=</operator> <name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <name><name>sbg</name><operator>-&gt;</operator><name>frame_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>avpriv_set_pts_info</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>probe_packets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>start_time</name></name> <operator>=</operator> <call><name>av_rescale</name><argument_list>(<argument><expr><name><name>script</name><operator>.</operator><name>start_ts</name></name></expr></argument>,
<argument><expr><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>, <argument><expr><name>AV_TIME_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <ternary><condition><expr><name><name>script</name><operator>.</operator><name>end_ts</name></name> <operator>==</operator> <name>AV_NOPTS_VALUE</name></expr> ?</condition><then> <expr><name>AV_NOPTS_VALUE</name></expr> </then><else>:
<expr><call><name>av_rescale</name><argument_list>(<argument><expr><name><name>script</name><operator>.</operator><name>end_ts</name></name> <operator>-</operator> <name><name>script</name><operator>.</operator><name>start_ts</name></name></expr></argument>,
<argument><expr><name><name>sbg</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>, <argument><expr><name>AV_TIME_BASE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>cur_dts</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>start_time</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>encode_intervals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>script</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>codecpar</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>inter</name><operator>.</operator><name>inter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_script</name><argument_list>(<argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name><name>inter</name><operator>.</operator><name>inter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_script</name><argument_list>(<argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sbg_read_packet</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>avf</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>packet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ts</name></decl>, <decl><type ref="prev"/><name>end_ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>cur_dts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_ts</name> <operator>=</operator> <name>ts</name> <operator>+</operator> <name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>codecpar</name><operator>-&gt;</operator><name>frame_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>duration</name> <operator>!=</operator> <name>AV_NOPTS_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end_ts</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>start_time</name> <operator>+</operator> <name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>duration</name></expr></argument>,
<argument><expr><name>end_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end_ts</name> <operator>&lt;=</operator> <name>ts</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_EOF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>av_new_packet</name><argument_list>(<argument><expr><name>packet</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>dts</name></name> <operator>=</operator> <name><name>packet</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>duration</name></name> <operator>=</operator> <name>end_ts</name> <operator>-</operator> <name>ts</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WL64</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WL32</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name><name>packet</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>packet</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sbg_read_seek2</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>avf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stream_index</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>min_ts</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>max_ts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>||</operator> <name>stream_index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stream_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>av_rescale_q</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>AV_TIME_BASE_Q</name></expr></argument>, <argument><expr><name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>time_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>avf</name><operator>-&gt;</operator><name>streams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>cur_dts</name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sbg_read_seek</name><parameter_list>(<parameter><decl><type><name>AVFormatContext</name> <modifier>*</modifier></type><name>avf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stream_index</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>sbg_read_seek2</name><argument_list>(<argument><expr><name>avf</name></expr></argument>, <argument><expr><name>stream_index</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>sbg_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"sample_rate"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sbg_demuxer</name></expr></argument>, <argument><expr><name>sample_rate</name></expr></argument>)</argument_list></call></expr>,
<expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{ <expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
<expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"frame_size"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sbg_demuxer</name></expr></argument>, <argument><expr><name>frame_size</name></expr></argument>)</argument_list></call></expr>,
<expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{ <expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
<expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"max_file_size"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sbg_demuxer</name></expr></argument>, <argument><expr><name>max_file_size</name></expr></argument>)</argument_list></call></expr>,
<expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{ <expr><operator>.</operator><name>i64</name> <operator>=</operator> <literal type="number">5000000</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
<expr><name>AV_OPT_FLAG_DECODING_PARAM</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>sbg_demuxer_class</name> <init>= <expr><block>{
<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"sbg_demuxer"</literal></expr>,
<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,
<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>sbg_options</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVInputFormat</name></type> <name>ff_sbg_demuxer</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"sbg"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"SBaGen binaural beats script"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sbg_demuxer</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>read_probe</name> <operator>=</operator> <name>sbg_read_probe</name></expr>,
<expr><operator>.</operator><name>read_header</name> <operator>=</operator> <name>sbg_read_header</name></expr>,
<expr><operator>.</operator><name>read_packet</name> <operator>=</operator> <name>sbg_read_packet</name></expr>,
<expr><operator>.</operator><name>read_seek</name> <operator>=</operator> <name>sbg_read_seek</name></expr>,
<expr><operator>.</operator><name>read_seek2</name> <operator>=</operator> <name>sbg_read_seek2</name></expr>,
<expr><operator>.</operator><name>extensions</name> <operator>=</operator> <literal type="string">"sbg"</literal></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>sbg_demuxer_class</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
