<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\avuienc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>avui_encode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>!=</operator> <literal type="number">720</literal> <operator>||</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>!=</operator> <literal type="number">486</literal> <operator>&amp;&amp;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name> <operator>!=</operator> <literal type="number">576</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Only 720x486 and 720x576 are supported.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>extradata</name></name> <operator>=</operator> <call><name>av_mallocz</name><argument_list>(<argument><expr><literal type="number">144</literal> <operator>+</operator> <name>AV_INPUT_BUFFER_PADDING_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>extradata_size</name></name> <operator>=</operator> <literal type="number">144</literal></expr>;</expr_stmt>

<macro><name>memcpy</name><argument_list>(<argument>avctx-&gt;extradata</argument>, <argument><literal type="string">"\0\0\0\x18""</literal>APRGAPRG0001<literal type="string">", 16);

if (avctx-&gt;field_order &gt; AV_FIELD_PROGRESSIVE) {

avctx-&gt;extradata[19] = 2;

} else {

avctx-&gt;extradata[19] = 1;

}

memcpy(avctx-&gt;extradata + 24, "</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\x78<literal type="string">""</literal>ARESARES0001<literal type="string">""</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\x98<literal type="string">", 20);

AV_WB32(avctx-&gt;extradata + 44, avctx-&gt;width);

AV_WB32(avctx-&gt;extradata + 48, avctx-&gt;height);

memcpy(avctx-&gt;extradata + 52, "</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\x1\<literal type="number">0</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\x20\<literal type="number">0</literal>\<literal type="number">0</literal>\<literal type="number">0</literal>\x2<literal type="string">", 12);

return 0;

}

static int avui_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

const AVFrame *pic, int *got_packet)

{

uint8_t *dst;

int i, j, skip, ret, size, interlaced;

interlaced = avctx-&gt;field_order &gt; AV_FIELD_PROGRESSIVE;

if (avctx-&gt;height == 486) {

skip = 10;

} else {

skip = 16;

}

size = 2 * avctx-&gt;width * (avctx-&gt;height + skip) + 8 * interlaced;

if ((ret = ff_alloc_packet2(avctx, pkt, size, size)) &lt; 0)

return ret;

dst = pkt-&gt;data;

if (!interlaced) {

memset(dst, 0, avctx-&gt;width * skip);

dst += avctx-&gt;width * skip;

}

for (i = 0; i &lt;= interlaced; i++) {

uint8_t *src;

if (interlaced &amp;&amp; avctx-&gt;height == 486) {

src = pic-&gt;data[0] + (1 - i) * pic-&gt;linesize[0];

} else {

src = pic-&gt;data[0] + i * pic-&gt;linesize[0];

}

memset(dst, 0, avctx-&gt;width * skip + 4 * i);

dst += avctx-&gt;width * skip + 4 * i;

for (j = 0; j &lt; avctx-&gt;height; j += interlaced + 1) {

memcpy(dst, src, avctx-&gt;width * 2);

src += (interlaced + 1) * pic-&gt;linesize[0];

dst += avctx-&gt;width * 2;

}

}

pkt-&gt;flags |= AV_PKT_FLAG_KEY;

*got_packet = 1;

return 0;

}

AVCodec ff_avui_encoder = {

.name = "</literal>avui<literal type="string">",

.long_name = NULL_IF_CONFIG_SMALL("</literal>Avid Meridien Uncompressed<literal type="string">"</literal></argument></argument_list></macro></block_content></block></function>),

.type = AVMEDIA_TYPE_VIDEO,

.id = AV_CODEC_ID_AVUI,

.init = avui_encode_init,

.encode2 = avui_encode_frame,

.capabilities = AV_CODEC_CAP_EXPERIMENTAL | AV_CODEC_CAP_INTRA_ONLY,

.pix_fmts = (const enum AVPixelFormat[]){ AV_PIX_FMT_UYVY422, AV_PIX_FMT_NONE },

};

</unit>
