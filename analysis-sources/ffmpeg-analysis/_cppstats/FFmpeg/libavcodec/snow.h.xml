<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\snow.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/motion_vector.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hpeldsp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"me_cmp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qpeldsp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"snow_dwt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rangecoder.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mathops.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpegvideo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h264qpel.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FF_ME_ITER</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MID_STATE</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PLANES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSHIFT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QROOT</name></cpp:macro> <cpp:value>(1&lt;&lt;QSHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOSSLESS_QLOG</name></cpp:macro> <cpp:value>-128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAC_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REF_FRAMES</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2_OBMC_MAX</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBMC_MAX</name></cpp:macro> <cpp:value>(1&lt;&lt;(LOG2_OBMC_MAX))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>BlockNode</name><block>{

<decl_stmt><decl><type><name>int16_t</name></type> <name>mx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int16_t</name></type> <name>my</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>ref</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>color</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>type</name></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_INTRA</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_OPT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>level</name></decl>;</decl_stmt> 

}</block></struct></type><name>BlockNode</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BlockNode</name></type> <name>null_block</name><init>= <expr><block>{ 

<expr><operator>.</operator><name>color</name><operator>=</operator> <block>{<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>}</block></expr>,

<expr><operator>.</operator><name>mx</name><operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>my</name><operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>ref</name><operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>type</name><operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>level</name><operator>=</operator> <literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2_MB_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB_SIZE</name></cpp:macro> <cpp:value>(1&lt;&lt;LOG2_MB_SIZE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODER_EXTRA_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTAPS_MAX</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>x_and_coeff</name><block>{

<decl_stmt><decl><type><name>int16_t</name></type> <name>x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>coeff</name></decl>;</decl_stmt>

}</block></struct></type> <name>x_and_coeff</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SubBand</name><block>{

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stride</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qlog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>DWTELEM</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>ibuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_x_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_y_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stride_line</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type> <name>x_coeff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>SubBand</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>state</name><index>[ <expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">512</literal></expr>]</index><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type><name>SubBand</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Plane</name><block>{

<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SubBand</name></type> <name><name>band</name><index>[<expr><name>MAX_DECOMPOSITIONS</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>htaps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int8_t</name></type> <name><name>hcoeff</name><index>[<expr><name>HTAPS_MAX</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>diag_mc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fast_mc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_htaps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int8_t</name></type> <name><name>last_hcoeff</name><index>[<expr><name>HTAPS_MAX</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_diag_mc</name></decl>;</decl_stmt>

}</block></struct></type><name>Plane</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SnowContext</name><block>{

<decl_stmt><decl><type><name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RangeCoder</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MECmpContext</name></type> <name>mecc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HpelDSPContext</name></type> <name>hdsp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QpelDSPContext</name></type> <name>qdsp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VideoDSPContext</name></type> <name>vdsp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>H264QpelContext</name></type> <name>h264qpel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MpegvideoEncDSPContext</name></type> <name>mpvencdsp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SnowDWTContext</name></type> <name>dwt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>input_picture</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>current_picture</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name><name>last_picture</name><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>halfpel_plane</name><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>mconly_picture</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>header_state</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>block_state</name><index>[<expr><literal type="number">128</literal> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keyframe</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>always_reset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spatial_decomposition_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_spatial_decomposition_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>temporal_decomposition_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spatial_decomposition_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_spatial_decomposition_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>temporal_decomposition_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_ref_frames</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_frames</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>int16_t</name> <argument_list>(<argument><expr><operator>*</operator><name><name>ref_mvs</name><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>

<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name><name>ref_scores</name><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWTELEM</name> <modifier>*</modifier></type><name>spatial_dwt_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWTELEM</name> <modifier>*</modifier></type><name>temp_dwt_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>spatial_idwt_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>temp_idwt_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>run_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>colorspace_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chroma_h_shift</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chroma_v_shift</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spatial_scalability</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qlog</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_qlog</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lambda</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lambda2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pass1_rc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mv_scale</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_mv_scale</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qbias</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_qbias</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QBIAS_SHIFT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>b_width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>b_height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>block_max_depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_block_max_depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_planes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Plane</name></type> <name><name>plane</name><index>[<expr><name>MAX_PLANES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ME_CACHE_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<decl_stmt><decl><type><name>unsigned</name></type> <name><name>me_cache</name><index>[<expr><name>ME_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>me_cache_generation</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slice_buffer</name></type> <name>sb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>memc_only</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>no_bitstream</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>intra_penalty</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>motion_est</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iterative_dia_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>scenechange_threshold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MpegEncContext</name></type> <name>m</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>scratchbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>emu_edge_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVMotionVector</name> <modifier>*</modifier></type><name>avmv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>avmv_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>encoding_error</name><index>[<expr><name>AV_NUM_DATA_POINTERS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pred</name></decl>;</decl_stmt>

}</block></struct></type><name>SnowContext</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>ff_obmc_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>uint8_t</name></type> <name><name>ff_qexp</name><index>[<expr><name>QROOT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name><name>ff_scale_mv_ref</name><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index><index>[<expr><name>MAX_REF_FRAMES</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>snow_interleave_line_header</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>high</name></decl></parameter>)</parameter_list><block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>width</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>low</name><index>[<expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>low</name><index>[<expr><operator>(</operator><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>snow_interleave_line_footer</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>high</name></decl></parameter>)</parameter_list><block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>-=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>low</name><index>[<expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>high</name><index>[<expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>low</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>low</name><index>[<expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>snow_horizontal_compose_lift_lead_out</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lift_high</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mul</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shift</name></decl></parameter>)</parameter_list><block>{<block_content>

<for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>w</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>mul</name> <operator>*</operator> <operator>(</operator><name><name>ref</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>ref</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <name>add</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>width</name><operator>^</operator><name>lift_high</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>w</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>w</name></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>mul</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>ref</name><index>[<expr><name>w</name></expr>]</index></name> <operator>+</operator> <name>add</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>snow_horizontal_compose_liftS_lead_out</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>)</parameter_list><block>{<block_content>

<for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>w</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>ref</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>ref</name><index>[<expr><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>+</operator><name>W_BO</name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <name>W_BS</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>width</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>w</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>w</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name><name>ref</name><index>[<expr><name>w</name></expr>]</index></name> <operator>+</operator> <name>W_BO</name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>src</name><index>[<expr><name>w</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <name>W_BS</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>ff_snow_common_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_snow_common_init_after_header</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_snow_common_end</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_snow_release_buffer</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_snow_reset_contexts</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_snow_alloc_blocks</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_snow_frame_start</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ff_snow_pred_block</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>stride</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>sx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockNode</name> <modifier>*</modifier></type><name>block</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>plane_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ff_snow_get_buffer</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>pred_mv</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>my</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>BlockNode</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockNode</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockNode</name> <modifier>*</modifier></type><name>tr</name></decl></parameter>)</parameter_list><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ref_frames</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>mx</name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>mx</name></name></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>mx</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>mx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my</name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>my</name></name></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>my</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>my</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>scale</name> <init>= <expr><name><name>ff_scale_mv_ref</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>mx</name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>mx</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>left</name><operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>top</name> <operator>-&gt;</operator><name>mx</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>top</name> <operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>tr</name> <operator>-&gt;</operator><name>mx</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>tr</name> <operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my</name> <operator>=</operator> <call><name>mid_pred</name><argument_list>(<argument><expr><operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>my</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>left</name><operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>top</name> <operator>-&gt;</operator><name>my</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>top</name> <operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>tr</name> <operator>-&gt;</operator><name>my</name></name> <operator>*</operator> <name><name>scale</name><index>[<expr><name><name>tr</name> <operator>-&gt;</operator><name>ref</name></name></expr>]</index></name> <operator>+</operator> <literal type="number">128</literal><operator>)</operator> <operator>&gt;&gt;</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>same_block</name><parameter_list>(<parameter><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>type</name></name><operator>&amp;</operator><name>BLOCK_INTRA</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>type</name></name><operator>&amp;</operator><name>BLOCK_INTRA</name><operator>)</operator></expr>)</condition><block>{<block_content>

<return>return <expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>color</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></if><else>else<block>{<block_content>

<return>return <expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>mx</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>mx</name></name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>my</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>my</name></name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>ref</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>ref</name></name><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>^</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator><operator>&amp;</operator><name>BLOCK_INTRA</name><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>add_yblock</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliced</name></decl></parameter>, <parameter><decl><type><name>slice_buffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst8</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dst_stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>obmc_stride</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset_dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane_index</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_width</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_height</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_height</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b_stride</name><init>= <expr><name>b_width</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>lt</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>b_x</name> <operator>+</operator> <name>b_y</name><operator>*</operator><name>b_stride</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>rt</name><init>= <expr><name>lt</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>lb</name><init>= <expr><name>lt</name><operator>+</operator><name>b_stride</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BlockNode</name> <modifier>*</modifier></type><name>rb</name><init>= <expr><name>lb</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>block</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmp_step</name><init>= <expr><ternary><condition><expr><name>src_stride</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>*</operator><name>MB_SIZE</name></expr> ?</condition><then> <expr><name>MB_SIZE</name></expr> </then><else>: <expr><name>MB_SIZE</name><operator>*</operator><name>src_stride</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>scratchbuf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ptmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>b_x</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>lt</name><operator>=</operator> <name>rt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lb</name><operator>=</operator> <name>rb</name></expr>;</expr_stmt>

</block_content>}</block></if><if type="elseif">else if<condition>(<expr><name>b_x</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>b_width</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>rt</name><operator>=</operator> <name>lt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rb</name><operator>=</operator> <name>lb</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>b_y</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>lt</name><operator>=</operator> <name>lb</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rt</name><operator>=</operator> <name>rb</name></expr>;</expr_stmt>

</block_content>}</block></if><if type="elseif">else if<condition>(<expr><name>b_y</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>b_height</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>lb</name><operator>=</operator> <name>lt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rb</name><operator>=</operator> <name>rt</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>src_x</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content> 

<expr_stmt><expr><name>obmc</name> <operator>-=</operator> <name>src_x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>b_w</name> <operator>+=</operator> <name>src_x</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sliced</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>offset_dst</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst</name> <operator>-=</operator> <name>src_x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src_x</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>src_x</name> <operator>+</operator> <name>b_w</name> <operator>&gt;</operator> <name>w</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>b_w</name> <operator>=</operator> <name>w</name> <operator>-</operator> <name>src_x</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>src_y</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>obmc</name> <operator>-=</operator> <name>src_y</name><operator>*</operator><name>obmc_stride</name></expr>;</expr_stmt>

<expr_stmt><expr><name>b_h</name> <operator>+=</operator> <name>src_y</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sliced</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>offset_dst</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst</name> <operator>-=</operator> <name>src_y</name><operator>*</operator><name>dst_stride</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src_y</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>src_y</name> <operator>+</operator> <name>b_h</name><operator>&gt;</operator> <name>h</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>b_h</name> <operator>=</operator> <name>h</name> <operator>-</operator> <name>src_y</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>b_w</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>b_h</name><operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sliced</name> <operator>&amp;&amp;</operator> <name>offset_dst</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>src_x</name> <operator>+</operator> <name>src_y</name><operator>*</operator><name>dst_stride</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dst8</name><operator>+=</operator> <name>src_x</name> <operator>+</operator> <name>src_y</name><operator>*</operator><name>src_stride</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptmp</name><operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>tmp_step</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptmp</name><operator>+=</operator><name>tmp_step</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_snow_pred_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>src_stride</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>b_w</name></expr></argument>, <argument><expr><name>b_h</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>lt</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptmp</name><operator>+=</operator><name>tmp_step</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_snow_pred_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>src_stride</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>b_w</name></expr></argument>, <argument><expr><name>b_h</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>lt</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptmp</name><operator>+=</operator><name>tmp_step</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_snow_pred_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>src_stride</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>b_w</name></expr></argument>, <argument><expr><name>b_h</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>lt</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>same_block</name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>=</operator> <name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_snow_pred_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>src_stride</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>, <argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>b_w</name></expr></argument>, <argument><expr><name>b_h</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>sliced</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dwt</name><operator>.</operator><name>inner_add_yblock</name></name><argument_list>(<argument><expr><name>obmc</name></expr></argument>, <argument><expr><name>obmc_stride</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>b_w</name></expr></argument>, <argument><expr><name>b_h</name></expr></argument>, <argument><expr><name>src_x</name></expr></argument>,<argument><expr><name>src_y</name></expr></argument>, <argument><expr><name>src_stride</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>add</name></expr></argument>, <argument><expr><name>dst8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<for>for<control>(<init><expr><name>y</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name><operator>&lt;</operator><name>b_h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc1</name><init>= <expr><name>obmc</name> <operator>+</operator> <name>y</name><operator>*</operator><name>obmc_stride</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc2</name><init>= <expr><name>obmc1</name><operator>+</operator> <operator>(</operator><name>obmc_stride</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc3</name><init>= <expr><name>obmc1</name><operator>+</operator> <name>obmc_stride</name><operator>*</operator><operator>(</operator><name>obmc_stride</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc4</name><init>= <expr><name>obmc3</name><operator>+</operator> <operator>(</operator><name>obmc_stride</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name><operator>&lt;</operator><name>b_w</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>v</name><init>= <expr><name><name>obmc1</name><index>[<expr><name>x</name></expr>]</index></name> <operator>*</operator> <name><name>block</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>src_stride</name></expr>]</index></name>

<operator>+</operator><name><name>obmc2</name><index>[<expr><name>x</name></expr>]</index></name> <operator>*</operator> <name><name>block</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>src_stride</name></expr>]</index></name>

<operator>+</operator><name><name>obmc3</name><index>[<expr><name>x</name></expr>]</index></name> <operator>*</operator> <name><name>block</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>src_stride</name></expr>]</index></name>

<operator>+</operator><name><name>obmc4</name><index>[<expr><name>x</name></expr>]</index></name> <operator>*</operator> <name><name>block</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>src_stride</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal> <operator>-</operator> <name>LOG2_OBMC_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>FRAC_BITS</name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal> <operator>-</operator> <name>FRAC_BITS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>add</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>+=</operator> <name><name>dst</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>dst_stride</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>FRAC_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <name>FRAC_BITS</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>v</name><operator>&amp;</operator><operator>(</operator><operator>~</operator><literal type="number">255</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name><operator>=</operator> <operator>~</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dst8</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>src_stride</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>dst_stride</name></expr>]</index></name> <operator>-=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>predict_slice</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mb_y</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>Plane</name> <modifier>*</modifier></type><name>p</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>plane_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mb_w</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_width</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mb_h</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_height</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>mb_x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>block_size</name> <init>= <expr><name>MB_SIZE</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>block_w</name> <init>= <expr><ternary><condition><expr><name>plane_index</name></expr> ?</condition><then> <expr><name>block_size</name><operator>&gt;&gt;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name></expr> </then><else>: <expr><name>block_size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>block_h</name> <init>= <expr><ternary><condition><expr><name>plane_index</name></expr> ?</condition><then> <expr><name>block_size</name><operator>&gt;&gt;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_v_shift</name></name></expr> </then><else>: <expr><name>block_size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>obmc</name> <init>= <expr><ternary><condition><expr><name>plane_index</name></expr> ?</condition><then> <expr><name><name>ff_obmc_tab</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name><operator>+</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name></expr>]</index></name></expr> </then><else>: <expr><name><name>ff_obmc_tab</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>obmc_stride</name><init>= <expr><ternary><condition><expr><name>plane_index</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>block_size</name><operator>)</operator><operator>&gt;&gt;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name></expr> </then><else>: <expr><literal type="number">2</literal><operator>*</operator><name>block_size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_stride</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst8</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>current_picture</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name><init>= <expr><name><name>p</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>h</name><init>= <expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>chroma_v_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>keyframe</name></name> <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>debug</name></name><operator>&amp;</operator><literal type="number">512</literal><operator>)</operator></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>mb_y</name><operator>==</operator><name>mb_h</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>add</name></expr>)</condition><block>{<block_content>

<for>for<control>(<init><expr><name>y</name><operator>=</operator><name>block_h</name><operator>*</operator><name>mb_y</name></expr>;</init> <condition><expr><name>y</name><operator>&lt;</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>block_h</name><operator>*</operator><operator>(</operator><name>mb_y</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name><operator>&lt;</operator><name>w</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>v</name><init>= <expr><name><name>buf</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>w</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><literal type="number">128</literal><operator>&lt;&lt;</operator><name>FRAC_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>FRAC_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <name>FRAC_BITS</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>v</name><operator>&amp;</operator><operator>(</operator><operator>~</operator><literal type="number">255</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name><operator>=</operator> <operator>~</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dst8</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>ref_stride</name></expr>]</index></name><operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></if><else>else<block>{<block_content>

<for>for<control>(<init><expr><name>y</name><operator>=</operator><name>block_h</name><operator>*</operator><name>mb_y</name></expr>;</init> <condition><expr><name>y</name><operator>&lt;</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>block_h</name><operator>*</operator><operator>(</operator><name>mb_y</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name><operator>&lt;</operator><name>w</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>w</name></expr>]</index></name><operator>-=</operator> <literal type="number">128</literal><operator>&lt;&lt;</operator><name>FRAC_BITS</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for<control>(<init><expr><name>mb_x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>mb_x</name><operator>&lt;=</operator><name>mb_w</name></expr>;</condition> <incr><expr><name>mb_x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>add_yblock</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dst8</name></expr></argument>, <argument><expr><name>obmc</name></expr></argument>,

<argument><expr><name>block_w</name><operator>*</operator><name>mb_x</name> <operator>-</operator> <name>block_w</name><operator>/</operator><literal type="number">2</literal></expr></argument>,

<argument><expr><name>block_h</name><operator>*</operator><name>mb_y</name> <operator>-</operator> <name>block_h</name><operator>/</operator><literal type="number">2</literal></expr></argument>,

<argument><expr><name>block_w</name></expr></argument>, <argument><expr><name>block_h</name></expr></argument>,

<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>,

<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ref_stride</name></expr></argument>, <argument><expr><name>obmc_stride</name></expr></argument>,

<argument><expr><name>mb_x</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>mb_y</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name>add</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>predict_plane</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>IDWTELEM</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mb_h</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_height</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mb_y</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>mb_y</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>mb_y</name><operator>&lt;=</operator><name>mb_h</name></expr>;</condition> <incr><expr><name>mb_y</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>predict_slice</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>plane_index</name></expr></argument>, <argument><expr><name>add</name></expr></argument>, <argument><expr><name>mb_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_blocks</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>my</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>b_width</name></name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rem_depth</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>block_max_depth</name></name> <operator>-</operator> <name>level</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name><init>= <expr><operator>(</operator><name>x</name> <operator>+</operator> <name>y</name><operator>*</operator><name>w</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>rem_depth</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>block_w</name><init>= <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>rem_depth</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>block_h</name><init>= <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>rem_depth</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>BlockNode</name></type> <name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>color</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>color</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name>cb</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>color</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>=</operator> <name>cr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>mx</name></name><operator>=</operator> <name>mx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>my</name></name><operator>=</operator> <name>my</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>ref</name></name><operator>=</operator> <name>ref</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>type</name></name><operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>.</operator><name>level</name></name><operator>=</operator> <name>level</name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>block_h</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>block_w</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>index</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>j</name><operator>*</operator><name>w</name></expr>]</index></name><operator>=</operator> <name>block</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>init_ref</name><parameter_list>(<parameter><decl><type><name>MotionEstContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>ref</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>ref2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>offset</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><init>= <expr><block>{

<expr><name>y</name><operator>*</operator><name><name>c</name><operator>-&gt;</operator> <name>stride</name></name> <operator>+</operator> <name>x</name></expr>,

<expr><operator>(</operator><operator>(</operator><name>y</name><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>uvstride</name></name> <operator>+</operator> <name>x</name><operator>)</operator><operator>&gt;&gt;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name><operator>)</operator></expr>,

<expr><operator>(</operator><operator>(</operator><name>y</name><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>uvstride</name></name> <operator>+</operator> <name>x</name><operator>)</operator><operator>&gt;&gt;</operator><name><name>s</name><operator>-&gt;</operator><name>chroma_h_shift</name></name><operator>)</operator></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator> <name><name>src</name> <index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>ref</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator> <name><name>ref</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>offset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><operator>!</operator><name>ref_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>int8_t</name></type> <name><name>ff_quant3bA</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QEXPSHIFT</name></cpp:macro> <cpp:value>(7-FRAC_BITS+8)</cpp:value></cpp:define> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>put_symbol</name><parameter_list>(<parameter><decl><type><name>RangeCoder</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_signed</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>v</name></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>a</name><init>= <expr><call><name>FFABS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>e</name><init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>el</name><init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>el</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>e</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>e</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><name>el</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">22</literal><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><operator>(</operator><name>a</name><operator>&gt;&gt;</operator><name>i</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">22</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>a</name><operator>&gt;&gt;</operator><name>i</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>is_signed</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">11</literal> <operator>+</operator> <name>el</name></expr></argument>, <argument><expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>get_symbol</name><parameter_list>(<parameter><decl><type><name>RangeCoder</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_signed</name></decl></parameter>)</parameter_list><block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>

<else>else<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>a</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while<condition>(<expr><call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content> 

<expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&gt;</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>a</name><operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>e</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name>a</name> <operator>+=</operator> <name>a</name> <operator>+</operator> <call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">22</literal> <operator>+</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<expr_stmt><expr><name>e</name><operator>=</operator> <operator>-</operator><operator>(</operator><name>is_signed</name> <operator>&amp;&amp;</operator> <call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">11</literal> <operator>+</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> 

<return>return <expr><operator>(</operator><name>a</name><operator>^</operator><name>e</name><operator>)</operator><operator>-</operator><name>e</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>put_symbol2</name><parameter_list>(<parameter><decl><type><name>RangeCoder</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name><init>= <expr><ternary><condition><expr><name>log2</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>v</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>log2</name><operator>&gt;=</operator><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while<condition>(<expr><name>v</name> <operator>&gt;=</operator> <name>r</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>log2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>log2</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>log2</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name><operator>+=</operator><name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>log2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>log2</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>put_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">31</literal><operator>-</operator><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><name>i</name><operator>)</operator><operator>&amp;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>get_symbol2</name><parameter_list>(<parameter><decl><type><name>RangeCoder</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name><init>= <expr><ternary><condition><expr><name>log2</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>log2</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>v</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>log2</name><operator>&gt;=</operator><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while<condition>(<expr><name>log2</name><operator>&lt;</operator><literal type="number">28</literal> <operator>&amp;&amp;</operator> <call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><name>log2</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>v</name><operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>log2</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>log2</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name><operator>+=</operator><name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>log2</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name>v</name><operator>+=</operator> <call><name>get_rac</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>state</name><operator>+</operator><literal type="number">31</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><name>i</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>v</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>unpack_coeffs</name><parameter_list>(<parameter><decl><type><name>SnowContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>SubBand</name> <modifier>*</modifier></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>orientation</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name><init>= <expr><name><name>b</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>h</name><init>= <expr><name><name>b</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>run</name></decl>, <decl><type ref="prev"/><name>runs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type><name>xc</name><init>= <expr><name><name>b</name><operator>-&gt;</operator><name>x_coeff</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type><name>prev_xc</name><init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type><name>prev2_xc</name><init>= <expr><name>xc</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type><name>parent_xc</name><init>= <expr><ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><name><name>parent</name><operator>-&gt;</operator><name>x_coeff</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>x_and_coeff</name> <modifier>*</modifier></type><name>prev_parent_xc</name><init>= <expr><name>parent_xc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>runs</name><operator>=</operator> <call><name>get_symbol2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>runs</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>run</name><operator>=</operator> <call><name>get_symbol2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>run</name><operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for<control>(<init><expr><name>y</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name><operator>&lt;</operator><name>h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>v</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lt</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>t</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rt</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>y</name> <operator>&amp;&amp;</operator> <name><name>prev_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>rt</name><operator>=</operator> <name><name>prev_xc</name><operator>-&gt;</operator><name>coeff</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for<control>(<init><expr><name>x</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name><operator>&lt;</operator><name>w</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>p</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>l</name><init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lt</name><operator>=</operator> <name>t</name></expr>;</expr_stmt> <expr_stmt><expr><name>t</name><operator>=</operator> <name>rt</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>y</name></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>prev_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prev_xc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>prev_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>rt</name><operator>=</operator> <name><name>prev_xc</name><operator>-&gt;</operator><name>coeff</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>rt</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>parent_xc</name></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>x</name><operator>&gt;&gt;</operator><literal type="number">1</literal> <operator>&gt;</operator> <name><name>parent_xc</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>parent_xc</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>x</name><operator>&gt;&gt;</operator><literal type="number">1</literal> <operator>==</operator> <name><name>parent_xc</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>p</name><operator>=</operator> <name><name>parent_xc</name><operator>-&gt;</operator><name>coeff</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>l</name><operator>|</operator><name>lt</name><operator>|</operator><name>t</name><operator>|</operator><name>rt</name><operator>|</operator><name>p</name></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>context</name><init>= <expr><call><name>av_log2</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>*</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>lt</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>t</name><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>rt</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>p</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name><operator>=</operator><call><name>get_rac</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>context</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>v</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>v</name><operator>=</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><call><name>get_symbol2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><name>context</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>context</name><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name><operator>+=</operator><call><name>get_rac</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <name><name>ff_quant3bA</name><index>[<expr><name>l</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr>]</index></name> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name><name>ff_quant3bA</name><index>[<expr><name>t</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint16_t</name><operator>)</operator><name>v</name> <operator>!=</operator> <name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Coefficient damaged\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>xc</name><operator>-&gt;</operator><name>x</name></name><operator>=</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>xc</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>coeff</name><operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>run</name></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>runs</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>run</name><operator>=</operator> <call><name>get_symbol2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>run</name><operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>v</name><operator>=</operator> <literal type="number">2</literal><operator>*</operator><operator>(</operator><call><name>get_symbol2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name><operator>+=</operator><call><name>get_rac</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint16_t</name><operator>)</operator><name>v</name> <operator>!=</operator> <name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Coefficient damaged\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>xc</name><operator>-&gt;</operator><name>x</name></name><operator>=</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>xc</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>coeff</name><operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>max_run</name></decl>;</decl_stmt>

<expr_stmt><expr><name>run</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>run</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>y</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_run</name><operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>run</name></expr></argument>, <argument><expr><name><name>prev_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name>x</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>max_run</name><operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>run</name></expr></argument>, <argument><expr><name>w</name><operator>-</operator><name>x</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>parent_xc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_run</name><operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>max_run</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name><name>parent_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name>x</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>max_run</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max_run</name> <operator>&lt;=</operator> <name>run</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name><operator>+=</operator> <name>max_run</name></expr>;</expr_stmt>

<expr_stmt><expr><name>run</name><operator>-=</operator> <name>max_run</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>xc</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>x</name><operator>=</operator> <name>w</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>prev_xc</name><operator>=</operator> <name>prev2_xc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev2_xc</name><operator>=</operator> <name>xc</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>parent_xc</name></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>y</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<while>while<condition>(<expr><name><name>parent_xc</name><operator>-&gt;</operator><name>x</name></name> <operator>!=</operator> <name><name>parent</name><operator>-&gt;</operator><name>width</name></name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>parent_xc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>parent_xc</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_parent_xc</name><operator>=</operator> <name>parent_xc</name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name>parent_xc</name><operator>=</operator> <name>prev_parent_xc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>xc</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>x</name><operator>=</operator> <name>w</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></function>

</unit>
