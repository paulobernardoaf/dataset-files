<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\iirfilter.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/attributes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/common.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iirfilter.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>FFIIRFilterCoeffs</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>gain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>cx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>cy</name></decl>;</decl_stmt>

}</block></struct></type> <name>FFIIRFilterCoeffs</name>;</typedef>

<typedef>typedef <type><struct>struct <name>FFIIRFilterState</name> <block>{

<decl_stmt><decl><type><name>float</name></type> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>FFIIRFilterState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXORDER</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>butterworth_init_coeffs</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>avc</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>IIRFilterMode</name></name></type> <name>filt_mode</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>cutoff_ratio</name></decl></parameter>,

<parameter><decl><type><name>float</name></type> <name>stopband</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>wa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name><name>p</name><index>[<expr><name>MAXORDER</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>filt_mode</name> <operator>!=</operator> <name>FF_FILTER_MODE_LOWPASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Butterworth filter currently only supports "</literal>

<literal type="string">"low-pass filter mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Butterworth filter currently only supports "</literal>

<literal type="string">"even filter orders\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>wa</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>tan</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <literal type="number">0.5</literal> <operator>*</operator> <name>cutoff_ratio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>order</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>order</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1LL</literal><operator>)</operator> <operator>/</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>order</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>order</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name><name>zp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>th</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <operator>(</operator><name>order</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <name>order</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>a_re</name></decl>, <decl><type ref="prev"/><name>a_im</name></decl>, <decl><type ref="prev"/><name>c_re</name></decl>, <decl><type ref="prev"/><name>c_im</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>cos</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>wa</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>wa</name></expr>;</expr_stmt>

<expr_stmt><expr><name>a_re</name> <operator>=</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>c_re</name> <operator>=</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>a_im</name> <operator>=</operator>

<name>c_im</name> <operator>=</operator> <name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>a_re</name> <operator>*</operator> <name>c_re</name> <operator>+</operator> <name>a_im</name> <operator>*</operator> <name>c_im</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>c_re</name> <operator>*</operator> <name>c_re</name> <operator>+</operator> <name>c_im</name> <operator>*</operator> <name>c_im</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>a_im</name> <operator>*</operator> <name>c_re</name> <operator>-</operator> <name>a_re</name> <operator>*</operator> <name>c_im</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>c_re</name> <operator>*</operator> <name>c_re</name> <operator>+</operator> <name>c_im</name> <operator>*</operator> <name>c_im</name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>order</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>a_re</name> <operator>=</operator> <name><name>p</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>a_im</name> <operator>=</operator> <name><name>p</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>a_re</name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>a_im</name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>a_re</name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>a_im</name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>a_re</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>zp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>a_re</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>gain</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>order</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>gain</name></name> <operator>+=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>-</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>-</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>/</operator>

<operator>(</operator><name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>p</name><index>[<expr><name>order</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>gain</name></name> <operator>/=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>order</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>biquad_init_coeffs</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>avc</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>IIRFilterMode</name></name></type> <name>filt_mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>order</name></decl></parameter>,

<parameter><decl><type><name>float</name></type> <name>cutoff_ratio</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>stopband</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>cos_w0</name></decl>, <decl><type ref="prev"/><name>sin_w0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>a0</name></decl>, <decl><type ref="prev"/><name>x0</name></decl>, <decl><type ref="prev"/><name>x1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>filt_mode</name> <operator>!=</operator> <name>FF_FILTER_MODE_HIGHPASS</name> <operator>&amp;&amp;</operator>

<name>filt_mode</name> <operator>!=</operator> <name>FF_FILTER_MODE_LOWPASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Biquad filter currently only supports "</literal>

<literal type="string">"high-pass and low-pass filter modes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Biquad filter must have order of 2\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cos_w0</name> <operator>=</operator> <call><name>cos</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <name>cutoff_ratio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sin_w0</name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><name>M_PI</name> <operator>*</operator> <name>cutoff_ratio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a0</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>sin_w0</name> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>filt_mode</name> <operator>==</operator> <name>FF_FILTER_MODE_HIGHPASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>gain</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>x0</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>x1</name> <operator>=</operator> <operator>(</operator><operator>-</operator><operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>cos_w0</name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>gain</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>x0</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>x1</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>-</operator><literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>sin_w0</name> <operator>/</operator> <literal type="number">2.0</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>cos_w0</name><operator>)</operator> <operator>/</operator> <name>a0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>x0</name> <operator>/</operator> <name><name>c</name><operator>-&gt;</operator><name>gain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>x1</name> <operator>/</operator> <name><name>c</name><operator>-&gt;</operator><name>gain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>av_cold</name> <name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>ff_iir_filter_init_coeffs</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>avc</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>IIRFilterType</name></name></type> <name>filt_type</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>IIRFilterMode</name></name></type> <name>filt_mode</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>cutoff_ratio</name></decl></parameter>,

<parameter><decl><type><name>float</name></type> <name>stopband</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>ripple</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FFIIRFilterCoeffs</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>order</name> <operator>&gt;</operator> <name>MAXORDER</name> <operator>||</operator> <name>cutoff_ratio</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FF_ALLOCZ_OR_GOTO</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FFIIRFilterCoeffs</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name>init_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOC_OR_GOTO</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>(</operator><name>order</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,

<argument><expr><name>init_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_ALLOC_OR_GOTO</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>cy</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>order</name></expr></argument>,

<argument><expr><name>init_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>filt_type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>FF_FILTER_TYPE_BUTTERWORTH</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>butterworth_init_coeffs</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>filt_mode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>cutoff_ratio</name></expr></argument>,

<argument><expr><name>stopband</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>FF_FILTER_TYPE_BIQUAD</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>biquad_init_coeffs</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>filt_mode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>cutoff_ratio</name></expr></argument>,

<argument><expr><name>stopband</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avc</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"filter type is not currently implemented\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>init_fail</name>;</goto>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>init_fail</name>:</label>

<expr_stmt><expr><call><name>ff_iir_filter_free_coeffsp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>av_cold</name> <name><name>struct</name> <name>FFIIRFilterState</name></name> <modifier>*</modifier></type><name>ff_iir_filter_init_state</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>order</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FFIIRFilterState</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>av_mallocz</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FFIIRFilterState</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>order</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_S16</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>source</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dest = av_clip_int16(lrintf(source));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_FLT</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>source</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dest = source;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILTER_BW_O4_1</name><parameter_list>(<parameter><type><name>i0</name></type></parameter>, <parameter><type><name>i1</name></type></parameter>, <parameter><type><name>i2</name></type></parameter>, <parameter><type><name>i3</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>in = *src0 * c-&gt;gain + c-&gt;cy[0] * s-&gt;x[i0] + c-&gt;cy[1] * s-&gt;x[i1] + c-&gt;cy[2] * s-&gt;x[i2] + c-&gt;cy[3] * s-&gt;x[i3]; res = (s-&gt;x[i0] + in) * 1 + (s-&gt;x[i1] + s-&gt;x[i3]) * 4 + s-&gt;x[i2] * 6; CONV_ ##fmt(*dst0, res) s-&gt;x[i0] = in; src0 += sstep; dst0 += dstep;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILTER_BW_O4</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ int i; const type *src0 = src; type *dst0 = dst; for (i = 0; i &lt; size; i += 4) { float in, res; FILTER_BW_O4_1(0, 1, 2, 3, fmt); FILTER_BW_O4_1(1, 2, 3, 0, fmt); FILTER_BW_O4_1(2, 3, 0, 1, fmt); FILTER_BW_O4_1(3, 0, 1, 2, fmt); } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILTER_DIRECT_FORM_II</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ int i; const type *src0 = src; type *dst0 = dst; for (i = 0; i &lt; size; i++) { int j; float in, res; in = *src0 * c-&gt;gain; for (j = 0; j &lt; c-&gt;order; j++) in += c-&gt;cy[j] * s-&gt;x[j]; res = s-&gt;x[0] + in + s-&gt;x[c-&gt;order &gt;&gt; 1] * c-&gt;cx[c-&gt;order &gt;&gt; 1]; for (j = 1; j &lt; c-&gt;order &gt;&gt; 1; j++) res += (s-&gt;x[j] + s-&gt;x[c-&gt;order - j]) * c-&gt;cx[j]; for (j = 0; j &lt; c-&gt;order - 1; j++) s-&gt;x[j] = s-&gt;x[j + 1]; CONV_ ##fmt(*dst0, res) s-&gt;x[c-&gt;order - 1] = in; src0 += sstep; dst0 += dstep; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILTER_O2</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ int i; const type *src0 = src; type *dst0 = dst; for (i = 0; i &lt; size; i++) { float in = *src0 * c-&gt;gain + s-&gt;x[0] * c-&gt;cy[0] + s-&gt;x[1] * c-&gt;cy[1]; CONV_ ##fmt(*dst0, s-&gt;x[0] + in + s-&gt;x[1] * c-&gt;cx[1]) s-&gt;x[0] = s-&gt;x[1]; s-&gt;x[1] = in; src0 += sstep; dst0 += dstep; } }</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>ff_iir_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>FFIIRFilterState</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>sstep</name></decl></parameter>,

<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>dstep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>order</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<macro><name>FILTER_O2</name><argument_list>(<argument>int16_t</argument>, <argument>S16</argument>)</argument_list></macro>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>order</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<macro><name>FILTER_BW_O4</name><argument_list>(<argument>int16_t</argument>, <argument>S16</argument>)</argument_list></macro>

</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>FILTER_DIRECT_FORM_II</name><argument_list>(<argument>int16_t</argument>, <argument>S16</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>ff_iir_filter_flt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>FFIIRFilterState</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>sstep</name></decl></parameter>,

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>dstep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>order</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<macro><name>FILTER_O2</name><argument_list>(<argument>float</argument>, <argument>FLT</argument>)</argument_list></macro>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>order</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<macro><name>FILTER_BW_O4</name><argument_list>(<argument>float</argument>, <argument>FLT</argument>)</argument_list></macro>

</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>FILTER_DIRECT_FORM_II</name><argument_list>(<argument>float</argument>, <argument>FLT</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>av_cold</name> <name>void</name></type> <name>ff_iir_filter_free_statep</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>FFIIRFilterState</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>av_cold</name> <name>void</name></type> <name>ff_iir_filter_free_coeffsp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>coeffsp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>FFIIRFilterCoeffs</name></name> <modifier>*</modifier></type><name>coeffs</name> <init>= <expr><operator>*</operator><name>coeffsp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>coeffs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>coeffs</name><operator>-&gt;</operator><name>cx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>coeffs</name><operator>-&gt;</operator><name>cy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><name>coeffsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>ff_iir_filter_init</name><parameter_list>(<parameter><decl><type><name>FFIIRFilterContext</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>filter_flt</name></name> <operator>=</operator> <name>ff_iir_filter_flt</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>HAVE_MIPSFPU</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ff_iir_filter_init_mips</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

</unit>
