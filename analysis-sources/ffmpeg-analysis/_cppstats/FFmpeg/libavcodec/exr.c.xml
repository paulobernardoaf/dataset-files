<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\exr.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/common.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/imgutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intfloat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/color_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytestream.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bswapdsp.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"exrdsp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"get_bits.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mathops.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread.h"</cpp:file></cpp:include>

<enum>enum <name>ExrCompr</name> <block>{

<decl><name>EXR_RAW</name></decl>,

<decl><name>EXR_RLE</name></decl>,

<decl><name>EXR_ZIP1</name></decl>,

<decl><name>EXR_ZIP16</name></decl>,

<decl><name>EXR_PIZ</name></decl>,

<decl><name>EXR_PXR24</name></decl>,

<decl><name>EXR_B44</name></decl>,

<decl><name>EXR_B44A</name></decl>,

<decl><name>EXR_DWA</name></decl>,

<decl><name>EXR_DWB</name></decl>,

<decl><name>EXR_UNKN</name></decl>,

}</block>;</enum>

<enum>enum <name>ExrPixelType</name> <block>{

<decl><name>EXR_UINT</name></decl>,

<decl><name>EXR_HALF</name></decl>,

<decl><name>EXR_FLOAT</name></decl>,

<decl><name>EXR_UNKNOWN</name></decl>,

}</block>;</enum>

<enum>enum <name>ExrTileLevelMode</name> <block>{

<decl><name>EXR_TILE_LEVEL_ONE</name></decl>,

<decl><name>EXR_TILE_LEVEL_MIPMAP</name></decl>,

<decl><name>EXR_TILE_LEVEL_RIPMAP</name></decl>,

<decl><name>EXR_TILE_LEVEL_UNKNOWN</name></decl>,

}</block>;</enum>

<enum>enum <name>ExrTileLevelRound</name> <block>{

<decl><name>EXR_TILE_ROUND_UP</name></decl>,

<decl><name>EXR_TILE_ROUND_DOWN</name></decl>,

<decl><name>EXR_TILE_ROUND_UNKNOWN</name></decl>,

}</block>;</enum>

<typedef>typedef <type><struct>struct <name>EXRChannel</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>xsub</name></decl>, <name>ysub</name>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrPixelType</name></name></type> <name>pixel_type</name></decl>;</decl_stmt>

}</block></struct></type> <name>EXRChannel</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EXRTileAttribute</name> <block>{

<decl_stmt><decl><type><name>int32_t</name></type> <name>xSize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int32_t</name></type> <name>ySize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrTileLevelMode</name></name></type> <name>level_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrTileLevelRound</name></name></type> <name>level_round</name></decl>;</decl_stmt>

}</block></struct></type> <name>EXRTileAttribute</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EXRThreadData</name> <block>{

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>uncompressed_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmp_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>lut</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ysize</name></decl>, <name>xsize</name>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>channel_line_size</name></decl>;</decl_stmt>

}</block></struct></type> <name>EXRThreadData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EXRContext</name> <block>{

<decl_stmt><decl><type><name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>picture</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExrDSPContext</name></type> <name>dsp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>

<decl_stmt><decl><type><name>BswapDSPContext</name></type> <name>bbdsp</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrCompr</name></name></type> <name>compression</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrPixelType</name></name></type> <name>pixel_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>channel_offsets</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>, <name>h</name>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>xmax</name></decl>, <name>xmin</name>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>ymax</name></decl>, <name>ymin</name>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>xdelta</name></decl>, <name>ydelta</name>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>scan_lines_per_block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EXRTileAttribute</name></type> <name>tile_attr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>is_tile</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>is_luma</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GetByteContext</name></type> <name>gb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EXRChannel</name> <modifier>*</modifier></type><name>channels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_channels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>current_channel_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>thread_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>layer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>AVColorTransferCharacteristic</name></name></type> <name>apply_trc_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>gamma</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>gamma_table</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>EXRContext</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP</name></cpp:macro> <cpp:value>0x38000000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP</name></cpp:macro> <cpp:value>0x47800000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_MAX_BIASED_EXP</name></cpp:macro> <cpp:value>(0xFF &lt;&lt; 23)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_FLOAT_MAX_BIASED_EXP</name></cpp:macro> <cpp:value>(0x1F &lt;&lt; 10)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name><name>union</name> <name>av_intfloat32</name></name></type> <name>exr_half2float</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>hf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sign</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>hf</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mantissa</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>hf</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>exp</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>hf</name> <operator>&amp;</operator> <name>HALF_FLOAT_MAX_BIASED_EXP</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>union</name> <name>av_intfloat32</name></name></type> <name>f</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>==</operator> <name>HALF_FLOAT_MAX_BIASED_EXP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>exp</name> <operator>=</operator> <name>FLOAT_MAX_BIASED_EXP</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mantissa</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mantissa</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>exp</name> <operator>==</operator> <literal type="number">0x0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mantissa</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mantissa</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>exp</name> <operator>=</operator> <name>HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>mantissa</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mantissa</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>exp</name> <operator>-=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">23</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>mantissa</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>mantissa</name> <operator>&lt;&lt;=</operator> <literal type="number">13</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>mantissa</name> <operator>&lt;&lt;=</operator> <literal type="number">13</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>exp</name> <operator>=</operator> <operator>(</operator><name>exp</name> <operator>&lt;&lt;</operator> <literal type="number">13</literal><operator>)</operator> <operator>+</operator> <name>HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>f</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>sign</name> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>|</operator> <name>exp</name> <operator>|</operator> <name>mantissa</name></expr>;</expr_stmt>

<return>return <expr><name>f</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16_t</name></type> <name>exr_flt2uint</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int32_t</name></type> <name>exp</name> <init>= <expr><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">23</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>+</operator> <literal type="number">7</literal> <operator>-</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&gt;=</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0xffff</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>&amp;=</operator> <literal type="number">0x007fffff</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>v</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">23</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">127</literal> <operator>+</operator> <literal type="number">7</literal> <operator>-</operator> <name>exp</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16_t</name></type> <name>exr_halflt2uint</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>exp</name> <init>= <expr><literal type="number">14</literal> <operator>-</operator> <operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&gt;=</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>==</operator> <literal type="number">14</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x8000</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">0xffff</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>v</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>exp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zip_uncompress</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressed_size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>uncompressed_size</name></decl></parameter>, <parameter><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>dest_len</name> <init>= <expr><name>uncompressed_size</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>uncompress</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest_len</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>compressed_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name> <operator>||</operator>

<name>dest_len</name> <operator>!=</operator> <name>uncompressed_size</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>uncompressed_size</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>predictor</name></name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>reorder_pixels</name></name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>rle_uncompress</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressed_size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>uncompressed_size</name></decl></parameter>, <parameter><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ssize</name> <init>= <expr><name>compressed_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dsize</name> <init>= <expr><name>uncompressed_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dend</name> <init>= <expr><name>d</name> <operator>+</operator> <name>dsize</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ssize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dsize</name> <operator>-=</operator> <name>count</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>(</operator><name>ssize</name> <operator>-=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dsize</name> <operator>-=</operator> <name>count</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>(</operator><name>ssize</name> <operator>-=</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>dend</name> <operator>!=</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>uncompressed_size</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>predictor</name></name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>dsp</name><operator>.</operator><name>reorder_pixels</name></name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USHORT_RANGE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 16)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITMAP_SIZE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 13)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>uint16_t</name></type> <name>reverse_lut</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>bitmap</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>lut</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>USHORT_RANGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>bitmap</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lut</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>lut</name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>USHORT_RANGE</name> <operator>-</operator> <name>k</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>i</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>apply_lut</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>lut</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dsize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dsize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lut</name><index>[<expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ENCBITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECBITS</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_ENCSIZE</name></cpp:macro> <cpp:value>((1 &lt;&lt; HUF_ENCBITS) + 1)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECSIZE</name></cpp:macro> <cpp:value>(1 &lt;&lt; HUF_DECBITS)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUF_DECMASK</name></cpp:macro> <cpp:value>(HUF_DECSIZE - 1)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>HufDec</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

}</block></struct></type> <name>HufDec</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>huf_canonical_code_table</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>hcode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name><name>n</name><index>[<expr><literal type="number">59</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HUF_ENCSIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>n</name><index>[<expr><name><name>hcode</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">58</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>nc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>c</name> <operator>+</operator> <name><name>n</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>nc</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HUF_ENCSIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name><name>hcode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hcode</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>l</name> <operator>|</operator> <operator>(</operator><name><name>n</name><index>[<expr><name>l</name></expr>]</index></name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHORT_ZEROCODE_RUN</name></cpp:macro> <cpp:value>59</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_ZEROCODE_RUN</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHORTEST_LONG_RUN</name></cpp:macro> <cpp:value>(2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONGEST_LONG_RUN</name></cpp:macro> <cpp:value>(255 + SHORTEST_LONG_RUN)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>huf_unpack_enc_table</name><parameter_list>(<parameter><decl><type><name>GetByteContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>,

<parameter><decl><type><name>int32_t</name></type> <name>im</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>iM</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>hcode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>GetBitContext</name></type> <name>gbit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>init_get_bits8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gbit</name></expr></argument>, <argument><expr><name><name>gb</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>im</name> <operator>&lt;=</operator> <name>iM</name></expr>;</condition> <incr><expr><name>im</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>l</name> <init>= <expr><name><name>hcode</name><index>[<expr><name>im</name></expr>]</index></name> <operator>=</operator> <call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gbit</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>LONG_ZEROCODE_RUN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>zerun</name> <init>= <expr><call><name>get_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gbit</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>SHORTEST_LONG_RUN</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>im</name> <operator>+</operator> <name>zerun</name> <operator>&gt;</operator> <name>iM</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>zerun</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hcode</name><index>[<expr><name>im</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>im</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>SHORT_ZEROCODE_RUN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>zerun</name> <init>= <expr><name>l</name> <operator>-</operator> <name>SHORT_ZEROCODE_RUN</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>im</name> <operator>+</operator> <name>zerun</name> <operator>&gt;</operator> <name>iM</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>zerun</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>hcode</name><index>[<expr><name>im</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>im</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><operator>(</operator><call><name>get_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gbit</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>huf_canonical_code_table</name><argument_list>(<argument><expr><name>hcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>huf_build_dec_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>hcode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>im</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>iM</name></decl></parameter>, <parameter><decl><type><name>HufDec</name> <modifier>*</modifier></type><name>hdecod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>im</name> <operator>&lt;=</operator> <name>iM</name></expr>;</condition> <incr><expr><name>im</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>c</name> <init>= <expr><name><name>hcode</name><index>[<expr><name>im</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>l</name> <init>= <expr><name><name>hcode</name><index>[<expr><name>im</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;&gt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>HUF_DECBITS</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>HufDec</name> <modifier>*</modifier></type><name>pl</name> <init>= <expr><name>hdecod</name> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>l</name> <operator>-</operator> <name>HUF_DECBITS</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pl</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>lit</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>pl</name><operator>-&gt;</operator><name>lit</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pl</name><operator>-&gt;</operator><name>p</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>pl</name><operator>-&gt;</operator><name>lit</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>im</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>HufDec</name> <modifier>*</modifier></type><name>pl</name> <init>= <expr><name>hdecod</name> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>HUF_DECBITS</name> <operator>-</operator> <name>l</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>HUF_DECBITS</name> <operator>-</operator> <name>l</name><operator>)</operator></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>pl</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pl</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>pl</name><operator>-&gt;</operator><name>p</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>lit</name></name> <operator>=</operator> <name>im</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_char</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>lc</name></type></parameter>, <parameter><type><name>gb</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ c = (c &lt;&lt; 8) | bytestream2_get_byte(gb); lc += 8; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_code</name><parameter_list>(<parameter><type><name>po</name></type></parameter>, <parameter><type><name>rlc</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>lc</name></type></parameter>, <parameter><type><name>gb</name></type></parameter>, <parameter><type><name>out</name></type></parameter>, <parameter><type><name>oe</name></type></parameter>, <parameter><type><name>outb</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (po == rlc) { if (lc &lt; 8) get_char(c, lc, gb); lc -= 8; cs = c &gt;&gt; lc; if (out + cs &gt; oe || out == outb) return AVERROR_INVALIDDATA; s = out[-1]; while (cs-- &gt; 0) *out++ = s; } else if (out &lt; oe) { *out++ = po; } else { return AVERROR_INVALIDDATA; } }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>huf_decode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>hcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HufDec</name> <modifier>*</modifier></type><name>hdecod</name></decl></parameter>,

<parameter><decl><type><name>GetByteContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbits</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>rlc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>outb</name> <init>= <expr><name>out</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><name>out</name> <operator>+</operator> <name>no</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>ie</name> <init>= <expr><name><name>gb</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <operator>(</operator><name>nbits</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>cs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>lc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>gb</name><operator>-&gt;</operator><name>buffer</name></name> <operator>&lt;</operator> <name>ie</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>get_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lc</name> <operator>&gt;=</operator> <name>HUF_DECBITS</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>HufDec</name></type> <name>pl</name> <init>= <expr><name><name>hdecod</name><index>[<expr><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>lc</name> <operator>-</operator> <name>HUF_DECBITS</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>HUF_DECMASK</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pl</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lc</name> <operator>-=</operator> <name><name>pl</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_code</name><argument_list>(<argument><expr><name><name>pl</name><operator>.</operator><name>lit</name></name></expr></argument>, <argument><expr><name>rlc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>oe</name></expr></argument>, <argument><expr><name>outb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pl</name><operator>.</operator><name>p</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pl</name><operator>.</operator><name>lit</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name><name>hcode</name><index>[<expr><name><name>pl</name><operator>.</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>lc</name> <argument_list type="generic">&lt; <argument><expr><name>l</name> <operator>&amp;&amp;</operator> <name>bytestream2_get_bytes_left</name><operator>(</operator><name>gb</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>get_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>&gt;=</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hcode</name><index>[<expr><name><name>pl</name><operator>.</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>==</operator>

<operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>lc</name> <operator>-</operator> <name>l</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <name>l</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lc</name> <operator>-=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_code</name><argument_list>(<argument><expr><name><name>pl</name><operator>.</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>rlc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>oe</name></expr></argument>, <argument><expr><name>outb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>pl</name><operator>.</operator><name>lit</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></while>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>nbits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">7</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>&gt;&gt;=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lc</name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>HufDec</name></type> <name>pl</name> <init>= <expr><name><name>hdecod</name><index>[<expr><operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>HUF_DECBITS</name> <operator>-</operator> <name>lc</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>HUF_DECMASK</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pl</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>lc</name> <operator>&gt;=</operator> <name><name>pl</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lc</name> <operator>-=</operator> <name><name>pl</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_code</name><argument_list>(<argument><expr><name><name>pl</name><operator>.</operator><name>lit</name></name></expr></argument>, <argument><expr><name>rlc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>oe</name></expr></argument>, <argument><expr><name>outb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>out</name> <operator>-</operator> <name>outb</name> <operator>!=</operator> <name>no</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>huf_uncompress</name><parameter_list>(<parameter><decl><type><name>GetByteContext</name> <modifier>*</modifier></type><name>gb</name></decl></parameter>,

<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dst_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int32_t</name></type> <name>src_size</name></decl>, <decl><type ref="prev"/><name>im</name></decl>, <decl><type ref="prev"/><name>iM</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>nBits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>freq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HufDec</name> <modifier>*</modifier></type><name>hdec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src_size</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>im</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iM</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nBits</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>im</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>im</name> <operator>&gt;=</operator> <name>HUF_ENCSIZE</name> <operator>||</operator>

<name>iM</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>iM</name> <operator>&gt;=</operator> <name>HUF_ENCSIZE</name> <operator>||</operator>

<name>src_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>freq</name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name>HUF_ENCSIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>freq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hdec</name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name>HUF_DECSIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>freq</name> <operator>||</operator> <operator>!</operator><name>hdec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>huf_unpack_enc_table</name><argument_list>(<argument><expr><name>gb</name></expr></argument>, <argument><expr><name>im</name></expr></argument>, <argument><expr><name>iM</name></expr></argument>, <argument><expr><name>freq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nBits</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>*</operator> <call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><name>gb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>huf_build_dec_table</name><argument_list>(<argument><expr><name>freq</name></expr></argument>, <argument><expr><name>im</name></expr></argument>, <argument><expr><name>iM</name></expr></argument>, <argument><expr><name>hdec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>huf_decode</name><argument_list>(<argument><expr><name>freq</name></expr></argument>, <argument><expr><name>hdec</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>nBits</name></expr></argument>, <argument><expr><name>iM</name></expr></argument>, <argument><expr><name>dst_size</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail</name>:</label>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HUF_DECSIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>hdec</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>hdec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>wdec14</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int16_t</name></type> <name>ls</name> <init>= <expr><name>l</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int16_t</name></type> <name>hs</name> <init>= <expr><name>h</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hi</name> <init>= <expr><name>hs</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ai</name> <init>= <expr><name>ls</name> <operator>+</operator> <operator>(</operator><name>hi</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hi</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int16_t</name></type> <name>as</name> <init>= <expr><name>ai</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int16_t</name></type> <name>bs</name> <init>= <expr><name>ai</name> <operator>-</operator> <name>hi</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <name>as</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <name>bs</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>A_OFFSET</name></cpp:macro> <cpp:value>(1 &lt;&lt; (NBITS - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_MASK</name></cpp:macro> <cpp:value>((1 &lt;&lt; NBITS) - 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>wdec16</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><name>l</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><name>h</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bb</name> <init>= <expr><operator>(</operator><name>m</name> <operator>-</operator> <operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>MOD_MASK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>aa</name> <init>= <expr><operator>(</operator><name>d</name> <operator>+</operator> <name>bb</name> <operator>-</operator> <name>A_OFFSET</name><operator>)</operator> <operator>&amp;</operator> <name>MOD_MASK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <name>bb</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <name>aa</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>wav_decode</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ox</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>ny</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oy</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>mx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>w14</name> <init>= <expr><operator>(</operator><name>mx</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nx</name> <operator>&gt;</operator> <name>ny</name><operator>)</operator></expr> ?</condition><then> <expr><name>ny</name></expr> </then><else>: <expr><name>nx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>p2</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>py</name> <init>= <expr><name>in</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ey</name> <init>= <expr><name>in</name> <operator>+</operator> <name>oy</name> <operator>*</operator> <operator>(</operator><name>ny</name> <operator>-</operator> <name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>i00</name></decl>, <decl><type ref="prev"/><name>i01</name></decl>, <decl><type ref="prev"/><name>i10</name></decl>, <decl><type ref="prev"/><name>i11</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>oy1</name> <init>= <expr><name>oy</name> <operator>*</operator> <name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>oy2</name> <init>= <expr><name>oy</name> <operator>*</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ox1</name> <init>= <expr><name>ox</name> <operator>*</operator> <name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ox2</name> <init>= <expr><name>ox</name> <operator>*</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>py</name> <operator>&lt;=</operator> <name>ey</name></expr>;</condition> <incr><expr><name>py</name> <operator>+=</operator> <name>oy2</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>px</name> <init>= <expr><name>py</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><name>py</name> <operator>+</operator> <name>ox</name> <operator>*</operator> <operator>(</operator><name>nx</name> <operator>-</operator> <name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>px</name> <operator>&lt;=</operator> <name>ex</name></expr>;</condition> <incr><expr><name>px</name> <operator>+=</operator> <name>ox2</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p01</name> <init>= <expr><name>px</name> <operator>+</operator> <name>ox1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p10</name> <init>= <expr><name>px</name> <operator>+</operator> <name>oy1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p11</name> <init>= <expr><name>p10</name> <operator>+</operator> <name>ox1</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>w14</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p10</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><operator>*</operator><name>p01</name></expr></argument>, <argument><expr><operator>*</operator><name>p11</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i01</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><name>i00</name></expr></argument>, <argument><expr><name>i01</name></expr></argument>, <argument><expr><name>px</name></expr></argument>, <argument><expr><name>p01</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><name>i10</name></expr></argument>, <argument><expr><name>i11</name></expr></argument>, <argument><expr><name>p10</name></expr></argument>, <argument><expr><name>p11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p10</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><operator>*</operator><name>p01</name></expr></argument>, <argument><expr><operator>*</operator><name>p11</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i01</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><name>i00</name></expr></argument>, <argument><expr><name>i01</name></expr></argument>, <argument><expr><name>px</name></expr></argument>, <argument><expr><name>p01</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><name>i10</name></expr></argument>, <argument><expr><name>i11</name></expr></argument>, <argument><expr><name>p10</name></expr></argument>, <argument><expr><name>p11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nx</name> <operator>&amp;</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p10</name> <init>= <expr><name>px</name> <operator>+</operator> <name>oy1</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>w14</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p10</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><name>p10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p10</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><name>p10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>px</name> <operator>=</operator> <name>i00</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ny</name> <operator>&amp;</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>px</name> <init>= <expr><name>py</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><name>py</name> <operator>+</operator> <name>ox</name> <operator>*</operator> <operator>(</operator><name>nx</name> <operator>-</operator> <name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>px</name> <operator>&lt;=</operator> <name>ex</name></expr>;</condition> <incr><expr><name>px</name> <operator>+=</operator> <name>ox2</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>p01</name> <init>= <expr><name>px</name> <operator>+</operator> <name>ox1</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>w14</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wdec14</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p01</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><name>p01</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wdec16</name><argument_list>(<argument><expr><operator>*</operator><name>px</name></expr></argument>, <argument><expr><operator>*</operator><name>p01</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i00</name></expr></argument>, <argument><expr><name>p01</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>px</name> <operator>=</operator> <name>i00</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>piz_uncompress</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ssize</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dsize</name></decl></parameter>, <parameter><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>GetByteContext</name></type> <name>gb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>maxval</name></decl>, <decl><type ref="prev"/><name>min_non_zero</name></decl>, <decl><type ref="prev"/><name>max_non_zero</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pixel_half_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EXRChannel</name> <modifier>*</modifier></type><name>channel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmp_offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>lut</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name> <operator>||</operator> <operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min_non_zero</name> <operator>=</operator> <call><name>bytestream2_get_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max_non_zero</name> <operator>=</operator> <call><name>bytestream2_get_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_non_zero</name> <operator>&gt;=</operator> <name>BITMAP_SIZE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>min_non_zero</name></expr></argument>, <argument><expr><name>BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_non_zero</name> <operator>&lt;=</operator> <name>max_non_zero</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>bytestream2_get_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name> <operator>+</operator> <name>min_non_zero</name></expr></argument>,

<argument><expr><name>max_non_zero</name> <operator>-</operator> <name>min_non_zero</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name> <operator>+</operator> <name>max_non_zero</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BITMAP_SIZE</name> <operator>-</operator> <name>max_non_zero</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>maxval</name> <operator>=</operator> <call><name>reverse_lut</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>huf_uncompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gb</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>dsize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>channel</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>channel</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pixel_half_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>pixel_half_size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>pixel_half_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wav_decode</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr></argument>, <argument><expr><name>pixel_half_size</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr></argument>,

<argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name>pixel_half_size</name></expr></argument>, <argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <name>pixel_half_size</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>apply_lut</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>dsize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tmp_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>channel</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>channel</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pixel_half_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>pixel_half_size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <name>tmp_offset</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name>pixel_half_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_offset</name> <operator>+=</operator> <name>pixel_half_size</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>bbdsp</name><operator>.</operator><name>bswap16_buf</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name>pixel_half_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name>pixel_half_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>out</name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name>pixel_half_size</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pxr24_uncompress</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>compressed_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>uncompressed_size</name></decl></parameter>,

<parameter><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>dest_len</name></decl>, <decl><type ref="prev"/><name>expected_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pixel_type</name> <operator>==</operator> <name>EXR_FLOAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expected_len</name> <operator>+=</operator> <operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pixel_type</name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expected_len</name> <operator>+=</operator> <operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>expected_len</name> <operator>+=</operator> <operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>dest_len</name> <operator>=</operator> <name>expected_len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>uncompress</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dest_len</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>compressed_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dest_len</name> <operator>!=</operator> <name>expected_len</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>EXRChannel</name> <modifier>*</modifier></type><name>channel</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>c</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>ptr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>pixel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>channel</name><operator>-&gt;</operator><name>pixel_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EXR_FLOAT</name></expr>:</case>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pixel</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream_put_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><name>EXR_HALF</name></expr>:</case>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pixel</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream_put_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><name>EXR_UINT</name></expr>:</case>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>*</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>++</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pixel</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream_put_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<default>default:</default>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></for></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unpack_14</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>b</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name><name>s</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>shift</name> <init>= <expr><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>bias</name> <init>= <expr><operator>(</operator><literal type="number">0x20</literal> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">8</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[ <expr><literal type="number">9</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[ <expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[ <expr><literal type="number">6</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator> <operator>-</operator> <name>bias</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x8000</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7fff</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>~</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unpack_3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name><name>s</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x8000</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7fff</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>~</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>b44_uncompress</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compressed_size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>uncompressed_size</name></decl></parameter>, <parameter><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int8_t</name> <modifier>*</modifier></type><name>sr</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stay_to_uncompress</name> <init>= <expr><name>compressed_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_b44_block_w</name></decl>, <decl><type ref="prev"/><name>nb_b44_block_h</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index_tl_x</name></decl>, <decl><type ref="prev"/><name>index_tl_y</name></decl>, <decl><type ref="prev"/><name>index_out</name></decl>, <decl><type ref="prev"/><name>index_tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>tmp_buffer</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>iY</name></decl>, <decl><type ref="prev"/><name>iX</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>target_channel_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nb_b44_block_w</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>%</operator> <literal type="number">4</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nb_b44_block_w</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_b44_block_h</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>%</operator> <literal type="number">4</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nb_b44_block_h</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name>c</name></expr>]</index></name><operator>.</operator><name>pixel_type</name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>iY</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iY</name> <operator>&lt;</operator> <name>nb_b44_block_h</name></expr>;</condition> <incr><expr><name>iY</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>iX</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iX</name> <operator>&lt;</operator> <name>nb_b44_block_w</name></expr>;</condition> <incr><expr><name>iX</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>stay_to_uncompress</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not enough data for B44A block: %d"</literal></expr></argument>, <argument><expr><name>stay_to_uncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><name>compressed_size</name> <operator>-</operator> <name>stay_to_uncompress</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xfc</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>unpack_3</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>tmp_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>stay_to_uncompress</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>stay_to_uncompress</name> <operator>&lt;</operator> <literal type="number">14</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not enough data for B44 block: %d"</literal></expr></argument>, <argument><expr><name>stay_to_uncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>unpack_14</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>tmp_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sr</name> <operator>+=</operator> <literal type="number">14</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>stay_to_uncompress</name> <operator>-=</operator> <literal type="number">14</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>index_tl_x</name> <operator>=</operator> <name>iX</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>index_tl_y</name> <operator>=</operator> <name>iY</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>index_tl_y</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>index_tl_y</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>index_tl_x</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>index_tl_x</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>index_out</name> <operator>=</operator> <name>target_channel_offset</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>+</operator> <name>y</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>index_tmp</name> <operator>=</operator> <operator>(</operator><name>y</name><operator>-</operator><name>index_tl_y</name><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <operator>(</operator><name>x</name><operator>-</operator><name>index_tl_x</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name><index>[<expr><name>index_out</name></expr>]</index></name> <operator>=</operator> <name><name>tmp_buffer</name><index>[<expr><name>index_tmp</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name><index>[<expr><name>index_out</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tmp_buffer</name><index>[<expr><name>index_tmp</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><name>target_channel_offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>stay_to_uncompress</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not enough data for uncompress channel: %d"</literal></expr></argument>, <argument><expr><name>stay_to_uncompress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>index_out</name> <operator>=</operator> <name>target_channel_offset</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>+</operator> <name>y</name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name><index>[<expr><name>index_out</name></expr>]</index></name></expr></argument>, <argument><expr><name>sr</name></expr></argument>, <argument><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sr</name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>target_channel_offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>stay_to_uncompress</name> <operator>-=</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_block</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>jobnr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>threadnr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>picture</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>thread_data</name><index>[<expr><name>threadnr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>channel_buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>line_offset</name></decl>, <decl><type ref="prev"/><name>uncompressed_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ptr_x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>data_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>line</name></decl>, <decl><type ref="prev"/><name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>tile_x</name></decl>, <decl><type ref="prev"/><name>tile_y</name></decl>, <decl><type ref="prev"/><name>tile_level_x</name></decl>, <decl><type ref="prev"/><name>tile_level_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>axmax</name> <init>= <expr><operator>(</operator><name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>-</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>bxmin</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>buf_size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>buf_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>rgb_channel_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>one_gamma</name> <init>= <expr><literal type="number">1.0f</literal> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>gamma</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>avpriv_trc_function</name></type> <name>trc_func</name> <init>= <expr><call><name>avpriv_get_trc_function_from_trc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>apply_trc_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>line_offset</name> <operator>=</operator> <call><name>AV_RL64</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <name>jobnr</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>buf_size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">20</literal> <operator>||</operator> <name>line_offset</name></expr></argument> &gt;</argument_list></name> <name>buf_size</name> <operator>-</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>line_offset</name> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>tile_x</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tile_y</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tile_level_x</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tile_level_y</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>data_size</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>data_size</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>line_offset</name> <operator>-</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tile_level_x</name> <operator>||</operator> <name>tile_level_y</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Subres tile before full res tile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>ymin</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Tiles with xmin/ymin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name> <operator>*</operator> <name>tile_y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name> <operator>*</operator> <name>tile_x</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>line</name> <argument_list type="generic">&lt; <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ymin</name></name> <operator>||</operator> <name>line</name></expr></argument> &gt;</argument_list></name> <name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>||</operator>

<name><name>col</name> <argument_list type="generic">&lt; <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>||</operator> <name>col</name></expr></argument> &gt;</argument_list></name> <name><name>s</name><operator>-&gt;</operator><name>xmax</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ydelta</name></name> <operator>-</operator> <name>tile_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name> <operator>-</operator> <name>tile_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>col</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>bxmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>col</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name><operator>)</operator> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>axmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>uncompressed_size</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>buf_size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>line_offset</name></expr></argument> &gt;</argument_list></name> <name>buf_size</name> <operator>-</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>line_offset</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>line</name> <argument_list type="generic">&lt; <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ymin</name></name> <operator>||</operator> <name>line</name></expr></argument> &gt;</argument_list></name> <name><name>s</name><operator>-&gt;</operator><name>ymax</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>AV_RL32</name><argument_list>(<argument><expr><name>src</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>data_size</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>data_size</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>line_offset</name> <operator>-</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>-</operator> <name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>uncompressed_size</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>EXR_RAW</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>data_size</name> <operator>!=</operator> <name>uncompressed_size</name> <operator>||</operator>

<name>line_offset</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>uncompressed_size</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>!=</operator> <name>EXR_RAW</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>data_size</name> <operator>&gt;</operator> <name>uncompressed_size</name> <operator>||</operator>

<name>line_offset</name> <operator>&gt;</operator> <name>buf_size</name> <operator>-</operator> <name>data_size</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>data_size</name> <operator>&lt;</operator> <name>uncompressed_size</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>av_fast_padded_malloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>tmp_size</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>data_size</name> <operator>&lt;</operator> <name>uncompressed_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_fast_padded_malloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>, <argument><expr><name>uncompressed_size</name> <operator>+</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EXR_ZIP1</name></expr>:</case>

<case>case <expr><name>EXR_ZIP16</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zip_uncompress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_PIZ</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>piz_uncompress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_PXR24</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pxr24_uncompress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_RLE</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rle_uncompress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_B44</name></expr>:</case>

<case>case <expr><name>EXR_B44A</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>b44_uncompress</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>uncompressed_size</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"decode_block() failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>rgb_channel_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>rgb_channel_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>src</name> <operator>+</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>line</name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>col</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>

<condition><expr><name>i</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>ysize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type> <name>a</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name><name>rgb</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>rgb_channel_count</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>rgb</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name><name>channel_buffer</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr_x</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bxmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr_x</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>==</operator> <name>EXR_FLOAT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>trc_func</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>union</name> <name>av_intfloat32</name></name></type> <name>t</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>rgb_channel_count</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rgb</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>trc_func</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>union</name> <name>av_intfloat32</name></name></type> <name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>rgb_channel_count</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>i</name></name> <operator>=</operator> <call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rgb</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>&gt;</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>powf</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>one_gamma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>rgb_channel_count</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gamma_table</name><index>[<expr><call><name>bytestream_get_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rgb</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>exr_halflt2uint</name><argument_list>(<argument><expr><call><name>bytestream_get_le16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>==</operator> <name>EXR_UINT</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name><name>td</name><operator>-&gt;</operator><name>xsize</name></name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>rgb_channel_count</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rgb</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_x</name><operator>++</operator> <operator>=</operator> <call><name>bytestream_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>axmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>channel_buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name><name>td</name><operator>-&gt;</operator><name>channel_line_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_header_variable</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_type</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>minimum_length</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>var_size</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>minimum_length</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>value_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>value_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value_type</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>var_size</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>var_size</name> <operator>&gt;</operator> <call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>var_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>-=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,

<argument><expr><literal type="string">"Unknown data type %s for header variable %s.\n"</literal></expr></argument>,

<argument><expr><name>value_type</name></expr></argument>, <argument><expr><name>value_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>var_size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_header</name><parameter_list>(<parameter><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVDictionary</name> <modifier>*</modifier></type><name>metadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>magic_number</name></decl>, <decl><type ref="prev"/><name>version</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>, <decl><type ref="prev"/><name>sar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>layer_match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dup_channels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ymin</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ydelta</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>=</operator> <name>EXR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>EXR_UNKN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Header too short to parse.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>magic_number</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>magic_number</name> <operator>!=</operator> <literal type="number">20000630</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong magic number %d.\n"</literal></expr></argument>, <argument><expr><name>magic_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>version</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Version %d"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>bytestream2_get_le24</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x08</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"deep data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x10</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"multipart"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>var_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"channels"</literal></expr></argument>,

<argument><expr><literal type="string">"chlist"</literal></expr></argument>, <argument><expr><literal type="number">38</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>GetByteContext</name></type> <name>ch_gb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>var_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">19</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>EXRChannel</name> <modifier>*</modifier></type><name>channel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ExrPixelType</name></name></type> <name>current_pixel_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>channel_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xsub</name></decl>, <decl><type ref="prev"/><name>ysub</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>layer_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,

<argument><expr><literal type="string">"Channel match layer : %s.\n"</literal></expr></argument>, <argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>layer_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>,

<argument><expr><literal type="string">"Channel doesn't match layer : %s.\n"</literal></expr></argument>, <argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>layer_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>layer_match</name></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"R"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"U"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>channel_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"G"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"V"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>channel_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"Y"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>channel_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"B"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"Z"</literal></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"W"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>channel_index</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"A"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>channel_index</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,

<argument><expr><literal type="string">"Unsupported channel %.256s.\n"</literal></expr></argument>, <argument><expr><name><name>ch_gb</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></while>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Incomplete header.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current_pixel_type</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>current_pixel_type</name> <operator>&gt;=</operator> <name>EXR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Pixel type %d"</literal></expr></argument>,

<argument><expr><name>current_pixel_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_PATCHWELCOME</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xsub</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ysub</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch_gb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xsub</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>ysub</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>,

<argument><expr><literal type="string">"Subsampling %dx%d"</literal></expr></argument>,

<argument><expr><name>xsub</name></expr></argument>, <argument><expr><name>ysub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_PATCHWELCOME</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>channel_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><name>channel_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>!=</operator> <name>EXR_UNKNOWN</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>!=</operator> <name>current_pixel_type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,

<argument><expr><literal type="string">"RGB channels not of the same depth.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>=</operator> <name>current_pixel_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><name>channel_index</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>channel_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,

<argument><expr><literal type="string">"Multiple channels with index %d.\n"</literal></expr></argument>, <argument><expr><name>channel_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>dup_channels</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <call><name>av_realloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr></argument>,

<argument><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EXRChannel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>channel</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>nb_channels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel</name><operator>-&gt;</operator><name>pixel_type</name></name> <operator>=</operator> <name>current_pixel_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel</name><operator>-&gt;</operator><name>xsub</name></name> <operator>=</operator> <name>xsub</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>channel</name><operator>-&gt;</operator><name>ysub</name></name> <operator>=</operator> <name>ysub</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>current_pixel_type</name> <operator>==</operator> <name>EXR_HALF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>current_channel_offset</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FFMIN3</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing red channel.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing green channel.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing blue channel.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gb</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name><name>ch_gb</name><operator>.</operator><name>buffer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"dataWindow"</literal></expr></argument>, <argument><expr><literal type="string">"box2i"</literal></expr></argument>,

<argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ymin</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>xmin</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ydelta</name></name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>ymin</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"displayWindow"</literal></expr></argument>,

<argument><expr><literal type="string">"box2i"</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"lineOrder"</literal></expr></argument>,

<argument><expr><literal type="string">"lineOrder"</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line_order</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line_order</name> <operator>=</operator> <call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"line order: %d.\n"</literal></expr></argument>, <argument><expr><name>line_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line_order</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown line order.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"pixelAspectRatio"</literal></expr></argument>,

<argument><expr><literal type="string">"float"</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sar</name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"compression"</literal></expr></argument>,

<argument><expr><literal type="string">"compression"</literal></expr></argument>, <argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>EXR_UNKN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,

<argument><expr><literal type="string">"Found more than one compression attribute.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"tiles"</literal></expr></argument>,

<argument><expr><literal type="string">"tiledesc"</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>tileLevel</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,

<argument><expr><literal type="string">"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name> <operator>=</operator> <call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tileLevel</name> <operator>=</operator> <call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_mode</name></name> <operator>=</operator> <name>tileLevel</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_round</name></name> <operator>=</operator> <operator>(</operator><name>tileLevel</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_mode</name></name> <operator>&gt;=</operator> <name>EXR_TILE_LEVEL_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Tile level mode %d"</literal></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_PATCHWELCOME</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_round</name></name> <operator>&gt;=</operator> <name>EXR_TILE_ROUND_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><literal type="string">"Tile level round %d"</literal></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>level_round</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_PATCHWELCOME</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>var_size</name> <operator>=</operator> <call><name>check_header_variable</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"writer"</literal></expr></argument>,

<argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>key</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bytestream2_get_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>var_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_dict_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"writer"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Incomplete header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> 

<while>while <condition>(<expr><call><name>bytestream2_get_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while></block_content></block></for>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ff_set_sar</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><call><name>av_d2q</name><argument_list>(<argument><expr><call><name>av_int2float</name><argument_list>(<argument><expr><name>sar</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>EXR_UNKN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing compression attribute.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid tile attribute.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Incomplete frame.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>metadata</name></name> <operator>=</operator> <name>metadata</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream2_skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>

<expr_stmt><expr><call><name>av_dict_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_frame</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ThreadFrame</name></type> <name>frame</name> <init>= <expr><block>{ <expr><operator>.</operator><name>f</name> <operator>=</operator> <name>data</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>picture</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>out_line_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_blocks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint64_t</name></type> <name>start_offset_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>start_next_scanline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PutByteContext</name></type> <name>offset_table_writer</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bytestream2_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>decode_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>picture</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pixel_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EXR_FLOAT</name></expr>:</case>

<case>case <expr><name>EXR_HALF</name></expr>:</case>

<case>case <expr><name>EXR_UINT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>channel_offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>AV_PIX_FMT_RGBA64</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>AV_PIX_FMT_YA16</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_luma</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>AV_PIX_FMT_RGB48</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name> <operator>=</operator> <name>AV_PIX_FMT_GRAY16</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Missing channel list.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>apply_trc_type</name></name> <operator>!=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>color_trc</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>apply_trc_type</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EXR_RAW</name></expr>:</case>

<case>case <expr><name>EXR_RLE</name></expr>:</case>

<case>case <expr><name>EXR_ZIP1</name></expr>:</case>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_PXR24</name></expr>:</case>

<case>case <expr><name>EXR_ZIP16</name></expr>:</case>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EXR_PIZ</name></expr>:</case>

<case>case <expr><name>EXR_B44</name></expr>:</case>

<case>case <expr><name>EXR_B44A</name></expr>:</case>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>avpriv_report_missing_feature</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><literal type="string">"Compression %d"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>ymin</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>xmin</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>xmax</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>w</name></name> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>h</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Wrong or missing size information.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_set_dimensions</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>pix_fmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>desc</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>out_line_size</name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>nb_components</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nb_blocks</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>xdelta</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>xSize</name></name><operator>)</operator> <operator>*</operator>

<operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ydelta</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>tile_attr</name><operator>.</operator><name>ySize</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><name>nb_blocks</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ydelta</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator>

<name><name>s</name><operator>-&gt;</operator><name>scan_lines_per_block</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_thread_get_buffer</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frame</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bytestream2_get_bytes_left</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nb_blocks</name> <operator>*</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_tile</name></name> <operator>&amp;&amp;</operator> <call><name>bytestream2_peek_le64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"recreating invalid scanline offset table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start_offset_table</name> <operator>=</operator> <call><name>bytestream2_tell</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start_next_scanline</name> <operator>=</operator> <name>start_offset_table</name> <operator>+</operator> <name>nb_blocks</name> <operator>*</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream2_init_writer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset_table_writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>avpkt</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>start_offset_table</name></expr>]</index></name></expr></argument>, <argument><expr><name>nb_blocks</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>nb_blocks</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>bytestream2_put_le64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset_table_writer</name></expr></argument>, <argument><expr><name>start_next_scanline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bytestream2_seek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>start_next_scanline</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start_next_scanline</name> <operator>+=</operator> <operator>(</operator><call><name>bytestream2_get_le32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>bytestream2_seek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>gb</name></name></expr></argument>, <argument><expr><name>start_offset_table</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>=</operator> <name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>picture</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ymin</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out_line_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>picture</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>picture</name></name> <operator>=</operator> <name>picture</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>avctx</name><operator>-&gt;</operator><name>execute2</name></name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>decode_block</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nb_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>picture</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>ymax</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>picture</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ymax</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>height</name></name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>out_line_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>picture</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>picture</name><operator>-&gt;</operator><name>pict_type</name></name> <operator>=</operator> <name>AV_PICTURE_TYPE_I</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>got_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>decode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>union</name> <name>av_intfloat32</name></name></type> <name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>one_gamma</name> <init>= <expr><literal type="number">1.0f</literal> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>gamma</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>avpriv_trc_function</name></type> <name>trc_func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ff_exrdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>dsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BIGENDIAN</name></expr></cpp:if>

<expr_stmt><expr><call><name>ff_bswapdsp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>bbdsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>trc_func</name> <operator>=</operator> <call><name>avpriv_get_trc_function_from_trc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>apply_trc_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>trc_func</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>exr_half2float</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>trc_func</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gamma_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>one_gamma</name> <operator>&gt;</operator> <literal type="number">0.9999f</literal> <operator>&amp;&amp;</operator> <name>one_gamma</name> <operator>&lt;</operator> <literal type="number">1.0001f</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gamma_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exr_halflt2uint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>exr_half2float</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gamma_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exr_halflt2uint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>powf</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>one_gamma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gamma_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exr_flt2uint</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EXRThreadData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_THREADS</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_init_thread_copy</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EXRThreadData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>decode_end</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>EXRContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>avctx</name><operator>-&gt;</operator><name>thread_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>EXRThreadData</name> <modifier>*</modifier></type><name>td</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>thread_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>uncompressed_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>thread_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(EXRContext, x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VD</name></cpp:macro> <cpp:value>AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"layer"</literal></expr>, <expr><literal type="string">"Set the decoding layer"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>layer</name></expr></argument>)</argument_list></call></expr>,

<expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{ <expr><operator>.</operator><name>str</name> <operator>=</operator> <literal type="string">""</literal></expr> }</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>VD</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"gamma"</literal></expr>, <expr><literal type="string">"Set the float gamma value when decoding"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>gamma</name></expr></argument>)</argument_list></call></expr>,

<expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{ <expr><operator>.</operator><name>dbl</name> <operator>=</operator> <literal type="number">1.0f</literal></expr> }</block></expr>, <expr><literal type="number">0.001</literal></expr>, <expr><name>FLT_MAX</name></expr>, <expr><name>VD</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"apply_trc"</literal></expr>, <expr><literal type="string">"color transfer characteristics to apply to EXR linear input"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>apply_trc_type</name></expr></argument>)</argument_list></call></expr>,

<expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr> }</block></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>AVCOL_TRC_NB</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"bt709"</literal></expr>, <expr><literal type="string">"BT.709"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_BT709</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"gamma"</literal></expr>, <expr><literal type="string">"gamma"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_UNSPECIFIED</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"gamma22"</literal></expr>, <expr><literal type="string">"BT.470 M"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_GAMMA22</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"gamma28"</literal></expr>, <expr><literal type="string">"BT.470 BG"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_GAMMA28</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"smpte170m"</literal></expr>, <expr><literal type="string">"SMPTE 170 M"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_SMPTE170M</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"smpte240m"</literal></expr>, <expr><literal type="string">"SMPTE 240 M"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_SMPTE240M</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"linear"</literal></expr>, <expr><literal type="string">"Linear"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_LINEAR</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"log"</literal></expr>, <expr><literal type="string">"Log"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_LOG</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"log_sqrt"</literal></expr>, <expr><literal type="string">"Log square root"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_LOG_SQRT</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"iec61966_2_4"</literal></expr>, <expr><literal type="string">"IEC 61966-2-4"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_IEC61966_2_4</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"bt1361"</literal></expr>, <expr><literal type="string">"BT.1361"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_BT1361_ECG</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"iec61966_2_1"</literal></expr>, <expr><literal type="string">"IEC 61966-2-1"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_IEC61966_2_1</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"bt2020_10bit"</literal></expr>, <expr><literal type="string">"BT.2020 - 10 bit"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_BT2020_10</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"bt2020_12bit"</literal></expr>, <expr><literal type="string">"BT.2020 - 12 bit"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_BT2020_12</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"smpte2084"</literal></expr>, <expr><literal type="string">"SMPTE ST 2084"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_SMPTEST2084</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="string">"smpte428_1"</literal></expr>, <expr><literal type="string">"SMPTE ST 428-1"</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name> <operator>=</operator> <name>AVCOL_TRC_SMPTEST428_1</name></expr> }</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>VD</name></expr>, <expr><literal type="string">"apply_trc_type"</literal></expr>}</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVClass</name></type> <name>exr_class</name> <init>= <expr><block>{

<expr><operator>.</operator><name>class_name</name> <operator>=</operator> <literal type="string">"EXR"</literal></expr>,

<expr><operator>.</operator><name>item_name</name> <operator>=</operator> <name>av_default_item_name</name></expr>,

<expr><operator>.</operator><name>option</name> <operator>=</operator> <name>options</name></expr>,

<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>LIBAVUTIL_VERSION_INT</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_exr_decoder</name> <init>= <expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"exr"</literal></expr>,

<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"OpenEXR image"</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,

<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_EXR</name></expr>,

<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EXRContext</name></expr></argument>)</argument_list></sizeof></expr>,

<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>decode_init</name></expr>,

<expr><operator>.</operator><name>init_thread_copy</name> <operator>=</operator> <call><name>ONLY_IF_THREADS_ENABLED</name><argument_list>(<argument><expr><name>decode_init_thread_copy</name></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>decode_end</name></expr>,

<expr><operator>.</operator><name>decode</name> <operator>=</operator> <name>decode_frame</name></expr>,

<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_DR1</name> <operator>|</operator> <name>AV_CODEC_CAP_FRAME_THREADS</name> <operator>|</operator>

<name>AV_CODEC_CAP_SLICE_THREADS</name></expr>,

<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>exr_class</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

</unit>
