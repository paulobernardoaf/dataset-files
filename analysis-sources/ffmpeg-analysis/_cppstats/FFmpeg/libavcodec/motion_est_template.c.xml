<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\motion_est_template.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/qsort.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpegvideo.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_COMMONuint32_t</name></cpp:macro> <cpp:value>av_unused * const score_map= c-&gt;score_map;const int av_unused xmin= c-&gt;xmin;const int av_unused ymin= c-&gt;ymin;const int av_unused xmax= c-&gt;xmax;const int av_unused ymax= c-&gt;ymax;uint8_t *mv_penalty= c-&gt;current_mv_penalty;const int pred_x= c-&gt;pred_x;const int pred_y= c-&gt;pred_y;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_HALF_MV</name><parameter_list>(<parameter><type><name>dx</name></type></parameter>, <parameter><type><name>dy</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const int hx= 2*(x)+(dx);const int hy= 2*(y)+(dy);d= cmp_hpel(s, x, y, dx, dy, size, h, ref_index, src_index, cmp_sub, chroma_cmp_sub, flags);d += (mv_penalty[hx - pred_x] + mv_penalty[hy - pred_y])*penalty_factor;COPY3_IF_LT(dmin, d, bx, hx, by, hy)}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hpel_motion_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mx_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>my_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mx</name> <init>= <expr><operator>*</operator><name>mx_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>my</name> <init>= <expr><operator>*</operator><name>my_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>sub_penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmp_sub</name></decl>, <decl><type ref="prev"/><name>chroma_cmp_sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bx</name><init>=<expr><literal type="number">2</literal><operator>*</operator><name>mx</name></expr></init></decl>, <decl><type ref="prev"/><name>by</name><init>=<expr><literal type="number">2</literal><operator>*</operator><name>my</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>int</name></type> <name>flags</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>sub_flags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmp_sub</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_sub_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmp_sub</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_sub_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition><block>{<block_content> 

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>me_cmp</name></name> <operator>!=</operator> <name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>me_sub_cmp</name></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmp_sub</name></expr></argument>, <argument><expr><name>chroma_cmp_sub</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>mx</name> <operator>||</operator> <name>my</name> <operator>||</operator> <name>size</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dmin</name> <operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>mx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>my</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mx</name> <operator>&gt;</operator> <name>xmin</name> <operator>&amp;&amp;</operator> <name><name>mx</name> <argument_list type="generic">&lt; <argument><expr><name>xmax</name> <operator>&amp;&amp;</operator>

<name>my</name></expr></argument> &gt;</argument_list></name> <name>ymin</name> <operator>&amp;&amp;</operator> <name>my</name> <operator>&lt;</operator> <name>ymax</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name><init>= <expr><name>dmin</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name><init>= <expr><operator>(</operator><name>my</name><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator> <operator>+</operator> <name>mx</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>t</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name>

<operator>+</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>bx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>by</name><operator>-</operator><literal type="number">2</literal> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>l</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator> <literal type="number">1</literal> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name>

<operator>+</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>bx</name><operator>-</operator><literal type="number">2</literal> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>by</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator> <literal type="number">1</literal> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name>

<operator>+</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>bx</name><operator>+</operator><literal type="number">2</literal> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>by</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name>

<operator>+</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>bx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>by</name><operator>+</operator><literal type="number">2</literal> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASSERT_LEVEL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ASSERT_LEVEL</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></cpp:if>

<decl_stmt><decl><type><name>unsigned</name></type> <name>key</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>map_generation</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>key</name><operator>=</operator> <operator>(</operator><operator>(</operator><name>my</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>mx</name><operator>)</operator> <operator>+</operator> <name>map_generation</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name><operator>=</operator> <operator>(</operator><operator>(</operator><name>my</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>mx</name><operator>)</operator> <operator>+</operator> <name>map_generation</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name><operator>=</operator> <operator>(</operator><operator>(</operator><name>my</name><operator>)</operator><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>mx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>map_generation</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name><operator>=</operator> <operator>(</operator><operator>(</operator><name>my</name><operator>)</operator><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>mx</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>map_generation</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name>t</name><operator>&lt;=</operator><name>b</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> ,<argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>l</name><operator>&lt;=</operator><name>r</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>t</name><operator>+</operator><name>r</name><operator>&lt;=</operator><name>b</name><operator>+</operator><name>l</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my</argument> )</argument_list></macro>

</block_content>}</block></else></if_stmt>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my</argument> )</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>t</name><operator>+</operator><name>l</name><operator>&lt;=</operator><name>b</name><operator>+</operator><name>r</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my</argument> )</argument_list></macro>

</block_content>}</block></else></if_stmt>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>mx</argument> , <argument>my</argument> )</argument_list></macro>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>l</name><operator>&lt;=</operator><name>r</name></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>t</name><operator>+</operator><name>l</name><operator>&lt;=</operator><name>b</name><operator>+</operator><name>r</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my</argument> )</argument_list></macro>

</block_content>}</block></else></if_stmt>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my</argument>)</argument_list></macro>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my</argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>t</name><operator>+</operator><name>r</name><operator>&lt;=</operator><name>b</name><operator>+</operator><name>l</name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my-<literal type="number">1</literal></argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx-<literal type="number">1</literal></argument>, <argument>my</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>mx</argument> , <argument>my</argument>)</argument_list></macro>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

<macro><name>CHECK_HALF_MV</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>mx</argument> , <argument>my</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>bx</name> <operator>&gt;=</operator> <name>xmin</name><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>bx</name> <operator>&lt;=</operator> <name>xmax</name><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>by</name> <operator>&gt;=</operator> <name>ymin</name><operator>*</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>by</name> <operator>&lt;=</operator> <name>ymax</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name> <operator>=</operator> <name>bx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name> <operator>=</operator> <name>by</name></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>no_sub_motion_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mx_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>my_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mx_ptr</name><operator>)</operator> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>my_ptr</name><operator>)</operator> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>get_mb_score</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>my</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add_rate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>mb_penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>mb_flags</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>qpel</name><init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FLAG_QPEL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mask</name><init>= <expr><literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>qpel</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmp_sub</name></decl>, <decl><type ref="prev"/><name>chroma_cmp_sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name></type>

<name>cmp_sub</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>mb_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>chroma_cmp_sub</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>mb_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx</name><operator>&gt;&gt;</operator><operator>(</operator><name>qpel</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>my</name><operator>&gt;&gt;</operator><operator>(</operator><name>qpel</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>mx</name><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>my</name><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmp_sub</name></expr></argument>, <argument><expr><name>chroma_cmp_sub</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>add_rate</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>mx</name> <operator>||</operator> <name>my</name> <operator>||</operator> <name>size</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>mx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>my</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>d</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_get_mb_score</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>my</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add_rate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_mb_score</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>add_rate</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_QUARTER_MV</name><parameter_list>(<parameter><type><name>dx</name></type></parameter>, <parameter><type><name>dy</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const int hx= 4*(x)+(dx);const int hy= 4*(y)+(dy);d= cmp_qpel(s, x, y, dx, dy, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags);d += (mv_penalty[hx - pred_x] + mv_penalty[hy - pred_y])*penalty_factor;COPY3_IF_LT(dmin, d, bx, hx, by, hy)}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>qpel_motion_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mx_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>my_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mx</name> <init>= <expr><operator>*</operator><name>mx_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>my</name> <init>= <expr><operator>*</operator><name>my_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>sub_penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>subpel_quality</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>me_subpel_quality</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>map</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmp_sub</name></decl>, <decl><type ref="prev"/><name>chroma_cmp_sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>int</name></type> <name>flags</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>sub_flags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>cmp_sub</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_sub_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmp_sub</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_sub_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition><block>{<block_content> 

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>me_cmp</name></name> <operator>!=</operator> <name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>me_sub_cmp</name></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx</name></expr></argument>, <argument><expr><name>my</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmp_sub</name></expr></argument>, <argument><expr><name>chroma_cmp_sub</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>mx</name> <operator>||</operator> <name>my</name> <operator>||</operator> <name>size</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dmin</name> <operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>mx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>my</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mx</name> <operator>&gt;</operator> <name>xmin</name> <operator>&amp;&amp;</operator> <name><name>mx</name> <argument_list type="generic">&lt; <argument><expr><name>xmax</name> <operator>&amp;&amp;</operator>

<name>my</name></expr></argument> &gt;</argument_list></name> <name>ymin</name> <operator>&amp;&amp;</operator> <name>my</name> <operator>&lt;</operator> <name>ymax</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bx</name><init>=<expr><literal type="number">4</literal><operator>*</operator><name>mx</name></expr></init></decl>, <decl><type ref="prev"/><name>by</name><init>=<expr><literal type="number">4</literal><operator>*</operator><name>my</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name><init>= <expr><name>dmin</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nx</name></decl>, <decl><type ref="prev"/><name>ny</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name><init>= <expr><operator>(</operator><name>my</name><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator> <operator>+</operator> <name>mx</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>t</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>l</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator> <literal type="number">1</literal> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator> <literal type="number">1</literal> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>b</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name> <operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>best</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>best_pos</name><index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>best</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>me</name><operator>.</operator><name>dia_size</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>tl</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bl</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>tr</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>br</name><init>= <expr><name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>+</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>ny</name><operator>=</operator> <operator>-</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>ny</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>ny</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>nx</name><operator>=</operator> <operator>-</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>nx</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>nx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>t2</name><init>= <expr><name>nx</name><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator><name>tr</name> <operator>+</operator> <name>tl</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>t</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator><name>tr</name><operator>-</operator><name>tl</name><operator>)</operator> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>t</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>c2</name><init>= <expr><name>nx</name><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator> <name>r</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>c</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator> <name>r</name><operator>-</operator> <name>l</name><operator>)</operator> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>b2</name><init>= <expr><name>nx</name><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator><name>br</name> <operator>+</operator> <name>bl</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>b</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>nx</name><operator>*</operator><operator>(</operator><name>br</name><operator>-</operator><name>bl</name><operator>)</operator> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>score</name><init>= <expr><operator>(</operator><name>ny</name><operator>*</operator><name>ny</name><operator>*</operator><operator>(</operator><name>b2</name> <operator>+</operator> <name>t2</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>c2</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>ny</name><operator>*</operator><operator>(</operator><name>b2</name> <operator>-</operator> <name>t2</name><operator>)</operator> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c2</name> <operator>+</operator> <literal type="number">512</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>nx</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ny</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>score</name> <operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>mx</name> <operator>+</operator> <name>nx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>my</name> <operator>+</operator> <name>ny</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>score</name> <operator>&lt;</operator> <name><name>best</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>best</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><literal type="number">7</literal><operator>-</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>best_pos</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">7</literal><operator>-</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator> <name>score</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>nx</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>mx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name>ny</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>my</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></if><else>else<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cx</name> <init>= <expr><literal type="number">4</literal><operator>*</operator><operator>(</operator><name>r</name> <operator>-</operator> <name>l</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cx2</name><init>= <expr><name>r</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>c</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cy</name> <init>= <expr><literal type="number">4</literal><operator>*</operator><operator>(</operator><name>b</name> <operator>-</operator> <name>t</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cy2</name><init>= <expr><name>b</name> <operator>+</operator> <name>t</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>c</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cxy</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>my</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>mx</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>map_generation</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>tl</name><operator>=</operator> <name><name>score_map</name><index>[<expr><operator>(</operator><name>index</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name>tl</name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>my</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmpf</name></expr></argument>, <argument><expr><name>chroma_cmpf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>cxy</name><operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>tl</name> <operator>+</operator> <operator>(</operator><name>cx</name> <operator>+</operator> <name>cy</name><operator>)</operator><operator>/</operator><literal type="number">4</literal> <operator>-</operator> <operator>(</operator><name>cx2</name> <operator>+</operator> <name>cy2</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>*</operator><name>cx2</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>cx</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name> <operator>==</operator> <literal type="number">32</literal><operator>*</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>*</operator><name>cx2</name> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name>cx</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name> <operator>==</operator> <literal type="number">32</literal><operator>*</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>*</operator><name>cy2</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>cy</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name> <operator>==</operator> <literal type="number">32</literal><operator>*</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>*</operator><name>cy2</name> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name>cy</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name> <operator>==</operator> <literal type="number">32</literal><operator>*</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><literal type="number">16</literal><operator>*</operator><name>cxy</name> <operator>+</operator> <literal type="number">16</literal><operator>*</operator><name>cy2</name> <operator>+</operator> <literal type="number">16</literal><operator>*</operator><name>cx2</name> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name>cy</name> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name>cx</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name> <operator>==</operator> <literal type="number">32</literal><operator>*</operator><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>ny</name><operator>=</operator> <operator>-</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>ny</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>ny</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>nx</name><operator>=</operator> <operator>-</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>nx</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>nx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>score</name><init>= <expr><name>ny</name><operator>*</operator><name>nx</name><operator>*</operator><name>cxy</name> <operator>+</operator> <name>nx</name><operator>*</operator><name>nx</name><operator>*</operator><name>cx2</name> <operator>+</operator> <name>ny</name><operator>*</operator><name>ny</name><operator>*</operator><name>cy2</name> <operator>+</operator> <name>nx</name><operator>*</operator><name>cx</name> <operator>+</operator> <name>ny</name><operator>*</operator><name>cy</name> <operator>+</operator> <literal type="number">32</literal><operator>*</operator><name>c</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>nx</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ny</name><operator>&amp;</operator><literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>score</name> <operator>+=</operator> <literal type="number">32</literal><operator>*</operator><operator>(</operator><name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>mx</name> <operator>+</operator> <name>nx</name> <operator>-</operator> <name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><literal type="number">4</literal><operator>*</operator><name>my</name> <operator>+</operator> <name>ny</name> <operator>-</operator> <name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>score</name> <operator>&lt;</operator> <name><name>best</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>best</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><literal type="number">7</literal><operator>-</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>best_pos</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">7</literal><operator>-</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator> <name>score</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>nx</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>mx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name>ny</name> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>my</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>subpel_quality</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name>nx</name><operator>=</operator> <name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ny</name><operator>=</operator> <name><name>best_pos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<macro><name>CHECK_QUARTER_MV</name><argument_list>(<argument>nx&amp;<literal type="number">3</literal></argument>, <argument>ny&amp;<literal type="number">3</literal></argument>, <argument>nx&gt;&gt;<literal type="number">2</literal></argument>, <argument>ny&gt;&gt;<literal type="number">2</literal></argument>)</argument_list></macro>

</block_content>}</block></for>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>bx</name> <operator>&gt;=</operator> <name>xmin</name><operator>*</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>bx</name> <operator>&lt;=</operator> <name>xmax</name><operator>*</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>by</name> <operator>&gt;=</operator> <name>ymin</name><operator>*</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>by</name> <operator>&lt;=</operator> <name>ymax</name><operator>*</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name> <operator>=</operator> <name>bx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name> <operator>=</operator> <name>by</name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name> <operator>=</operator><literal type="number">4</literal><operator>*</operator><name>mx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name> <operator>=</operator><literal type="number">4</literal><operator>*</operator><name>my</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_MV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const unsigned key = ((unsigned)(y)&lt;&lt;ME_MAP_MV_BITS) + (x) + map_generation;const int index= (((unsigned)(y)&lt;&lt;ME_MAP_SHIFT) + (x))&amp;(ME_MAP_SIZE-1);av_assert2((x) &gt;= xmin);av_assert2((x) &lt;= xmax);av_assert2((y) &gt;= ymin);av_assert2((y) &lt;= ymax);if(map[index]!=key){d= cmp(s, x, y, 0, 0, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags);map[index]= key;score_map[index]= d;d += (mv_penalty[((x)*(1&lt;&lt;shift))-pred_x] + mv_penalty[((y)*(1&lt;&lt;shift))-pred_y])*penalty_factor;COPY3_IF_LT(dmin, d, best[0], x, best[1], y)}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CLIPPED_MV</name><parameter_list>(<parameter><type><name>ax</name></type></parameter>,<parameter><type><name>ay</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const int Lx= ax;const int Ly= ay;const int Lx2= FFMAX(xmin, FFMIN(Lx, xmax));const int Ly2= FFMAX(ymin, FFMIN(Ly, ymax));CHECK_MV(Lx2, Ly2)}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_MV_DIR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>new_dir</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const unsigned key = ((unsigned)(y)&lt;&lt;ME_MAP_MV_BITS) + (x) + map_generation;const int index= (((unsigned)(y)&lt;&lt;ME_MAP_SHIFT) + (x))&amp;(ME_MAP_SIZE-1);if(map[index]!=key){d= cmp(s, x, y, 0, 0, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags);map[index]= key;score_map[index]= d;d += (mv_penalty[(int)((unsigned)(x)&lt;&lt;shift)-pred_x] + mv_penalty[(int)((unsigned)(y)&lt;&lt;shift)-pred_y])*penalty_factor;if(d&lt;dmin){best[0]=x;best[1]=y;dmin=d;next_dir= new_dir;}}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>S</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if( (x)&lt;(xmin&lt;&lt;(S)) ) av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d xmin" #v, xmin, (x), (y), s-&gt;mb_x, s-&gt;mb_y);if( (x)&gt;(xmax&lt;&lt;(S)) ) av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d xmax" #v, xmax, (x), (y), s-&gt;mb_x, s-&gt;mb_y);if( (y)&lt;(ymin&lt;&lt;(S)) ) av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d ymin" #v, ymin, (x), (y), s-&gt;mb_x, s-&gt;mb_y);if( (y)&gt;(ymax&lt;&lt;(S)) ) av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d ymax" #v, ymax, (x), (y), s-&gt;mb_x, s-&gt;mb_y);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_COMMON2uint32_t</name></cpp:macro> <cpp:value>*map= c-&gt;map;const int qpel= flags&amp;FLAG_QPEL;const int shift= 1+qpel;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>small_diamond_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>next_dir</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>key</name> <init>= <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator> <operator>+</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>map_generation</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name><init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><name>ME_MAP_SHIFT</name><operator>)</operator> <operator>+</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>ME_MAP_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>map</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <name>key</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>score_map</name><index>[<expr><name>index</name></expr>]</index></name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmpf</name></expr></argument>, <argument><expr><name>chroma_cmpf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><index>[<expr><name>index</name></expr>]</index></name><operator>=</operator> <name>key</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dir</name><init>= <expr><name>next_dir</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>next_dir</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>dir</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>x</name><operator>&gt;</operator><name>xmin</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>CHECK_MV_DIR</name><argument_list>(<argument>x-<literal type="number">1</literal></argument>, <argument>y</argument> , <argument><literal type="number">0</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>dir</name><operator>!=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>y</name><operator>&gt;</operator><name>ymin</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>CHECK_MV_DIR</name><argument_list>(<argument>x</argument> , <argument>y-<literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>dir</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>x</name><operator>&lt;</operator><name>xmax</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>CHECK_MV_DIR</name><argument_list>(<argument>x+<literal type="number">1</literal></argument>, <argument>y</argument> , <argument><literal type="number">2</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>dir</name><operator>!=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>y</name><operator>&lt;</operator><name>ymax</name></expr>)</condition><block type="pseudo"><block_content> <macro><name>CHECK_MV_DIR</name><argument_list>(<argument>x</argument> , <argument>y+<literal type="number">1</literal></argument>, <argument><literal type="number">3</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name>next_dir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>funny_diamond_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dia_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dia_size</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>dia_size</name><operator>&lt;=</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>dia_size</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>dia_size</name><operator>&amp;</operator><operator>(</operator><name>dia_size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name>x</name> <operator>+</operator> <name>dia_size</name> <operator>&gt;</operator> <name>xmax</name>

<operator>||</operator> <name>x</name> <operator>-</operator> <name><name>dia_size</name> <argument_list type="generic">&lt; <argument><expr><name>xmin</name>

<operator>||</operator> <name>y</name> <operator>+</operator> <name>dia_size</name></expr></argument> &gt;</argument_list></name> <name>ymax</name>

<operator>||</operator> <name>y</name> <operator>-</operator> <name>dia_size</name> <operator>&lt;</operator> <name>ymin</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for<control>(<init><expr><name>dir</name><operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dir</name><operator>&lt;</operator><name>dia_size</name></expr>;</condition> <incr><expr><name>dir</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>+</operator> <name>dir</name></expr></argument> , <argument><expr><name>y</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>dir</name></expr></argument>, <argument><expr><name>y</name> <operator>-</operator> <name>dir</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator> <name>dir</name></expr></argument> , <argument><expr><name>y</name> <operator>-</operator> <name>dia_size</name> <operator>+</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator> <name>dia_size</name> <operator>+</operator> <name>dir</name></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <name>dir</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>x</name><operator>!=</operator><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name>y</name><operator>!=</operator><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dia_size</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hex_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dia_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>,<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dec</name><init>= <expr><name>dia_size</name> <operator>&amp;</operator> <operator>(</operator><name>dia_size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init>;</init><condition><expr><name>dia_size</name></expr>;</condition> <incr><expr><name>dia_size</name><operator>=</operator> <ternary><condition><expr><name>dec</name></expr> ?</condition><then> <expr><name>dia_size</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></else></ternary></expr></incr>)</control><block>{<block_content>

<do>do<block>{<block_content>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator><name>dia_size</name></expr></argument> , <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator> <name>dia_size</name></expr></argument> , <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><operator>(</operator> <name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>y</name><operator>+</operator><name>dia_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><operator>(</operator> <name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>y</name><operator>-</operator><name>dia_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>dia_size</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><operator>(</operator><operator>-</operator><name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>y</name><operator>+</operator><name>dia_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><operator>(</operator><operator>-</operator><name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>y</name><operator>-</operator><name>dia_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>while<condition>(<expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>x</name> <operator>||</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>y</name></expr>)</condition>;</do>

</block_content>}</block></for>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>l2s_dia_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>,<decl><type ref="prev"/><name>i</name></decl>,<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dia_size</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dec</name><init>= <expr><name>dia_size</name> <operator>&amp;</operator> <operator>(</operator><name>dia_size</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>hex</name><index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">0</literal></expr>,<expr><operator>-</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init>;</init> <condition><expr><name>dia_size</name></expr>;</condition> <incr><expr><name>dia_size</name><operator>=</operator> <ternary><condition><expr><name>dec</name></expr> ?</condition><then> <expr><name>dia_size</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>dia_size</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></else></ternary></expr></incr>)</control><block>{<block_content>

<do>do<block>{<block_content>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><name><name>hex</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name>dia_size</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><name><name>hex</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name>dia_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>while<condition>(<expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>x</name> <operator>||</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>y</name></expr>)</condition>;</do>

</block_content>}</block></for>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>umh_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>,<decl><type ref="prev"/><name>x2</name></decl>,<decl><type ref="prev"/><name>y2</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dia_size</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&amp;</operator><literal type="number">0xFE</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>hex</name><index>[<expr><literal type="number">16</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><block>{<expr><operator>-</operator><literal type="number">4</literal></expr>,<expr><operator>-</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">4</literal></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{ <expr><literal type="number">4</literal></expr>,<expr><operator>-</operator><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">4</literal></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>,<expr><operator>-</operator><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">0</literal></expr>,<expr><operator>-</operator><literal type="number">4</literal></expr>}</block></expr>, <expr><block>{ <expr><literal type="number">2</literal></expr>,<expr><operator>-</operator><literal type="number">3</literal></expr>}</block></expr>,}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>x2</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>x</name><operator>-</operator><name>dia_size</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>x2</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><name>dia_size</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>x2</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for<control>(<init><expr><name>y2</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>y</name><operator>-</operator><name>dia_size</name><operator>/</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ymin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>y2</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>y</name><operator>+</operator><name>dia_size</name><operator>/</operator><literal type="number">2</literal><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>ymax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y2</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>y2</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>y</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>ymin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>y2</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>y</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>ymax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>x2</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>x</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>x2</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>x2</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;=</operator><name>dia_size</name><operator>/</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><name><name>hex</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name>j</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><name><name>hex</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><call><name>hex_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>full_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dia_size</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>y</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><operator>-</operator><name>dia_size</name></expr></argument>, <argument><expr><name>ymin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>y</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>,<argument><expr><name>ymax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for<control>(<init><expr><name>x</name><operator>=</operator><call><name>FFMAX</name><argument_list>(<argument><expr><operator>-</operator><name>dia_size</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>x</name><operator>&lt;=</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>,<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><name>x</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name><operator>=</operator> <name>dmin</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument> , <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CLIPPED_MV</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name>y</name></expr>;</expr_stmt>

<return>return <expr><name>d</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAB_CHECK_MV</name><parameter_list>(<parameter><type><name>ax</name></type></parameter>,<parameter><type><name>ay</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const unsigned key = ((ay)&lt;&lt;ME_MAP_MV_BITS) + (ax) + map_generation;const int index= (((ay)&lt;&lt;ME_MAP_SHIFT) + (ax))&amp;(ME_MAP_SIZE-1);if(map[index]!=key){d= cmp(s, ax, ay, 0, 0, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags);map[index]= key;score_map[index]= d;d += (mv_penalty[((ax)&lt;&lt;shift)-pred_x] + mv_penalty[((ay)&lt;&lt;shift)-pred_y])*penalty_factor;if(d &lt; minima[minima_count-1].height){int j=0;while(d &gt;= minima[j].height) j++;memmove(&amp;minima [j+1], &amp;minima [j], (minima_count - j - 1)*sizeof(Minima));minima[j].checked= 0;minima[j].height= d;minima[j].x= ax;minima[j].y= ay;i=-1;continue;}}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SAB_SIZE</name></cpp:macro> <cpp:value>ME_MAP_SIZE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sab_diamond_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Minima</name></type> <name><name>minima</name><index>[<expr><name>MAX_SAB_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minima_count</name><init>= <expr><call><name>FFABS</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><name>minima_count</name> <operator>&lt;=</operator> <name>MAX_SAB_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ME_MAP_SIZE</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>MAX_SAB_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>key</name><init>= <expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>key</name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ME_MAP_MV_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>ME_MAP_MV_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>key</name> <operator>&amp;</operator> <operator>(</operator><operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>ME_MAP_MV_BITS</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>map_generation</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>height</name><operator>=</operator> <name><name>score_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name><operator>=</operator> <name>key</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>key</name><operator>&gt;&gt;=</operator><name>ME_MAP_MV_BITS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name><operator>=</operator> <name>key</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ME_MAP_MV_BITS</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name><operator>-=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ME_MAP_MV_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name><operator>-=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ME_MAP_MV_BITS</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>&gt;</operator> <name>xmax</name> <operator>||</operator> <name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>&lt;</operator> <name>xmin</name>

<operator>||</operator> <name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>&gt;</operator> <name>ymax</name> <operator>||</operator> <name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>&lt;</operator> <name>ymin</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>checked</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>||</operator> <name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>height</name><operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name><operator>)</operator><operator>&lt;&lt;</operator><name>shift</name><operator>)</operator><operator>-</operator><name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><operator>(</operator><operator>(</operator><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name><operator>)</operator><operator>&lt;&lt;</operator><name>shift</name><operator>)</operator><operator>-</operator><name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>AV_QSORT</name><argument_list>(<argument><expr><name>minima</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>Minima</name></expr></argument>, <argument><expr><name>minima_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>minima_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>height</name><operator>=</operator><literal type="number">256</literal><operator>*</operator><literal type="number">256</literal><operator>*</operator><literal type="number">256</literal><operator>*</operator><literal type="number">64</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>checked</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name><operator>=</operator> <name><name>minima</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>minima_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x</name><init>= <expr><name><name>minima</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y</name><init>= <expr><name><name>minima</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>minima</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checked</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name>x</name> <operator>&gt;=</operator> <name>xmax</name> <operator>||</operator> <name>x</name> <operator>&lt;=</operator> <name>xmin</name>

<operator>||</operator> <name>y</name> <operator>&gt;=</operator> <name>ymax</name> <operator>||</operator> <name>y</name> <operator>&lt;=</operator> <name>ymin</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<macro><name>SAB_CHECK_MV</name><argument_list>(<argument>x-<literal type="number">1</literal></argument>, <argument>y</argument>)</argument_list></macro>

<macro><name>SAB_CHECK_MV</name><argument_list>(<argument>x+<literal type="number">1</literal></argument>, <argument>y</argument>)</argument_list></macro>

<macro><name>SAB_CHECK_MV</name><argument_list>(<argument>x</argument> , <argument>y-<literal type="number">1</literal></argument>)</argument_list></macro>

<macro><name>SAB_CHECK_MV</name><argument_list>(<argument>x</argument> , <argument>y+<literal type="number">1</literal></argument>)</argument_list></macro>

<expr_stmt><expr><name><name>minima</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checked</name><operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name><name>minima</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator> <name><name>minima</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <name><name>minima</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>height</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>xmax</name> <operator>&amp;&amp;</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>xmin</name>

<operator>&amp;&amp;</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>ymax</name> <operator>&amp;&amp;</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>ymin</name></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<macro><name>CHECK_MV</name><argument_list>(<argument>best[<literal type="number">0</literal>]-<literal type="number">1</literal></argument>, <argument>best[<literal type="number">1</literal>]</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>best[<literal type="number">0</literal>]+<literal type="number">1</literal></argument>, <argument>best[<literal type="number">1</literal>]</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>best[<literal type="number">0</literal>]</argument>, <argument>best[<literal type="number">1</literal>]-<literal type="number">1</literal></argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>best[<literal type="number">0</literal>]</argument>, <argument>best[<literal type="number">1</literal>]+<literal type="number">1</literal></argument>)</argument_list></macro>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>var_diamond_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dia_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name>

<name>unsigned</name></type> <name>map_generation</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>map_generation</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dia_size</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>dia_size</name><operator>&lt;=</operator><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name></expr>;</condition> <incr><expr><name>dia_size</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y</name><init>= <expr><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>start</name><operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>ymax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>, <argument><expr><name>xmax</name> <operator>-</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dir</name><operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>dir</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>dir</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>+</operator> <name>dir</name></expr></argument> , <argument><expr><name>y</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>start</name><operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>x</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>, <argument><expr><name>y</name> <operator>-</operator> <name>ymin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dir</name><operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>dir</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>dir</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>+</operator> <name>dia_size</name> <operator>-</operator> <name>dir</name></expr></argument>, <argument><expr><name>y</name> <operator>-</operator> <name>dir</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>start</name><operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><name>y</name> <operator>+</operator> <name>dia_size</name> <operator>+</operator> <name>ymin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>, <argument><expr><name>x</name> <operator>-</operator> <name>xmin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dir</name><operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>dir</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>dir</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator> <name>dir</name></expr></argument> , <argument><expr><name>y</name> <operator>-</operator> <name>dia_size</name> <operator>+</operator> <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>start</name><operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><name>x</name> <operator>+</operator> <name>dia_size</name> <operator>+</operator> <name>xmin</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>dia_size</name></expr></argument>, <argument><expr><name>ymax</name> <operator>-</operator> <name>y</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>dir</name><operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>dir</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>dir</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_MV</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator> <name>dia_size</name> <operator>+</operator> <name>dir</name></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <name>dir</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>x</name><operator>!=</operator><name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name>y</name><operator>!=</operator><name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dia_size</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>diamond_search</name><parameter_list>(<parameter><decl><type><name>MpegEncContext</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dmin</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>src_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>funny_diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&lt;</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>sab_diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&lt;</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>small_diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&gt;</operator><literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>full_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&gt;</operator><literal type="number">768</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>umh_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&gt;</operator><literal type="number">512</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>hex_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dia_size</name></name><operator>&gt;</operator><literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>l2s_dia_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>var_diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>epzs_motion_search_internal</name><argument_list>(<argument><expr><name>MpegEncContext</name> <operator>*</operator> <name>s</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>mx_ptr</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>my_ptr</name></expr></argument>,

<argument><expr><name>int</name> <name><name>P</name><index>[<expr><literal type="number">10</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>int</name> <name>src_index</name></expr></argument>, <argument><expr><name>int</name> <name>ref_index</name></expr></argument>, <argument><expr><call><name>int16_t</name> <argument_list>(<argument><expr><operator>*</operator><name>last_mv</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,

<argument><expr><name>int</name> <name>ref_mv_scale</name></expr></argument>, <argument><expr><name>int</name> <name>flags</name></expr></argument>, <argument><expr><name>int</name> <name>size</name></expr></argument>, <argument><expr><name>int</name> <name>h</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>best</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>dmin</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name></type> <name>map_generation</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>penalty_factor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ref_mv_stride</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mb_stride</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ref_mv_xy</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>*</operator> <name>ref_mv_stride</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>LOAD_COMMON</name>

<name>LOAD_COMMON2</name></expr></expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>pre_pass</name></name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>penalty_factor</name><operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>pre_penalty_factor</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_pre_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_pre_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<expr_stmt><expr><name>penalty_factor</name><operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>map_generation</name><operator>=</operator> <call><name>update_map_generation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_assert2</name><argument_list>(<argument><expr><name>cmpf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <call><name>cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>cmpf</name></expr></argument>, <argument><expr><name>chroma_cmpf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>map_generation</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>score_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator> <name>dmin</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>pict_type</name></name> <operator>==</operator> <name>AV_PICTURE_TYPE_B</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FLAG_DIRECT</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>mpv_flags</name></name> <operator>&amp;</operator> <name>FF_MPV_FLAG_MV0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dmin</name> <operator>+=</operator> <operator>(</operator><name><name>mv_penalty</name><index>[<expr><name>pred_x</name></expr>]</index></name> <operator>+</operator> <name><name>mv_penalty</name><index>[<expr><name>pred_y</name></expr>]</index></name><operator>)</operator><operator>*</operator><name>penalty_factor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>first_slice_line</name></name></expr>)</condition> <block>{<block_content>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_LEFT[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_LEFT[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>dmin</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>h</name><operator>*</operator><name>h</name><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>mv0_threshold</name></name><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator> <name><name>P_LEFT</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator><name><name>P_LEFT</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>

<operator>|</operator><name><name>P_TOP</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator><name><name>P_TOP</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>

<operator>|</operator><name><name>P_TOPRIGHT</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>|</operator><name><name>P_TOPRIGHT</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name><operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>skip</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>CHECK_MV</name><argument_list>( <argument>P_MEDIAN[<literal type="number">0</literal>] &gt;&gt;shift</argument> , <argument>P_MEDIAN[<literal type="number">1</literal>] &gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(P_MEDIAN[<literal type="number">0</literal>]&gt;&gt;shift)</argument> , <argument>(P_MEDIAN[<literal type="number">1</literal>]&gt;&gt;shift)-<literal type="number">1</literal></argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(P_MEDIAN[<literal type="number">0</literal>]&gt;&gt;shift)</argument> , <argument>(P_MEDIAN[<literal type="number">1</literal>]&gt;&gt;shift)+<literal type="number">1</literal></argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(P_MEDIAN[<literal type="number">0</literal>]&gt;&gt;shift)-<literal type="number">1</literal></argument>, <argument>(P_MEDIAN[<literal type="number">1</literal>]&gt;&gt;shift)</argument> )</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(P_MEDIAN[<literal type="number">0</literal>]&gt;&gt;shift)+<literal type="number">1</literal></argument>, <argument>(P_MEDIAN[<literal type="number">1</literal>]&gt;&gt;shift)</argument> )</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_LEFT[<literal type="number">0</literal>] &gt;&gt;shift</argument>, <argument>P_LEFT[<literal type="number">1</literal>] &gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_TOP[<literal type="number">0</literal>] &gt;&gt;shift</argument>, <argument>P_TOP[<literal type="number">1</literal>] &gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_TOPRIGHT[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_TOPRIGHT[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>dmin</name><operator>&gt;</operator><name>h</name><operator>*</operator><name>h</name><operator>*</operator><literal type="number">4</literal></expr>)</condition><block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>pre_pass</name></name></expr>)</condition><block>{<block_content>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy-<literal type="number">1</literal>][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy-<literal type="number">1</literal>][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>first_slice_line</name></name></expr>)</condition><block type="pseudo"><block_content>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy-ref_mv_stride][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy-ref_mv_stride][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro></block_content></block></if></if_stmt>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy+<literal type="number">1</literal>][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy+<literal type="number">1</literal>][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>s</name><operator>-&gt;</operator><name>end_mb_y</name></name></expr>)</condition><block type="pseudo"><block_content> 

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy+ref_mv_stride][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy+ref_mv_stride][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>last_predictor_count</name></name></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>last_predictor_count</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xstart</name><init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>-</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ystart</name><init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>-</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xend</name><init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_width</name></name></expr></argument> , <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>+</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yend</name><init>= <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_height</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>+</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mb_y</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>mb_y</name><operator>=</operator><name>ystart</name></expr>;</init> <condition><expr><name>mb_y</name><operator>&lt;</operator><name>yend</name></expr>;</condition> <incr><expr><name>mb_y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>mb_x</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>mb_x</name><operator>=</operator><name>xstart</name></expr>;</init> <condition><expr><name>mb_x</name><operator>&lt;</operator><name>xend</name></expr>;</condition> <incr><expr><name>mb_x</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xy</name><init>= <expr><name>mb_x</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>mb_y</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name>ref_mv_stride</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mx</name><init>= <expr><operator>(</operator><name><name>last_mv</name><index>[<expr><name>xy</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name>ref_mv_scale</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal><operator>)</operator><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>my</name><init>= <expr><operator>(</operator><name><name>last_mv</name><index>[<expr><name>xy</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name>ref_mv_scale</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal><operator>)</operator><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>mx</name><operator>&gt;</operator><name>xmax</name> <operator>||</operator> <name><name>mx</name><argument_list type="generic">&lt;<argument><expr><name>xmin</name> <operator>||</operator> <name>my</name></expr></argument>&gt;</argument_list></name><name>ymax</name> <operator>||</operator> <name>my</name><operator>&lt;</operator><name>ymin</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<macro><name>CHECK_MV</name><argument_list>(<argument>mx</argument>,<argument>my</argument>)</argument_list></macro>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <call><name>diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ff_epzs_motion_search</name><argument_list>(<argument><expr><name>MpegEncContext</name> <operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>mx_ptr</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>my_ptr</name></expr></argument>,

<argument><expr><name>int</name> <name><name>P</name><index>[<expr><literal type="number">10</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>int</name> <name>src_index</name></expr></argument>, <argument><expr><name>int</name> <name>ref_index</name></expr></argument>,

<argument><expr><call><name>int16_t</name> <argument_list>(<argument><expr><operator>*</operator><name>last_mv</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>, <argument><expr><name>int</name> <name>ref_mv_scale</name></expr></argument>,

<argument><expr><name>int</name> <name>size</name></expr></argument>, <argument><expr><name>int</name> <name>h</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>h</name><operator>==</operator><literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>size</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>

<return>return <expr><call><name>epzs_motion_search_internal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx_ptr</name></expr></argument>, <argument><expr><name>my_ptr</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>last_mv</name></expr></argument>, <argument><expr><name>ref_mv_scale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if><else>else<block>{<block_content>

<return>return <expr><call><name>epzs_motion_search_internal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mx_ptr</name></expr></argument>, <argument><expr><name>my_ptr</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>last_mv</name></expr></argument>, <argument><expr><name>ref_mv_scale</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>epzs_motion_search2</name><argument_list>(<argument><expr><name>MpegEncContext</name> <operator>*</operator> <name>s</name></expr></argument>,

<argument><expr><name>int</name> <operator>*</operator><name>mx_ptr</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>my_ptr</name></expr></argument>, <argument><expr><name>int</name> <name><name>P</name><index>[<expr><literal type="number">10</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>int</name> <name>src_index</name></expr></argument>, <argument><expr><name>int</name> <name>ref_index</name></expr></argument>, <argument><expr><call><name>int16_t</name> <argument_list>(<argument><expr><operator>*</operator><name>last_mv</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>,

<argument><expr><name>int</name> <name>ref_mv_scale</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>int</name> <name>size</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MotionEstContext</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>c</name><init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>best</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>, <decl><type ref="prev"/><name>dmin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>map_generation</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>penalty_factor</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>penalty_factor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>h</name><init>=<expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ref_mv_stride</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mb_stride</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ref_mv_xy</name><init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mb_x</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name> <operator>*</operator><name>ref_mv_stride</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>me_cmp_func</name></type> <name>cmpf</name></decl>, <decl><type ref="prev"/><name>chroma_cmpf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON</name>

<name>int</name></type> <name>flags</name><init>= <expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LOAD_COMMON2</name></type>

<name>cmpf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>chroma_cmpf</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>mecc</name><operator>.</operator><name>me_cmp</name><index>[<expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>map_generation</name><operator>=</operator> <call><name>update_map_generation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dmin</name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>first_slice_line</name></name></expr>)</condition> <block>{<block_content>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_LEFT[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_LEFT[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_MV1[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_MV1[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

</block_content>}</block></if><else>else<block>{<block_content>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_MV1[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_MV1[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_MEDIAN[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_MEDIAN[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_LEFT[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_LEFT[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_TOP[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_TOP[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_MV</name><argument_list>(<argument>P_TOPRIGHT[<literal type="number">0</literal>]&gt;&gt;shift</argument>, <argument>P_TOPRIGHT[<literal type="number">1</literal>]&gt;&gt;shift</argument>)</argument_list></macro>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>dmin</name><operator>&gt;</operator><literal type="number">64</literal><operator>*</operator><literal type="number">4</literal></expr>)</condition><block>{<block_content>

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy+<literal type="number">1</literal>][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy+<literal type="number">1</literal>][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro>

<if_stmt><if>if<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mb_y</name></name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>s</name><operator>-&gt;</operator><name>end_mb_y</name></name></expr>)</condition><block type="pseudo"><block_content> 

<macro><name>CHECK_CLIPPED_MV</name><argument_list>(<argument>(last_mv[ref_mv_xy+ref_mv_stride][<literal type="number">0</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>,

<argument>(last_mv[ref_mv_xy+ref_mv_stride][<literal type="number">1</literal>]*ref_mv_scale + (<literal type="number">1</literal>&lt;&lt;<literal type="number">15</literal>))&gt;&gt;<literal type="number">16</literal></argument>)</argument_list></macro></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dmin</name><operator>=</operator> <call><name>diamond_search</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr><name>dmin</name></expr></argument>, <argument><expr><name>src_index</name></expr></argument>, <argument><expr><name>ref_index</name></expr></argument>, <argument><expr><name>penalty_factor</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mx_ptr</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>my_ptr</name><operator>=</operator> <name><name>best</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name>dmin</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

</unit>
