<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\h264chroma_template.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bit_depth_template.c"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H264_CHROMA_MC</name><parameter_list>(<parameter><type><name>OPNAME</name></type></parameter>, <parameter><type><name>OP</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>static void FUNCC(OPNAME ##h264_chroma_mc1)(uint8_t *_dst , uint8_t *_src , ptrdiff_t stride, int h, int x, int y){pixel *dst = (pixel*)_dst;pixel *src = (pixel*)_src;const int A=(8-x)*(8-y);const int B=( x)*(8-y);const int C=(8-x)*( y);const int D=( x)*( y);int i;stride &gt;&gt;= sizeof(pixel)-1;av_assert2(x&lt;8 &amp;&amp; y&lt;8 &amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0);if(D){for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));dst+= stride;src+= stride;}} else if (B + C) {const int E= B+C;const int step= C ? stride : 1;for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + E*src[step+0]));dst+= stride;src+= stride;}} else {for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0]));dst+= stride;src+= stride;}}}static void FUNCC(OPNAME ##h264_chroma_mc2)(uint8_t *_dst , uint8_t *_src , ptrdiff_t stride, int h, int x, int y){pixel *dst = (pixel*)_dst;pixel *src = (pixel*)_src;const int A=(8-x)*(8-y);const int B=( x)*(8-y);const int C=(8-x)*( y);const int D=( x)*( y);int i;stride &gt;&gt;= sizeof(pixel)-1;av_assert2(x&lt;8 &amp;&amp; y&lt;8 &amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0);if(D){for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));dst+= stride;src+= stride;}} else if (B + C) {const int E= B+C;const ptrdiff_t step = C ? stride : 1;for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + E*src[step+0]));OP(dst[1], (A*src[1] + E*src[step+1]));dst+= stride;src+= stride;}} else {for ( i = 0; i &lt; h; i++){OP(dst[0], A * src[0]);OP(dst[1], A * src[1]);dst += stride;src += stride;}}}static void FUNCC(OPNAME ##h264_chroma_mc4)(uint8_t *_dst , uint8_t *_src , ptrdiff_t stride, int h, int x, int y){pixel *dst = (pixel*)_dst;pixel *src = (pixel*)_src;const int A=(8-x)*(8-y);const int B=( x)*(8-y);const int C=(8-x)*( y);const int D=( x)*( y);int i;stride &gt;&gt;= sizeof(pixel)-1;av_assert2(x&lt;8 &amp;&amp; y&lt;8 &amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0);if(D){for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));dst+= stride;src+= stride;}} else if (B + C) {const int E= B+C;const ptrdiff_t step = C ? stride : 1;for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + E*src[step+0]));OP(dst[1], (A*src[1] + E*src[step+1]));OP(dst[2], (A*src[2] + E*src[step+2]));OP(dst[3], (A*src[3] + E*src[step+3]));dst+= stride;src+= stride;}} else {for ( i = 0; i &lt; h; i++){OP(dst[0], A * src[0]);OP(dst[1], A * src[1]);OP(dst[2], A * src[2]);OP(dst[3], A * src[3]);dst += stride;src += stride;}}}static void FUNCC(OPNAME ##h264_chroma_mc8)(uint8_t *_dst , uint8_t *_src , ptrdiff_t stride, int h, int x, int y){pixel *dst = (pixel*)_dst;pixel *src = (pixel*)_src;const int A=(8-x)*(8-y);const int B=( x)*(8-y);const int C=(8-x)*( y);const int D=( x)*( y);int i;stride &gt;&gt;= sizeof(pixel)-1;av_assert2(x&lt;8 &amp;&amp; y&lt;8 &amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0);if(D){for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));OP(dst[4], (A*src[4] + B*src[5] + C*src[stride+4] + D*src[stride+5]));OP(dst[5], (A*src[5] + B*src[6] + C*src[stride+5] + D*src[stride+6]));OP(dst[6], (A*src[6] + B*src[7] + C*src[stride+6] + D*src[stride+7]));OP(dst[7], (A*src[7] + B*src[8] + C*src[stride+7] + D*src[stride+8]));dst+= stride;src+= stride;}} else if (B + C) {const int E= B+C;const ptrdiff_t step = C ? stride : 1;for(i=0; i&lt;h; i++){OP(dst[0], (A*src[0] + E*src[step+0]));OP(dst[1], (A*src[1] + E*src[step+1]));OP(dst[2], (A*src[2] + E*src[step+2]));OP(dst[3], (A*src[3] + E*src[step+3]));OP(dst[4], (A*src[4] + E*src[step+4]));OP(dst[5], (A*src[5] + E*src[step+5]));OP(dst[6], (A*src[6] + E*src[step+6]));OP(dst[7], (A*src[7] + E*src[step+7]));dst+= stride;src+= stride;}} else {for ( i = 0; i &lt; h; i++){OP(dst[0], A * src[0]);OP(dst[1], A * src[1]);OP(dst[2], A * src[2]);OP(dst[3], A * src[3]);OP(dst[4], A * src[4]);OP(dst[5], A * src[5]);OP(dst[6], A * src[6]);OP(dst[7], A * src[7]);dst += stride;src += stride;}}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_avg</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (((a)+(((b) + 32)&gt;&gt;6)+1)&gt;&gt;1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_put</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (((b) + 32)&gt;&gt;6)</cpp:value></cpp:define>

<macro><name>H264_CHROMA_MC</name><argument_list>(<argument>put_</argument> , <argument>op_put</argument>)</argument_list></macro>

<macro><name>H264_CHROMA_MC</name><argument_list>(<argument>avg_</argument> , <argument>op_avg</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>op_avg</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>op_put</name></cpp:undef>

</unit>
