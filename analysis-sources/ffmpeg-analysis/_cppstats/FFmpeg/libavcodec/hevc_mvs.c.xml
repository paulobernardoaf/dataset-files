<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\hevc_mvs.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hevcdec.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>l0_l1_cand_idx</name><index>[<expr><literal type="number">12</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, }</block></expr>,

<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, }</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>ff_hevc_set_neighbour_available</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x0b</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>y0b</name> <init>= <expr><call><name>av_mod_uintp2</name><argument_list>(<argument><expr><name>y0</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up</name></name> <operator>=</operator> <operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_flag</name></name> <operator>||</operator> <name>y0b</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_left</name></name> <operator>=</operator> <operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>ctb_left_flag</name></name> <operator>||</operator> <name>x0b</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_left</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>x0b</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>y0b</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_left_flag</name></name></expr> </then><else>: <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_left</name></name> <operator>&amp;&amp;</operator> <name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_right_sap</name></name> <operator>=</operator>

<ternary><condition><expr><operator>(</operator><operator>(</operator><name>x0b</name> <operator>+</operator> <name>nPbW</name><operator>)</operator> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator><operator>)</operator></expr> ?</condition><then>

<expr><name><name>lc</name><operator>-&gt;</operator><name>ctb_up_right_flag</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>y0b</name></expr> </then><else>: <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_right</name></name> <operator>=</operator>

<name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_right_sap</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>x0</name> <operator>+</operator> <name>nPbW</name><operator>)</operator> <operator>&lt;</operator> <name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_bottom_left</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>y0</name> <operator>+</operator> <name>nPbH</name><operator>)</operator> <operator>&gt;=</operator> <name><name>lc</name><operator>-&gt;</operator><name>end_of_tiles_y</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_left</name></name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>z_scan_block_avail</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xCurr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yCurr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>xN</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yN</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_TB_ADDR_ZS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s-&gt;ps.pps-&gt;min_tb_addr_zs[(y) * (s-&gt;ps.sps-&gt;tb_mask+2) + (x)]</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>xCurr_ctb</name> <init>= <expr><name>xCurr</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>yCurr_ctb</name> <init>= <expr><name>yCurr</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xN_ctb</name> <init>= <expr><name>xN</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>yN_ctb</name> <init>= <expr><name>yN</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><name>yN_ctb</name> <operator>&lt;</operator> <name>yCurr_ctb</name> <operator>||</operator> <name>xN_ctb</name> <operator>&lt;</operator> <name>xCurr_ctb</name></expr> )</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>Curr</name> <init>= <expr><call><name>MIN_TB_ADDR_ZS</name><argument_list>(<argument><expr><operator>(</operator><name>xCurr</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>tb_mask</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>yCurr</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>tb_mask</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><call><name>MIN_TB_ADDR_ZS</name><argument_list>(<argument><expr><operator>(</operator><name>xN</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>tb_mask</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>yN</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_tb_size</name></name><operator>)</operator> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>tb_mask</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>N</name> <operator>&lt;=</operator> <name>Curr</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>is_diff_mer</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xN</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yN</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xP</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yP</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>plevel</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>log2_parallel_merge_level</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>xN</name> <operator>&gt;&gt;</operator> <name>plevel</name> <operator>==</operator> <name>xP</name> <operator>&gt;&gt;</operator> <name>plevel</name> <operator>&amp;&amp;</operator>

<name>yN</name> <operator>&gt;&gt;</operator> <name>plevel</name> <operator>==</operator> <name>yP</name> <operator>&gt;&gt;</operator> <name>plevel</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_MV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AV_RN32A(&amp;A.x) == AV_RN32A(&amp;B.x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(A.x == B.x)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>compare_mv_ref_idx</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MvField</name></name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MvField</name></name></type> <name>B</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>a_pf</name> <init>= <expr><name><name>A</name><operator>.</operator><name>pred_flag</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>b_pf</name> <init>= <expr><name><name>B</name><operator>.</operator><name>pred_flag</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a_pf</name> <operator>==</operator> <name>b_pf</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>a_pf</name> <operator>==</operator> <name>PF_BI</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>MATCH</name><argument_list>(<argument><expr><name><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MATCH_MV</name><argument_list>(<argument><expr><name><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>MATCH</name><argument_list>(<argument><expr><name><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MATCH_MV</name><argument_list>(<argument><expr><name><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>a_pf</name> <operator>==</operator> <name>PF_L0</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>MATCH</name><argument_list>(<argument><expr><name><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MATCH_MV</name><argument_list>(<argument><expr><name><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>a_pf</name> <operator>==</operator> <name>PF_L1</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>MATCH</name><argument_list>(<argument><expr><name><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MATCH_MV</name><argument_list>(<argument><expr><name><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>mv_scale</name><parameter_list>(<parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>td</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tb</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tx</name></decl>, <decl><type ref="prev"/><name>scale_factor</name></decl>;</decl_stmt>

<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>av_clip_int8</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tb</name> <operator>=</operator> <call><name>av_clip_int8</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tx</name> <operator>=</operator> <operator>(</operator><literal type="number">0x4000</literal> <operator>+</operator> <call><name>abs</name><argument_list>(<argument><expr><name>td</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>td</name></expr>;</expr_stmt>

<expr_stmt><expr><name>scale_factor</name> <operator>=</operator> <call><name>av_clip_intp2</name><argument_list>(<argument><expr><operator>(</operator><name>tb</name> <operator>*</operator> <name>tx</name> <operator>+</operator> <literal type="number">32</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>av_clip_int16</name><argument_list>(<argument><expr><operator>(</operator><name>scale_factor</name> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <literal type="number">127</literal> <operator>+</operator>

<operator>(</operator><name>scale_factor</name> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>av_clip_int16</name><argument_list>(<argument><expr><operator>(</operator><name>scale_factor</name> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">127</literal> <operator>+</operator>

<operator>(</operator><name>scale_factor</name> <operator>*</operator> <name><name>src</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_mvset</name><parameter_list>(<parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mvLXCol</name></decl></parameter>, <parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mvCol</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>colPic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>poc</name></decl></parameter>,

<parameter><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>X</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refIdxLx</name></decl></parameter>,

<parameter><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList_col</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>listCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refidxCol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cur_lt</name> <init>= <expr><name><name>refPicList</name><index>[<expr><name>X</name></expr>]</index></name><operator>.</operator><name><name>isLongTerm</name><index>[<expr><name>refIdxLx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>col_lt</name> <init>= <expr><name><name>refPicList_col</name><index>[<expr><name>listCol</name></expr>]</index></name><operator>.</operator><name><name>isLongTerm</name><index>[<expr><name>refidxCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>col_poc_diff</name></decl>, <decl><type ref="prev"/><name>cur_poc_diff</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_lt</name> <operator>!=</operator> <name>col_lt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mvLXCol</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mvLXCol</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>col_poc_diff</name> <operator>=</operator> <name>colPic</name> <operator>-</operator> <name><name>refPicList_col</name><index>[<expr><name>listCol</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name>refidxCol</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_poc_diff</name> <operator>=</operator> <name>poc</name> <operator>-</operator> <name><name>refPicList</name><index>[<expr><name>X</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name>refIdxLx</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_lt</name> <operator>||</operator> <name>col_poc_diff</name> <operator>==</operator> <name>cur_poc_diff</name> <operator>||</operator> <operator>!</operator><name>col_poc_diff</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mvLXCol</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>mvCol</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mvLXCol</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>mvCol</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>mv_scale</name><argument_list>(<argument><expr><name>mvLXCol</name></expr></argument>, <argument><expr><name>mvCol</name></expr></argument>, <argument><expr><name>col_poc_diff</name></expr></argument>, <argument><expr><name>cur_poc_diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_MVSET</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>check_mvset(mvLXCol, temp_col.mv + l, colPic, s-&gt;poc, refPicList, X, refIdxLx, refPicList_col, L ##l, temp_col.ref_idx[l])</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>derive_temporal_colocated_mvs</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>MvField</name></type> <name>temp_col</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>refIdxLx</name></decl></parameter>, <parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mvLXCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>X</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>colPic</name></decl></parameter>, <parameter><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList_col</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>temp_col</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_INTRA</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>temp_col</name><operator>.</operator><name>pred_flag</name></name> <operator>&amp;</operator> <name>PF_L0</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>temp_col</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_L0</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>temp_col</name><operator>.</operator><name>pred_flag</name></name> <operator>==</operator> <name>PF_BI</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>check_diffpicount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>refPicList</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nb_refs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>refPicList</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>poc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>check_diffpicount</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_diffpicount</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>X</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>collocated_list</name></name> <operator>==</operator> <name>L1</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>CHECK_MVSET</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAB_MVF</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tab_mvf[(y) * min_pu_width + x]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAB_MVF_PU</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TAB_MVF(((x ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size), ((y ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DERIVE_TEMPORAL_COLOCATED_MVS</name></cpp:macro> <cpp:value>derive_temporal_colocated_mvs(s, temp_col, refIdxLx, mvLXCol, X, colPic, ff_hevc_get_ref_list(s, ref, x, y))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>temporal_luma_motion_vector</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refIdxLx</name></decl></parameter>,

<parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mvLXCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>X</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name></type> <name>temp_col</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>x_pu</name></decl>, <decl><type ref="prev"/><name>y_pu</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>availableFlagLXCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>colPic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HEVCFrame</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>collocated_ref</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mvLXCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mvLXCol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tab_mvf</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>colPic</name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>poc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x0</name> <operator>+</operator> <name>nPbW</name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name>y0</name> <operator>+</operator> <name>nPbH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tab_mvf</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>y0</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>y</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_ctb_size</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<name>y</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&amp;&amp;</operator>

<name>x</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">15</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">15</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>==</operator> <name>FF_THREAD_FRAME</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ff_thread_await_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>x_pu</name> <operator>=</operator> <name>x</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y_pu</name> <operator>=</operator> <name>y</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>temp_col</name> <operator>=</operator> <call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x_pu</name></expr></argument>, <argument><expr><name>y_pu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>availableFlagLXCol</name> <operator>=</operator> <name>DERIVE_TEMPORAL_COLOCATED_MVS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tab_mvf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>availableFlagLXCol</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x0</name> <operator>+</operator> <operator>(</operator><name>nPbW</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name>y0</name> <operator>+</operator> <operator>(</operator><name>nPbH</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">15</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">15</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>threads_type</name></name> <operator>==</operator> <name>FF_THREAD_FRAME</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ff_thread_await_progress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>tf</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>x_pu</name> <operator>=</operator> <name>x</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y_pu</name> <operator>=</operator> <name>y</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>log2_min_pu_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>temp_col</name> <operator>=</operator> <call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x_pu</name></expr></argument>, <argument><expr><name>y_pu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>availableFlagLXCol</name> <operator>=</operator> <name>DERIVE_TEMPORAL_COLOCATED_MVS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>availableFlagLXCol</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVAILABLE</name><parameter_list>(<parameter><type><name>cand</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(cand &amp;&amp; !(TAB_MVF_PU(v).pred_flag == PF_INTRA))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRED_BLOCK_AVAILABLE</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>z_scan_block_avail(s, x0, y0, x ##v, y ##v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_MV_REFIDX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>compare_mv_ref_idx(TAB_MVF_PU(a), TAB_MVF_PU(b))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>derive_spatial_merge_candidates</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>singleMCLFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_idx</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>merge_idx</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>MvField</name></name></type> <name><name>mergecandlist</name><index>[]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_bottom_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_bottom_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up_right</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_right_sap</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xA1</name> <init>= <expr><name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yA1</name> <init>= <expr><name>y0</name> <operator>+</operator> <name>nPbH</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xB1</name> <init>= <expr><name>x0</name> <operator>+</operator> <name>nPbW</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yB1</name> <init>= <expr><name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xB0</name> <init>= <expr><name>x0</name> <operator>+</operator> <name>nPbW</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yB0</name> <init>= <expr><name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xA0</name> <init>= <expr><name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yA0</name> <init>= <expr><name>y0</name> <operator>+</operator> <name>nPbH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xB2</name> <init>= <expr><name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yB2</name> <init>= <expr><name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nb_refs</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_P</name><operator>)</operator></expr> ?</condition><then>

<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>nb_refs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>zero_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_merge_cand</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_orig_merge_cand</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_a0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_a1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleMCLFlag</name> <operator>&amp;&amp;</operator> <name>part_idx</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_Nx2N</name> <operator>||</operator>

<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_nLx2N</name> <operator>||</operator>

<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_nRx2N</name><operator>)</operator> <operator>||</operator>

<call><name>is_diff_mer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xA1</name></expr></argument>, <argument><expr><name>yA1</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_available_a1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>is_available_a1</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_left</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name> <operator>=</operator> <call><name>TAB_MVF_PU</name><argument_list>(<argument><expr><name>A1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleMCLFlag</name> <operator>&amp;&amp;</operator> <name>part_idx</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_2NxN</name> <operator>||</operator>

<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_2NxnU</name> <operator>||</operator>

<name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>part_mode</name></name> <operator>==</operator> <name>PART_2NxnD</name><operator>)</operator> <operator>||</operator>

<call><name>is_diff_mer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xB1</name></expr></argument>, <argument><expr><name>yB1</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_available_b1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>is_available_b1</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up</name></expr></argument>, <argument><expr><name>B1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b1</name> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>is_available_a1</name> <operator>&amp;&amp;</operator> <call><name>COMPARE_MV_REFIDX</name><argument_list>(<argument><expr><name>B1</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name> <operator>=</operator> <call><name>TAB_MVF_PU</name><argument_list>(<argument><expr><name>B1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>is_available_b0</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up_right</name></expr></argument>, <argument><expr><name>B0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>xB0</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator>

<call><name>PRED_BLOCK_AVAILABLE</name><argument_list>(<argument><expr><name>B0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_diff_mer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xB0</name></expr></argument>, <argument><expr><name>yB0</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b0</name> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>is_available_b1</name> <operator>&amp;&amp;</operator> <call><name>COMPARE_MV_REFIDX</name><argument_list>(<argument><expr><name>B0</name></expr></argument>, <argument><expr><name>B1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name> <operator>=</operator> <call><name>TAB_MVF_PU</name><argument_list>(<argument><expr><name>B0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>is_available_a0</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_bottom_left</name></expr></argument>, <argument><expr><name>A0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>yA0</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&amp;&amp;</operator>

<call><name>PRED_BLOCK_AVAILABLE</name><argument_list>(<argument><expr><name>A0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_diff_mer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xA0</name></expr></argument>, <argument><expr><name>yA0</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a0</name> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>is_available_a1</name> <operator>&amp;&amp;</operator> <call><name>COMPARE_MV_REFIDX</name><argument_list>(<argument><expr><name>A0</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name> <operator>=</operator> <call><name>TAB_MVF_PU</name><argument_list>(<argument><expr><name>A0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>is_available_b2</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up_left</name></expr></argument>, <argument><expr><name>B2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_diff_mer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>xB2</name></expr></argument>, <argument><expr><name>yB2</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b2</name> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>is_available_a1</name> <operator>&amp;&amp;</operator> <call><name>COMPARE_MV_REFIDX</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name>is_available_b1</name> <operator>&amp;&amp;</operator> <call><name>COMPARE_MV_REFIDX</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>B1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<name>nb_merge_cand</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name> <operator>=</operator> <call><name>TAB_MVF_PU</name><argument_list>(<argument><expr><name>B2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_temporal_mvp_enabled_flag</name></name> <operator>&amp;&amp;</operator>

<name>nb_merge_cand</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>max_num_merge_cand</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Mv</name></type> <name>mv_l0_col</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name>mv_l1_col</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>available_l0</name> <init>= <expr><call><name>temporal_luma_motion_vector</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mv_l0_col</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>available_l1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name><operator>)</operator></expr> ?</condition><then>

<expr><call><name>temporal_luma_motion_vector</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mv_l1_col</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>available_l0</name> <operator>||</operator> <name>available_l1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>available_l0</name> <operator>+</operator> <operator>(</operator><name>available_l1</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_ZERO16</name><argument_list>(<argument><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>ref_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mv_l0_col</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>mv_l1_col</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nb_orig_merge_cand</name> <operator>=</operator> <name>nb_merge_cand</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name> <operator>&amp;&amp;</operator> <name>nb_orig_merge_cand</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<name>nb_orig_merge_cand</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>max_num_merge_cand</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>comb_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>comb_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nb_merge_cand</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>max_num_merge_cand</name></name> <operator>&amp;&amp;</operator>

<name>comb_idx</name> <operator>&lt;</operator> <name>nb_orig_merge_cand</name> <operator>*</operator> <operator>(</operator><name>nb_orig_merge_cand</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>comb_idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l0_cand_idx</name> <init>= <expr><name><name>l0_l1_cand_idx</name><index>[<expr><name>comb_idx</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l1_cand_idx</name> <init>= <expr><name><name>l0_l1_cand_idx</name><index>[<expr><name>comb_idx</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name></type> <name>l0_cand</name> <init>= <expr><name><name>mergecandlist</name><index>[<expr><name>l0_cand_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name></type> <name>l1_cand</name> <init>= <expr><name><name>mergecandlist</name><index>[<expr><name>l1_cand_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>l0_cand</name><operator>.</operator><name>pred_flag</name></name> <operator>&amp;</operator> <name>PF_L0</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>l1_cand</name><operator>.</operator><name>pred_flag</name></name> <operator>&amp;</operator> <name>PF_L1</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>refPicList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name><name>l0_cand</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name> <operator>!=</operator>

<name><name>refPicList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name><name>l1_cand</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>||</operator>

<call><name>AV_RN32A</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l0_cand</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>AV_RN32A</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1_cand</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>l0_cand</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>l1_cand</name><operator>.</operator><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>PF_BI</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l0_cand</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_COPY32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1_cand</name><operator>.</operator><name>mv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>nb_merge_cand</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>max_num_merge_cand</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>PF_L0</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_type</name></name> <operator>==</operator> <name>HEVC_SLICE_B</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_ZERO32</name><argument_list>(<argument><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>mv</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_ZERO32</name><argument_list>(<argument><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name>mv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>ref_idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>zero_idx</name> <operator>&lt;</operator> <name>nb_refs</name></expr> ?</condition><then> <expr><name>zero_idx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mergecandlist</name><index>[<expr><name>nb_merge_cand</name></expr>]</index></name><operator>.</operator><name><name>ref_idx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>zero_idx</name> <operator>&lt;</operator> <name>nb_refs</name></expr> ?</condition><then> <expr><name>zero_idx</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_idx</name> <operator>==</operator> <name>nb_merge_cand</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nb_merge_cand</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>zero_idx</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>ff_hevc_luma_mv_merge_mode</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_idx</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>merge_idx</name></decl></parameter>, <parameter><decl><type><name>MvField</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>singleMCLFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nCS</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_cb_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name></type> <name><name>mergecand_list</name><index>[<expr><name>MRG_MAX_NUM_CANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nPbW2</name> <init>= <expr><name>nPbW</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nPbH2</name> <init>= <expr><name>nPbH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>pps</name><operator>-&gt;</operator><name>log2_parallel_merge_level</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nCS</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>singleMCLFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x0</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y0</name> <operator>=</operator> <name><name>lc</name><operator>-&gt;</operator><name>cu</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>nPbW</name> <operator>=</operator> <name>nCS</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nPbH</name> <operator>=</operator> <name>nCS</name></expr>;</expr_stmt>

<expr_stmt><expr><name>part_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_hevc_set_neighbour_available</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>derive_spatial_merge_candidates</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>, <argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>log2_cb_size</name></expr></argument>,

<argument><expr><name>singleMCLFlag</name></expr></argument>, <argument><expr><name>part_idx</name></expr></argument>,

<argument><expr><name>merge_idx</name></expr></argument>, <argument><expr><name>mergecand_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mergecand_list</name><index>[<expr><name>merge_idx</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>==</operator> <name>PF_BI</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>nPbW2</name> <operator>+</operator> <name>nPbH2</name><operator>)</operator> <operator>==</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mergecand_list</name><index>[<expr><name>merge_idx</name></expr>]</index></name><operator>.</operator><name>pred_flag</name> <operator>=</operator> <name>PF_L0</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>mv</name> <operator>=</operator> <name><name>mergecand_list</name><index>[<expr><name>merge_idx</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>dist_scale</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>min_pu_width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>elist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx_curr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_pic_elist</name> <init>= <expr><name><name>refPicList</name><index>[<expr><name>elist</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>ref_idx</name><index>[<expr><name>elist</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_pic_curr</name> <init>= <expr><name><name>refPicList</name><index>[<expr><name>ref_idx_curr</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name>ref_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ref_pic_elist</name> <operator>!=</operator> <name>ref_pic_curr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>poc_diff</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>-</operator> <name>ref_pic_elist</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>poc_diff</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>poc_diff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mv_scale</name><argument_list>(<argument><expr><name>mv</name></expr></argument>, <argument><expr><name>mv</name></expr></argument>, <argument><expr><name>poc_diff</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>poc</name></name> <operator>-</operator> <name>ref_pic_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mv_mp_mode_mx</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pred_flag_index</name></decl></parameter>,

<parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx_curr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name>pred_flag</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>pred_flag_index</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>

<name><name>refPicList</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>ref_idx</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name><name>refPicList</name><index>[<expr><name>ref_idx_curr</name></expr>]</index></name><operator>.</operator><name><name>list</name><index>[<expr><name>ref_idx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>mv</name> <operator>=</operator> <call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>mv</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mv_mp_mode_mx_lt</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pred_flag_index</name></decl></parameter>,

<parameter><decl><type><name>Mv</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx_curr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ref_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RefPicList</name> <modifier>*</modifier></type><name>refPicList</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>refPicList</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name>pred_flag</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>pred_flag_index</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>currIsLongTerm</name> <init>= <expr><name><name>refPicList</name><index>[<expr><name>ref_idx_curr</name></expr>]</index></name><operator>.</operator><name><name>isLongTerm</name><index>[<expr><name>ref_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>colIsLongTerm</name> <init>=

<expr><name><name>refPicList</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name><operator>.</operator><name><name>isLongTerm</name><index>[<expr><operator>(</operator><call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>ref_idx</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name><operator>)</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>colIsLongTerm</name> <operator>==</operator> <name>currIsLongTerm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>mv</name> <operator>=</operator> <call><name>TAB_MVF</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>mv</name><index>[<expr><name>pred_flag_index</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currIsLongTerm</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dist_scale</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mv</name></expr></argument>, <argument><expr><name>min_pu_width</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>,

<argument><expr><name>pred_flag_index</name></expr></argument>, <argument><expr><name>ref_idx_curr</name></expr></argument>, <argument><expr><name>ref_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_MX</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>pred</name></type></parameter>, <parameter><type><name>mx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mv_mp_mode_mx(s, (x ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size, (y ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size, pred, &amp;mx, ref_idx_curr, ref_idx)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_MX_LT</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>pred</name></type></parameter>, <parameter><type><name>mx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mv_mp_mode_mx_lt(s, (x ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size, (y ##v) &gt;&gt; s-&gt;ps.sps-&gt;log2_min_pu_size, pred, &amp;mx, ref_idx_curr, ref_idx)</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>ff_hevc_luma_mv_mvp_mode</name><parameter_list>(<parameter><decl><type><name>HEVCContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPbW</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>nPbH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log2_cb_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_idx</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>merge_idx</name></decl></parameter>, <parameter><decl><type><name>MvField</name> <modifier>*</modifier></type><name>mv</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>mvp_lx_flag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>LX</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HEVCLocalContext</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>HEVClc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MvField</name> <modifier>*</modifier></type><name>tab_mvf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ref</name><operator>-&gt;</operator><name>tab_mvf</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>isScaledFlag_L0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>availableFlagLXA0</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>availableFlagLXB0</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>numMVPCandLX</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_pu_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>min_pu_width</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xA0</name></decl>, <decl><type ref="prev"/><name>yA0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_a0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xA1</name></decl>, <decl><type ref="prev"/><name>yA1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_a1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xB0</name></decl>, <decl><type ref="prev"/><name>yB0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xB1</name></decl>, <decl><type ref="prev"/><name>yB1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xB2</name></decl>, <decl><type ref="prev"/><name>yB2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_available_b2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Mv</name></type> <name><name>mvpcand_list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Mv</name></type> <name>mxA</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Mv</name></type> <name>mxB</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_idx_curr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ref_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pred_flag_index_l0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pred_flag_index_l1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_bottom_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_bottom_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up_left</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_left</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cand_up_right</name> <init>= <expr><name><name>lc</name><operator>-&gt;</operator><name>na</name><operator>.</operator><name>cand_up_right_sap</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ref_idx_curr</name> <operator>=</operator> <name>LX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ref_idx</name> <operator>=</operator> <name><name>mv</name><operator>-&gt;</operator><name>ref_idx</name><index>[<expr><name>LX</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pred_flag_index_l0</name> <operator>=</operator> <name>LX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pred_flag_index_l1</name> <operator>=</operator> <operator>!</operator><name>LX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>xA0</name> <operator>=</operator> <name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>yA0</name> <operator>=</operator> <name>y0</name> <operator>+</operator> <name>nPbH</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_available_a0</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_bottom_left</name></expr></argument>, <argument><expr><name>A0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>yA0</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>height</name></name> <operator>&amp;&amp;</operator>

<call><name>PRED_BLOCK_AVAILABLE</name><argument_list>(<argument><expr><name>A0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xA1</name> <operator>=</operator> <name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>yA1</name> <operator>=</operator> <name>y0</name> <operator>+</operator> <name>nPbH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_available_a1</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_left</name></expr></argument>, <argument><expr><name>A1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a0</name> <operator>||</operator> <name>is_available_a1</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isScaledFlag_L0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a0</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>A0</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>A0</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a1</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a0</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>A0</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>A0</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_a1</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>b_candidates</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>availableFlagLXA0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>b_candidates</name>:</label>

<expr_stmt><expr><name>xB0</name> <operator>=</operator> <name>x0</name> <operator>+</operator> <name>nPbW</name></expr>;</expr_stmt>

<expr_stmt><expr><name>yB0</name> <operator>=</operator> <name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_available_b0</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up_right</name></expr></argument>, <argument><expr><name>B0</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>xB0</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>sps</name><operator>-&gt;</operator><name>width</name></name> <operator>&amp;&amp;</operator>

<call><name>PRED_BLOCK_AVAILABLE</name><argument_list>(<argument><expr><name>B0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xB1</name> <operator>=</operator> <name>x0</name> <operator>+</operator> <name>nPbW</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>yB1</name> <operator>=</operator> <name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_available_b1</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up</name></expr></argument>, <argument><expr><name>B1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xB2</name> <operator>=</operator> <name>x0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>yB2</name> <operator>=</operator> <name>y0</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_available_b2</name> <operator>=</operator> <call><name>AVAILABLE</name><argument_list>(<argument><expr><name>cand_up_left</name></expr></argument>, <argument><expr><name>B2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b0</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B0</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B0</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b1</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B1</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B1</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b2</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MP_MX</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>scalef</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>scalef</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isScaledFlag_L0</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>availableFlagLXB0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>availableFlagLXA0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mxA</name> <operator>=</operator> <name>mxB</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B0</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>availableFlagLXB0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B0</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>availableFlagLXB0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B1</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>availableFlagLXB0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B1</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_available_b2</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>availableFlagLXB0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>pred_flag_index_l0</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>availableFlagLXB0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>availableFlagLXB0</name> <operator>=</operator> <call><name>MP_MX_LT</name><argument_list>(<argument><expr><name>B2</name></expr></argument>, <argument><expr><name>pred_flag_index_l1</name></expr></argument>, <argument><expr><name>mxB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>availableFlagLXA0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mvpcand_list</name><index>[<expr><name>numMVPCandLX</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>mxA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>availableFlagLXB0</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>availableFlagLXA0</name> <operator>||</operator> <name><name>mxA</name><operator>.</operator><name>x</name></name> <operator>!=</operator> <name><name>mxB</name><operator>.</operator><name>x</name></name> <operator>||</operator> <name><name>mxA</name><operator>.</operator><name>y</name></name> <operator>!=</operator> <name><name>mxB</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mvpcand_list</name><index>[<expr><name>numMVPCandLX</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>mxB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>numMVPCandLX</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh</name><operator>.</operator><name>slice_temporal_mvp_enabled_flag</name></name> <operator>&amp;&amp;</operator>

<name>mvp_lx_flag</name> <operator>==</operator> <name>numMVPCandLX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Mv</name></type> <name>mv_col</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>available_col</name> <init>= <expr><call><name>temporal_luma_motion_vector</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>nPbW</name></expr></argument>,

<argument><expr><name>nPbH</name></expr></argument>, <argument><expr><name>ref_idx</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>mv_col</name></expr></argument>, <argument><expr><name>LX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>available_col</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mvpcand_list</name><index>[<expr><name>numMVPCandLX</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>mv_col</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mv</name><operator>-&gt;</operator><name>mv</name><index>[<expr><name>LX</name></expr>]</index></name> <operator>=</operator> <name><name>mvpcand_list</name><index>[<expr><name>mvp_lx_flag</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
