<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavcodec\mips\lsp_mips.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_MIPSFPU</name> <operator>&amp;&amp;</operator> <name>HAVE_INLINE_ASM</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_MIPS32R6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAVE_MIPS64R6</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/mips/asmdefs.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>void</name></type> <name>ff_lsp2polyf_mips</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>lsp</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lp_half_order</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type> <name>p_fi</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type> <name>p_f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>f</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>f</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal> <operator>*</operator> <name><name>lsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lsp</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>lp_half_order</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>f_j_2</name></decl>, <decl><type ref="prev"/><name>f_j_1</name></decl>, <decl><type ref="prev"/><name>f_j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><name><name>lsp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<asm>__asm__ <specifier>volatile</specifier>(

"move %[p_f], %[p_fi] \n\t"

"add.d %[val], %[val], %[val] \n\t"

PTR_ADDIU "%[p_fi], 8 \n\t"

"ldc1 %[f_j_1], 0(%[p_f]) \n\t"

"ldc1 %[f_j], 8(%[p_f]) \n\t"

"neg.d %[val], %[val] \n\t"

"add.d %[tmp], %[f_j_1], %[f_j_1] \n\t"

"madd.d %[tmp], %[tmp], %[f_j], %[val] \n\t"

"addiu %[j], %[i], -2 \n\t"

"ldc1 %[f_j_2], -8(%[p_f]) \n\t"

"sdc1 %[tmp], 16(%[p_f]) \n\t"

"beqz %[j], ff_lsp2polyf_lp_j_end%= \n\t"

"ff_lsp2polyf_lp_j%=: \n\t"

"add.d %[tmp], %[f_j], %[f_j_2] \n\t"

"madd.d %[tmp], %[tmp], %[f_j_1], %[val] \n\t"

"mov.d %[f_j], %[f_j_1] \n\t"

"addiu %[j], -1 \n\t"

"mov.d %[f_j_1], %[f_j_2] \n\t"

"ldc1 %[f_j_2], -16(%[p_f]) \n\t"

"sdc1 %[tmp], 8(%[p_f]) \n\t"

PTR_ADDIU "%[p_f], -8 \n\t"

"bgtz %[j], ff_lsp2polyf_lp_j%= \n\t"

"ff_lsp2polyf_lp_j_end%=: \n\t"

: [f_j_2]"=&amp;f"(f_j_2), [f_j_1]"=&amp;f"(f_j_1), [val]"+f"(val),

[tmp]"=&amp;f"(tmp), [f_j]"=&amp;f"(f_j), [p_f]"+r"(p_f),

[j]"+r"(j), [p_fi]"+r"(p_fi)

: [i]"r"(i)

: "memory"

);</asm>

<expr_stmt><expr><name><name>f</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_lsp2polyf</name></cpp:macro> <cpp:value>ff_lsp2polyf_mips</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
