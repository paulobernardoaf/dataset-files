#include "avcodec.h"
#include "ass.h"
#include "libavutil/avassert.h"
#include "libavutil/avstring.h"
#include "libavutil/bprint.h"
#include "libavutil/common.h"
int ff_ass_subtitle_header(AVCodecContext *avctx,
const char *font, int font_size,
int color, int back_color,
int bold, int italic, int underline,
int border_style, int alignment)
{
avctx->subtitle_header = av_asprintf(
"[Script Info]\r\n"
"; Script generated by FFmpeg/Lavc%s\r\n"
"ScriptType: v4.00+\r\n"
"PlayResX: %d\r\n"
"PlayResY: %d\r\n"
"\r\n"
"[V4+ Styles]\r\n"
"Format: Name, "
"Fontname, Fontsize, "
"PrimaryColour, SecondaryColour, OutlineColour, BackColour, "
"Bold, Italic, Underline, StrikeOut, "
"ScaleX, ScaleY, "
"Spacing, Angle, "
"BorderStyle, Outline, Shadow, "
"Alignment, MarginL, MarginR, MarginV, "
"Encoding\r\n"
"Style: "
"Default," 
"%s,%d," 
"&H%x,&H%x,&H%x,&H%x," 
"%d,%d,%d,0," 
"100,100," 
"0,0," 
"%d,1,0," 
"%d,10,10,10," 
"0\r\n" 
"\r\n"
"[Events]\r\n"
"Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n",
!(avctx->flags & AV_CODEC_FLAG_BITEXACT) ? AV_STRINGIFY(LIBAVCODEC_VERSION) : "",
ASS_DEFAULT_PLAYRESX, ASS_DEFAULT_PLAYRESY,
font, font_size, color, color, back_color, back_color,
-bold, -italic, -underline, border_style, alignment);
if (!avctx->subtitle_header)
return AVERROR(ENOMEM);
avctx->subtitle_header_size = strlen(avctx->subtitle_header);
return 0;
}
int ff_ass_subtitle_header_default(AVCodecContext *avctx)
{
return ff_ass_subtitle_header(avctx, ASS_DEFAULT_FONT,
ASS_DEFAULT_FONT_SIZE,
ASS_DEFAULT_COLOR,
ASS_DEFAULT_BACK_COLOR,
ASS_DEFAULT_BOLD,
ASS_DEFAULT_ITALIC,
ASS_DEFAULT_UNDERLINE,
ASS_DEFAULT_BORDERSTYLE,
ASS_DEFAULT_ALIGNMENT);
}
char *ff_ass_get_dialog(int readorder, int layer, const char *style,
const char *speaker, const char *text)
{
return av_asprintf("%d,%d,%s,%s,0,0,0,,%s",
readorder, layer, style ? style : "Default",
speaker ? speaker : "", text);
}
int ff_ass_add_rect(AVSubtitle *sub, const char *dialog,
int readorder, int layer, const char *style,
const char *speaker)
{
char *ass_str;
AVSubtitleRect **rects;
rects = av_realloc_array(sub->rects, sub->num_rects+1, sizeof(*sub->rects));
if (!rects)
return AVERROR(ENOMEM);
sub->rects = rects;
rects[sub->num_rects] = av_mallocz(sizeof(*rects[0]));
if (!rects[sub->num_rects])
return AVERROR(ENOMEM);
rects[sub->num_rects]->type = SUBTITLE_ASS;
ass_str = ff_ass_get_dialog(readorder, layer, style, speaker, dialog);
if (!ass_str)
return AVERROR(ENOMEM);
rects[sub->num_rects]->ass = ass_str;
sub->num_rects++;
return 0;
}
void ff_ass_decoder_flush(AVCodecContext *avctx)
{
FFASSDecoderContext *s = avctx->priv_data;
if (!(avctx->flags2 & AV_CODEC_FLAG2_RO_FLUSH_NOOP))
s->readorder = 0;
}
void ff_ass_bprint_text_event(AVBPrint *buf, const char *p, int size,
const char *linebreaks, int keep_ass_markup)
{
const char *p_end = p + size;
for (; p < p_end && *p; p++) {
if (linebreaks && strchr(linebreaks, *p)) {
av_bprintf(buf, "\\N");
} else if (!keep_ass_markup && strchr("{}\\", *p)) {
av_bprintf(buf, "\\%c", *p);
} else if (p[0] == '\n') {
if (p < p_end - 1)
av_bprintf(buf, "\\N");
} else if (p[0] == '\r' && p < p_end - 1 && p[1] == '\n') {
continue;
} else {
av_bprint_chars(buf, *p, 1);
}
}
}
