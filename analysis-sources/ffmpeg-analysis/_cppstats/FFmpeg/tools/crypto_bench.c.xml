<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\tools\crypto_bench.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_crypto</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_gcrypt</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_tomcrypt</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_mbedcrypto</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/crc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/timer.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>AV_READ_TIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AV_READ_TIME</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_UNISTD_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_GETOPT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/getopt.c"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INPUT_SIZE</name></cpp:macro> <cpp:value>1048576</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_OUTPUT_SIZE</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enabled_libs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enabled_algos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>specified_runs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>hardcoded_key</name> <init>= <expr><literal type="string">"FFmpeg is the best program ever."</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fatal_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Fatal error: %s\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>hash_impl</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>run</name>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/md5.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/sha.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/sha512.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/ripemd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/aes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/blowfish.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/camellia.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/cast5.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/des.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/twofish.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/rc4.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/xtea.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_lavu</name></cpp:macro> <cpp:value>IMPL_USE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_md5</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>av_md5_sum</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_LAVU_MD</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>namespace</name></type></parameter>, <parameter><type><name>hsize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_lavu_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { static struct type *h; if (!h &amp;&amp; !(h = av_ ##namespace ##_alloc())) fatal_error("out of memory"); av_ ##namespace ##_init(h, hsize); av_ ##namespace ##_update(h, input, size); av_ ##namespace ##_final(h, output); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>DEFINE_LAVU_MD</name><argument_list>(<argument><expr><name>sha1</name></expr></argument>, <argument><expr><name>AVSHA</name></expr></argument>, <argument><expr><name>sha</name></expr></argument>, <argument><expr><literal type="number">160</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_LAVU_MD</name><argument_list>(<argument><expr><name>sha256</name></expr></argument>, <argument><expr><name>AVSHA</name></expr></argument>, <argument><expr><name>sha</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_LAVU_MD</name><argument_list>(<argument><expr><name>sha512</name></expr></argument>, <argument><expr><name>AVSHA512</name></expr></argument>, <argument><expr><name>sha512</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_LAVU_MD</name><argument_list>(<argument><expr><name>ripemd128</name></expr></argument>, <argument><expr><name>AVRIPEMD</name></expr></argument>, <argument><expr><name>ripemd</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_LAVU_MD</name><argument_list>(<argument><expr><name>ripemd160</name></expr></argument>, <argument><expr><name>AVRIPEMD</name></expr></argument>, <argument><expr><name>ripemd</name></expr></argument>, <argument><expr><literal type="number">160</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_aes128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVAES</name></name> <modifier>*</modifier></type><name>aes</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aes</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>aes</name> <operator>=</operator> <call><name>av_aes_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_aes_init</name><argument_list>(<argument><expr><name>aes</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_aes_crypt</name><argument_list>(<argument><expr><name>aes</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_blowfish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVBlowfish</name></name> <modifier>*</modifier></type><name>blowfish</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>blowfish</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>blowfish</name> <operator>=</operator> <call><name>av_blowfish_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_blowfish_init</name><argument_list>(<argument><expr><name>blowfish</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_blowfish_crypt</name><argument_list>(<argument><expr><name>blowfish</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_camellia</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVCAMELLIA</name></name> <modifier>*</modifier></type><name>camellia</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>camellia</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>camellia</name> <operator>=</operator> <call><name>av_camellia_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_camellia_init</name><argument_list>(<argument><expr><name>camellia</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_camellia_crypt</name><argument_list>(<argument><expr><name>camellia</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_cast128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVCAST5</name></name> <modifier>*</modifier></type><name>cast</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cast</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>cast</name> <operator>=</operator> <call><name>av_cast5_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_cast5_init</name><argument_list>(<argument><expr><name>cast</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_cast5_crypt</name><argument_list>(<argument><expr><name>cast</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_des</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVDES</name></name> <modifier>*</modifier></type><name>des</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>des</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>des</name> <operator>=</operator> <call><name>av_des_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_des_init</name><argument_list>(<argument><expr><name>des</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_des_crypt</name><argument_list>(<argument><expr><name>des</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_twofish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVTWOFISH</name></name> <modifier>*</modifier></type><name>twofish</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>twofish</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>twofish</name> <operator>=</operator> <call><name>av_twofish_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_twofish_init</name><argument_list>(<argument><expr><name>twofish</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_twofish_crypt</name><argument_list>(<argument><expr><name>twofish</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_rc4</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVRC4</name></name> <modifier>*</modifier></type><name>rc4</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rc4</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>rc4</name> <operator>=</operator> <call><name>av_rc4_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_rc4_init</name><argument_list>(<argument><expr><name>rc4</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_rc4_crypt</name><argument_list>(<argument><expr><name>rc4</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_lavu_xtea</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>AVXTEA</name></name> <modifier>*</modifier></type><name>xtea</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xtea</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>xtea</name> <operator>=</operator> <call><name>av_xtea_alloc</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>av_xtea_init</name><argument_list>(<argument><expr><name>xtea</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_xtea_crypt</name><argument_list>(<argument><expr><name>xtea</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_crypto</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPENSSL_DISABLE_OLD_DES_SUPPORT</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/sha.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ripemd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/aes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/blowfish.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/camellia.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/cast.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/des.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/rc4.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CRYPTO_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>function</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_crypto_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { function(input, size, output); }</cpp:value></cpp:define>

<macro><name>DEFINE_CRYPTO_WRAPPER</name><argument_list>(<argument>md5</argument>, <argument>MD5</argument>)</argument_list></macro>

<macro><name>DEFINE_CRYPTO_WRAPPER</name><argument_list>(<argument>sha1</argument>, <argument>SHA1</argument>)</argument_list></macro>

<macro><name>DEFINE_CRYPTO_WRAPPER</name><argument_list>(<argument>sha256</argument>, <argument>SHA256</argument>)</argument_list></macro>

<macro><name>DEFINE_CRYPTO_WRAPPER</name><argument_list>(<argument>sha512</argument>, <argument>SHA512</argument>)</argument_list></macro>

<macro><name>DEFINE_CRYPTO_WRAPPER</name><argument_list>(<argument>ripemd160</argument>, <argument>RIPEMD160</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_aes128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AES_KEY</name></type> <name>aes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AES_set_encrypt_key</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>aes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>AES_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_blowfish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>BF_KEY</name></type> <name>blowfish</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BF_set_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>BF_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_camellia</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>CAMELLIA_KEY</name></type> <name>camellia</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Camellia_set_key</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>camellia</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Camellia_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>camellia</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_cast128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>CAST_KEY</name></type> <name>cast</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CAST_set_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cast</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CAST_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cast</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_des</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>DES_key_schedule</name></type> <name>des</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DES_set_key</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>DES_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>des</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_crypto_rc4</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RC4_KEY</name></type> <name>rc4</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RC4_set_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RC4</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_crypto</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL_USE(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_crypto</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_gcrypt</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gcrypt.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_GCRYPT_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>algo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_gcrypt_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { gcry_md_hash_buffer(GCRY_MD_ ##algo, output, input, size); }</cpp:value></cpp:define>

<macro><name>DEFINE_GCRYPT_WRAPPER</name><argument_list>(<argument>md5</argument>, <argument>MD5</argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_WRAPPER</name><argument_list>(<argument>sha1</argument>, <argument>SHA1</argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_WRAPPER</name><argument_list>(<argument>sha256</argument>, <argument>SHA256</argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_WRAPPER</name><argument_list>(<argument>sha512</argument>, <argument>SHA512</argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_WRAPPER</name><argument_list>(<argument>ripemd160</argument>, <argument>RMD160</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>cypher</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_gcrypt_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { static gcry_cipher_hd_t suffix; if (!suffix) gcry_cipher_open(&amp;suffix, GCRY_CIPHER_ ##cypher, GCRY_CIPHER_MODE_ ##mode, 0); gcry_cipher_setkey(suffix, hardcoded_key, sz); gcry_cipher_encrypt(suffix, output, size, input, size); }</cpp:value></cpp:define>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>aes128</argument>, <argument>AES128</argument>, <argument>ECB</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>blowfish</argument>, <argument>BLOWFISH</argument>, <argument>ECB</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>camellia</argument>, <argument>CAMELLIA128</argument>, <argument>ECB</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>cast128</argument>, <argument>CAST5</argument>, <argument>ECB</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>des</argument>, <argument>DES</argument>, <argument>ECB</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>twofish</argument>, <argument>TWOFISH128</argument>, <argument>ECB</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_GCRYPT_CYPHER_WRAPPER</name><argument_list>(<argument>rc4</argument>, <argument>ARCFOUR</argument>, <argument>STREAM</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_gcrypt</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL_USE(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_gcrypt</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_mbedcrypto</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/aes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/arc4.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/blowfish.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/camellia.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/des.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/ripemd160.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/sha1.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/sha256.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/sha512.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbedtls/xtea.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_MBEDCRYPTO_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_mbedcrypto_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { mbedtls_ ##suffix ##_ret(input, size, output); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_MBEDCRYPTO_WRAPPER_SHA2</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_mbedcrypto_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { mbedtls_ ##suffix ##_ret(input, size, output, 0); }</cpp:value></cpp:define>

<macro><name>DEFINE_MBEDCRYPTO_WRAPPER</name><argument_list>(<argument>md5</argument>)</argument_list></macro>

<macro><name>DEFINE_MBEDCRYPTO_WRAPPER</name><argument_list>(<argument>ripemd160</argument>)</argument_list></macro>

<macro><name>DEFINE_MBEDCRYPTO_WRAPPER</name><argument_list>(<argument>sha1</argument>)</argument_list></macro>

<macro><name>DEFINE_MBEDCRYPTO_WRAPPER_SHA2</name><argument_list>(<argument>sha256</argument>)</argument_list></macro>

<macro><name>DEFINE_MBEDCRYPTO_WRAPPER_SHA2</name><argument_list>(<argument>sha512</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_MBEDCRYPTO_CYPHER_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>cypher</name></type></parameter>, <parameter><type><name>algo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_mbedcrypto_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { mbedtls_ ##cypher ##_context cypher; mbedtls_ ##cypher ##_init(&amp;cypher); mbedtls_ ##cypher ##_setkey_enc(&amp;cypher, hardcoded_key, 128); for (int i = 0; i &lt; size; i += 16) mbedtls_ ##cypher ##_crypt_ecb(&amp;cypher, MBEDTLS_ ##algo ##_ENCRYPT, input + i, output + i); mbedtls_ ##cypher ##_free(&amp;cypher); }</cpp:value></cpp:define>

<macro><name>DEFINE_MBEDCRYPTO_CYPHER_WRAPPER</name><argument_list>(<argument>aes128</argument>, <argument>aes</argument>, <argument>AES</argument>)</argument_list></macro>

<macro><name>DEFINE_MBEDCRYPTO_CYPHER_WRAPPER</name><argument_list>(<argument>camellia</argument>, <argument>camellia</argument>, <argument>CAMELLIA</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_mbedcrypto_blowfish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mbedtls_blowfish_context</name></type> <name>blowfish</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mbedtls_blowfish_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_blowfish_setkey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mbedtls_blowfish_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>, <argument><expr><name>MBEDTLS_BLOWFISH_ENCRYPT</name></expr></argument>,

<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>mbedtls_blowfish_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_mbedcrypto_des</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mbedtls_des_context</name></type> <name>des</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mbedtls_des_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_des_setkey_enc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>des</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mbedtls_des_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>des</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>mbedtls_des_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_mbedcrypto_rc4</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mbedtls_arc4_context</name></type> <name>rc4</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mbedtls_arc4_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_arc4_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_arc4_crypt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_arc4_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_mbedcrypto_xtea</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mbedtls_xtea_context</name></type> <name>xtea</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mbedtls_xtea_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mbedtls_xtea_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mbedtls_xtea_crypt_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>, <argument><expr><name>MBEDTLS_XTEA_ENCRYPT</name></expr></argument>,

<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>mbedtls_xtea_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_mbedcrypto</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL_USE(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_mbedcrypto</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_tomcrypt</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tomcrypt.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_TOMCRYPT_WRAPPER</name><parameter_list>(<parameter><type><name>suffix</name></type></parameter>, <parameter><type><name>namespace</name></type></parameter>, <parameter><type><name>algo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void run_tomcrypt_ ##suffix(uint8_t *output, const uint8_t *input, unsigned size) { hash_state md; namespace ##_init(&amp;md); namespace ##_process(&amp;md, input, size); namespace ##_done(&amp;md, output); }</cpp:value></cpp:define>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>md5</argument>, <argument>md5</argument>, <argument>MD5</argument>)</argument_list></macro>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>sha1</argument>, <argument>sha1</argument>, <argument>SHA1</argument>)</argument_list></macro>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>sha256</argument>, <argument>sha256</argument>, <argument>SHA256</argument>)</argument_list></macro>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>sha512</argument>, <argument>sha512</argument>, <argument>SHA512</argument>)</argument_list></macro>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>ripemd128</argument>, <argument>rmd128</argument>, <argument>RIPEMD128</argument>)</argument_list></macro>

<macro><name>DEFINE_TOMCRYPT_WRAPPER</name><argument_list>(<argument>ripemd160</argument>, <argument>rmd160</argument>, <argument>RIPEMD160</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_aes128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>aes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>aes_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>aes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>aes_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_blowfish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>blowfish</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>blowfish_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>blowfish_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blowfish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_camellia</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>camellia</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>camellia_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>camellia</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>camellia_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>camellia</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_cast128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>cast</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cast5_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>cast5_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_des</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>des</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>des_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>des_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_rc4</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rc4_state</name></type> <name>rc4</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rc4_stream_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rc4_stream_crypt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rc4_stream_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_twofish</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>twofish</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>twofish_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>twofish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>twofish_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>twofish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_tomcrypt_xtea</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>xtea</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xtea_setup</name><argument_list>(<argument><expr><name>hardcoded_key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xtea_ecb_encrypt</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xtea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_tomcrypt</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL_USE(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE_tomcrypt</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>crc32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>av_crc</name><argument_list>(<argument><expr><call><name>av_crc_get_table</name><argument_list>(<argument><expr><name>AV_CRC_32_IEEE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_implementation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>hash_impl</name></name> <modifier>*</modifier></type><name>impl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>t0</name></decl>, <decl><type ref="prev"/><name>t1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>nruns</name> <init>= <expr><ternary><condition><expr><name>specified_runs</name></expr> ?</condition><then> <expr><name>specified_runs</name></expr> </then><else>: <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator> <operator>/</operator> <name>size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>outlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>outcrc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>mtime</name></decl>, <decl><type ref="prev"/><name>ttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ttime2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>stime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>outref</name><index>[<expr><name>MAX_OUTPUT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enabled_libs</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>av_stristr</name><argument_list>(<argument><expr><name>enabled_libs</name></expr></argument>, <argument><expr><name><name>impl</name><operator>-&gt;</operator><name>lib</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>enabled_algos</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>av_stristr</name><argument_list>(<argument><expr><name>enabled_algos</name></expr></argument>, <argument><expr><name><name>impl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sscanf</name><argument_list>(<argument><expr><name><name>impl</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><literal type="string">"crc:%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>outcrc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>impl</name><operator>-&gt;</operator><name>output</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>outlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>impl</name><operator>-&gt;</operator><name>output</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>outref</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name><name>impl</name><operator>-&gt;</operator><name>run</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nruns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>t0</name> <operator>=</operator> <call><name>AV_READ_TIME</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>impl</name><operator>-&gt;</operator><name>run</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>AV_READ_TIME</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>outlen</name></expr> ?</condition><then> <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>outref</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>crc32</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>outcrc</name></expr></else></ternary></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Expected: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>outlen</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>outlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><call><name>crc32</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"output mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mtime</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>t1</name> <operator>-</operator> <name>t0</name><operator>)</operator> <operator>/</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ttime</name> <operator>+=</operator> <name>mtime</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ttime2</name> <operator>+=</operator> <name>mtime</name> <operator>*</operator> <name>mtime</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>ttime</name> <operator>/=</operator> <name>nruns</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ttime2</name> <operator>/=</operator> <name>nruns</name></expr>;</expr_stmt>

<expr_stmt><expr><name>stime</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>ttime2</name> <operator>-</operator> <name>ttime</name> <operator>*</operator> <name>ttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-10s %-12s size: %7d runs: %6d time: %8.3f +- %.3f\n"</literal></expr></argument>,

<argument><expr><name><name>impl</name><operator>-&gt;</operator><name>lib</name></name></expr></argument>, <argument><expr><name><name>impl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nruns</name></expr></argument>, <argument><expr><name>ttime</name></expr></argument>, <argument><expr><name>stime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_USE</name><parameter_list>(<parameter><type><name>lib</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>symbol</name></type></parameter>, <parameter><type><name>output</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #lib, name, run_ ##lib ##_ ##symbol, output },</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL</name><parameter_list>(<parameter><type><name>lib</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL_USE_ ##lib(lib, __VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPL_ALL</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IMPL(lavu, __VA_ARGS__) IMPL(crypto, __VA_ARGS__) IMPL(gcrypt, __VA_ARGS__) IMPL(mbedcrypto, __VA_ARGS__) IMPL(tomcrypt, __VA_ARGS__)</cpp:value></cpp:define>

<decl_stmt><decl><type><name><name>struct</name> <name>hash_impl</name></name></type> <name><name>implementations</name><index>[]</index></name> <init>= <expr><block>{

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"MD5"</literal></argument>, <argument>md5</argument>, <argument><literal type="string">"aa26ff5b895356bcffd9292ba9f89e66"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"SHA-1"</literal></argument>, <argument>sha1</argument>, <argument><literal type="string">"1fd8bd1fa02f5b0fe916b0d71750726b096c5744"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"SHA-256"</literal></argument>, <argument>sha256</argument>, <argument><literal type="string">"14028ac673b3087e51a1d407fbf0df4deeec8f217119e13b07bf2138f93db8c5"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"SHA-512"</literal></argument>, <argument>sha512</argument>, <argument><literal type="string">"3afdd44a80d99af15c87bd724cb717243193767835ce866dd5d58c02d674bb57"</literal>

<literal type="string">"7c25b9e118c200a189fcd5a01ef106a4e200061f3e97dbf50ba065745fd46bef"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>lavu</argument>, <argument><literal type="string">"RIPEMD-128"</literal></argument>, <argument>ripemd128</argument>, <argument><literal type="string">"9ab8bfba2ddccc5d99c9d4cdfb844a5f"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>tomcrypt</argument>, <argument><literal type="string">"RIPEMD-128"</literal></argument>, <argument>ripemd128</argument>, <argument><literal type="string">"9ab8bfba2ddccc5d99c9d4cdfb844a5f"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"RIPEMD-160"</literal></argument>, <argument>ripemd160</argument>, <argument><literal type="string">"62a5321e4fc8784903bb43ab7752c75f8b25af00"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"AES-128"</literal></argument>, <argument>aes128</argument>, <argument><literal type="string">"crc:ff6bc888"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"CAMELLIA"</literal></argument>, <argument>camellia</argument>, <argument><literal type="string">"crc:7abb59a7"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>lavu</argument>, <argument><literal type="string">"CAST-128"</literal></argument>, <argument>cast128</argument>, <argument><literal type="string">"crc:456aa584"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>crypto</argument>, <argument><literal type="string">"CAST-128"</literal></argument>, <argument>cast128</argument>, <argument><literal type="string">"crc:456aa584"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>gcrypt</argument>, <argument><literal type="string">"CAST-128"</literal></argument>, <argument>cast128</argument>, <argument><literal type="string">"crc:456aa584"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>tomcrypt</argument>, <argument><literal type="string">"CAST-128"</literal></argument>, <argument>cast128</argument>, <argument><literal type="string">"crc:456aa584"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"BLOWFISH"</literal></argument>, <argument>blowfish</argument>, <argument><literal type="string">"crc:33e8aa74"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"DES"</literal></argument>, <argument>des</argument>, <argument><literal type="string">"crc:31291e0b"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>lavu</argument>, <argument><literal type="string">"TWOFISH"</literal></argument>, <argument>twofish</argument>, <argument><literal type="string">"crc:9edbd5c1"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>gcrypt</argument>, <argument><literal type="string">"TWOFISH"</literal></argument>, <argument>twofish</argument>, <argument><literal type="string">"crc:9edbd5c1"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>tomcrypt</argument>, <argument><literal type="string">"TWOFISH"</literal></argument>, <argument>twofish</argument>, <argument><literal type="string">"crc:9edbd5c1"</literal></argument>)</argument_list></macro>

<macro><name>IMPL_ALL</name><argument_list>(<argument><literal type="string">"RC4"</literal></argument>, <argument>rc4</argument>, <argument><literal type="string">"crc:538d37b2"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>lavu</argument>, <argument><literal type="string">"XTEA"</literal></argument>, <argument>xtea</argument>, <argument><literal type="string">"crc:931fc270"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>mbedcrypto</argument>, <argument><literal type="string">"XTEA"</literal></argument>, <argument>xtea</argument>, <argument><literal type="string">"crc:931fc270"</literal></argument>)</argument_list></macro>

<macro><name>IMPL</name><argument_list>(<argument>tomcrypt</argument>, <argument><literal type="string">"XTEA"</literal></argument>, <argument>xtea</argument>, <argument><literal type="string">"crc:931fc270"</literal></argument>)</argument_list></macro>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>input</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>impl</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"hl:a:r:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<expr_stmt><expr><name>enabled_libs</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<expr_stmt><expr><name>enabled_algos</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<expr_stmt><expr><name>specified_runs</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: %s [-l libs] [-a algos] [-r runs]\n"</literal></expr></argument>,

<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_crypto</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+crypto"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_gcrypt</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+gcrypt"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_mbedcrypto</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+mbedcrypto"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>USE_EXT_LIBS</name><operator>)</operator> <operator>&amp;</operator> <name>USE_tomcrypt</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+tomcrypt"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Built with the following external libraries:\n"</literal>

<literal type="string">"make VERSUS=%s\n"</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Built without external libraries; use\n"</literal>

<literal type="string">"make VERSUS=crypto+gcrypt+mbedcrypto+tomcrypt tools/crypto_bench\n"</literal>

<literal type="string">"to enable them.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>opt</name> <operator>!=</operator> <literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>MAX_INPUT_SIZE</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>input</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_INPUT_SIZE</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>AV_WB32</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>output</name> <operator>=</operator> <name>input</name> <operator>+</operator> <name>MAX_INPUT_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>MAX_INPUT_SIZE</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>impl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>impl</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>implementations</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>impl</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>run_implementation</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>implementations</name><index>[<expr><name>impl</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
