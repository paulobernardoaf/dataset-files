<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libswscale\slice.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"swscale_internal.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lines</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_ring</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>is_ring</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>should_free_lines</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_lines</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>idx</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>should_free_lines</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><name><name>idx</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free_lines</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>size</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_ring</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_slice</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>AVPixelFormat</name></name></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lumLines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chrLines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h_sub_sample</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v_sub_sample</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ring</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>lumLines</name></expr>,

<expr><name>chrLines</name></expr>,

<expr><name>chrLines</name></expr>,

<expr><name>lumLines</name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>h_chr_sub_sample</name></name> <operator>=</operator> <name>h_sub_sample</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v_chr_sub_sample</name></name> <operator>=</operator> <name>v_sub_sample</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>fmt</name></name> <operator>=</operator> <name>fmt</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_ring</name></name> <operator>=</operator> <name>ring</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>should_free_lines</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator> <ternary><condition><expr><name>ring</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name>ring</name></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>+</operator> <name><name>size</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">2</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name> <operator>=</operator> <name><name>size</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_slice</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>should_free_lines</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_lines</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_rotate_slice</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lum</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">3</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name>lum</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>n</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>chr</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name>chr</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>n</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_init_slice_from_src</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>stride</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcW</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lumY</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lumH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chrY</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chrH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relative</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>start</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>lumY</name></expr>,

<expr><name>chrY</name></expr>,

<expr><name>chrY</name></expr>,

<expr><name>lumY</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>end</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>lumY</name> <operator>+</operator><name>lumH</name></expr>,

<expr><name>chrY</name> <operator>+</operator> <name>chrH</name></expr>,

<expr><name>chrY</name> <operator>+</operator> <name>chrH</name></expr>,

<expr><name>lumY</name> <operator>+</operator> <name>lumH</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>src_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>relative</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>start</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name><name>stride</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>,

<expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>relative</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>start</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name><name>stride</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>,

<expr><name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>relative</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>start</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name><name>stride</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>,

<expr><name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>relative</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>start</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name><name>stride</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>srcW</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lines</name> <init>= <expr><name><name>end</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tot_lines</name> <init>= <expr><name><name>end</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>first</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>start</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>first</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;=</operator> <name>tot_lines</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>tot_lines</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lines</name></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name><name>start</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>first</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>src_</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>j</name> <operator>*</operator> <name><name>stride</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceY</name> <operator>=</operator> <name><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lines</name> <operator>=</operator> <ternary><condition><expr><name>lines</name> <operator>&gt;</operator> <name>n</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>lines</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceH</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lines</name></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>src_</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>j</name> <operator>*</operator> <name><name>stride</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_ones</name><parameter_list>(<parameter><decl><type><name>SwsSlice</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is16bit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>available_lines</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><ternary><condition><expr><name>is16bit</name></expr> ?</condition><then> <expr><name>n</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></then><else>: <expr><name>n</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is16bit</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>)</operator><index>[<expr><name>k</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">18</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>plane</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>line</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>)</operator><index>[<expr><name>k</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">14</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_min_buffer_size</name><parameter_list>(<parameter><decl><type><name>SwsContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_lum_size</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_chr_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lumY</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dstH</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>dstH</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chrDstH</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>chrDstH</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>lumFilterPos</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>vLumFilterPos</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>chrFilterPos</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>vChrFilterPos</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lumFilterSize</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>vLumFilterSize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chrFilterSize</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>vChrFilterSize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chrSubSample</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcVSubSample</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>out_lum_size</name> <operator>=</operator> <name>lumFilterSize</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_chr_size</name> <operator>=</operator> <name>chrFilterSize</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>lumY</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lumY</name> <operator>&lt;</operator> <name>dstH</name></expr>;</condition> <incr><expr><name>lumY</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>chrY</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>lumY</name> <operator>*</operator> <name>chrDstH</name> <operator>/</operator> <name>dstH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nextSlice</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><name><name>lumFilterPos</name><index>[<expr><name>lumY</name></expr>]</index></name> <operator>+</operator> <name>lumFilterSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name><name>chrFilterPos</name><index>[<expr><name>chrY</name></expr>]</index></name> <operator>+</operator> <name>chrFilterSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>

<operator>&lt;&lt;</operator> <name>chrSubSample</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nextSlice</name> <operator>&gt;&gt;=</operator> <name>chrSubSample</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nextSlice</name> <operator>&lt;&lt;=</operator> <name>chrSubSample</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>out_lum_size</name><operator>)</operator> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>out_lum_size</name><operator>)</operator></expr></argument>, <argument><expr><name>nextSlice</name> <operator>-</operator> <name><name>lumFilterPos</name><index>[<expr><name>lumY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>out_chr_size</name><operator>)</operator> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>out_chr_size</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>nextSlice</name> <operator>&gt;&gt;</operator> <name>chrSubSample</name><operator>)</operator> <operator>-</operator> <name><name>chrFilterPos</name><index>[<expr><name>chrY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_init_filters</name><parameter_list>(<parameter><decl><type><name>SwsContext</name> <modifier>*</modifier></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_ydesc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_cdesc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_vdesc</name> <init>= <expr><ternary><condition><expr><call><name>isPlanarYUV</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstFormat</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isGray</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstFormat</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_lum_conv</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>lumToYV12</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>readLumPlanar</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>alpToYV12</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>readAlpPlanar</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_chr_conv</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>chrToYV12</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>readChrPlanar</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_gamma</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>is_internal_gamma</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>srcIdx</name></decl>, <decl><type ref="prev"/><name>dstIdx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dst_stride</name> <init>= <expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstW</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">66</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type> <name>pal</name> <init>= <expr><ternary><condition><expr><call><name>usePal</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcFormat</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>pal_yuv</name></name></expr> </then><else>: <expr><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>input_rgb2yuv_table</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lumBufSize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chrBufSize</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_min_buffer_size</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lumBufSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chrBufSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lumBufSize</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>lumBufSize</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>vLumFilterSize</name></name> <operator>+</operator> <name>MAX_LINES_AHEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>chrBufSize</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>chrBufSize</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>vChrFilterSize</name></name> <operator>+</operator> <name>MAX_LINES_AHEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>dstBpc</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_stride</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num_ydesc</name> <operator>=</operator> <ternary><condition><expr><name>need_lum_conv</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>num_cdesc</name> <operator>=</operator> <ternary><condition><expr><name>need_chr_conv</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>num_ydesc</name></expr></argument>, <argument><expr><name>num_cdesc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>numDesc</name></name> <operator>=</operator> <name>num_ydesc</name> <operator>+</operator> <name>num_cdesc</name> <operator>+</operator> <name>num_vdesc</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>need_gamma</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>descIndex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_ydesc</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>need_gamma</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>descIndex</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>num_ydesc</name> <operator>+</operator> <name>num_cdesc</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>need_gamma</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SwsFilterDescriptor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>numDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name> <operator>=</operator> <call><name>av_mallocz_array</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SwsSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_slice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcFormat</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcH</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcH</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcHSubSample</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcVSubSample</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name><operator>-</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_slice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcFormat</name></name></expr></argument>, <argument><expr><name>lumBufSize</name></expr></argument>, <argument><expr><name>chrBufSize</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcHSubSample</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrSrcVSubSample</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcW</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">78</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_slice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>srcFormat</name></name></expr></argument>, <argument><expr><name>lumBufSize</name></expr></argument>, <argument><expr><name>chrBufSize</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrDstHSubSample</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrDstVSubSample</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_lines</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dst_stride</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstW</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fill_ones</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dst_stride</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstBpc</name></name> <operator>==</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>alloc_slice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstFormat</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>dstH</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrDstH</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrDstHSubSample</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrDstVSubSample</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>srcIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dstIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_gamma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_gamma_convert</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name></name> <operator>+</operator> <name>index</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name> <operator>+</operator> <name>srcIdx</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>inv_gamma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_lum_conv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_desc_fmt_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>srcIdx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>dstIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>alpha</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>needAlpha</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>srcIdx</name> <operator>=</operator> <name>dstIdx</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dstIdx</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>num_ydesc</name></expr></argument>, <argument><expr><name>num_cdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_desc_hscale</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>srcIdx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>dstIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hLumFilter</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hLumFilterPos</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hLumFilterSize</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>lumXInc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>alpha</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>needAlpha</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><name>srcIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dstIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_chr_conv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_desc_cfmt_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>srcIdx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>dstIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>srcIdx</name> <operator>=</operator> <name>dstIdx</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dstIdx</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>num_ydesc</name></expr></argument>, <argument><expr><name>num_cdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>needs_hcscale</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_desc_chscale</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>srcIdx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>dstIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hChrFilter</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hChrFilterPos</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>hChrFilterSize</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>chrXInc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_desc_no_chr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>srcIdx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>dstIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><name>srcIdx</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dstIdx</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_vscale</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name></name> <operator>+</operator> <name>index</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name> <operator>+</operator> <name>srcIdx</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name> <operator>+</operator> <name>dstIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_gamma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ff_init_gamma_convert</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>desc</name></name> <operator>+</operator> <name>index</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name> <operator>+</operator> <name>dstIdx</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>gamma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>cleanup</name>:</label>

<expr_stmt><expr><call><name>ff_free_filters</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>ff_free_filters</name><parameter_list>(<parameter><decl><type><name>SwsContext</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>desc</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>numDesc</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>slice</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>numSlice</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_slice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
