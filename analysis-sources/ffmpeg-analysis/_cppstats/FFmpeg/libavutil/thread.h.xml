<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavutil\thread.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_PTHREADS</name> <operator>||</operator> <name>HAVE_W32THREADS</name> <operator>||</operator> <name>HAVE_OS2THREADS</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_PTHREADS</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASSERT_LEVEL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ASSERT_LEVEL</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_PTHREAD_ABORT</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><name>ret</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char errbuf[AV_ERROR_MAX_STRING_SIZE] = ""; av_log(NULL, AV_LOG_FATAL, AV_STRINGIFY(func) " failed with error: %s\n", av_make_error_string(errbuf, AV_ERROR_MAX_STRING_SIZE, AVERROR(ret))); abort(); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_PTHREAD_NORET</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int ret = func(__VA_ARGS__); if (ret) ASSERT_PTHREAD_ABORT(func, ret); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_PTHREAD</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ASSERT_PTHREAD_NORET(func, __VA_ARGS__); return 0; } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_join</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type> <name>thread</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>value_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_join</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>value_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_mutex_init</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pthread_mutexattr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>attr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_NORET</name><argument_list>(<argument><expr><name>pthread_mutex_init</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>local_attr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_NORET</name><argument_list>(<argument><expr><name>pthread_mutexattr_init</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_NORET</name><argument_list>(<argument><expr><name>pthread_mutexattr_settype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_attr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_ERRORCHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_NORET</name><argument_list>(<argument><expr><name>pthread_mutex_init</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_NORET</name><argument_list>(<argument><expr><name>pthread_mutexattr_destroy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_mutex_destroy</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_mutex_lock</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_mutex_lock</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_mutex_unlock</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_init</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pthread_condattr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_cond_init</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_destroy</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_cond_destroy</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_signal</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_cond_signal</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_broadcast</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_cond_broadcast</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_wait</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_cond_wait</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_cond_timedwait</name><parameter_list>(<parameter><decl><type><name>pthread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>abstime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>abstime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>!=</operator> <name>ETIMEDOUT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD_ABORT</name><argument_list>(<argument><expr><name>pthread_cond_timedwait</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strict_pthread_once</name><parameter_list>(<parameter><decl><type><name>pthread_once_t</name> <modifier>*</modifier></type><name>once_control</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_routine</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT_PTHREAD</name><argument_list>(<argument><expr><name>pthread_once</name></expr></argument>, <argument><expr><name>once_control</name></expr></argument>, <argument><expr><name>init_routine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_join</name></cpp:macro> <cpp:value>strict_pthread_join</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_mutex_init</name></cpp:macro> <cpp:value>strict_pthread_mutex_init</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_mutex_destroy</name></cpp:macro> <cpp:value>strict_pthread_mutex_destroy</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_mutex_lock</name></cpp:macro> <cpp:value>strict_pthread_mutex_lock</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_mutex_unlock</name></cpp:macro> <cpp:value>strict_pthread_mutex_unlock</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_init</name></cpp:macro> <cpp:value>strict_pthread_cond_init</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_destroy</name></cpp:macro> <cpp:value>strict_pthread_cond_destroy</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_signal</name></cpp:macro> <cpp:value>strict_pthread_cond_signal</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_broadcast</name></cpp:macro> <cpp:value>strict_pthread_cond_broadcast</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_wait</name></cpp:macro> <cpp:value>strict_pthread_cond_wait</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_cond_timedwait</name></cpp:macro> <cpp:value>strict_pthread_cond_timedwait</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_once</name></cpp:macro> <cpp:value>strict_pthread_once</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_OS2THREADS</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/os2threads.h"</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/w32pthreads.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVMutex</name></cpp:macro> <cpp:value>pthread_mutex_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AV_MUTEX_INITIALIZER</name></cpp:macro> <cpp:value>PTHREAD_MUTEX_INITIALIZER</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_mutex_init</name></cpp:macro> <cpp:value>pthread_mutex_init</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_mutex_lock</name></cpp:macro> <cpp:value>pthread_mutex_lock</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_mutex_unlock</name></cpp:macro> <cpp:value>pthread_mutex_unlock</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_mutex_destroy</name></cpp:macro> <cpp:value>pthread_mutex_destroy</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVOnce</name></cpp:macro> <cpp:value>pthread_once_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AV_ONCE_INIT</name></cpp:macro> <cpp:value>PTHREAD_ONCE_INIT</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_thread_once</name><parameter_list>(<parameter><type><name>control</name></type></parameter>, <parameter><type><name>routine</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pthread_once(control, routine)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVMutex</name></cpp:macro> <cpp:value>char</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AV_MUTEX_INITIALIZER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ff_mutex_init</name><parameter_list>(<parameter><decl><type><name>AVMutex</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ff_mutex_lock</name><parameter_list>(<parameter><decl><type><name>AVMutex</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ff_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>AVMutex</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ff_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>AVMutex</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AVOnce</name></cpp:macro> <cpp:value>char</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AV_ONCE_INIT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ff_thread_once</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>routine</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>control</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>routine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>control</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
