<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats\FFmpeg\libavfilter\af_arnndn.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/float_dsp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/tx.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avfilter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filters.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"formats.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_SIZE_SHIFT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_SIZE</name></cpp:macro> <cpp:value>(120&lt;&lt;FRAME_SIZE_SHIFT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_SIZE</name></cpp:macro> <cpp:value>(2*FRAME_SIZE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREQ_SIZE</name></cpp:macro> <cpp:value>(FRAME_SIZE + 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PITCH_MIN_PERIOD</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PITCH_MAX_PERIOD</name></cpp:macro> <cpp:value>768</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PITCH_FRAME_SIZE</name></cpp:macro> <cpp:value>960</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PITCH_BUF_SIZE</name></cpp:macro> <cpp:value>(PITCH_MAX_PERIOD+PITCH_FRAME_SIZE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQUARE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)*(x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_BANDS</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEPS_MEM</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_DELTA_CEPS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NB_FEATURES</name></cpp:macro> <cpp:value>(NB_BANDS+3*NB_DELTA_CEPS+2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEIGHTS_SCALE</name></cpp:macro> <cpp:value>(1.f/256)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NEURONS</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTIVATION_TANH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTIVATION_SIGMOID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTIVATION_RELU</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Q15ONE</name></cpp:macro> <cpp:value>1.0f</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>DenseLayer</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>bias</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>input_weights</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_inputs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_neurons</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>activation</name></decl>;</decl_stmt>

}</block></struct></type> <name>DenseLayer</name>;</typedef>

<typedef>typedef <type><struct>struct <name>GRULayer</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>bias</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>input_weights</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>recurrent_weights</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_inputs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_neurons</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>activation</name></decl>;</decl_stmt>

}</block></struct></type> <name>GRULayer</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RNNModel</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>input_dense_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>DenseLayer</name> <modifier>*</modifier></type><name>input_dense</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>vad_gru_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>GRULayer</name> <modifier>*</modifier></type><name>vad_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>noise_gru_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>GRULayer</name> <modifier>*</modifier></type><name>noise_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>denoise_gru_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>GRULayer</name> <modifier>*</modifier></type><name>denoise_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>denoise_output_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>DenseLayer</name> <modifier>*</modifier></type><name>denoise_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>vad_output_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>DenseLayer</name> <modifier>*</modifier></type><name>vad_output</name></decl>;</decl_stmt>

}</block></struct></type> <name>RNNModel</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RNNState</name> <block>{

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>vad_gru_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>noise_gru_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>denoise_gru_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RNNModel</name> <modifier>*</modifier></type><name>model</name></decl>;</decl_stmt>

}</block></struct></type> <name>RNNState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DenoiseState</name> <block>{

<decl_stmt><decl><type><name>float</name></type> <name><name>analysis_mem</name><index>[<expr><name>FRAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>cepstral_mem</name><index>[<expr><name>CEPS_MEM</name></expr>]</index><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>memid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>float</name></expr></argument>, <argument><expr><name>synthesis_mem</name></expr></argument>)</argument_list></call><index>[<expr><name>FRAME_SIZE</name></expr>]</index></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>pitch_buf</name><index>[<expr><name>PITCH_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>pitch_enh_buf</name><index>[<expr><name>PITCH_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>last_gain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_period</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>mem_hp_x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>lastg</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RNNState</name></type> <name>rnn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVTXContext</name> <modifier>*</modifier></type><name>tx</name></decl>, <modifier>*</modifier><name>txi</name>;</decl_stmt>

<decl_stmt><decl><type><name>av_tx_fn</name></type> <name>tx_fn</name></decl>, <name>txi_fn</name>;</decl_stmt>

}</block></struct></type> <name>DenoiseState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AudioRNNContext</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>model_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>channels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECLARE_ALIGNED</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>float</name></expr></argument>, <argument><expr><name>window</name></expr></argument>)</argument_list></call><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>dct_table</name><index>[<expr><name>NB_BANDS</name><operator>*</operator><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RNNModel</name> <modifier>*</modifier></type><name>model</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFloatDSPContext</name> <modifier>*</modifier></type><name>fdsp</name></decl>;</decl_stmt>

}</block></struct></type> <name>AudioRNNContext</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ACTIVATION_TANH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ACTIVATION_SIGMOID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ACTIVATION_RELU</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rnnoise_model_free</name><parameter_list>(<parameter><decl><type><name>RNNModel</name> <modifier>*</modifier></type><name>model</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_MAYBE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ptr) free(ptr); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_DENSE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (model-&gt;name) { av_free((void *) model-&gt;name-&gt;input_weights); av_free((void *) model-&gt;name-&gt;bias); av_free((void *) model-&gt;name); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_GRU</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (model-&gt;name) { av_free((void *) model-&gt;name-&gt;input_weights); av_free((void *) model-&gt;name-&gt;recurrent_weights); av_free((void *) model-&gt;name-&gt;bias); av_free((void *) model-&gt;name); } } while (0)</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>model</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FREE_DENSE</name><argument_list>(<argument><expr><name>input_dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_GRU</name><argument_list>(<argument><expr><name>vad_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_GRU</name><argument_list>(<argument><expr><name>noise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_GRU</name><argument_list>(<argument><expr><name>denoise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_DENSE</name><argument_list>(<argument><expr><name>denoise_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE_DENSE</name><argument_list>(<argument><expr><name>vad_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_free</name><argument_list>(<argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RNNModel</name> <modifier>*</modifier></type><name>rnnoise_model_from_file</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RNNModel</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DenseLayer</name> <modifier>*</modifier></type><name>input_dense</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GRULayer</name> <modifier>*</modifier></type><name>vad_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GRULayer</name> <modifier>*</modifier></type><name>noise_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GRULayer</name> <modifier>*</modifier></type><name>denoise_gru</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DenseLayer</name> <modifier>*</modifier></type><name>denoise_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DenseLayer</name> <modifier>*</modifier></type><name>vad_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>in</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"rnnoise-nu model file version %d\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>in</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RNNModel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC_LAYER</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name = av_calloc(1, sizeof(type)); if (!name) { rnnoise_model_free(ret); return NULL; } ret-&gt;name = name</cpp:value></cpp:define>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>DenseLayer</name></expr></argument>, <argument><expr><name>input_dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>GRULayer</name></expr></argument>, <argument><expr><name>vad_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>GRULayer</name></expr></argument>, <argument><expr><name>noise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>GRULayer</name></expr></argument>, <argument><expr><name>denoise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>DenseLayer</name></expr></argument>, <argument><expr><name>denoise_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_LAYER</name><argument_list>(<argument><expr><name>DenseLayer</name></expr></argument>, <argument><expr><name>vad_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_VAL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (fscanf(f, "%d", &amp;in) != 1 || in &lt; 0 || in &gt; 128) { rnnoise_model_free(ret); return NULL; } name = in; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_ACTIVATION</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int activation; INPUT_VAL(activation); switch (activation) { case F_ACTIVATION_SIGMOID: name = ACTIVATION_SIGMOID; break; case F_ACTIVATION_RELU: name = ACTIVATION_RELU; break; default: name = ACTIVATION_TANH; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_ARRAY</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { float *values = av_calloc((len), sizeof(float)); if (!values) { rnnoise_model_free(ret); return NULL; } name = values; for (int i = 0; i &lt; (len); i++) { if (fscanf(f, "%d", &amp;in) != 1) { rnnoise_model_free(ret); return NULL; } values[i] = in; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_ARRAY3</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>len0</name></type></parameter>, <parameter><type><name>len1</name></type></parameter>, <parameter><type><name>len2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { float *values = av_calloc(FFALIGN((len0), 4) * FFALIGN((len1), 4) * (len2), sizeof(float)); if (!values) { rnnoise_model_free(ret); return NULL; } name = values; for (int k = 0; k &lt; (len0); k++) { for (int i = 0; i &lt; (len2); i++) { for (int j = 0; j &lt; (len1); j++) { if (fscanf(f, "%d", &amp;in) != 1) { rnnoise_model_free(ret); return NULL; } values[j * (len2) * FFALIGN((len0), 4) + i * FFALIGN((len0), 4) + k] = in; } } } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_DENSE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { INPUT_VAL(name-&gt;nb_inputs); INPUT_VAL(name-&gt;nb_neurons); ret-&gt;name ##_size = name-&gt;nb_neurons; INPUT_ACTIVATION(name-&gt;activation); INPUT_ARRAY(name-&gt;input_weights, name-&gt;nb_inputs * name-&gt;nb_neurons); INPUT_ARRAY(name-&gt;bias, name-&gt;nb_neurons); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_GRU</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { INPUT_VAL(name-&gt;nb_inputs); INPUT_VAL(name-&gt;nb_neurons); ret-&gt;name ##_size = name-&gt;nb_neurons; INPUT_ACTIVATION(name-&gt;activation); INPUT_ARRAY3(name-&gt;input_weights, name-&gt;nb_inputs, name-&gt;nb_neurons, 3); INPUT_ARRAY3(name-&gt;recurrent_weights, name-&gt;nb_neurons, name-&gt;nb_neurons, 3); INPUT_ARRAY(name-&gt;bias, name-&gt;nb_neurons * 3); } while (0)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>INPUT_DENSE</name><argument_list>(<argument><expr><name>input_dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INPUT_GRU</name><argument_list>(<argument><expr><name>vad_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INPUT_GRU</name><argument_list>(<argument><expr><name>noise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INPUT_GRU</name><argument_list>(<argument><expr><name>denoise_gru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INPUT_DENSE</name><argument_list>(<argument><expr><name>denoise_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INPUT_DENSE</name><argument_list>(<argument><expr><name>vad_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vad_output</name><operator>-&gt;</operator><name>nb_neurons</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rnnoise_model_free</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>query_formats</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVFilterFormats</name> <modifier>*</modifier></type><name>formats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilterChannelLayouts</name> <modifier>*</modifier></type><name>layouts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVSampleFormat</name></name></type> <name><name>sample_fmts</name><index>[]</index></name> <init>= <expr><block>{

<expr><name>AV_SAMPLE_FMT_FLTP</name></expr>,

<expr><name>AV_SAMPLE_FMT_NONE</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name><name>sample_rates</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">48000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>formats</name> <operator>=</operator> <call><name>ff_make_format_list</name><argument_list>(<argument><expr><name>sample_fmts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>formats</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_set_common_formats</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>formats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>layouts</name> <operator>=</operator> <call><name>ff_all_channel_counts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>layouts</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_set_common_channel_layouts</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>layouts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>formats</name> <operator>=</operator> <call><name>ff_make_format_list</name><argument_list>(<argument><expr><name>sample_rates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>formats</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>ff_set_common_samplerates</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>formats</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_input</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>channels</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>channels</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>st</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DenoiseState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>st</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>model</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>model</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>vad_gru_state</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>noise_gru_state</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>noise_gru_size</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>denoise_gru_state</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>denoise_gru_size</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>vad_gru_state</name></name> <operator>||</operator>

<operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>noise_gru_state</name></name> <operator>||</operator>

<operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>rnn</name><operator>.</operator><name>denoise_gru_state</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_tx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>tx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>tx_fn</name></name></expr></argument>, <argument><expr><name>AV_TX_FLOAT_FFT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WINDOW_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>av_tx_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>txi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>txi_fn</name></name></expr></argument>, <argument><expr><name>AV_TX_FLOAT_FFT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WINDOW_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>biquad</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name><name>mem</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>xi</name></decl>, <decl><type ref="prev"/><name>yi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xi</name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>yi</name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name>xi</name> <operator>-</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name>yi</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name>xi</name> <operator>-</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name>yi</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>yi</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNN_MOVE</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memmove((dst), (src), (n)*sizeof(*(dst)) + 0*((dst)-(src)) ))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNN_CLEAR</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memset((dst), 0, (n)*sizeof(*(dst))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNN_COPY</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memcpy((dst), (src), (n)*sizeof(*(dst)) + 0*((dst)-(src)) ))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>forward_transform</name><parameter_list>(<parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVComplexFloat</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>x</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>y</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>WINDOW_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name><name>st</name><operator>-&gt;</operator><name>tx_fn</name></name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>tx</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>FREQ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>inverse_transform</name><parameter_list>(<parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>x</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>y</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FREQ_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>FREQ_SIZE</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>WINDOW_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>=</operator> <name><name>x</name><index>[<expr><name>WINDOW_SIZE</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>re</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>=</operator> <operator>-</operator><name><name>x</name><index>[<expr><name>WINDOW_SIZE</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>im</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name><name>st</name><operator>-&gt;</operator><name>txi_fn</name></name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>txi</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>WINDOW_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>/</operator> <name>WINDOW_SIZE</name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>eband5ms</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">24</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">78</literal></expr>, <expr><literal type="number">100</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_band_energy</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>bandE</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>X</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>sum</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>band_size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>band_size</name> <operator>=</operator> <operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>band_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>frac</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>j</name> <operator>/</operator> <name>band_size</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SQUARE</name><argument_list>(<argument><expr><name><name>X</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <call><name>SQUARE</name><argument_list>(<argument><expr><name><name>X</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>frac</name><operator>)</operator> <operator>*</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>frac</name> <operator>*</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>NB_BANDS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>bandE</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_band_corr</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>bandE</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>X</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>sum</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>band_size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>band_size</name> <operator>=</operator> <operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>band_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>frac</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>j</name> <operator>/</operator> <name>band_size</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>X</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;&lt;</operator><name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>*</operator> <name><name>P</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;&lt;</operator><name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>re</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <name><name>X</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;&lt;</operator><name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>*</operator> <name><name>P</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;&lt;</operator><name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name><operator>.</operator><name>im</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>frac</name><operator>)</operator> <operator>*</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>frac</name> <operator>*</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><name>NB_BANDS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>bandE</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>frame_analysis</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVComplexFloat</name> <modifier>*</modifier></type><name>X</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>Ex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>analysis_mem</name></name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name>x</name> <operator>+</operator> <name>FRAME_SIZE</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>analysis_mem</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>vector_fmul</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>WINDOW_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>forward_transform</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compute_band_energy</name><argument_list>(<argument><expr><name>Ex</name></expr></argument>, <argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>frame_synthesis</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>inverse_transform</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>vector_fmul</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>WINDOW_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>vector_fmac_scalar</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>synthesis_mem</name></name></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>synthesis_mem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><name>FRAME_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>xcorr_kernel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name><name>sum</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>y_0</name></decl>, <decl><type ref="prev"/><name>y_1</name></decl>, <decl><type ref="prev"/><name>y_2</name></decl>, <decl><type ref="prev"/><name>y_3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>y_0</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_1</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_2</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>x</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_3</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>x</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_0</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>x</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_1</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>x</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>y_2</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>j</name><operator>++</operator> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>x</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>y_3</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name><operator>++</operator> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name><init>=<expr><operator>*</operator><name>x</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>y_0</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name><init>=<expr><operator>*</operator><name>x</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>y_1</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>tmp</name> <operator>*</operator> <name>y_1</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>celt_inner_prod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>xy</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>xy</name> <operator>+=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>xy</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>celt_pitch_xcorr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>,

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>xcorr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_pitch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_pitch</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>sum</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xcorr_kernel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_pitch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>celt_inner_prod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>celt_autocorr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, 

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, 

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>window</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>overlap</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>lag</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fastN</name> <init>= <expr><name>n</name> <operator>-</operator> <name>lag</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>xptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>float</name> <name><name>xx</name><index>[<expr><name>PITCH_BUF_SIZE</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>overlap</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>xptr</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>overlap</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>xx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>window</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xx</name><index>[<expr><name>n</name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>n</name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>window</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>xptr</name> <operator>=</operator> <name>xx</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>celt_pitch_xcorr</name><argument_list>(<argument><expr><name>xptr</name></expr></argument>, <argument><expr><name>xptr</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><name>fastN</name></expr></argument>, <argument><expr><name>lag</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>lag</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>d</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>k</name> <operator>+</operator> <name>fastN</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <name><name>xptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>xptr</name><index>[<expr><name>i</name><operator>-</operator><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>ac</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>shift</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>celt_lpc</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>lpc</name></decl></parameter>, 

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>error</name> <init>= <expr><name><name>ac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RNN_CLEAR</name><argument_list>(<argument><expr><name>lpc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>p</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>rr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>rr</name> <operator>+=</operator> <operator>(</operator><name><name>lpc</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>ac</name><index>[<expr><name>i</name> <operator>-</operator> <name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>rr</name> <operator>+=</operator> <name><name>ac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><name>rr</name><operator>/</operator><name>error</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp1</name></decl>, <decl><type ref="prev"/><name>tmp2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name><name>lpc</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name><name>lpc</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>tmp1</name> <operator>+</operator> <operator>(</operator><name>r</name><operator>*</operator><name>tmp2</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name>tmp2</name> <operator>+</operator> <operator>(</operator><name>r</name><operator>*</operator><name>tmp1</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>error</name> <operator>-</operator> <operator>(</operator><name>r</name> <operator>*</operator> <name>r</name> <operator>*</operator><name>error</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name> <operator>&lt;</operator> <literal type="number">.001f</literal> <operator>*</operator> <name><name>ac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>celt_fir5</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>num</name></decl></parameter>,

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>num0</name></decl>, <decl><type ref="prev"/><name>num1</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>, <decl><type ref="prev"/><name>num3</name></decl>, <decl><type ref="prev"/><name>num4</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>mem0</name></decl>, <decl><type ref="prev"/><name>mem1</name></decl>, <decl><type ref="prev"/><name>mem2</name></decl>, <decl><type ref="prev"/><name>mem3</name></decl>, <decl><type ref="prev"/><name>mem4</name></decl>;</decl_stmt>

<expr_stmt><expr><name>num0</name> <operator>=</operator> <name><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num1</name> <operator>=</operator> <name><name>num</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num2</name> <operator>=</operator> <name><name>num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num3</name> <operator>=</operator> <name><name>num</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num4</name> <operator>=</operator> <name><name>num</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem0</name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem1</name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem2</name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem3</name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem4</name> <operator>=</operator> <name><name>mem</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>num0</name><operator>*</operator><name>mem0</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>num1</name><operator>*</operator><name>mem1</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>num2</name><operator>*</operator><name>mem2</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>num3</name><operator>*</operator><name>mem3</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>num4</name><operator>*</operator><name>mem4</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>mem4</name> <operator>=</operator> <name>mem3</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem3</name> <operator>=</operator> <name>mem2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem2</name> <operator>=</operator> <name>mem1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem1</name> <operator>=</operator> <name>mem0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem0</name> <operator>=</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mem0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>mem1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>mem2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>mem3</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>mem4</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pitch_downsample</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name><name>x</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>x_lp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>C</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>ac</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name><init>=<expr><name>Q15ONE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>lpc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>mem</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><init>=<expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>lpc2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>c1</name> <init>= <expr><literal type="number">.8f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><name>len</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x_lp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>)</operator><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>x_lp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>C</name><operator>==</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><name>len</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x_lp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>)</operator><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>x_lp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>+</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>celt_autocorr</name><argument_list>(<argument><expr><name>x_lp</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*=</operator> <literal type="number">1.0001f</literal></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ac</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-=</operator> <name><name>ac</name><index>[<expr><name>i</name></expr>]</index></name><operator>*</operator><operator>(</operator><literal type="number">.008f</literal><operator>*</operator><name>i</name><operator>)</operator><operator>*</operator><operator>(</operator><literal type="number">.008f</literal><operator>*</operator><name>i</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>celt_lpc</name><argument_list>(<argument><expr><name>lpc</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">.9f</literal> <operator>*</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>lpc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>tmp</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>lpc2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lpc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">.8f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>lpc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>c1</name> <operator>*</operator> <name><name>lpc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>lpc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>c1</name> <operator>*</operator> <name><name>lpc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>lpc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>c1</name> <operator>*</operator> <name><name>lpc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lpc2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c1</name> <operator>*</operator> <name><name>lpc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>celt_fir5</name><argument_list>(<argument><expr><name>x_lp</name></expr></argument>, <argument><expr><name>lpc2</name></expr></argument>, <argument><expr><name>x_lp</name></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>dual_inner_prod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>y01</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>y02</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>xy1</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>xy2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>xy01</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>xy02</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>xy01</name> <operator>+=</operator> <operator>(</operator><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>y01</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>xy02</name> <operator>+=</operator> <operator>(</operator><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>y02</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>xy1</name> <operator>=</operator> <name>xy01</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>xy2</name> <operator>=</operator> <name>xy02</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float</name></type> <name>compute_pitch_gain</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>xy</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>xx</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>yy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>xy</name> <operator>/</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>+</operator> <name>xx</name> <operator>*</operator> <name>yy</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>second_check</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>float</name></type> <name>remove_doubling</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxperiod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minperiod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>T0_</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prev_period</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>prev_gain</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>T</name></decl>, <decl><type ref="prev"/><name>T0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>g</name></decl>, <decl><type ref="prev"/><name>g0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>pg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>xy</name></decl>,<decl><type ref="prev"/><name>xx</name></decl>,<decl><type ref="prev"/><name>yy</name></decl>,<decl><type ref="prev"/><name>xy2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>xcorr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>best_xy</name></decl>, <decl><type ref="prev"/><name>best_yy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minperiod0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>yy_lookup</name><index>[<expr><name>PITCH_MAX_PERIOD</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>minperiod0</name> <operator>=</operator> <name>minperiod</name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxperiod</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>minperiod</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>T0_</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_period</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>N</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>maxperiod</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>T0_</name><operator>&gt;=</operator><name>maxperiod</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>T0_</name><operator>=</operator><name>maxperiod</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>T</name> <operator>=</operator> <name>T0</name> <operator>=</operator> <operator>*</operator><name>T0_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dual_inner_prod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name><operator>-</operator><name>T0</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>yy_lookup</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>xx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>yy</name><operator>=</operator><name>xx</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxperiod</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>yy</name> <operator>=</operator> <name>yy</name><operator>+</operator><operator>(</operator><name><name>x</name><index>[<expr><operator>-</operator><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>x</name><index>[<expr><operator>-</operator><name>i</name></expr>]</index></name><operator>)</operator><operator>-</operator><operator>(</operator><name><name>x</name><index>[<expr><name>N</name><operator>-</operator><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>x</name><index>[<expr><name>N</name><operator>-</operator><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>yy_lookup</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>yy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>yy</name> <operator>=</operator> <name><name>yy_lookup</name><index>[<expr><name>T0</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>best_xy</name> <operator>=</operator> <name>xy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>best_yy</name> <operator>=</operator> <name>yy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <name>g0</name> <operator>=</operator> <call><name>compute_pitch_gain</name><argument_list>(<argument><expr><name>xy</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>yy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>T1</name></decl>, <decl><type ref="prev"/><name>T1b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>g1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>cont</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>thresh</name></decl>;</decl_stmt>

<expr_stmt><expr><name>T1</name> <operator>=</operator> <operator>(</operator><literal type="number">2</literal><operator>*</operator><name>T0</name><operator>+</operator><name>k</name><operator>)</operator><operator>/</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>k</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>T1</name> <operator>&lt;</operator> <name>minperiod</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name><operator>==</operator><literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>T1</name><operator>+</operator><name>T0</name><operator>&gt;</operator><name>maxperiod</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>T1b</name> <operator>=</operator> <name>T0</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>T1b</name> <operator>=</operator> <name>T0</name><operator>+</operator><name>T1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else

<block>{<block_content>

<expr_stmt><expr><name>T1b</name> <operator>=</operator> <operator>(</operator><literal type="number">2</literal><operator>*</operator><name><name>second_check</name><index>[<expr><name>k</name></expr>]</index></name><operator>*</operator><name>T0</name><operator>+</operator><name>k</name><operator>)</operator><operator>/</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>k</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>dual_inner_prod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><operator>-</operator><name>T1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><operator>-</operator><name>T1b</name></expr>]</index></name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xy2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xy</name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name>xy</name> <operator>+</operator> <name>xy2</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>yy</name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name><name>yy_lookup</name><index>[<expr><name>T1</name></expr>]</index></name> <operator>+</operator> <name><name>yy_lookup</name><index>[<expr><name>T1b</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>g1</name> <operator>=</operator> <call><name>compute_pitch_gain</name><argument_list>(<argument><expr><name>xy</name></expr></argument>, <argument><expr><name>xx</name></expr></argument>, <argument><expr><name>yy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FFABS</name><argument_list>(<argument><expr><name>T1</name><operator>-</operator><name>prev_period</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cont</name> <operator>=</operator> <name>prev_gain</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>FFABS</name><argument_list>(<argument><expr><name>T1</name><operator>-</operator><name>prev_period</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <literal type="number">5</literal> <operator>*</operator> <name>k</name> <operator>*</operator> <name>k</name> <operator>&lt;</operator> <name>T0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cont</name> <operator>=</operator> <name>prev_gain</name> <operator>*</operator> <literal type="number">.5f</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>cont</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>thresh</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">.3f</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="number">.7f</literal> <operator>*</operator> <name>g0</name><operator>)</operator> <operator>-</operator> <name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>T1</name><operator>&lt;</operator><literal type="number">3</literal><operator>*</operator><name>minperiod</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>thresh</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">.4f</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="number">.85f</literal> <operator>*</operator> <name>g0</name><operator>)</operator> <operator>-</operator> <name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>T1</name><operator>&lt;</operator><literal type="number">2</literal><operator>*</operator><name>minperiod</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>thresh</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">.5f</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="number">.9f</literal> <operator>*</operator> <name>g0</name><operator>)</operator> <operator>-</operator> <name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g1</name> <operator>&gt;</operator> <name>thresh</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>best_xy</name> <operator>=</operator> <name>xy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>best_yy</name> <operator>=</operator> <name>yy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>T</name> <operator>=</operator> <name>T1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <name>g1</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>best_xy</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>best_xy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>best_yy</name> <operator>&lt;=</operator> <name>best_xy</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pg</name> <operator>=</operator> <name>Q15ONE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>pg</name> <operator>=</operator> <name>best_xy</name><operator>/</operator><operator>(</operator><name>best_yy</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>celt_inner_prod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name><operator>-</operator><operator>(</operator><name>T</name><operator>+</operator><name>k</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>xcorr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-</operator><name><name>xcorr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">.7f</literal> <operator>*</operator> <operator>(</operator><name><name>xcorr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-</operator><name><name>xcorr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>xcorr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><name><name>xcorr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><literal type="number">.7f</literal> <operator>*</operator> <operator>(</operator><name><name>xcorr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>xcorr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pg</name> <operator>&gt;</operator> <name>g</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pg</name> <operator>=</operator> <name>g</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>T0_</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>T</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>T0_</name><operator>&lt;</operator><name>minperiod0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>T0_</name><operator>=</operator><name>minperiod0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>pg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_best_pitch</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>xcorr</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>max_pitch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>best_pitch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>best_num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>best_den</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>Syy</name> <init>= <expr><literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>best_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_num</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_den</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_den</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pitch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>Syy</name> <operator>+=</operator> <name><name>y</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>y</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_pitch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>xcorr16</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xcorr16</name> <operator>=</operator> <name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>xcorr16</name> <operator>*=</operator> <literal type="number">1e-12f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <name>xcorr16</name> <operator>*</operator> <name>xcorr16</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>num</name> <operator>*</operator> <name><name>best_den</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name><name>best_num</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>Syy</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>num</name> <operator>*</operator> <name><name>best_den</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name><name>best_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>Syy</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>best_num</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>best_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_den</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>best_den</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pitch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_den</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Syy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>best_num</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_den</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Syy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>best_pitch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>Syy</name> <operator>+=</operator> <name><name>y</name><index>[<expr><name>i</name><operator>+</operator><name>len</name></expr>]</index></name><operator>*</operator><name><name>y</name><index>[<expr><name>i</name><operator>+</operator><name>len</name></expr>]</index></name> <operator>-</operator> <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>Syy</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Syy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pitch_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>x_lp</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>y</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_pitch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pitch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>best_pitch</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>x_lp4</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>y_lp4</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>xcorr</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>lag</name> <operator>=</operator> <name>len</name><operator>+</operator><name>max_pitch</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>len</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>x_lp4</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>x_lp</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>lag</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>y_lp4</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>y</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>celt_pitch_xcorr</name><argument_list>(<argument><expr><name>x_lp4</name></expr></argument>, <argument><expr><name>y_lp4</name></expr></argument>, <argument><expr><name>xcorr</name></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>max_pitch</name><operator>&gt;&gt;</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_best_pitch</name><argument_list>(<argument><expr><name>xcorr</name></expr></argument>, <argument><expr><name>y_lp4</name></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>max_pitch</name><operator>&gt;&gt;</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>best_pitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><name>max_pitch</name></expr></argument> &gt;</argument_list></name><operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FFABS</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>FFABS</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name><name>best_pitch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>celt_inner_prod</name><argument_list>(<argument><expr><name>x_lp</name></expr></argument>, <argument><expr><name>y</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xcorr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>find_best_pitch</name><argument_list>(<argument><expr><name>xcorr</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>len</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>max_pitch</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>best_pitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <operator>(</operator><name>max_pitch</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>xcorr</name><index>[<expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>xcorr</name><index>[<expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>xcorr</name><index>[<expr><name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>-</operator> <name>a</name> <operator>&gt;</operator> <literal type="number">.7f</literal> <operator>*</operator> <operator>(</operator><name>b</name> <operator>-</operator> <name>a</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>a</name> <operator>-</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">.7f</literal> <operator>*</operator> <operator>(</operator><name>b</name><operator>-</operator><name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pitch</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>best_pitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dct</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>dct_table</name><index>[<expr><name>j</name> <operator>*</operator> <name>NB_BANDS</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sum</name> <operator>*</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">2.f</literal> <operator>/</operator> <literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compute_frame_features</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>AVComplexFloat</name> <modifier>*</modifier></type><name>X</name></decl></parameter>, <parameter><decl><type><name>AVComplexFloat</name> <modifier>*</modifier></type><name>P</name></decl></parameter>,

<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>Ex</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>Ep</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>Exp</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>features</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ceps_0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ceps_1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ceps_2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>spec_variability</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>Ly</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>float</name> <name><name>pitch_buf</name><index>[<expr><name>PITCH_BUF_SIZE</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pitch_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>gain</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>float</name> <argument_list>*<argument><expr><operator>(</operator><name><name>pre</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>;

<argument><expr><name>float</name> <name><name>tmp</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></expr></argument>;

<argument><expr><name>float</name> <name>follow</name></expr></argument>, <argument><expr><name>logMax</name></expr></argument>;

<argument><expr><call><name>frame_analysis</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>Ex</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>RNN_MOVE</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>pitch_buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>pitch_buf</name><index>[<expr><name>FRAME_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><name>PITCH_BUF_SIZE</name><operator>-</operator><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>pitch_buf</name><index>[<expr><name>PITCH_BUF_SIZE</name><operator>-</operator><name>FRAME_SIZE</name></expr>]</index></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><name><name>pre</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>pitch_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>;

<argument><expr><call><name>pitch_downsample</name><argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><name>pitch_buf</name></expr></argument>, <argument><expr><name>PITCH_BUF_SIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>pitch_search</name><argument_list>(<argument><expr><name>pitch_buf</name><operator>+</operator><operator>(</operator><name>PITCH_MAX_PERIOD</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>pitch_buf</name></expr></argument>, <argument><expr><name>PITCH_FRAME_SIZE</name></expr></argument>,

<argument><expr><name>PITCH_MAX_PERIOD</name><operator>-</operator><literal type="number">3</literal><operator>*</operator><name>PITCH_MIN_PERIOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pitch_index</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><name>pitch_index</name> <operator>=</operator> <name>PITCH_MAX_PERIOD</name><operator>-</operator><name>pitch_index</name></expr></argument>;

<argument><expr><name>gain</name> <operator>=</operator> <call><name>remove_doubling</name><argument_list>(<argument><expr><name>pitch_buf</name></expr></argument>, <argument><expr><name>PITCH_MAX_PERIOD</name></expr></argument>, <argument><expr><name>PITCH_MIN_PERIOD</name></expr></argument>,

<argument><expr><name>PITCH_FRAME_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pitch_index</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>last_period</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>last_gain</name></name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><name><name>st</name><operator>-&gt;</operator><name>last_period</name></name> <operator>=</operator> <name>pitch_index</name></expr></argument>;

<argument><expr><name><name>st</name><operator>-&gt;</operator><name>last_gain</name></name> <operator>=</operator> <name>gain</name></expr></argument>;

for <argument><expr><operator>(</operator><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal>; <name>i</name> <operator>&lt;</operator> <name>WINDOW_SIZE</name>; <name>i</name><operator>++</operator><operator>)</operator>

<name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>pitch_buf</name><index>[<expr><name>PITCH_BUF_SIZE</name><operator>-</operator><name>WINDOW_SIZE</name><operator>-</operator><name>pitch_index</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>;

<argument><expr><call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>vector_fmul</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name>WINDOW_SIZE</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>forward_transform</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>compute_band_energy</name><argument_list>(<argument><expr><name>Ep</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>compute_band_corr</name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></argument>;

for <argument><expr><operator>(</operator><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal>; <name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name>; <name>i</name><operator>++</operator><operator>)</operator>

<name><name>Exp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>Exp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">.001f</literal><operator>+</operator><name><name>Ex</name><index>[<expr><name>i</name></expr>]</index></name><operator>*</operator><name><name>Ep</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>;

<argument><expr><call><name>dct</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr></argument>;

for <argument><expr><operator>(</operator><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal>; <name>i</name> <operator>&lt;</operator> <name>NB_DELTA_CEPS</name>; <name>i</name><operator>++</operator><operator>)</operator>

<name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>NB_DELTA_CEPS</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>;

<argument><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>NB_DELTA_CEPS</name></expr>]</index></name> <operator>-=</operator> <literal type="number">1.3</literal></expr></argument>;

<argument><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>NB_DELTA_CEPS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <literal type="number">0.9</literal></expr></argument>;

<argument><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><literal type="number">3</literal><operator>*</operator><name>NB_DELTA_CEPS</name></expr>]</index></name> <operator>=</operator> <literal type="number">.01</literal><operator>*</operator><operator>(</operator><name>pitch_index</name><operator>-</operator><literal type="number">300</literal><operator>)</operator></expr></argument>;

<argument><expr><name>logMax</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>;

<argument><expr><name>follow</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>;

for <argument><expr><operator>(</operator><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal>; <name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name>; <name>i</name><operator>++</operator><operator>)</operator> <block>{

<expr><name><name>Ly</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>log10f</name><argument_list>(<argument><expr><literal type="number">1e-2f</literal> <operator>+</operator> <name><name>Ex</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>Ly</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>logMax</name><operator>-</operator><literal type="number">7</literal></expr></argument>, <argument><expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>follow</name><operator>-</operator><literal type="number">1.5</literal></expr></argument>, <argument><expr><name><name>Ly</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>logMax</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>logMax</name></expr></argument>, <argument><expr><name><name>Ly</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;

<expr><name>follow</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>follow</name><operator>-</operator><literal type="number">1.5</literal></expr></argument>, <argument><expr><name><name>Ly</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;

<expr><name>E</name> <operator>+=</operator> <name><name>Ex</name><index>[<expr><name>i</name></expr>]</index></name></expr>;

}</block></expr></argument>

<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <literal type="number">0.04f</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RNN_CLEAR</name><argument_list>(<argument><expr><name>features</name></expr></argument>, <argument><expr><name>NB_FEATURES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt></argument_list></call></expr></expr_stmt>

<expr_stmt><expr><call><name>dct</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>features</name></expr></argument>, <argument><expr><name>Ly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>features</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-=</operator> <literal type="number">12</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>features</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ceps_0</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ceps_1</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>memid</name></name> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name>CEPS_MEM</name><operator>+</operator><name><name>st</name><operator>-&gt;</operator><name>memid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ceps_2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>memid</name></name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name>CEPS_MEM</name><operator>+</operator><name><name>st</name><operator>-&gt;</operator><name>memid</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ceps_0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>features</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_DELTA_CEPS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ceps_0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>ceps_1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>ceps_2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ceps_0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>ceps_2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><name>NB_DELTA_CEPS</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>ceps_0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name><name>ceps_1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>ceps_2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name> <operator>==</operator> <name>CEPS_MEM</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>memid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CEPS_MEM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>mindist</name> <init>= <expr><literal type="number">1e15f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CEPS_MEM</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>dist</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>cepstral_mem</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>dist</name> <operator>+=</operator> <name>tmp</name><operator>*</operator><name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mindist</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>mindist</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>spec_variability</name> <operator>+=</operator> <name>mindist</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>features</name><index>[<expr><name>NB_BANDS</name><operator>+</operator><literal type="number">3</literal><operator>*</operator><name>NB_DELTA_CEPS</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>spec_variability</name><operator>/</operator><name>CEPS_MEM</name><operator>-</operator><literal type="number">2.1</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>interp_band_gain</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>bandE</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>g</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>FREQ_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>band_size</name> <init>= <expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>band_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>frac</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>j</name> <operator>/</operator> <name>band_size</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><index>[<expr><operator>(</operator><name><name>eband5ms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>FRAME_SIZE_SHIFT</name><operator>)</operator> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>frac</name><operator>)</operator> <operator>*</operator> <name><name>bandE</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>frac</name> <operator>*</operator> <name><name>bandE</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pitch_filter</name><parameter_list>(<parameter><decl><type><name>AVComplexFloat</name> <modifier>*</modifier></type><name>X</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVComplexFloat</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>Ex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>Ep</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>Exp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>newE</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>r</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>norm</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>rf</name><index>[<expr><name>FREQ_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>normf</name><index>[<expr><name>FREQ_SIZE</name></expr>]</index></name><init>=<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>Exp</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><name><name>g</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>SQUARE</name><argument_list>(<argument><expr><name><name>Exp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><call><name>SQUARE</name><argument_list>(<argument><expr><name><name>g</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>/</operator><operator>(</operator><literal type="number">.001</literal> <operator>+</operator> <call><name>SQUARE</name><argument_list>(<argument><expr><name><name>g</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>-</operator><call><name>SQUARE</name><argument_list>(<argument><expr><name><name>Exp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><call><name>av_clipf</name><argument_list>(<argument><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>Ex</name><index>[<expr><name>i</name></expr>]</index></name><operator>/</operator><operator>(</operator><literal type="number">1e-8</literal><operator>+</operator><name><name>Ep</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>interp_band_gain</name><argument_list>(<argument><expr><name>rf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FREQ_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>+=</operator> <name><name>rf</name><index>[<expr><name>i</name></expr>]</index></name><operator>*</operator><name><name>P</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>+=</operator> <name><name>rf</name><index>[<expr><name>i</name></expr>]</index></name><operator>*</operator><name><name>P</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>compute_band_energy</name><argument_list>(<argument><expr><name>newE</name></expr></argument>, <argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>norm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>Ex</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <operator>(</operator><literal type="number">1e-8</literal><operator>+</operator><name><name>newE</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>interp_band_gain</name><argument_list>(<argument><expr><name>normf</name></expr></argument>, <argument><expr><name>norm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FREQ_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>*=</operator> <name><name>normf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>*=</operator> <name><name>normf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>float</name></type> <name><name>tansig_table</name><index>[<expr><literal type="number">201</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="number">0.000000f</literal></expr>, <expr><literal type="number">0.039979f</literal></expr>, <expr><literal type="number">0.079830f</literal></expr>, <expr><literal type="number">0.119427f</literal></expr>, <expr><literal type="number">0.158649f</literal></expr>,

<expr><literal type="number">0.197375f</literal></expr>, <expr><literal type="number">0.235496f</literal></expr>, <expr><literal type="number">0.272905f</literal></expr>, <expr><literal type="number">0.309507f</literal></expr>, <expr><literal type="number">0.345214f</literal></expr>,

<expr><literal type="number">0.379949f</literal></expr>, <expr><literal type="number">0.413644f</literal></expr>, <expr><literal type="number">0.446244f</literal></expr>, <expr><literal type="number">0.477700f</literal></expr>, <expr><literal type="number">0.507977f</literal></expr>,

<expr><literal type="number">0.537050f</literal></expr>, <expr><literal type="number">0.564900f</literal></expr>, <expr><literal type="number">0.591519f</literal></expr>, <expr><literal type="number">0.616909f</literal></expr>, <expr><literal type="number">0.641077f</literal></expr>,

<expr><literal type="number">0.664037f</literal></expr>, <expr><literal type="number">0.685809f</literal></expr>, <expr><literal type="number">0.706419f</literal></expr>, <expr><literal type="number">0.725897f</literal></expr>, <expr><literal type="number">0.744277f</literal></expr>,

<expr><literal type="number">0.761594f</literal></expr>, <expr><literal type="number">0.777888f</literal></expr>, <expr><literal type="number">0.793199f</literal></expr>, <expr><literal type="number">0.807569f</literal></expr>, <expr><literal type="number">0.821040f</literal></expr>,

<expr><literal type="number">0.833655f</literal></expr>, <expr><literal type="number">0.845456f</literal></expr>, <expr><literal type="number">0.856485f</literal></expr>, <expr><literal type="number">0.866784f</literal></expr>, <expr><literal type="number">0.876393f</literal></expr>,

<expr><literal type="number">0.885352f</literal></expr>, <expr><literal type="number">0.893698f</literal></expr>, <expr><literal type="number">0.901468f</literal></expr>, <expr><literal type="number">0.908698f</literal></expr>, <expr><literal type="number">0.915420f</literal></expr>,

<expr><literal type="number">0.921669f</literal></expr>, <expr><literal type="number">0.927473f</literal></expr>, <expr><literal type="number">0.932862f</literal></expr>, <expr><literal type="number">0.937863f</literal></expr>, <expr><literal type="number">0.942503f</literal></expr>,

<expr><literal type="number">0.946806f</literal></expr>, <expr><literal type="number">0.950795f</literal></expr>, <expr><literal type="number">0.954492f</literal></expr>, <expr><literal type="number">0.957917f</literal></expr>, <expr><literal type="number">0.961090f</literal></expr>,

<expr><literal type="number">0.964028f</literal></expr>, <expr><literal type="number">0.966747f</literal></expr>, <expr><literal type="number">0.969265f</literal></expr>, <expr><literal type="number">0.971594f</literal></expr>, <expr><literal type="number">0.973749f</literal></expr>,

<expr><literal type="number">0.975743f</literal></expr>, <expr><literal type="number">0.977587f</literal></expr>, <expr><literal type="number">0.979293f</literal></expr>, <expr><literal type="number">0.980869f</literal></expr>, <expr><literal type="number">0.982327f</literal></expr>,

<expr><literal type="number">0.983675f</literal></expr>, <expr><literal type="number">0.984921f</literal></expr>, <expr><literal type="number">0.986072f</literal></expr>, <expr><literal type="number">0.987136f</literal></expr>, <expr><literal type="number">0.988119f</literal></expr>,

<expr><literal type="number">0.989027f</literal></expr>, <expr><literal type="number">0.989867f</literal></expr>, <expr><literal type="number">0.990642f</literal></expr>, <expr><literal type="number">0.991359f</literal></expr>, <expr><literal type="number">0.992020f</literal></expr>,

<expr><literal type="number">0.992631f</literal></expr>, <expr><literal type="number">0.993196f</literal></expr>, <expr><literal type="number">0.993718f</literal></expr>, <expr><literal type="number">0.994199f</literal></expr>, <expr><literal type="number">0.994644f</literal></expr>,

<expr><literal type="number">0.995055f</literal></expr>, <expr><literal type="number">0.995434f</literal></expr>, <expr><literal type="number">0.995784f</literal></expr>, <expr><literal type="number">0.996108f</literal></expr>, <expr><literal type="number">0.996407f</literal></expr>,

<expr><literal type="number">0.996682f</literal></expr>, <expr><literal type="number">0.996937f</literal></expr>, <expr><literal type="number">0.997172f</literal></expr>, <expr><literal type="number">0.997389f</literal></expr>, <expr><literal type="number">0.997590f</literal></expr>,

<expr><literal type="number">0.997775f</literal></expr>, <expr><literal type="number">0.997946f</literal></expr>, <expr><literal type="number">0.998104f</literal></expr>, <expr><literal type="number">0.998249f</literal></expr>, <expr><literal type="number">0.998384f</literal></expr>,

<expr><literal type="number">0.998508f</literal></expr>, <expr><literal type="number">0.998623f</literal></expr>, <expr><literal type="number">0.998728f</literal></expr>, <expr><literal type="number">0.998826f</literal></expr>, <expr><literal type="number">0.998916f</literal></expr>,

<expr><literal type="number">0.999000f</literal></expr>, <expr><literal type="number">0.999076f</literal></expr>, <expr><literal type="number">0.999147f</literal></expr>, <expr><literal type="number">0.999213f</literal></expr>, <expr><literal type="number">0.999273f</literal></expr>,

<expr><literal type="number">0.999329f</literal></expr>, <expr><literal type="number">0.999381f</literal></expr>, <expr><literal type="number">0.999428f</literal></expr>, <expr><literal type="number">0.999472f</literal></expr>, <expr><literal type="number">0.999513f</literal></expr>,

<expr><literal type="number">0.999550f</literal></expr>, <expr><literal type="number">0.999585f</literal></expr>, <expr><literal type="number">0.999617f</literal></expr>, <expr><literal type="number">0.999646f</literal></expr>, <expr><literal type="number">0.999673f</literal></expr>,

<expr><literal type="number">0.999699f</literal></expr>, <expr><literal type="number">0.999722f</literal></expr>, <expr><literal type="number">0.999743f</literal></expr>, <expr><literal type="number">0.999763f</literal></expr>, <expr><literal type="number">0.999781f</literal></expr>,

<expr><literal type="number">0.999798f</literal></expr>, <expr><literal type="number">0.999813f</literal></expr>, <expr><literal type="number">0.999828f</literal></expr>, <expr><literal type="number">0.999841f</literal></expr>, <expr><literal type="number">0.999853f</literal></expr>,

<expr><literal type="number">0.999865f</literal></expr>, <expr><literal type="number">0.999875f</literal></expr>, <expr><literal type="number">0.999885f</literal></expr>, <expr><literal type="number">0.999893f</literal></expr>, <expr><literal type="number">0.999902f</literal></expr>,

<expr><literal type="number">0.999909f</literal></expr>, <expr><literal type="number">0.999916f</literal></expr>, <expr><literal type="number">0.999923f</literal></expr>, <expr><literal type="number">0.999929f</literal></expr>, <expr><literal type="number">0.999934f</literal></expr>,

<expr><literal type="number">0.999939f</literal></expr>, <expr><literal type="number">0.999944f</literal></expr>, <expr><literal type="number">0.999948f</literal></expr>, <expr><literal type="number">0.999952f</literal></expr>, <expr><literal type="number">0.999956f</literal></expr>,

<expr><literal type="number">0.999959f</literal></expr>, <expr><literal type="number">0.999962f</literal></expr>, <expr><literal type="number">0.999965f</literal></expr>, <expr><literal type="number">0.999968f</literal></expr>, <expr><literal type="number">0.999970f</literal></expr>,

<expr><literal type="number">0.999973f</literal></expr>, <expr><literal type="number">0.999975f</literal></expr>, <expr><literal type="number">0.999977f</literal></expr>, <expr><literal type="number">0.999978f</literal></expr>, <expr><literal type="number">0.999980f</literal></expr>,

<expr><literal type="number">0.999982f</literal></expr>, <expr><literal type="number">0.999983f</literal></expr>, <expr><literal type="number">0.999984f</literal></expr>, <expr><literal type="number">0.999986f</literal></expr>, <expr><literal type="number">0.999987f</literal></expr>,

<expr><literal type="number">0.999988f</literal></expr>, <expr><literal type="number">0.999989f</literal></expr>, <expr><literal type="number">0.999990f</literal></expr>, <expr><literal type="number">0.999990f</literal></expr>, <expr><literal type="number">0.999991f</literal></expr>,

<expr><literal type="number">0.999992f</literal></expr>, <expr><literal type="number">0.999992f</literal></expr>, <expr><literal type="number">0.999993f</literal></expr>, <expr><literal type="number">0.999994f</literal></expr>, <expr><literal type="number">0.999994f</literal></expr>,

<expr><literal type="number">0.999994f</literal></expr>, <expr><literal type="number">0.999995f</literal></expr>, <expr><literal type="number">0.999995f</literal></expr>, <expr><literal type="number">0.999996f</literal></expr>, <expr><literal type="number">0.999996f</literal></expr>,

<expr><literal type="number">0.999996f</literal></expr>, <expr><literal type="number">0.999997f</literal></expr>, <expr><literal type="number">0.999997f</literal></expr>, <expr><literal type="number">0.999997f</literal></expr>, <expr><literal type="number">0.999997f</literal></expr>,

<expr><literal type="number">0.999997f</literal></expr>, <expr><literal type="number">0.999998f</literal></expr>, <expr><literal type="number">0.999998f</literal></expr>, <expr><literal type="number">0.999998f</literal></expr>, <expr><literal type="number">0.999998f</literal></expr>,

<expr><literal type="number">0.999998f</literal></expr>, <expr><literal type="number">0.999998f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>,

<expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>,

<expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>, <expr><literal type="number">0.999999f</literal></expr>,

<expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>,

<expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>, <expr><literal type="number">1.000000f</literal></expr>,

<expr><literal type="number">1.000000f</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>tansig_approx</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>dy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>sign</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>x</name><operator>&lt;</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>x</name><operator>&gt;</operator><operator>-</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>x</name><operator>=</operator><operator>-</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floor</name><argument_list>(<argument><expr><literal type="number">.5f</literal><operator>+</operator><literal type="number">25</literal><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>-=</operator> <literal type="number">.04f</literal><operator>*</operator><name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>tansig_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>dy</name> <operator>=</operator> <literal type="number">1</literal><operator>-</operator><name>y</name><operator>*</operator><name>y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name>y</name> <operator>+</operator> <name>x</name><operator>*</operator><name>dy</name><operator>*</operator><operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>y</name><operator>*</operator><name>x</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>sign</name><operator>*</operator><name>y</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>sigmoid_approx</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">.5f</literal> <operator>+</operator> <literal type="number">.5f</literal><operator>*</operator><call><name>tansig_approx</name><argument_list>(<argument><expr><literal type="number">.5f</literal><operator>*</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_dense</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DenseLayer</name> <modifier>*</modifier></type><name>layer</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>N</name> <init>= <expr><name><name>layer</name><operator>-&gt;</operator><name>nb_neurons</name></name></expr></init></decl>, <decl><type ref="prev"/><name>M</name> <init>= <expr><name><name>layer</name><operator>-&gt;</operator><name>nb_inputs</name></name></expr></init></decl>, <decl><type ref="prev"/><name>stride</name> <init>= <expr><name>N</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><name><name>layer</name><operator>-&gt;</operator><name>bias</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>M</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>layer</name><operator>-&gt;</operator><name>input_weights</name><index>[<expr><name>j</name> <operator>*</operator> <name>stride</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>*</operator> <name><name>input</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>layer</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_SIGMOID</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sigmoid_approx</name><argument_list>(<argument><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>layer</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_TANH</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tansig_approx</name><argument_list>(<argument><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>layer</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_RELU</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_gru</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GRULayer</name> <modifier>*</modifier></type><name>gru</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>M</name> <init>= <expr><name><name>gru</name><operator>-&gt;</operator><name>nb_inputs</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>N</name> <init>= <expr><name><name>gru</name><operator>-&gt;</operator><name>nb_neurons</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>AN</name> <init>= <expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>AM</name> <init>= <expr><call><name>FFALIGN</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stride</name> <init>= <expr><literal type="number">3</literal> <operator>*</operator> <name>AN</name></expr></init></decl>, <decl><type ref="prev"/><name>istride</name> <init>= <expr><literal type="number">3</literal> <operator>*</operator> <name>AM</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><name><name>gru</name><operator>-&gt;</operator><name>bias</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>scalarproduct_float</name></name><argument_list>(<argument><expr><name><name>gru</name><operator>-&gt;</operator><name>input_weights</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>AM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>scalarproduct_float</name></name><argument_list>(<argument><expr><name><name>gru</name><operator>-&gt;</operator><name>recurrent_weights</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>stride</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>AN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sigmoid_approx</name><argument_list>(<argument><expr><name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><name><name>gru</name><operator>-&gt;</operator><name>bias</name><index>[<expr><name>N</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>scalarproduct_float</name></name><argument_list>(<argument><expr><name><name>gru</name><operator>-&gt;</operator><name>input_weights</name></name> <operator>+</operator> <name>AM</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>AM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>scalarproduct_float</name></name><argument_list>(<argument><expr><name><name>gru</name><operator>-&gt;</operator><name>recurrent_weights</name></name> <operator>+</operator> <name>AN</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>stride</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>AN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sigmoid_approx</name><argument_list>(<argument><expr><name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><name><name>gru</name><operator>-&gt;</operator><name>bias</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>N</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>fdsp</name><operator>-&gt;</operator><name>scalarproduct_float</name></name><argument_list>(<argument><expr><name><name>gru</name><operator>-&gt;</operator><name>input_weights</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>AM</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>istride</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>AM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>gru</name><operator>-&gt;</operator><name>recurrent_weights</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>AN</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>stride</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>*</operator> <name><name>state</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>r</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>gru</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_SIGMOID</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>sigmoid_approx</name><argument_list>(<argument><expr><name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>gru</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_TANH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>tansig_approx</name><argument_list>(<argument><expr><name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>gru</name><operator>-&gt;</operator><name>activation</name></name> <operator>==</operator> <name>ACTIVATION_RELU</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WEIGHTS_SCALE</name> <operator>*</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>state</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>sum</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>RNN_COPY</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_SIZE</name></cpp:macro> <cpp:value>42</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_rnn</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>RNNState</name> <modifier>*</modifier></type><name>rnn</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>gains</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vad</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>dense_out</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>noise_input</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LOCAL_ALIGNED_32</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>denoise_input</name></expr></argument>, <argument><expr><index>[<expr><name>MAX_NEURONS</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compute_dense</name><argument_list>(<argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>input_dense</name></name></expr></argument>, <argument><expr><name>dense_out</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compute_gru</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru</name></name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>vad_gru_state</name></name></expr></argument>, <argument><expr><name>dense_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compute_dense</name><argument_list>(<argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_output</name></name></expr></argument>, <argument><expr><name>vad</name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>vad_gru_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>input_dense_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>noise_input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dense_out</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>noise_input</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>input_dense_size</name></name></expr>]</index></name> <operator>=</operator> <name><name>rnn</name><operator>-&gt;</operator><name>vad_gru_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INPUT_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>noise_input</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>input_dense_size</name></name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name></expr>]</index></name> <operator>=</operator> <name><name>input</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>compute_gru</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>noise_gru</name></name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>noise_gru_state</name></name></expr></argument>, <argument><expr><name>noise_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>denoise_input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>rnn</name><operator>-&gt;</operator><name>vad_gru_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>noise_gru_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>denoise_input</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name></expr>]</index></name> <operator>=</operator> <name><name>rnn</name><operator>-&gt;</operator><name>noise_gru_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INPUT_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>denoise_input</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>vad_gru_size</name></name> <operator>+</operator> <name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>noise_gru_size</name></name></expr>]</index></name> <operator>=</operator> <name><name>input</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>compute_gru</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>denoise_gru</name></name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>denoise_gru_state</name></name></expr></argument>, <argument><expr><name>denoise_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compute_dense</name><argument_list>(<argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>model</name><operator>-&gt;</operator><name>denoise_output</name></name></expr></argument>, <argument><expr><name>gains</name></expr></argument>, <argument><expr><name><name>rnn</name><operator>-&gt;</operator><name>denoise_gru_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float</name></type> <name>rnnoise_channel</name><parameter_list>(<parameter><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>DenoiseState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>X</name><index>[<expr><name>FREQ_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVComplexFloat</name></type> <name><name>P</name><index>[<expr><name>WINDOW_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>x</name><index>[<expr><name>FRAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>Ex</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>Ep</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>Exp</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>features</name><index>[<expr><name>NB_FEATURES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>g</name><index>[<expr><name>NB_BANDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>gf</name><index>[<expr><name>FREQ_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>vad_prob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>float</name></type> <name><name>a_hp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1.99599</literal></expr>, <expr><literal type="number">0.99600</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>float</name></type> <name><name>b_hp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>silence</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>biquad</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>mem_hp_x</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>b_hp</name></expr></argument>, <argument><expr><name>a_hp</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>silence</name> <operator>=</operator> <call><name>compute_frame_features</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>Ex</name></expr></argument>, <argument><expr><name>Ep</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>features</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silence</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compute_rnn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>rnn</name></name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vad_prob</name></expr></argument>, <argument><expr><name>features</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pitch_filter</name><argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>Ex</name></expr></argument>, <argument><expr><name>Ep</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>alpha</name> <init>= <expr><literal type="number">.6f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name><name>g</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>alpha</name> <operator>*</operator> <name><name>st</name><operator>-&gt;</operator><name>lastg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>lastg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>g</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>interp_band_gain</name><argument_list>(<argument><expr><name>gf</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FREQ_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>re</name> <operator>*=</operator> <name><name>gf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>X</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>im</name> <operator>*=</operator> <name><name>gf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>frame_synthesis</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vad_prob</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ThreadData</name> <block>{

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl>, <modifier>*</modifier><name>out</name>;</decl_stmt>

}</block></struct></type> <name>ThreadData</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>rnnoise_channels</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobnr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nb_jobs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ThreadData</name> <modifier>*</modifier></type><name>td</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name><name>td</name><operator>-&gt;</operator><name>in</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>td</name><operator>-&gt;</operator><name>out</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>start</name> <init>= <expr><operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>channels</name></name> <operator>*</operator> <name>jobnr</name><operator>)</operator> <operator>/</operator> <name>nb_jobs</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>end</name> <init>= <expr><operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>channels</name></name> <operator>*</operator> <operator>(</operator><name>jobnr</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>nb_jobs</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rnnoise_channel</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>out</name><operator>-&gt;</operator><name>extended_data</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>float</name> <operator>*</operator><operator>)</operator><name><name>in</name><operator>-&gt;</operator><name>extended_data</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ThreadData</name></type> <name>td</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>ff_get_audio_buffer</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>pts</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>pts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>td</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>rnnoise_channels</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>channels</name></name></expr></argument>,

<argument><expr><call><name>ff_filter_get_nb_threads</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>activate</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FF_FILTER_FORWARD_STATUS_BACK</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>inlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_inlink_consume_samples</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>, <argument><expr><name>FRAME_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>filter_frame</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FF_FILTER_FORWARD_STATUS</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>outlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FF_FILTER_FORWARD_WANTED</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>inlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FFERROR_NOT_READY</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>fdsp</name></name> <operator>=</operator> <call><name>avpriv_float_dsp_alloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>fdsp</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>model_name</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>av_fopen_utf8</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>model_name</name></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>model</name></name> <operator>=</operator> <call><name>rnnoise_model_from_file</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>model</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FRAME_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><literal type="number">.5</literal><operator>*</operator><name>M_PI</name><operator>*</operator><call><name>sin</name><argument_list>(<argument><expr><literal type="number">.5</literal><operator>*</operator><name>M_PI</name><operator>*</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">.5</literal><operator>)</operator><operator>/</operator><name>FRAME_SIZE</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><literal type="number">.5</literal><operator>*</operator><name>M_PI</name><operator>*</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">.5</literal><operator>)</operator><operator>/</operator><name>FRAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>WINDOW_SIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NB_BANDS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dct_table</name><index>[<expr><name>i</name><operator>*</operator><name>NB_BANDS</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>cosf</name><argument_list>(<argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">.5f</literal><operator>)</operator> <operator>*</operator> <name>j</name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <name>NB_BANDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dct_table</name><index>[<expr><name>i</name><operator>*</operator><name>NB_BANDS</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>*=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>void</name></type> <name>uninit</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>AudioRNNContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>fdsp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rnnoise_model_free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>model</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>model</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>st</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>rnn</name><operator>.</operator><name>vad_gru_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>rnn</name><operator>.</operator><name>noise_gru_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name><name>rnn</name><operator>.</operator><name>denoise_gru_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_tx_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_tx_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name><index>[<expr><name>ch</name></expr>]</index></name><operator>.</operator><name>txi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>inputs</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,

<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>,

<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_input</name></expr>,

}</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>outputs</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,

<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>,

}</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(AudioRNNContext, x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AF</name></cpp:macro> <cpp:value>AV_OPT_FLAG_AUDIO_PARAM|AV_OPT_FLAG_FILTERING_PARAM</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>arnndn_options</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"model"</literal></expr>, <expr><literal type="string">"set model name"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>model_name</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><name>NULL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AF</name></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"m"</literal></expr>, <expr><literal type="string">"set model name"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>model_name</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><name>NULL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AF</name></expr> }</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AVFILTER_DEFINE_CLASS</name><argument_list>(<argument><expr><name>arnndn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_af_arnndn</name> <init>= <expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"arnndn"</literal></expr>,

<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Reduce noise from speech using Recurrent Neural Networks."</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,

<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AudioRNNContext</name></expr></argument>)</argument_list></sizeof></expr>,

<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>arnndn_class</name></expr>,

<expr><operator>.</operator><name>activate</name> <operator>=</operator> <name>activate</name></expr>,

<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>init</name></expr>,

<expr><operator>.</operator><name>uninit</name> <operator>=</operator> <name>uninit</name></expr>,

<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>inputs</name></expr>,

<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>outputs</name></expr>,

<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_SLICE_THREADS</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

</unit>
