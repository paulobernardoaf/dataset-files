<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\proc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iseq.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROC_NEW_REQUIRES_BLOCK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>__GNUC__</name> <operator>&lt;</operator> <literal type="number">5</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_CLOBBERED</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(volatile VALUE *)&amp;(v))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_CLOBBERED</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_TYPED_REFERENCE</name><parameter_list>(<parameter><type><name>_type</name></type></parameter>, <parameter><type><name>_ref</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>*(_type*)&amp;_ref = (_type)rb_gc_location((VALUE)_ref)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_REFERENCE</name><parameter_list>(<parameter><type><name>_ref</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UPDATE_TYPED_REFERENCE(VALUE, _ref)</cpp:value></cpp:define>

<function_decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>rb_vm_cref_in_context</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>METHOD</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>recv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>iclass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>me</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cUnboundMethod</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cMethod</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cBinding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cProc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_block_call_func</name></type> <name>bmcall</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>method_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>method_min_max_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attached</name></cpp:macro> <cpp:value>id__attached__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_METHOD_PROC_IFUNC</name><parameter_list>(<parameter><type><name>ifunc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ifunc)-&gt;func == bmcall)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>block_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name> <operator>&amp;&amp;</operator> <name><name>captured</name><operator>-&gt;</operator><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>block_compact</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name> <operator>&amp;&amp;</operator> <name><name>captured</name><operator>-&gt;</operator><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_REFERENCE</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>proc_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>block_compact</name><argument_list>(<argument><expr><operator>(</operator>struct <name>rb_block</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>proc_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>block_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_LEAVE</name><argument_list>(<argument><expr><literal type="string">"proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>rb_proc_t</name></type> <name>basic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>env</name><index>[<expr><name>VM_ENV_DATA_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 

}</block></struct></type> <name>cfunc_proc_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>proc_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>cfunc_proc_t</name> <operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>env</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>cfunc_proc_t</name></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_proc_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>proc_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"proc"</literal></expr>,

<expr><block>{

<expr><name>proc_mark</name></expr>,

<expr><name>RUBY_TYPED_DEFAULT_FREE</name></expr>,

<expr><name>proc_memsize</name></expr>,

<expr><name>proc_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name> <operator>|</operator> <name>RUBY_TYPED_WB_PROTECTED</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_proc_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<return>return <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rb_proc_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_data_type</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_is_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_clone</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_proc_dup</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CLONESETUP</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_lambda_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>binding_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_FREE_ENTER</name><argument_list>(<argument><expr><literal type="string">"binding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_FREE_LEAVE</name><argument_list>(<argument><expr><literal type="string">"binding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>binding_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_ENTER</name><argument_list>(<argument><expr><literal type="string">"binding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>block_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_LEAVE</name><argument_list>(<argument><expr><literal type="string">"binding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>binding_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>block_compact</name><argument_list>(<argument><expr><operator>(</operator>struct <name>rb_block</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_REFERENCE</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>binding_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_binding_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ruby_binding_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"binding"</literal></expr>,

<expr><block>{

<expr><name>binding_mark</name></expr>,

<expr><name>binding_free</name></expr>,

<expr><name>binding_memsize</name></expr>,

<expr><name>binding_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_WB_PROTECTED</name> <operator>|</operator> <name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_binding_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rb_binding_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ruby_binding_data_type</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>binding_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bindval</name> <init>= <expr><call><name>rb_binding_alloc</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_copy</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>first_lineno</name></name></expr>;</expr_stmt>

<return>return <expr><name>bindval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>binding_clone</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bindval</name> <init>= <expr><call><name>binding_dup</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CLONESETUP</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>bindval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_binding_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_vm_make_binding</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_f_binding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_binding_new</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_eval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"12"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>bindval</name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_f_eval</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument> )</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>get_local_variable_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>envp</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>lid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>*</operator><name>envp</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_CFRAME</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_iseq</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>lid</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>==</operator> <name>iseq</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>==</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>env</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>rb_vm_bh_to_procval</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>VM_ENV_BLOCK_HANDLER</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>envp</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>env</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>envp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>rb_vm_env_prev_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>envp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>

<name>check_local_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><operator>*</operator><name>pname</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lid</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_local_id</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"wrong local variable name `%1$s' for %2$s"</literal></expr></argument>,

<argument><expr><name>bindval</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_local_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"wrong local variable name `%1$s' for %2$s"</literal></expr></argument>,

<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>lid</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_local_variables</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_env_local_variables</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_local_variable_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name> <init>= <expr><call><name>check_local_id</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lid</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>undefined</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>get_local_variable_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><name>lid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>undefined</name>:</label>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"local variable `%1$s' is not defined for %2$s"</literal></expr></argument>,

<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>*</operator><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_local_variable_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name> <init>= <expr><call><name>check_local_id</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lid</name> <operator>=</operator> <call><name>rb_intern_str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>get_local_variable_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><name>lid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>rb_binding_add_dynavars</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_local_variable_defined_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name> <init>= <expr><call><name>check_local_id</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lid</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>get_local_variable_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>env</name></expr></argument>, <argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_receiver</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_block_self</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bind_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>loc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pathobj_path</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>cfunc_proc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ifunc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>cfunc_proc_t</name> <modifier>*</modifier></type><name>sproc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>cfunc_proc_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_data_type</name></expr></argument>, <argument><expr><name>sproc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>sproc</name><operator>-&gt;</operator><name>basic</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_block_type_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>block_type_ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name> <operator>=</operator> <name>ep</name> <operator>=</operator> <name><name>sproc</name><operator>-&gt;</operator><name>env</name></name> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name> <operator>=</operator> <name>VM_FRAME_MAGIC_IFUNC</name> <operator>|</operator> <name>VM_FRAME_FLAG_CFRAME</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name> <operator>|</operator> <name>VM_ENV_FLAG_ESCAPED</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_SPECVAL</name></expr>]</index></name> <operator>=</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></argument>, <argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_proc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_proc_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_block_type_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>block_type_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type>

<name>rb_vm_ifunc_new</name><parameter_list>(<parameter><decl><type><name>rb_block_call_func_t</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<union>union <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>vm_ifunc_argc</name></name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>packed</name></decl>;</decl_stmt>

}</block> <decl><name>arity</name></decl>;</union>

<if_stmt><if>if <condition>(<expr><name>min_argc</name> <operator>&lt;</operator> <name>UNLIMITED_ARGUMENTS</name> <operator>||</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> <operator>*</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>SIZEOF_VALUE</name></expr></cpp:if>

<name>min_argc</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>SIZEOF_VALUE</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"minimum argument number out of range: %d"</literal></expr></argument>,

<argument><expr><name>min_argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_argc</name> <operator>&lt;</operator> <name>UNLIMITED_ARGUMENTS</name> <operator>||</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> <operator>*</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>SIZEOF_VALUE</name></expr></cpp:if>

<name>max_argc</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>SIZEOF_VALUE</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"maximum argument number out of range: %d"</literal></expr></argument>,

<argument><expr><name>max_argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>arity</name><operator>.</operator><name>argc</name><operator>.</operator><name>min</name></name> <operator>=</operator> <name>min_argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arity</name><operator>.</operator><name>argc</name><operator>.</operator><name>max</name></name> <operator>=</operator> <name>max_argc</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_ifunc</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name><name>arity</name><operator>.</operator><name>packed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator>struct <name>vm_ifunc</name> <operator>*</operator><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_func_proc_new</name><parameter_list>(<parameter><decl><type><name>rb_block_call_func_t</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><call><name>rb_vm_ifunc_proc_new</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>cfunc_proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ifunc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_func_lambda_new</name><parameter_list>(<parameter><decl><type><name>rb_block_call_func_t</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><call><name>rb_vm_ifunc_new</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>val</name></expr></argument>, <argument><expr><name>min_argc</name></expr></argument>, <argument><expr><name>max_argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>cfunc_proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ifunc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>proc_without_block</name><index>[]</index></name> <init>= <expr><literal type="string">"tried to create Proc object without a block"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_lambda</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>kernel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>block_handler</name> <operator>=</operator> <call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>PROC_NEW_REQUIRES_BLOCK</name></expr></cpp:if>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>block_handler</name> <operator>=</operator> <call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_lambda</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>proc_without_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>kernel</name></expr> ?</condition><then> <expr><literal type="string">"Kernel#proc"</literal></expr> </then><else>: <expr><literal type="string">"Proc.new"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_warn_deprecated</name><argument_list>(<argument><expr><literal type="string">"Capturing the given block using %s"</literal></expr></argument>,

<argument><expr><literal type="string">"`&amp;block`"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>proc_without_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<expr_stmt><expr><name>procval</name> <operator>=</operator> <call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>klass</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newprocval</name> <init>= <expr><call><name>rb_proc_dup</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>newprocval</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>newprocval</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>klass</name> <operator>!=</operator> <name>rb_cProc</name><operator>)</operator></expr> ?</condition><then>

<expr><call><name>sym_proc_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>rb_sym_to_proc</name><argument_list>(<argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

<break>break;</break>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<return>return <expr><call><name>rb_vm_make_proc_lambda</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>last_ruby_cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_lambda</name> <operator>&amp;&amp;</operator> <name>last_ruby_cfp</name> <operator>&amp;&amp;</operator> <call><name>vm_cfp_forwarded_bh_p</name><argument_list>(<argument><expr><name>last_ruby_cfp</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_vm_make_proc_lambda</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>proc_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_proc_s_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block</name> <init>= <expr><call><name>proc_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_obj_call_init_kw</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_block_proc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>f_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_block_lambda</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>f_lambda</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_block_lambda</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static VALUE

proc_call(int argc, VALUE *argv, VALUE procval)

{

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>check_argc</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>argc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too many arguments (%lu)"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>argc</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_argc</name><parameter_list>(<parameter><type><name>argc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(argc)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name></type>

<name>rb_proc_call_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>check_argc</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vret</name> <operator>=</operator> <call><name>rb_vm_invoke_proc</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,

<argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_call</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vret</name> <operator>=</operator> <call><name>rb_vm_invoke_proc</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>proc</name></expr></argument>,

<argument><expr><call><name>check_argc</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>, <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_to_block_handler</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VM_BLOCK_HANDLER_NONE</name></expr> </then><else>: <expr><name>procval</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_call_with_block_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_procval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vret</name> <operator>=</operator> <call><name>rb_vm_invoke_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><call><name>proc_to_block_handler</name><argument_list>(<argument><expr><name>passed_procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_call_with_block</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vret</name> <operator>=</operator> <call><name>rb_vm_invoke_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>, <argument><expr><call><name>proc_to_block_handler</name><argument_list>(<argument><expr><name>passed_procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>arity</name> <init>= <expr><call><name>rb_proc_arity</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>rb_iseq_min_max_arity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <ternary><condition><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>==</operator> <name>FALSE</name></expr> ?</condition><then>

<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>+</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>+</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name> <operator>+</operator>

<operator>(</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>==</operator> <name>TRUE</name> <operator>||</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>==</operator> <name>TRUE</name><operator>)</operator></expr>

</then><else>: <expr><name>UNLIMITED_ARGUMENTS</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>+</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name> <operator>+</operator> <operator>(</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_vm_block_min_max_arity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<return>return <expr><call><name>rb_iseq_min_max_arity</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>vm_proc_block</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_METHOD_PROC_IFUNC</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>method_min_max_arity</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ifunc</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name><name>ifunc</name><operator>-&gt;</operator><name>argc</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt>

<return>return <expr><name><name>ifunc</name><operator>-&gt;</operator><name>argc</name><operator>.</operator><name>min</name></name></expr>;</return>

</block_content>}</block>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_proc_min_max_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_block_min_max_arity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_proc_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>rb_vm_block_min_max_arity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr> ?</condition><then> <expr><name>min</name> <operator>==</operator> <name>max</name></expr> </then><else>: <expr><name>max</name> <operator>!=</operator> <name>UNLIMITED_ARGUMENTS</name></expr></else></ternary><operator>)</operator></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><operator>-</operator><name>min</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>block_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>block_type_iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name> <operator>=</operator> <operator>*</operator><call><name>VM_BH_TO_ISEQ_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>block_type_ifunc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name> <operator>=</operator> <operator>*</operator><call><name>VM_BH_TO_IFUNC_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>block_type_symbol</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>block_type_proc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name> <operator>=</operator> <call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_block_pair_yield_optimizable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_block</name></name></type> <name>block</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no block given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>block_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>rb_vm_block_min_max_arity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><name>block_handler</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>!=</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block>

<default>default:</default>

<return>return <expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_block_arity</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_block</name></name></type> <name>block</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no block given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>block_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>rb_vm_block_min_max_arity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><name>block_handler</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr> ?</condition><then> <expr><name>min</name> <operator>==</operator> <name>max</name></expr> </then><else>: <expr><name>max</name> <operator>!=</operator> <name>UNLIMITED_ARGUMENTS</name></expr></else></ternary><operator>)</operator></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><operator>-</operator><name>min</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block>

<default>default:</default>

<return>return <expr><ternary><condition><expr><name>max</name> <operator>!=</operator> <name>UNLIMITED_ARGUMENTS</name></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><operator>-</operator><name>min</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_block_min_max_arity</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_block</name></name></type> <name>block</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no block given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>block_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_block_min_max_arity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_proc_get_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>is_proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_proc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>is_proc</name> <operator>=</operator> <operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<return>return <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<return>return <expr><call><name>rb_proc_get_iseq</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name>is_proc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_METHOD_PROC_IFUNC</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_proc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>is_proc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_method_iseq</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ifunc</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>rb_proc_get_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>loc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iseq</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_iseq_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseq_location</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseq_location</name><argument_list>(<argument><expr><call><name>rb_proc_get_iseq</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_unnamed_parameters</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>arity</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>param</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>arity</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>arity</name></expr> </then><else>: <expr><name>arity</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>arity</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>~</operator><name>arity</name></expr> </then><else>: <expr><name>arity</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>req</name></decl>, <decl><type ref="prev"/><name>rest</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><literal type="string">"req"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>n</name></expr>;</condition> <incr><expr><operator>--</operator><name>n</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>arity</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><literal type="string">"rest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>~</operator><name>arity</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>param</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_proc_parameters</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_proc_get_iseq</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iseq</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_unnamed_parameters</name><argument_list>(<argument><expr><call><name>rb_proc_arity</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_iseq_parameters</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>is_proc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>st_index_t</name></type>

<name>rb_hash_proc</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>prc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>prc</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_sym_to_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_proc_cache</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>SYM_PROC_CACHE_SIZE</name> <init>= <expr><literal type="number">67</literal></expr></init></decl>}</block>;</enum>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sym_proc_cache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sym_proc_cache</name> <operator>=</operator> <call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>SYM_PROC_CACHE_SIZE</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>, <argument><expr><name>SYM_PROC_CACHE_SIZE</name><operator>*</operator><literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>SYM2ID</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>id</name> <operator>%</operator> <name>SYM_PROC_CACHE_SIZE</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sym</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>sym_proc_new</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RARRAY_ASET</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RARRAY_ASET</name><argument_list>(<argument><expr><name>sym_proc_cache</name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>proc</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_proc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_block_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>additional_info</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cname</name> <init>= <expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":"</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>vm_proc_block</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%p %"</literal><name>PRIsVALUE</name><literal type="string">":%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>self</name></expr></argument>,

<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%p(&amp;%+"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>self</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>additional_info</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>additional_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_block_to_s</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr> ?</condition><then> <expr><literal type="string">" (lambda)"</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_to_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>bm_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>bm_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UPDATE_REFERENCE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_REFERENCE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_REFERENCE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_TYPED_REFERENCE</name><argument_list>(<argument><expr><name>rb_method_entry_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>bm_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>METHOD</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>method_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"method"</literal></expr>,

<expr><block>{

<expr><name>bm_mark</name></expr>,

<expr><name>RUBY_TYPED_DEFAULT_FREE</name></expr>,

<expr><name>bm_memsize</name></expr>,

<expr><name>bm_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_obj_is_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>m</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>respond_to_missing_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>rmiss</name> <init>= <expr><name>idRespond_to_missing</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_basic_definition_p</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rmiss</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rmiss</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>sym</name></expr></argument>, <argument><expr><ternary><condition><expr><name>scope</name></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mnew_missing</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mclass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>mclass</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>rb_method_definition_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>VM_METHOD_TYPE_MISSING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_create</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>method</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mnew_missing_by_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mclass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vid</name> <init>= <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>respond_to_missing_p</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>mnew_missing</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mclass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mnew_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>iclass</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mclass</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name> <init>= <expr><name>METHOD_VISI_UNDEF</name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>respond_to_missing_p</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>mnew_missing</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mclass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_print_undef</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>visi</name> <operator>==</operator> <name>METHOD_VISI_UNDEF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>visi</name> <operator>!=</operator> <name>METHOD_VISI_PUBLIC</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_print_inaccessible</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_without_refinements</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>mclass</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>method</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mnew_from_me</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>iclass</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mclass</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>mnew_internal</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mclass</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mnew</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mclass</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iclass</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_with_refinements</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>mnew_from_me</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mclass</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>method_entry_defined_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>defined_class</name></expr> ?</condition><then> <expr><name>defined_class</name></expr> </then><else>: <expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_eq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>m1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>m2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass1</name></decl>, <decl><type ref="prev"/><name>klass2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Check_TypedStruct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>m1</name> <operator>=</operator> <operator>(</operator>struct <name>METHOD</name> <operator>*</operator><operator>)</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>m2</name> <operator>=</operator> <operator>(</operator>struct <name>METHOD</name> <operator>*</operator><operator>)</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>klass1</name> <operator>=</operator> <call><name>method_entry_defined_class</name><argument_list>(<argument><expr><name><name>m1</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>klass2</name> <operator>=</operator> <call><name>method_entry_defined_class</name><argument_list>(<argument><expr><name><name>m2</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_method_entry_eq</name><argument_list>(<argument><expr><name><name>m1</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name><name>m2</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>klass1</name> <operator>!=</operator> <name>klass2</name> <operator>||</operator>

<name><name>m1</name><operator>-&gt;</operator><name>klass</name></name> <operator>!=</operator> <name><name>m2</name><operator>-&gt;</operator><name>klass</name></name> <operator>||</operator>

<name><name>m1</name><operator>-&gt;</operator><name>recv</name></name> <operator>!=</operator> <name><name>m2</name><operator>-&gt;</operator><name>recv</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_method_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_unbind</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>orig</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>method</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_receiver</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_original_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_owner</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_method_name_error</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_fstring_lit("undefined method `%1$s' for"s" `%2$s'")</cpp:value></cpp:define>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>attached</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>MSG</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<goto>goto <name>normal_class</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>MSG</name><argument_list>(<argument><expr><literal type="string">" module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<label><name>normal_class</name>:</label>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>MSG</name><argument_list>(<argument><expr><literal type="string">" class"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_name_err_raise_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MSG</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>obj_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>mclass</name> <init>= <expr><name>rb_cMethod</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>m</name> <init>= <expr><call><name>mnew_missing_by_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>mclass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>m</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_method_name_error</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>mnew</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mclass</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>obj_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_public_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>obj_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_singleton_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_singleton_class_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<label><name>undef</name>:</label>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"undefined singleton method `%1$s' for `%2$s'"</literal></expr></argument>,

<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>m</name> <init>= <expr><call><name>mnew_missing_by_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>rb_cMethod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>m</name></expr>;</return></block_content></block></if></if_stmt>

<goto>goto <name>undef</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_at</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>undef</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>mnew_from_me</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_instance_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_name_error</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>mnew</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_public_instance_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_name_error</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>mnew</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_define_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>rb_vm_cref_in_context</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_scope_visibility_t</name></type> <name>default_scope_visi</name> <init>= <expr><block>{<expr><name>METHOD_VISI_PUBLIC</name></expr>, <expr><name>FALSE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_scope_visibility_t</name> <modifier>*</modifier></type><name>scope_visi</name> <init>= <expr><operator>&amp;</operator><name>default_scope_visi</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_method</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>scope_visi</name> <operator>=</operator> <call><name>CREF_SCOPE_VISI</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROC_NEW_REQUIRES_BLOCK</name></expr></cpp:if>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>rb_block_lambda</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>rb_vm_frame_block_handler</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>proc_without_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>rb_sym_to_proc</name><argument_list>(<argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>rb_vm_make_lambda</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb_cProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_method</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_method</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"wrong argument type %s (expected Proc/Method/UnboundMethod)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_to_id</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_method</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>method</name> <init>= <expr><operator>(</operator>struct <name>METHOD</name> <operator>*</operator><operator>)</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>method</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name> <operator>!=</operator> <name>mod</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_class_inherited_p</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"can't bind singleton method to a different class"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"bind argument must be a subclass of % "</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_method_entry_set</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name><name>scope_visi</name><operator>-&gt;</operator><name>method_visi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope_visi</name><operator>-&gt;</operator><name>module_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_entry_set</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>method</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_proc_dup</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_proc_iseq</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_BMETHOD</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>procval</name></expr></argument>, <argument><expr><name><name>scope_visi</name><operator>-&gt;</operator><name>method_visi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope_visi</name><operator>-&gt;</operator><name>module_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_BMETHOD</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>body</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_obj_define_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_mod_define_method</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>top_define_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>top_wrapper</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"main.define_method in the wrapped load is effective only in wrapper module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name>rb_cObject</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>rb_mod_define_method</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_clone</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>clone</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>orig</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLONESETUP</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clone</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_method_call_pass_called_kw</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_method_call_with_block_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>procval</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_call_kw</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_method_call_with_block_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>procval</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_call</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_method_call_with_block</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>method_callable_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"method_callable_method_entry: not callable."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>call_method_data</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_procval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_passed_block_handler_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>proc_to_block_handler</name><argument_list>(<argument><expr><name>passed_procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,

<argument><expr><call><name>method_callable_method_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_call_with_block_kw</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_procval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"can't call unbound method; bind first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>call_method_data</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>passed_procval</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_call_with_block</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_method_call_with_block_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>passed_procval</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>convert_umethod_to_method_components</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>methclass_out</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klass_out</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iclass_out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>me_out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>methclass</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iclass</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>methclass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refined_class</name> <init>= <expr><call><name>rb_refinement_module_get_refined_class</name><argument_list>(<argument><expr><name>methclass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>methclass</name> <operator>=</operator> <name>refined_class</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>methclass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>methclass</name> <operator>!=</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>methclass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>methclass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"singleton method called for a different object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"bind argument must be an instance of % "</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>methclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ic</name> <init>= <expr><call><name>rb_class_search_ancestor</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name>ic</name></expr>;</expr_stmt>

<expr_stmt><expr><name>iclass</name> <operator>=</operator> <name>ic</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_include_class_new</name><argument_list>(<argument><expr><name>methclass</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator> <call><name>rb_method_entry_complement_defined_class</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>methclass_out</name> <operator>=</operator> <name>methclass</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>klass_out</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>iclass_out</name> <operator>=</operator> <name>iclass</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>me_out</name> <operator>=</operator> <name>me</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>umethod_bind</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>methclass</name></decl>, <decl><type ref="prev"/><name>klass</name></decl>, <decl><type ref="prev"/><name>iclass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>convert_umethod_to_method_components</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>methclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bound</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bound</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bound</name><operator>-&gt;</operator><name>iclass</name></name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bound</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>method</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>umethod_bind_call</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>methclass</name></decl>, <decl><type ref="prev"/><name>klass</name></decl>, <decl><type ref="prev"/><name>iclass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>convert_umethod_to_method_components</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>methclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name></type> <name>bound</name> <init>= <expr><block>{ <expr><name>recv</name></expr>, <expr><name>klass</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>me</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>passed_procval</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>call_method_data</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>passed_procval</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_method_entry_min_max_arity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>def</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>*</operator><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>check_argc</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<return>return <expr><operator>*</operator><name>max</name> <operator>=</operator> <literal type="number">1</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<return>return <expr><operator>*</operator><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><name>def</name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<return>return <expr><call><name>rb_proc_min_max_arity</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><call><name>rb_iseq_min_max_arity</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<return>return <expr><operator>*</operator><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_SEND</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_BLOCK_CALL</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>UNLIMITED_ARGUMENTS</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_method_entry_min_max_arity: invalid method entry type (%d)"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_method_entry_arity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>min</name> <init>= <expr><call><name>rb_method_entry_min_max_arity</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>min</name> <operator>==</operator> <name>max</name></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><operator>-</operator><name>min</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_arity_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>method_arity</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>method_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_method_entry_arity</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>original_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>me</name> <operator>=</operator> <call><name>rb_method_entry</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>method_min_max_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_method_entry_min_max_arity</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_mod_method_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>original_method_entry</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><call><name>rb_method_entry_arity</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_obj_method_arity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_mod_method_arity</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type>

<name>rb_method_def</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>method_def_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<return>return <expr><call><name>rb_proc_get_iseq</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<return>return <expr><call><name>method_def_iseq</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_method_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_def_iseq</name><argument_list>(<argument><expr><call><name>rb_method_def</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>method_cref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>rb_method_def</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><name>def</name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<default>default:</default>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_def_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_ATTRSET</name> <operator>||</operator> <name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_IVAR</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>iseq_location</name><argument_list>(<argument><expr><call><name>method_def_iseq</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_entry_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>method_def_location</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_method_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_def_location</name><argument_list>(<argument><expr><call><name>rb_method_def</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_method_parameters</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_method_iseq</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iseq</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_unnamed_parameters</name><argument_list>(<argument><expr><call><name>method_arity</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_iseq_parameters</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sharp</name> <init>= <expr><literal type="string">"#"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mklass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;% "</literal><name>PRIsVALUE</name><literal type="string">": "</literal></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mklass</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mklass</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mklass</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mklass</name> <operator>=</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_ALIAS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>defined_class</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>defined_class</name> <operator>=</operator> <call><name>method_entry_defined_class</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>defined_class</name> <operator>=</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>, <argument><expr><name>attached</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name> <operator>==</operator> <name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sharp</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sharp</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mklass</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><name>mklass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>mklass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>defined_class</name> <operator>!=</operator> <name>mklass</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"(% "</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sharp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>called_id</name></name> <operator>!=</operator> <name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"(%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" (not-implemented)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>params</name> <init>= <expr><call><name>rb_method_parameters</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pair</name></decl>, <decl><type ref="prev"/><name>name</name></decl>, <decl><type ref="prev"/><name>kind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>req</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"req"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>opt</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"opt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>keyreq</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"keyreq"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>rest</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"rest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>keyrest</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"keyrest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>block</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>nokey</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"nokey"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>forwarding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>pair</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>name</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>req</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>opt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>rest</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>keyrest</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>block</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>nokey</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>req</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>opt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">"=..."</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>keyreq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">":"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>key</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">": ..."</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>rest</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>forwarding</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"*%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>keyrest</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"**%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>block</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>forwarding</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&amp;%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>nokey</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"**nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<block>{<block_content> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>loc</name> <init>= <expr><call><name>rb_method_location</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %"</literal><name>PRIsVALUE</name><literal type="string">":%"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mproc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>rb_mRubyVMFrozenCore</name></expr></argument>, <argument><expr><name>idProc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mlambda</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>rb_mRubyVMFrozenCore</name></expr></argument>, <argument><expr><name>idLambda</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>bmcall</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<return>return <expr><call><name>rb_method_call_with_block_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>blockarg</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_proc_new</name><parameter_list>(

<parameter><decl><type><name>rb_block_call_func_t</name></type> <name>func</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_iterate</name><argument_list>(<argument><expr><name>mproc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_to_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>procval</name> <operator>=</operator> <call><name>rb_iterate</name><argument_list>(<argument><expr><name>mlambda</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bmcall</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_super_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>METHOD</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>super_class</name></decl>, <decl><type ref="prev"/><name>iclass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr>struct <name>METHOD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>method_data_type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iclass</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>iclass</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iclass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>super_class</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>iclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>super_class</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><name>super_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>mnew_internal</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>iclass</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>localjump_xvalue</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iv_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><literal type="string">"@exit_value"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>localjump_reason</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iv_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><literal type="string">"@reason"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>rb_vm_cref_new_toplevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type>

<name>env_clone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>new_ep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>new_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>new_env</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name> <operator>&gt;</operator> <name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cref</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>rb_vm_cref_new_toplevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_body</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>new_body</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_ep</name> <operator>=</operator> <operator>&amp;</operator><name><name>new_body</name><index>[<expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name> <operator>-</operator> <name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_env</name> <operator>=</operator> <call><name>vm_env_new</name><argument_list>(<argument><expr><name>new_ep</name></expr></argument>, <argument><expr><name>new_body</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>new_env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>new_ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>new_env</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_binding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bindval</name></decl>, <decl><type ref="prev"/><name>binding_self</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr>;</expr_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>binding_self</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<goto>goto <name>error</name>;</goto>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_METHOD_PROC_IFUNC</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ifunc</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;empty_iseq&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>empty</name></decl>;</decl_stmt>

<expr_stmt><expr><name>binding_self</name> <operator>=</operator> <call><name>method_receiver</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_method_iseq</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>env_clone</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><call><name>method_cref</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>empty</name> <operator>=</operator> <call><name>rb_iseq_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<label><name>error</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"Can't create Binding from C level Proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><name>bindval</name> <operator>=</operator> <call><name>rb_binding_alloc</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>, <argument><expr><name>binding_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_ep_update</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>,

<argument><expr><call><name>rb_iseq_pathobj_new</name><argument_list>(<argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"(binding)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>bindval</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_block_call_func</name></type> <name>curry</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_curry_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arity</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name> <init>= <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>passed</name></expr></argument>, <argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>procp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_lambda</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_freeze</name><argument_list>(<argument><expr><name>passed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_freeze</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>rb_proc_new</name><argument_list>(<argument><expr><name>curry</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>is_lambda</name></expr>;</expr_stmt>

<return>return <expr><name>proc</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>curry</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>, <decl><type ref="prev"/><name>passed</name></decl>, <decl><type ref="prev"/><name>arity</name></decl>;</decl_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>passed</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arity</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>passed</name> <operator>=</operator> <call><name>rb_ary_plus</name><argument_list>(<argument><expr><name>passed</name></expr></argument>, <argument><expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_freeze</name><argument_list>(<argument><expr><name>passed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>passed</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>blockarg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arity</name> <operator>=</operator> <call><name>make_curry_proc</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>passed</name></expr></argument>, <argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arity</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><call><name>check_argc</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>passed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>passed</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blockarg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_curry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sarity</name></decl>, <decl><type ref="prev"/><name>max_arity</name></decl>, <decl><type ref="prev"/><name>min_arity</name> <init>= <expr><call><name>rb_proc_min_max_arity</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_arity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arity</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>arity</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arity</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>min_arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sarity</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_proc_lambda_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>sarity</name></expr></argument>, <argument><expr><name>min_arity</name></expr></argument>, <argument><expr><name>max_arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>make_curry_proc</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_method_curry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name> <init>= <expr><call><name>method_to_proc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>proc_curry</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>compose</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>fargs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>rb_proc_call_with_block_kw</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>blockarg</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>rb_funcall_with_block_kw</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>blockarg</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_proc_call</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>to_callable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>f</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>f</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>f</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_respond_to</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>f</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"callable object is expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_proc_compose_to_left</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_proc_compose_to_right</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_compose_to_left</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_proc_compose_to_left</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>to_callable</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_proc_compose_to_left</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>, <decl><type ref="prev"/><name>args</name></decl>, <decl><type ref="prev"/><name><name>procs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>procp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_lambda</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>procs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>procs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>rb_ary_tmp_new_from_values</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_obj_respond_to</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>rb_proc_new</name><argument_list>(<argument><expr><name>compose</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>is_lambda</name></expr>;</expr_stmt>

<return>return <expr><name>proc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_compose_to_right</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_proc_compose_to_right</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>to_callable</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_proc_compose_to_right</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>, <decl><type ref="prev"/><name>args</name></decl>, <decl><type ref="prev"/><name><name>procs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>procp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_lambda</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>procs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>procs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>rb_ary_tmp_new_from_values</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>rb_proc_new</name><argument_list>(<argument><expr><name>compose</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>procp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>procp</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>is_lambda</name></expr>;</expr_stmt>

<return>return <expr><name>proc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_method_compose_to_left</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>to_callable</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>method_to_proc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>proc_compose_to_left</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_method_compose_to_right</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>to_callable</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>method_to_proc</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>proc_compose_to_right</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_ruby2_keywords</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for proc (proc created from method)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for proc (proc accepts keywords or proc does not accept argument splat)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for proc (proc not defined in Ruby)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_Proc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<expr_stmt><expr><name>rb_cProc</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Proc"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>rb_proc_s_new</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"==="</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"yield"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

rb_define_method(rb_cProc, "call", proc_call, -1);

rb_define_method(rb_cProc, "[]", proc_call, -1);

rb_define_method(rb_cProc, "===", proc_call, -1);

rb_define_method(rb_cProc, "yield", proc_call, -1);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"to_proc"</literal></expr></argument>, <argument><expr><name>proc_to_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"arity"</literal></expr></argument>, <argument><expr><name>proc_arity</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"clone"</literal></expr></argument>, <argument><expr><name>proc_clone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"dup"</literal></expr></argument>, <argument><expr><name>rb_proc_dup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>proc_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>proc_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"lambda?"</literal></expr></argument>, <argument><expr><name>rb_proc_lambda_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"binding"</literal></expr></argument>, <argument><expr><name>proc_binding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"curry"</literal></expr></argument>, <argument><expr><name>proc_curry</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>proc_compose_to_left</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>, <argument><expr><name>proc_compose_to_right</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"source_location"</literal></expr></argument>, <argument><expr><name>rb_proc_location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>, <argument><expr><name>rb_proc_parameters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><literal type="string">"ruby2_keywords"</literal></expr></argument>, <argument><expr><name>proc_ruby2_keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eLocalJumpError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"LocalJumpError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eLocalJumpError</name></expr></argument>, <argument><expr><literal type="string">"exit_value"</literal></expr></argument>, <argument><expr><name>localjump_xvalue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eLocalJumpError</name></expr></argument>, <argument><expr><literal type="string">"reason"</literal></expr></argument>, <argument><expr><name>localjump_reason</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSysStackError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SystemStackError"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_register_special_exception</name><argument_list>(<argument><expr><name>ruby_error_sysstack</name></expr></argument>, <argument><expr><name>rb_eSysStackError</name></expr></argument>, <argument><expr><literal type="string">"stack level too deep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_global_function</name><argument_list>(<argument><expr><literal type="string">"proc"</literal></expr></argument>, <argument><expr><name>f_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_global_function</name><argument_list>(<argument><expr><literal type="string">"lambda"</literal></expr></argument>, <argument><expr><name>f_lambda</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cMethod</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Method"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>method_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>method_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>method_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"clone"</literal></expr></argument>, <argument><expr><name>method_clone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"call"</literal></expr></argument>, <argument><expr><name>rb_method_call_pass_called_kw</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>rb_method_call_pass_called_kw</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"curry"</literal></expr></argument>, <argument><expr><name>rb_method_curry</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>rb_method_compose_to_left</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>, <argument><expr><name>rb_method_compose_to_right</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_method_call_pass_called_kw</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"arity"</literal></expr></argument>, <argument><expr><name>method_arity_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>method_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>method_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"to_proc"</literal></expr></argument>, <argument><expr><name>method_to_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name>method_receiver</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>method_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"original_name"</literal></expr></argument>, <argument><expr><name>method_original_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"owner"</literal></expr></argument>, <argument><expr><name>method_owner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"unbind"</literal></expr></argument>, <argument><expr><name>method_unbind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"source_location"</literal></expr></argument>, <argument><expr><name>rb_method_location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>, <argument><expr><name>rb_method_parameters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMethod</name></expr></argument>, <argument><expr><literal type="string">"super_method"</literal></expr></argument>, <argument><expr><name>method_super_method</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"method"</literal></expr></argument>, <argument><expr><name>rb_obj_method</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"public_method"</literal></expr></argument>, <argument><expr><name>rb_obj_public_method</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"singleton_method"</literal></expr></argument>, <argument><expr><name>rb_obj_singleton_method</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cUnboundMethod</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"UnboundMethod"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>method_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>method_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>method_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"clone"</literal></expr></argument>, <argument><expr><name>method_clone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"arity"</literal></expr></argument>, <argument><expr><name>method_arity_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>method_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>method_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>method_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"original_name"</literal></expr></argument>, <argument><expr><name>method_original_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"owner"</literal></expr></argument>, <argument><expr><name>method_owner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"bind"</literal></expr></argument>, <argument><expr><name>umethod_bind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"bind_call"</literal></expr></argument>, <argument><expr><name>umethod_bind_call</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"source_location"</literal></expr></argument>, <argument><expr><name>rb_method_location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"parameters"</literal></expr></argument>, <argument><expr><name>rb_method_parameters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cUnboundMethod</name></expr></argument>, <argument><expr><literal type="string">"super_method"</literal></expr></argument>, <argument><expr><name>method_super_method</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cModule</name></expr></argument>, <argument><expr><literal type="string">"instance_method"</literal></expr></argument>, <argument><expr><name>rb_mod_instance_method</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cModule</name></expr></argument>, <argument><expr><literal type="string">"public_instance_method"</literal></expr></argument>, <argument><expr><name>rb_mod_public_instance_method</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cModule</name></expr></argument>, <argument><expr><literal type="string">"define_method"</literal></expr></argument>, <argument><expr><name>rb_mod_define_method</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"define_singleton_method"</literal></expr></argument>, <argument><expr><name>rb_obj_define_method</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_private_method</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"define_method"</literal></expr></argument>, <argument><expr><name>top_define_method</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_Binding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_cBinding</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Binding"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"clone"</literal></expr></argument>, <argument><expr><name>binding_clone</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"dup"</literal></expr></argument>, <argument><expr><name>binding_dup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"eval"</literal></expr></argument>, <argument><expr><name>bind_eval</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"local_variables"</literal></expr></argument>, <argument><expr><name>bind_local_variables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"local_variable_get"</literal></expr></argument>, <argument><expr><name>bind_local_variable_get</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"local_variable_set"</literal></expr></argument>, <argument><expr><name>bind_local_variable_set</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"local_variable_defined?"</literal></expr></argument>, <argument><expr><name>bind_local_variable_defined_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name>bind_receiver</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>, <argument><expr><literal type="string">"source_location"</literal></expr></argument>, <argument><expr><name>bind_location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_global_function</name><argument_list>(<argument><expr><literal type="string">"binding"</literal></expr></argument>, <argument><expr><name>rb_f_binding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
