<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm_core.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VM_CHECK_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_OR_RUBY_DEBUG</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n) &gt; 0) ? (n) : RUBY_DEBUG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CHECK_MODE</name></cpp:macro> <cpp:value>N_OR_RUBY_DEBUG(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VMDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VMDEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VMDEBUG</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VMDEBUG</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDARG_PROTOTYPES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>va_init_list</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>va_start((a),(b))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;varargs.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>va_init_list</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>va_start((a))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUBY_ASSERT_MESG_WHEN(VM_CHECK_MODE &gt; 0, expr, #expr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_UNREACHABLE</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_bug(#func ": unreachable")</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_UNREACHABLE</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UNREACHABLE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/serial.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/stdbool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/list/list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"method.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_atomic.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_opts.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread_native.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_win32.h"</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_pthread.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_MODEL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VM_INSN_INFO_TABLE_IMPL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_INSN_INFO_TABLE_IMPL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NSIG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NSIG</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSIG</name></cpp:macro> <cpp:value>NSIG_MAX</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SIG_MAXSIG</name></expr></argument>)</argument_list></call></expr></cpp:elif> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NSIG</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSIG</name></cpp:macro> <cpp:value>_SIG_MAXSIG</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_SIGMAX</name></expr></argument>)</argument_list></call></expr></cpp:elif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSIG</name></cpp:macro> <cpp:value>(_SIGMAX + 1)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NSIG</name></expr></argument>)</argument_list></call></expr></cpp:elif> 

<cpp:empty>#</cpp:empty>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSIG</name></cpp:macro> <cpp:value>(sizeof(sigset_t) * CHAR_BIT + 1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_NSIG</name></cpp:macro> <cpp:value>NSIG</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_SIGCHLD</name></cpp:macro> <cpp:value>(SIGCLD)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_SIGCHLD</name></cpp:macro> <cpp:value>(SIGCHLD)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_SIGCHLD</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGCHLD_LOSSY</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGCHLD_LOSSY</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAITPID_USE_SIGCHLD</name></cpp:macro> <cpp:value>(RUBY_SIGCHLD || SIGCHLD_LOSSY)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGALTSTACK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SA_SIGINFO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SIGALTSTACK</name></cpp:macro></cpp:define>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>rb_allocate_sigaltstack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>rb_register_sigaltstack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK_INIT</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>altstack</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>var = rb_register_sigaltstack(altstack)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK_FREE</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xfree(var)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>var</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK_INIT</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>altstack</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK_FREE</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ALTSTACK</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOKEN_THREADED_CODE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_DIRECT_THREADED_CODE</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_DIRECT_THREADED_CODE</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_TOKEN_THREADED_CODE</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_TOKEN_THREADED_CODE</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_DIRECT_THREADED_CODE</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_STACK_CACHING</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>void</name></type> <name>rb_vm_encoded_insn_data_table_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>rb_num_t</name>;</typedef>

<typedef>typedef <type><name>signed</name> <name>long</name></type> <name>rb_snum_t</name>;</typedef>

<enum>enum <name>ruby_tag_type</name> <block>{

<decl><name>RUBY_TAG_NONE</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,

<decl><name>RUBY_TAG_RETURN</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,

<decl><name>RUBY_TAG_BREAK</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,

<decl><name>RUBY_TAG_NEXT</name> <init>= <expr><literal type="number">0x3</literal></expr></init></decl>,

<decl><name>RUBY_TAG_RETRY</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,

<decl><name>RUBY_TAG_REDO</name> <init>= <expr><literal type="number">0x5</literal></expr></init></decl>,

<decl><name>RUBY_TAG_RAISE</name> <init>= <expr><literal type="number">0x6</literal></expr></init></decl>,

<decl><name>RUBY_TAG_THROW</name> <init>= <expr><literal type="number">0x7</literal></expr></init></decl>,

<decl><name>RUBY_TAG_FATAL</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,

<decl><name>RUBY_TAG_MASK</name> <init>= <expr><literal type="number">0xf</literal></expr></init></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_NONE</name></cpp:macro> <cpp:value>RUBY_TAG_NONE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_RETURN</name></cpp:macro> <cpp:value>RUBY_TAG_RETURN</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_BREAK</name></cpp:macro> <cpp:value>RUBY_TAG_BREAK</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_NEXT</name></cpp:macro> <cpp:value>RUBY_TAG_NEXT</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_RETRY</name></cpp:macro> <cpp:value>RUBY_TAG_RETRY</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_REDO</name></cpp:macro> <cpp:value>RUBY_TAG_REDO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_RAISE</name></cpp:macro> <cpp:value>RUBY_TAG_RAISE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_THROW</name></cpp:macro> <cpp:value>RUBY_TAG_THROW</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_FATAL</name></cpp:macro> <cpp:value>RUBY_TAG_FATAL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAG_MASK</name></cpp:macro> <cpp:value>RUBY_TAG_MASK</cpp:value></cpp:define>

<enum>enum <name>ruby_vm_throw_flags</name> <block>{

<decl><name>VM_THROW_NO_ESCAPE_FLAG</name> <init>= <expr><literal type="number">0x8000</literal></expr></init></decl>,

<decl><name>VM_THROW_STATE_MASK</name> <init>= <expr><literal type="number">0xff</literal></expr></init></decl>

}</block>;</enum>

<struct_decl>struct <name>rb_thread_struct</name>;</struct_decl>

<struct_decl>struct <name>rb_control_frame_struct</name>;</struct_decl>

<typedef>typedef <type><name><name>struct</name> <name>rb_compile_option_struct</name></name></type> <name>rb_compile_option_t</name>;</typedef>

<struct>struct <name>iseq_inline_cache_entry</name> <block>{

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>ic_serial</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>ic_cref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>iseq_inline_iv_cache_entry</name> <block>{

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>ic_serial</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>

}</block>;</struct>

<union>union <name>iseq_inline_storage_entry</name> <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type><name>running_thread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

}</block> <decl><name>once</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_inline_cache_entry</name></name></type> <name>cache</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_inline_iv_cache_entry</name></name></type> <name>iv_cache</name></decl>;</decl_stmt>

}</block>;</union>

<struct>struct <name>rb_calling_info</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name></decl>;</decl_stmt>

}</block>;</struct>

<struct_decl>struct <name>rb_execution_context_struct</name>;</struct_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CoreDataFromValue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type*)DATA_PTR(obj)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CoreDataFromValue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type*)rb_data_object_get(obj)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetCoreDataFromValue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ptr) = CoreDataFromValue((obj), type))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>rb_iseq_location_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>pathobj</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>base_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>node_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_code_location_t</name></type> <name>code_location</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_iseq_location_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATHOBJ_PATH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATHOBJ_REALPATH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>pathobj_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pathobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>pathobj</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>PATHOBJ_PATH</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>pathobj_realpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pathobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>pathobj</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><name>PATHOBJ_REALPATH</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<struct_decl>struct <name>rb_mjit_unit</name>;</struct_decl>

<struct>struct <name>rb_iseq_constant_body</name> <block>{

<enum>enum <name>iseq_type</name> <block>{

<decl><name>ISEQ_TYPE_TOP</name></decl>,

<decl><name>ISEQ_TYPE_METHOD</name></decl>,

<decl><name>ISEQ_TYPE_BLOCK</name></decl>,

<decl><name>ISEQ_TYPE_CLASS</name></decl>,

<decl><name>ISEQ_TYPE_RESCUE</name></decl>,

<decl><name>ISEQ_TYPE_ENSURE</name></decl>,

<decl><name>ISEQ_TYPE_EVAL</name></decl>,

<decl><name>ISEQ_TYPE_MAIN</name></decl>,

<decl><name>ISEQ_TYPE_PLAIN</name></decl>

}</block> <decl><name>type</name></decl>;</enum> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iseq_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded</name></decl>;</decl_stmt> 

<struct>struct <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_lead</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_opt</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_rest</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_post</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_kw</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_kwrest</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_block</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ambiguous_param0</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>accepts_no_kwarg</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ruby2_keywords</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block> <decl><name>flags</name></decl>;</struct>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lead_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rest_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>post_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>post_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>block_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>opt_table</name></decl>;</decl_stmt> 

<struct><specifier>const</specifier> struct <name>rb_iseq_param_keyword</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>required_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rest_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>default_values</name></decl>;</decl_stmt>

}</block> <decl><modifier>*</modifier><name>keyword</name></decl>;</struct>

}</block> <decl><name>param</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_iseq_location_t</name></type> <name>location</name></decl>;</decl_stmt>

<struct>struct <name>iseq_insn_info</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>succ_index_table</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block> <decl><name>insns_info</name></decl>;</struct>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>local_table</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>catch_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_struct</name></name> <modifier>*</modifier></type><name>parent_iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_struct</name></name> <modifier>*</modifier></type><name>local_iseq</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is_entries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>call_data</name></decl>;</decl_stmt> 

<struct>struct <block>{

<decl_stmt><decl><type><name>rb_snum_t</name></type> <name>flip_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverage</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pc2branchindex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>original_iseq</name></decl>;</decl_stmt>

}</block> <decl><name>variable</name></decl>;</struct>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>local_table_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>is_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ci_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>stack_max</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name></type> <name>catch_except_p</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_MJIT</name></expr></cpp:if>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>jit_func</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_execution_context_struct</name></name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> 

<decl_stmt><decl><type><name>long</name> <name>unsigned</name></type> <name>total_calls</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>rb_mjit_unit</name></name> <modifier>*</modifier></type><name>jit_unit</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>iseq_unique_id</name></decl>;</decl_stmt> 

}</block>;</struct>

<struct>struct <name>rb_iseq_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>wrapper</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt> 

<union>union <block>{ 

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data</name></name> <modifier>*</modifier></type><name>compile_data</name></decl>;</decl_stmt> 

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

}</block> <decl><name>loader</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_hook_list_struct</name></name> <modifier>*</modifier></type><name>local_hooks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>global_trace_events</name></decl>;</decl_stmt>

}</block> <decl><name>exec</name></decl>;</struct>

}</block> <decl><name>aux</name></decl>;</union>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LAZY_LOAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_LAZY_LOAD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LAZY_LOAD</name></expr></cpp:if>

<function_decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_complete</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LAZY_LOAD</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_complete</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>def_iseq_ptr</name><parameter_list>(<parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_ISEQ</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"def_iseq_ptr: not iseq (%d)"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>ruby_special_exceptions</name> <block>{

<decl><name>ruby_error_reenter</name></decl>,

<decl><name>ruby_error_nomemory</name></decl>,

<decl><name>ruby_error_sysstack</name></decl>,

<decl><name>ruby_error_stackfatal</name></decl>,

<decl><name>ruby_error_stream_closed</name></decl>,

<decl><name>ruby_special_error_count</name></decl>

}</block>;</enum>

<enum>enum <name>ruby_basic_operators</name> <block>{

<decl><name>BOP_PLUS</name></decl>,

<decl><name>BOP_MINUS</name></decl>,

<decl><name>BOP_MULT</name></decl>,

<decl><name>BOP_DIV</name></decl>,

<decl><name>BOP_MOD</name></decl>,

<decl><name>BOP_EQ</name></decl>,

<decl><name>BOP_EQQ</name></decl>,

<decl><name>BOP_LT</name></decl>,

<decl><name>BOP_LE</name></decl>,

<decl><name>BOP_LTLT</name></decl>,

<decl><name>BOP_AREF</name></decl>,

<decl><name>BOP_ASET</name></decl>,

<decl><name>BOP_LENGTH</name></decl>,

<decl><name>BOP_SIZE</name></decl>,

<decl><name>BOP_EMPTY_P</name></decl>,

<decl><name>BOP_NIL_P</name></decl>,

<decl><name>BOP_SUCC</name></decl>,

<decl><name>BOP_GT</name></decl>,

<decl><name>BOP_GE</name></decl>,

<decl><name>BOP_NOT</name></decl>,

<decl><name>BOP_NEQ</name></decl>,

<decl><name>BOP_MATCH</name></decl>,

<decl><name>BOP_FREEZE</name></decl>,

<decl><name>BOP_UMINUS</name></decl>,

<decl><name>BOP_MAX</name></decl>,

<decl><name>BOP_MIN</name></decl>,

<decl><name>BOP_CALL</name></decl>,

<decl><name>BOP_AND</name></decl>,

<decl><name>BOP_OR</name></decl>,

<decl><name>BOP_LAST_</name></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetVMPtr</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GetCoreDataFromValue((obj), rb_vm_t, (ptr))</cpp:value></cpp:define>

<struct_decl>struct <name>rb_vm_struct</name>;</struct_decl>

<typedef>typedef <function_decl><type><name>void</name></type> <name>rb_vm_at_exit_func</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_vm_struct</name></name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>rb_at_exit_list</name> <block>{

<decl_stmt><decl><type><name>rb_vm_at_exit_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_at_exit_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_at_exit_list</name>;</typedef>

<struct_decl>struct <name>rb_objspace</name>;</struct_decl>

<function_decl><type><name><name>struct</name> <name>rb_objspace</name></name> <modifier>*</modifier></type><name>rb_objspace_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_objspace_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_objspace</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_objspace_call_finalizer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_objspace</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>rb_hook_list_struct</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_event_hook_struct</name></name> <modifier>*</modifier></type><name>hooks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>need_clean</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>running</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_hook_list_t</name>;</typedef>

<typedef>typedef <type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>RB_BUILTIN</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_vm_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_global_vm_lock_t</name></type> <name>gvl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type><name>main_thread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type><name>running_thread</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>main_altstack</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>fork_gen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_nativethread_lock_t</name></type> <name>waitpid_lock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>waiting_pids</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>waiting_grps</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>waiting_fds</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>living_threads</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>thgroup_default</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>living_thread_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>ubf_async_safe</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>running</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>thread_abort_on_exception</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>thread_report_on_exception</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>safe_level_</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sleeper</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mark_object_ary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name><name>special_exceptions</name><index>[<expr><name>ruby_special_error_count</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>top_self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>load_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>load_path_snapshot</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>load_path_check_cache</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>expanded_load_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loaded_features</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loaded_features_snapshot</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>loaded_features_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>loading_table</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>cmd</name><index>[<expr><name>RUBY_NSIG</name></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name>trap_list</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_hook_list_t</name></type> <name>global_hooks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>ensure_rollback_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_postponed_job_struct</name></name> <modifier>*</modifier></type><name>postponed_job_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>postponed_job_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>src_encoding_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>workqueue</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_nativethread_lock_t</name></type> <name>workqueue_lock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>verbose</name></decl>, <name>debug</name>, <name>orig_progname</name>, <name>progname</name>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>coverage_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type> <name>defined_module_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_objspace</name></name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_at_exit_list</name> <modifier>*</modifier></type><name>at_exit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_strings</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>frozen_strings</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>builtin_function_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>builtin_inline_index</name></decl>;</decl_stmt>

<struct>struct <block>{ 

<decl_stmt><decl><type><name>size_t</name></type> <name>thread_vm_stack_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>thread_machine_stack_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fiber_vm_stack_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fiber_machine_stack_size</name></decl>;</decl_stmt>

}</block> <decl><name>default_params</name></decl>;</struct>

<decl_stmt><decl><type><name>short</name></type> <name><name>redefined_flag</name><index>[<expr><name>BOP_LAST_</name></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_vm_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_SIZE_ALIGN</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_VM_STACK_SIZE</name></cpp:macro> <cpp:value>( 128 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_VM_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 2 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE</name></cpp:macro> <cpp:value>( 128 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 16 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_VM_STACK_SIZE</name></cpp:macro> <cpp:value>( 16 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_VM_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 2 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE</name></cpp:macro> <cpp:value>( 64 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 32 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 16 * 1024 * sizeof(VALUE))</cpp:value></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>__has_feature</name><argument_list>(<argument><expr><name>memory_sanitizer</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>__has_feature</name><argument_list>(<argument><expr><name>address_sanitizer</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_VM_THREAD_MACHINE_STACK_SIZE</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE</name></cpp:macro> <cpp:value>(1024 * 1024 * sizeof(VALUE))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_VM_THREAD_MACHINE_STACK_SIZE_MIN</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 512 * 1024 * sizeof(VALUE))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_VM_FIBER_MACHINE_STACK_SIZE</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE</name></cpp:macro> <cpp:value>( 256 * 1024 * sizeof(VALUE))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN</name></cpp:macro> <cpp:value>( 128 * 1024 * sizeof(VALUE))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGER_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYMBOL_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 6)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 7)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGEXP_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NIL_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 9)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUE_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 10)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALSE_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 11)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROC_REDEFINED_OP_FLAG</name></cpp:macro> <cpp:value>(1 &lt;&lt; 12)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASIC_OP_UNREDEFINED_P</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>klass</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(LIKELY((GET_VM()-&gt;redefined_flag[(op)]&amp;(klass)) == 0))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VM_DEBUG_BP_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEBUG_BP_CHECK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VM_DEBUG_VERIFY_METHOD_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEBUG_VERIFY_METHOD_CACHE</name></cpp:macro> <cpp:value>(VMDEBUG != 0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>rb_captured_block</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

}</block> <decl><name>code</name></decl>;</union>

}</block>;</struct>

<enum>enum <name>rb_block_handler_type</name> <block>{

<decl><name>block_handler_type_iseq</name></decl>,

<decl><name>block_handler_type_ifunc</name></decl>,

<decl><name>block_handler_type_symbol</name></decl>,

<decl><name>block_handler_type_proc</name></decl>

}</block>;</enum>

<enum>enum <name>rb_block_type</name> <block>{

<decl><name>block_type_iseq</name></decl>,

<decl><name>block_type_ifunc</name></decl>,

<decl><name>block_type_symbol</name></decl>,

<decl><name>block_type_proc</name></decl>

}</block>;</enum>

<struct>struct <name>rb_block</name> <block>{

<union>union <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name></type> <name>captured</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>symbol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

}</block> <decl><name>as</name></decl>;</union>

<decl_stmt><decl><type><name><name>enum</name> <name>rb_block_type</name></name></type> <name>type</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><struct>struct <name>rb_control_frame_struct</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>block_code</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>__bp__</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_DEBUG_BP_CHECK</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>bp_check</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>rb_control_frame_t</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ruby_threadptr_data_type</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type>

<name>rb_thread_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>thval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator>struct <name>rb_thread_struct</name> <operator>*</operator><operator>)</operator><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>thval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ruby_threadptr_data_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>rb_thread_status</name> <block>{

<decl><name>THREAD_RUNNABLE</name></decl>,

<decl><name>THREAD_STOPPED</name></decl>,

<decl><name>THREAD_STOPPED_FOREVER</name></decl>,

<decl><name>THREAD_KILLED</name></decl>

}</block>;</enum>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_JMP_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>RUBY_JMP_BUF</name></type> <name>rb_jmpbuf_t</name>;</typedef>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>void</name> <modifier>*</modifier></type><name><name>rb_jmpbuf_t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>rb_vm_tag</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>retval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_jmpbuf_t</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_vm_tag</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>

}</block>;</struct>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>rb_vm_tag_buf_offset</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>rb_vm_tag</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>rb_vm_tag_buf_end</name></expr></argument>,

<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>rb_vm_tag</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rb_jmpbuf_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator>

<sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_vm_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct>struct <name>rb_vm_protect_tag</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_vm_protect_tag</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>rb_unblock_callback</name> <block>{

<decl_stmt><decl><type><name>rb_unblock_function_t</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

}</block>;</struct>

<struct_decl>struct <name>rb_mutex_struct</name>;</struct_decl>

<typedef>typedef <type><struct>struct <name>rb_thread_list_struct</name><block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_thread_list_struct</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_thread_list_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_ensure_entry</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>marker</name></decl>;</decl_stmt>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>e_proc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>VALUE</name></type> <name>data2</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_ensure_entry_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_ensure_list</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_ensure_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_ensure_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_ensure_list_t</name>;</typedef>

<typedef>typedef <type><name>char</name></type> <name><name>rb_thread_id_string_t</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_nativethread_id_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>rb_fiber_struct</name></name></type> <name>rb_fiber_t</name>;</typedef>

<struct>struct <name>rb_execution_context_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>vm_stack</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>vm_stack_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_vm_tag</name></name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_vm_protect_tag</name></name> <modifier>*</modifier></type><name>protect_tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>interrupt_flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>interrupt_mask</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_fiber_t</name> <modifier>*</modifier></type><name>fiber_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_thread_struct</name></name> <modifier>*</modifier></type><name>thread_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>local_storage</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>local_storage_recursive_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>local_storage_recursive_hash_for_trace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>root_lep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>root_svar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ensure_list_t</name> <modifier>*</modifier></type><name>ensure_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_trace_arg_struct</name></name> <modifier>*</modifier></type><name>trace_arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>errinfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>raised_flag</name></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>BITFIELD</name><argument_list>(<argument><expr>enum <name>method_missing_reason</name></expr></argument>, <argument><expr><name>method_missing_reason</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>private_const_reference</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>stack_maxsize</name></decl>;</decl_stmt>

<macro><name>RUBY_ALIGNAS</name><argument_list>(<argument>SIZEOF_VALUE</argument>)</argument_list></macro> <decl_stmt><decl><type><name>jmp_buf</name></type> <name>regs</name></decl>;</decl_stmt>

}</block> <decl><name>machine</name></decl>;</struct>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>rb_execution_context_t</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name><name>struct</name> <name>rb_execution_context_struct</name></name></type> <name>rb_execution_context_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_execution_context_t</name></cpp:macro> <cpp:value>rb_execution_context_t</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CORE_H_EC_DEFINED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>rb_ec_set_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_ec_initialize_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_ec_clear_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>rb_thread_struct</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>vmlt_node</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>last_status</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>top_self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>top_wrapper</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_nativethread_id_t</name></type> <name>thread_id</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NON_SCALAR_THREAD_ID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>rb_thread_id_string_t</name></type> <name>thread_id_string</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>BITFIELD</name><argument_list>(<argument><expr>enum <name>rb_thread_status</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>to_kill</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>abort_on_exception</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>report_on_exception</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pending_interrupt_queue_checked</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int8_t</name></type> <name>priority</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint32_t</name></type> <name>running_time_us</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>native_thread_data_t</name></type> <name>native_thread_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>blocking_region_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>thgroup</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>retval</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pending_interrupt_queue</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pending_interrupt_mask_stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_nativethread_lock_t</name></type> <name>interrupt_lock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_unblock_callback</name></name></type> <name>unblock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>locking_mutex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_mutex_struct</name></name> <modifier>*</modifier></type><name>keeping_mutexes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_list_t</name> <modifier>*</modifier></type><name>join_list</name></decl>;</decl_stmt>

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name></decl>;</decl_stmt>

}</block> <decl><name>proc</name></decl>;</struct>

<struct>struct <block>{

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

}</block> <decl><name>func</name></decl>;</struct>

}</block> <decl><name>invoke_arg</name></decl>;</union>

<enum>enum <block>{

<decl><name>thread_invoke_type_none</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>thread_invoke_type_proc</name></decl>,

<decl><name>thread_invoke_type_func</name></decl>

}</block> <decl><name>invoke_type</name></decl>;</enum>

<decl_stmt><decl><type><name>VALUE</name></type> <name>stat_insn_usage</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_fiber_t</name> <modifier>*</modifier></type><name>root_fiber</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_jmpbuf_t</name></type> <name>root_jmpbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>altstack</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>rb_thread_t</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>VM_DEFINECLASS_TYPE_CLASS</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,

<decl><name>VM_DEFINECLASS_TYPE_SINGLETON_CLASS</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,

<decl><name>VM_DEFINECLASS_TYPE_MODULE</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,

<decl><name>VM_DEFINECLASS_TYPE_MASK</name> <init>= <expr><literal type="number">0x07</literal></expr></init></decl>

}</block></enum></type> <name>rb_vm_defineclass_type_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEFINECLASS_TYPE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((rb_vm_defineclass_type_t)(x) &amp; VM_DEFINECLASS_TYPE_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEFINECLASS_FLAG_SCOPED</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEFINECLASS_FLAG_HAS_SUPERCLASS</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEFINECLASS_SCOPED_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; VM_DEFINECLASS_FLAG_SCOPED)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_DEFINECLASS_HAS_SUPERCLASS_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; VM_DEFINECLASS_FLAG_HAS_SUPERCLASS)</cpp:value></cpp:define>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_new</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_new_top</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_new_main</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_new_with_opt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_compile_option_t</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<struct_decl>struct <name>iseq_link_anchor</name>;</struct_decl>

<struct>struct <name>rb_iseq_new_with_callback_callback_func</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>reserved</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>iseq_link_anchor</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type>

<name>rb_iseq_new_with_callback_new_callback</name><parameter_list>(

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>iseq_link_anchor</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_ifunc</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator>struct <name>rb_iseq_new_with_callback_callback_func</name> <operator>*</operator><operator>)</operator><name>memo</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>rb_iseq_new_with_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type> <name>ifunc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_compile_option_t</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseq_disasm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_iseq_disasm_insn</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>iseqval</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>child</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseq_coverage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>VALUE</name></type> <name>rb_cISeq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>VALUE</name></type> <name>rb_cRubyVM</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>VALUE</name></type> <name>rb_mRubyVMFrozenCore</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>VALUE</name></type> <name>rb_block_param_proxy</name></decl>;</decl_stmt>

<macro><name>RUBY_SYMBOL_EXPORT_END</name></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetProcPtr</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GetCoreDataFromValue((obj), rb_proc_t, (ptr))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name></type> <name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>is_from_method</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>is_lambda</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> 

}</block></struct></type> <name>rb_proc_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>env_size</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_env_t</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ruby_binding_data_type</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetBindingPtr</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GetCoreDataFromValue((obj), rb_binding_t, (ptr))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name></type> <name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>pathobj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>first_lineno</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_binding_t</name>;</typedef>

<enum>enum <name>vm_check_match_type</name> <block>{

<decl><name>VM_CHECKMATCH_TYPE_WHEN</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>VM_CHECKMATCH_TYPE_CASE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,

<decl><name>VM_CHECKMATCH_TYPE_RESCUE</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CHECKMATCH_TYPE_MASK</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CHECKMATCH_ARRAY</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>

<enum>enum <name>vm_special_object_type</name> <block>{

<decl><name>VM_SPECIAL_OBJECT_VMCORE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>VM_SPECIAL_OBJECT_CBASE</name></decl>,

<decl><name>VM_SPECIAL_OBJECT_CONST_BASE</name></decl>

}</block>;</enum>

<enum>enum <name>vm_svar_index</name> <block>{

<decl><name>VM_SVAR_LASTLINE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 

<decl><name>VM_SVAR_BACKREF</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 

<decl><name>VM_SVAR_EXTRA_START</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,

<decl><name>VM_SVAR_FLIPFLOP_START</name> <init>= <expr><literal type="number">2</literal></expr></init></decl> 

}</block>;</enum>

<typedef>typedef <type><name><name>struct</name> <name>iseq_inline_cache_entry</name></name> <modifier>*</modifier></type><name>IC</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>iseq_inline_iv_cache_entry</name></name> <modifier>*</modifier></type><name>IVC</name>;</typedef>

<typedef>typedef <type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>ISE</name>;</typedef>

<typedef>typedef <type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>CALL_INFO</name>;</typedef>

<typedef>typedef <type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>CALL_CACHE</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>CALL_DATA</name>;</typedef>

<typedef>typedef <type><name>VALUE</name></type> <name>CDHASH</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FUNC_FASTCALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_FASTCALL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <expr_stmt><expr><call><call><name>rb_control_frame_t</name> <argument_list>*

<argument><expr><operator>(</operator><call><name>FUNC_FASTCALL</name><argument_list>(<argument><expr><operator>*</operator><name>rb_insn_func_t</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name>rb_execution_context_t</name> <operator>*</operator><operator>,</operator> <name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator></expr></argument>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_TAGGED_PTR_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>tag</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((VALUE)(p) | (tag))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_TAGGED_PTR_REF</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void *)((v) &amp; ~mask))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_GUARDED_PTR</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>VM_TAGGED_PTR_SET((p), 0x01)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_GUARDED_PTR_REF</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>VM_TAGGED_PTR_REF((p), 0x03)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_GUARDED_PTR_P</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((VALUE)(p)) &amp; 0x01)</cpp:value></cpp:define>

<argument><expr>enum <block>{

<expr><name>VM_FRAME_MAGIC_METHOD</name> <operator>=</operator> <literal type="number">0x11110001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_BLOCK</name> <operator>=</operator> <literal type="number">0x22220001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_CLASS</name> <operator>=</operator> <literal type="number">0x33330001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_TOP</name> <operator>=</operator> <literal type="number">0x44440001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_CFUNC</name> <operator>=</operator> <literal type="number">0x55550001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_IFUNC</name> <operator>=</operator> <literal type="number">0x66660001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_EVAL</name> <operator>=</operator> <literal type="number">0x77770001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_RESCUE</name> <operator>=</operator> <literal type="number">0x78880001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_DUMMY</name> <operator>=</operator> <literal type="number">0x79990001</literal></expr>,

<expr><name>VM_FRAME_MAGIC_MASK</name> <operator>=</operator> <literal type="number">0x7fff0001</literal></expr>,

<expr><name>VM_FRAME_FLAG_PASSED</name> <operator>=</operator> <literal type="number">0x0010</literal></expr>,

<expr><name>VM_FRAME_FLAG_FINISH</name> <operator>=</operator> <literal type="number">0x0020</literal></expr>,

<expr><name>VM_FRAME_FLAG_BMETHOD</name> <operator>=</operator> <literal type="number">0x0040</literal></expr>,

<expr><name>VM_FRAME_FLAG_CFRAME</name> <operator>=</operator> <literal type="number">0x0080</literal></expr>,

<expr><name>VM_FRAME_FLAG_LAMBDA</name> <operator>=</operator> <literal type="number">0x0100</literal></expr>,

<expr><name>VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM</name> <operator>=</operator> <literal type="number">0x0200</literal></expr>,

<expr><name>VM_FRAME_FLAG_CFRAME_KW</name> <operator>=</operator> <literal type="number">0x0400</literal></expr>,

<expr><name>VM_ENV_FLAG_LOCAL</name> <operator>=</operator> <literal type="number">0x0002</literal></expr>,

<expr><name>VM_ENV_FLAG_ESCAPED</name> <operator>=</operator> <literal type="number">0x0004</literal></expr>,

<expr><name>VM_ENV_FLAG_WB_REQUIRED</name> <operator>=</operator> <literal type="number">0x0008</literal></expr>

}</block></expr></argument>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_DATA_SIZE</name></cpp:macro> <cpp:value>( 3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_DATA_INDEX_ME_CREF</name></cpp:macro> <cpp:value>(-2)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_DATA_INDEX_SPECVAL</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_DATA_INDEX_FLAGS</name></cpp:macro> <cpp:value>( 0)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_DATA_INDEX_ENV</name></cpp:macro> <cpp:value>( 1)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_ENV_INDEX_LAST_LVAR</name></cpp:macro> <cpp:value>(-VM_ENV_DATA_SIZE)</cpp:value></cpp:define>

<argument><expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <macro><name>VM_FORCE_WRITE_SPECIAL_CONST</name><argument_list>(<argument>const VALUE *ptr</argument>, <argument>VALUE special_const_value</argument>)</argument_list></macro></expr></argument>;

<argument><expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name>

<macro><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument>const VALUE *ep</argument>, <argument>VALUE flag</argument>)</argument_list></macro>

<block>{

<expr><name>VALUE</name> <name>flags</name> <operator>=</operator> <name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr>;

<expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>VM_FORCE_WRITE_SPECIAL_CONST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>flag</name></expr></argument>)</argument_list></call></expr>;

}</block>

<specifier>static</specifier> <specifier>inline</specifier> <name>void</name>

<macro><name>VM_ENV_FLAGS_UNSET</name><argument_list>(<argument>const VALUE *ep</argument>, <argument>VALUE flag</argument>)</argument_list></macro>

<block>{

<expr><name>VALUE</name> <name>flags</name> <operator>=</operator> <name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr>;

<expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>VM_FORCE_WRITE_SPECIAL_CONST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>flag</name></expr></argument>)</argument_list></call></expr>;

}</block>

<specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name>

<macro><name>VM_ENV_FLAGS</name><argument_list>(<argument>const VALUE *ep</argument>, <argument>long flag</argument>)</argument_list></macro>

<block>{

<expr><name>VALUE</name> <name>flags</name> <operator>=</operator> <name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr>;

<expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<return>return <expr><name>flags</name> <operator>&amp;</operator> <name>flag</name></expr>;</return>

}</block></expr></argument></argument_list></call></call></expr></expr_stmt></typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name></type>

<name>VM_FRAME_TYPE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_MASK</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_LAMBDA_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_LAMBDA</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_CFRAME_KW_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_CFRAME_KW</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_FINISHED_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_FINISH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_BMETHOD_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_BMETHOD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>rb_obj_is_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>imemo_iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_NORMAL_ISEQ_P</name><parameter_list>(<parameter><type><name>iseq</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_obj_is_iseq((VALUE)iseq)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_CFRAME_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cframe_p</name> <init>= <expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_CFRAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RUBY_VM_NORMAL_ISEQ_P</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cframe_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cframe_p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_FRAME_RUBYFRAME_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><call><name>VM_FRAME_CFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBYVM_CFUNC_FRAME_P</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VM_FRAME_TYPE(cfp) == VM_FRAME_MAGIC_CFUNC)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_GUARDED_PREV_EP</name><parameter_list>(<parameter><type><name>ep</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GC_GUARDED_PTR(ep)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_BLOCK_HANDLER_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_ENV_LOCAL_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_LOCAL</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>VM_ENV_PREV_EP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>GC_GUARDED_PTR_REF</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_SPECVAL</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_ENV_BLOCK_HANDLER</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_SPECVAL</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function_decl><type><name>int</name></type> <name>rb_vm_ep_in_heap_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_ENV_ESCAPED_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_vm_ep_in_heap_p</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>!</operator><operator>!</operator><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_assert_env</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>imemo_env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_ENV_ENVVAL</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>envval</name> <init>= <expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_assert_env</name><argument_list>(<argument><expr><name>envval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>envval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type>

<name>VM_ENV_ENVVAL_PTR</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>rb_env_t</name> <operator>*</operator><operator>)</operator><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type>

<name>vm_env_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>env_ep</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>env_body</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>env_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>(</operator><name>rb_env_t</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_env</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>env_ep</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>env_body</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name> <operator>=</operator> <name>env_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>env_ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>env</name></expr>;</expr_stmt>

<return>return <expr><name>env</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>VM_FORCE_WRITE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>VM_FORCE_WRITE_SPECIAL_CONST</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>special_const_value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>special_const_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_FORCE_WRITE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>special_const_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>VM_STACK_ENV_WRITE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_WB_REQUIRED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_FORCE_WRITE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>rb_vm_ep_local_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>rb_vm_proc_local_ep</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_block_ep_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_block_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_frame_block_handler</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((cfp)+1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_NEXT_CONTROL_FRAME</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((cfp)-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_VALID_CONTROL_FRAME_P</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>, <parameter><type><name>ecfp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void *)(ecfp) &gt; (void *)(cfp))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>RUBY_VM_END_CONTROL_FRAME</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><call><name>RUBY_VM_VALID_CONTROL_FRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><call><name>RUBY_VM_END_CONTROL_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_BH_ISEQ_BLOCK_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>block_handler</name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x01</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_TAGGED_PTR_REF</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_FROM_ISEQ_BLOCK</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_TAGGED_PTR_SET</name><argument_list>(<argument><expr><name>captured</name></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_BH_ISEQ_BLOCK_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type>

<name>VM_BH_TO_ISEQ_BLOCK</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_TAGGED_PTR_REF</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_BH_ISEQ_BLOCK_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>captured</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>VM_BH_IFUNC_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>block_handler</name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x03</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>block_handler</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x03</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_ifunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_FROM_IFUNC_BLOCK</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_TAGGED_PTR_SET</name><argument_list>(<argument><expr><name>captured</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_BH_IFUNC_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type>

<name>VM_BH_TO_IFUNC_BLOCK</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_TAGGED_PTR_REF</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_BH_IFUNC_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>captured</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type>

<name>VM_BH_TO_CAPT_BLOCK</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_TAGGED_PTR_REF</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_BH_IFUNC_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>VM_BH_ISEQ_BLOCK_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>captured</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>enum</name> <name>rb_block_handler_type</name></name></type>

<name>vm_block_handler_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_BH_ISEQ_BLOCK_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>block_handler_type_iseq</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VM_BH_IFUNC_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>block_handler_type_ifunc</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>block_handler_type_symbol</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler_type_proc</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_block_handler_verify</name><argument_list>(<argument><expr><macro><name>MAYBE_UNUSED</name><argument_list>(<argument>VALUE block_handler</argument>)</argument_list></macro></expr></argument>)</argument_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name> <operator>||</operator>

<operator>(</operator><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_cfp_forwarded_bh_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator> <name><name>cfp</name><operator>-&gt;</operator><name>block_code</name></name><operator>)</operator> <operator>==</operator> <name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>enum</name> <name>rb_block_type</name></name></type>

<name>vm_block_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<switch>switch <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_ifunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_block_type_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>rb_block_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>mb</name> <init>= <expr><operator>(</operator>struct <name>rb_block</name> <operator>*</operator><operator>)</operator><name>block</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type>

<name>vm_proc_block</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>rb_proc_t</name> <operator>*</operator><operator>)</operator><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>block</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>vm_block_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>vm_block_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>vm_proc_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_block_iseq</name><argument_list>(<argument><expr><call><name>vm_proc_block</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>vm_proc_ep</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><call><name>vm_proc_block</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>vm_block_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case> <return>return <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case> <return>return <expr><call><name>vm_proc_iseq</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<case>case <expr><name>block_type_symbol</name></expr>:</case> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_block_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>vm_block_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<case>case <expr><name>block_type_ifunc</name></expr>:</case> <return>return <expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case> <return>return <expr><call><name>vm_proc_ep</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_symbol</name></expr>:</case> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_block_ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_block_self</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<return>return <expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<return>return <expr><call><name>vm_block_self</name><argument_list>(<argument><expr><call><name>vm_proc_block</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_block_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_TO_SYMBOL</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_FROM_SYMBOL</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>symbol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>symbol</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_TO_PROC</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_BH_FROM_PROC</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>VALUE</name></type> <name>rb_thread_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_binding_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_proc_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_proc_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_vmdebug_stack_dump_raw</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_vmdebug_debug_print_pre</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>_pc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_vmdebug_debug_print_post</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

, <parameter><decl><type><name>VALUE</name></type> <name>reg_a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>reg_b</name></decl></parameter>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDR</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_vmdebug_stack_dump_raw(GET_EC(), GET_EC()-&gt;cfp)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDR2</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_vmdebug_stack_dump_raw(GET_EC(), (cfp))</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>rb_vm_bugreport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>RETSIGTYPE</name></type> (<modifier>*</modifier><name>ruby_sighandler_t</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<macro><name>NORETURN</name><argument_list>(<argument>void rb_bug_for_fatal_signal(ruby_sighandler_t default_sighandler, int sig, const void *, const char *fmt, ...)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<name>VALUE</name></type> <name>rb_iseq_eval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseq_eval_main</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseq_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseq_realpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_END</name>

<name>VALUE</name></type> <name>rb_iseq_pathobj_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_iseq_pathobj_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_ec_frame_method_id_and_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>called_idp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klassp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_ec_setup_exception</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cause</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_invoke_proc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_make_proc_lambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>rb_vm_make_proc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_vm_make_proc_lambda</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>rb_vm_make_lambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_vm_make_proc_lambda</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_make_binding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>src_cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_env_local_variables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>rb_vm_env_prev_env</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>rb_binding_add_dynavars</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dyncount</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>dynvars</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_inc_const_missing_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_gvl_destroy</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_vm_call_kw</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MJIT_STATIC</name> <name>void</name></type> <name>rb_vm_pop_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_thread_start_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_thread_stop_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_thread_reset_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_thread_wakeup_timer_thread</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_vm_living_threads_init</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waiting_fds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waiting_pids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>workqueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waiting_grps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>living_threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>living_thread_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_vm_living_threads_insert</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>living_threads</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>vmlt_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>living_thread_num</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_vm_living_threads_remove</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>vmlt_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>living_thread_num</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> <name>rb_backtrace_iter_func</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>rb_vm_get_ruby_level_next_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>rb_vm_get_binding_creatable_next_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_vm_get_sourceline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_stack_to_heap</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ruby_thread_init_stack</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_vm_control_frame_id_and_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>called_idp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klassp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_rewind_cfp</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MJIT_STATIC</name> <name>VALUE</name></type> <name>rb_vm_bh_to_procval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_register_special_exception_str</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>ruby_special_exceptions</name></name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exception_class</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_vm_register_special_exception</name><parameter_list>(<parameter><type><name>sp</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_vm_register_special_exception_str(sp, e, rb_usascii_str_new_static((m), (long)rb_strlen_lit(m)))</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>rb_gc_mark_machine_stack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_rewrite_cref</name><parameter_list>(<parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>old_klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>new_klass</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_cref_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MJIT_STATIC</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_vm_frame_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sysstack_error</name></cpp:macro> <cpp:value>GET_VM()-&gt;special_exceptions[ruby_error_sysstack]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_CONST_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1/!!(expr))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_STACK_OVERFLOWED_P</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>, <parameter><type><name>sp</name></type></parameter>, <parameter><type><name>margin</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!RUBY_CONST_ASSERT(sizeof(*(sp)) == sizeof(VALUE)) || !RUBY_CONST_ASSERT(sizeof(*(cfp)) == sizeof(rb_control_frame_t)) || ((rb_control_frame_t *)((sp) + (margin)) + 1) &gt;= (cfp))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHEN_VM_STACK_OVERFLOWED</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>, <parameter><type><name>sp</name></type></parameter>, <parameter><type><name>margin</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (LIKELY(!VM_STACK_OVERFLOWED_P(cfp, sp, margin))) {(void)0;} else</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_VM_STACK_OVERFLOW0</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>, <parameter><type><name>sp</name></type></parameter>, <parameter><type><name>margin</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WHEN_VM_STACK_OVERFLOWED(cfp, sp, margin) vm_stackoverflow()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_VM_STACK_OVERFLOW</name><parameter_list>(<parameter><type><name>cfp</name></type></parameter>, <parameter><type><name>margin</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WHEN_VM_STACK_OVERFLOWED(cfp, (cfp)-&gt;sp, margin) vm_stackoverflow()</cpp:value></cpp:define>

<function_decl><type><name>VALUE</name></type> <name>rb_catch_protect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>rb_block_call_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name> <modifier>*</modifier></type><name>stateptr</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_VM_THREAD_MODEL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<decl_stmt><decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<name>RUBY_EXTERN</name> <name>rb_vm_t</name> <modifier>*</modifier></type><name>ruby_current_vm_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ruby_current_execution_context_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_event_flag_t</name></type> <name>ruby_vm_event_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>rb_event_flag_t</name></type> <name>ruby_vm_event_enabled_global_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RUBY_EXTERN</name> <name>unsigned</name> <name>int</name></type> <name>ruby_vm_event_local_num</name></decl>;</decl_stmt>

<function><type><name>RUBY_SYMBOL_EXPORT_END</name>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_VM</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_current_vm()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_THREAD</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_current_thread()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_EC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_current_execution_context()</cpp:value></cpp:define>

<specifier>static</specifier> <specifier>inline</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type>

<name>rb_ec_thread_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>ec</name><operator>-&gt;</operator><name>thread_ptr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_vm_t</name> <modifier>*</modifier></type>

<name>rb_ec_vm_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>th</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type>

<name>rb_current_execution_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>ruby_current_execution_context_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type>

<name>rb_current_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_vm_t</name> <modifier>*</modifier></type>

<name>rb_current_vm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>ruby_current_vm_ptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>

<name>ruby_current_execution_context_ptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>

<call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>

<call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>ruby_current_vm_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ruby_current_vm_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_thread_set_current_raw</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_current_execution_context_ptr</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_thread_set_current</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>running_thread</name></name> <operator>!=</operator> <name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>running_time_us</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_thread_set_current_raw</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>running_thread</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"unsupported thread model"</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <block>{

<decl><name>TIMER_INTERRUPT_MASK</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,

<decl><name>PENDING_INTERRUPT_MASK</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,

<decl><name>POSTPONED_JOB_INTERRUPT_MASK</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,

<decl><name>TRAP_INTERRUPT_MASK</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_SET_TIMER_INTERRUPT</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ATOMIC_OR((ec)-&gt;interrupt_flag, TIMER_INTERRUPT_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_SET_INTERRUPT</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ATOMIC_OR((ec)-&gt;interrupt_flag, PENDING_INTERRUPT_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_SET_POSTPONED_JOB_INTERRUPT</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ATOMIC_OR((ec)-&gt;interrupt_flag, POSTPONED_JOB_INTERRUPT_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_SET_TRAP_INTERRUPT</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ATOMIC_OR((ec)-&gt;interrupt_flag, TRAP_INTERRUPT_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_INTERRUPTED</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ec)-&gt;interrupt_flag &amp; ~(ec)-&gt;interrupt_mask &amp; (PENDING_INTERRUPT_MASK|TRAP_INTERRUPT_MASK))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_INTERRUPTED_ANY</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ec)-&gt;interrupt_flag &amp; ~(ec)-&gt;interrupt_mask)</cpp:value></cpp:define>

<function_decl><type><name>VALUE</name></type> <name>rb_exc_set_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>bt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_signal_buff_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_signal_exec</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_check_signal</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>mth</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_signal_raise</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_signal_exit</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_threadptr_execute_interrupts</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_interrupt</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_unlock_all_locking_mutexes</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_pending_interrupt_clear</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_pending_interrupt_enque</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_ec_get_errinfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_ec_error_print</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>ec</name></decl></parameter>, <parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>errinfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_execution_context_update</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_execution_context_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_fiber_close</name><parameter_list>(<parameter><decl><type><name>rb_fiber_t</name> <modifier>*</modifier></type><name>fib</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Init_native_thread</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_CHECK_INTS</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_vm_check_ints(ec)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_vm_check_ints</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>ec</name> <operator>==</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>RUBY_VM_INTERRUPTED_ANY</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_threadptr_execute_interrupts</name><argument_list>(<argument><expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>rb_trace_arg_struct</name> <block>{

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>event</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>called_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>klass_solved</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><name>void</name></type> <name>rb_hook_list_mark</name><parameter_list>(<parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>hooks</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_hook_list_free</name><parameter_list>(<parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>hooks</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_hook_list_connect_tracepoint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>target_line</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_hook_list_remove_tracepoint</name><parameter_list>(<parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_exec_event_hooks</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_trace_arg_struct</name></name> <modifier>*</modifier></type><name>trace_arg</name></decl></parameter>, <parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>hooks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pop_p</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_EVENT_HOOK_ORIG</name><parameter_list>(<parameter><type><name>ec_</name></type></parameter>, <parameter><type><name>hooks_</name></type></parameter>, <parameter><type><name>flag_</name></type></parameter>, <parameter><type><name>self_</name></type></parameter>, <parameter><type><name>id_</name></type></parameter>, <parameter><type><name>called_id_</name></type></parameter>, <parameter><type><name>klass_</name></type></parameter>, <parameter><type><name>data_</name></type></parameter>, <parameter><type><name>pop_p_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const rb_event_flag_t flag_arg_ = (flag_); rb_hook_list_t *hooks_arg_ = (hooks_); if (UNLIKELY((hooks_arg_)-&gt;events &amp; (flag_arg_))) { rb_exec_event_hook_orig(ec_, hooks_arg_, flag_arg_, self_, id_, called_id_, klass_, data_, pop_p_); } } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_exec_event_hook_orig</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>hooks</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>flag</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pop_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_trace_arg_struct</name></name></type> <name>trace_arg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>flag</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>event</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>cfp</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>self</name></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>called_id</name></name> <operator>=</operator> <name>called_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>klass</name></name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace_arg</name><operator>.</operator><name>klass_solved</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exec_event_hooks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trace_arg</name></expr></argument>, <argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>pop_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_hook_list_t</name> <modifier>*</modifier></type>

<name>rb_vm_global_hooks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>&amp;</operator><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>global_hooks</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_EVENT_HOOK</name><parameter_list>(<parameter><type><name>ec_</name></type></parameter>, <parameter><type><name>flag_</name></type></parameter>, <parameter><type><name>self_</name></type></parameter>, <parameter><type><name>id_</name></type></parameter>, <parameter><type><name>called_id_</name></type></parameter>, <parameter><type><name>klass_</name></type></parameter>, <parameter><type><name>data_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXEC_EVENT_HOOK_ORIG(ec_, rb_vm_global_hooks(ec_), flag_, self_, id_, called_id_, klass_, data_, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><parameter_list>(<parameter><type><name>ec_</name></type></parameter>, <parameter><type><name>flag_</name></type></parameter>, <parameter><type><name>self_</name></type></parameter>, <parameter><type><name>id_</name></type></parameter>, <parameter><type><name>called_id_</name></type></parameter>, <parameter><type><name>klass_</name></type></parameter>, <parameter><type><name>data_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXEC_EVENT_HOOK_ORIG(ec_, rb_vm_global_hooks(ec_), flag_, self_, id_, called_id_, klass_, data_, 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_exec_event_hook_script_compiled</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eval_script</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_SCRIPT_COMPILED</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>eval_script</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr> </then><else>:

<expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>eval_script</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>rb_vm_trap_exit</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<name>int</name></type> <name>rb_thread_check_trap_pending</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_EVENT_COVERAGE_LINE</name></cpp:macro> <cpp:value>0x010000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_EVENT_COVERAGE_BRANCH</name></cpp:macro> <cpp:value>0x020000</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_get_coverages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_set_coverages</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_clear_coverages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_reset_coverages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_postponed_job_flush</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>;</function_decl>

<expr><name>RUBY_SYMBOL_EXPORT_END</name></expr>

</unit>
