<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\ccan\list\list.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/str/str.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/container_of/container_of.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/check_type/check_type.h"</cpp:file></cpp:include>

<struct>struct <name>list_node</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>list_head</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>n</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_LOC</name></cpp:macro> <cpp:value>__FILE__ ":" stringify(__LINE__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_debug</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>loc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)loc, h)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_debug_node</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>loc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)loc, n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_HEAD_INIT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ { &amp;(name).n, &amp;(name).n } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_HEAD</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct list_head name = LIST_HEAD_INIT(name)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_head_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_node_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_add_after</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_add_after_(h, p, n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_add_after_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>list_debug</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_add</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_add_(h, n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_add_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_add_after_</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_add_before</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_add_before_(h, p, n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_add_before_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>list_debug</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_add_tail</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_add_tail_(h, n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_add_tail_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_add_before_</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_empty</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_empty_(h, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>list_empty_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>list_debug</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CCAN_LIST_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_empty_nodebug</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_empty(h)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>list_empty_nodebug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>list_empty_nocheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_del</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_del_(n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_del_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>list_debug_node</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CCAN_LIST_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_del_init</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_del_init_(n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_del_init_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_del_</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_node_init</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_del_from</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CCAN_LIST_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <name><name>i</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>!=</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_swap</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_swap_(o, n, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_swap_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>list_debug_node</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <operator>*</operator><name>o</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CCAN_LIST_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_entry</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>container_of(n, type, member)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_top</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_top_((h), list_off_(type, member)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>list_top_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>-</operator> <name>off</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_pop</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_pop_((h), list_off_(type, member)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>list_pop_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>n</name> <operator>-</operator> <name>off</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_tail</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_tail_((h), list_off_(type, member)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>list_tail_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>h</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>prev</name></name> <operator>-</operator> <name>off</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_off(h, i, list_off_var_(i, member))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_rev</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_rev_off(h, i, list_off_var_(i, member))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_rev_safe</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_rev_safe_off(h, i, nxt, list_off_var_(i, member))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_safe</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_safe_off(h, i, nxt, list_off_var_(i, member))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_next</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((list_typeof(i))list_entry_or_null(list_debug(h, __FILE__ ":" stringify(__LINE__)), (i)-&gt;member.next, list_off_var_((i), member)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_prev</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((list_typeof(i))list_entry_or_null(list_debug(h, __FILE__ ":" stringify(__LINE__)), (i)-&gt;member.prev, list_off_var_((i), member)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_append_list</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_append_list_(t, f, __FILE__ ":" stringify(__LINE__))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_append_list_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>from_tail</name> <init>= <expr><call><name>list_debug</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>n</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>to_tail</name> <init>= <expr><call><name>list_debug</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>n</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>from_tail</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>from_tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>to_tail</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_prepend_list</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_prepend_list_(t, f, LIST_LOC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_prepend_list_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abortstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>from_tail</name> <init>= <expr><call><name>list_debug</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>n</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>to_head</name> <init>= <expr><call><name>list_debug</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>abortstr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>n</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>from</name><operator>-&gt;</operator><name>n</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>from_tail</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>from_tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>to_head</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_off_dir_</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>off</name></type></parameter>, <parameter><type><name>dir</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (i = list_node_to_off_(list_debug(h, LIST_LOC)-&gt;n.dir, (off)); list_node_from_off_((void *)i, (off)) != &amp;(h)-&gt;n; i = list_node_to_off_(list_node_from_off_((void *)i, (off))-&gt;dir, (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_safe_off_dir_</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>, <parameter><type><name>off</name></type></parameter>, <parameter><type><name>dir</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (i = list_node_to_off_(list_debug(h, LIST_LOC)-&gt;n.dir, (off)), nxt = list_node_to_off_(list_node_from_off_(i, (off))-&gt;dir, (off)); list_node_from_off_(i, (off)) != &amp;(h)-&gt;n; i = nxt, nxt = list_node_to_off_(list_node_from_off_(i, (off))-&gt;dir, (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_off_dir_((h),(i),(off),next)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_rev_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_off_dir_((h),(i),(off),prev)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_safe_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_safe_off_dir_((h),(i),(nxt),(off),next)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_for_each_rev_safe_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_for_each_safe_off_dir_((h),(i),(nxt),(off),prev)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_entry_off</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_node_from_off_((n), (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_head_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_head_off((h), (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_tail_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)list_tail_((h), (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_add_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_add((h), list_node_from_off_((n), (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_del_off</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_del(list_node_from_off_((n), (off)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_del_from_off</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>list_del_from(h, list_node_from_off_((n), (off)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>list_node_to_off_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>node</name> <operator>-</operator> <name>off</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>list_node_from_off_</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator>struct <name>list_node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>+</operator> <name>off</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_off_</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(container_off(type, member) + check_type(((type *)0)-&gt;member, struct list_node))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_off_var_</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(container_off_var(var, member) + check_type(var-&gt;member, struct list_node))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_TYPEOF</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_typeof</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typeof(var)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_typeof</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void *</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>list_entry_or_null</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>n</name> <operator>-</operator> <name>off</name></expr>;</return>

</block_content>}</block></function>

</unit>
