<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\thread_pthread.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>THREAD_SYSTEM_DEPENDENT_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_RESOURCE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_THR_STKSEGMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;thread.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FCNTL_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_SYS_FCNTL_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/fcntl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PRCTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__HAIKU__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;kernel/OS.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_EVENTFD_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EVENTFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_EVENTFD</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/eventfd.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_EVENTFD</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_UBF_LIST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER_POSIX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER_PTHREAD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UBF_TIMER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMER_SETTIME</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMER_CREATE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_UBF_LIST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER</name></cpp:macro> <cpp:value>UBF_TIMER_POSIX</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UBF_LIST</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER</name></cpp:macro> <cpp:value>UBF_TIMER_PTHREAD</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER</name></cpp:macro> <cpp:value>UBF_TIMER_NONE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>rtimer_state</name> <block>{

<decl><name>RTIMER_DISARM</name></decl>,

<decl><name>RTIMER_ARMING</name></decl>,

<decl><name>RTIMER_ARMED</name></decl>,

<decl><name>RTIMER_DEAD</name></decl>

}</block>;</enum>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_POSIX</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>itimerspec</name></name></type> <name>zero</name></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>state</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>owner</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>timer_t</name></type> <name>timerid</name></decl>;</decl_stmt>

}</block> <decl><name>timer_posix</name> <init>= <expr><block>{

<expr><name>RTIMER_DEAD</name></expr>,

}</block></expr></init></decl>;</struct>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:elif>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>timer_pthread_fn</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name><name>low</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>armed</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>owner</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_t</name></type> <name>thid</name></decl>;</decl_stmt>

}</block> <decl><name>timer_pthread</name> <init>= <expr><block>{

<expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,

}</block></expr></init></decl>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_lock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>native_mutex_trylock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_cond_signal</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_cond_broadcast</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_cond_wait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_cond_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_cond_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_thread_cache_altstack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ubf_wakeup_all_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ubf_threads_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>native_cond_timedwait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>abs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>sigwait_timeout</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sigwait_fd</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>drained_p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ubf_timer_disarm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>threadptr_trap_interrupt</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMER_THREAD_CREATED_P</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(signal_self_pipe.owner_process == getpid())</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUSY_WAIT_SIGNALS</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THREAD_INVALID</name></cpp:macro> <cpp:value>((const rb_thread_t *)-1)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>sigwait_th</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SCHED_YIELD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_thread_yield</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(void)sched_yield()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_thread_yield</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_CONDATTR_SETCLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_GETTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_condattr_t</name></type> <name>condattr_mono</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_condattr_t</name> <modifier>*</modifier></type><name>condattr_monotonic</name> <init>= <expr><operator>&amp;</operator><name>condattr_mono</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>condattr_monotonic</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_QUANTUM_MSEC</name></cpp:macro> <cpp:value>(100)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_QUANTUM_USEC</name></cpp:macro> <cpp:value>(TIME_QUANTUM_MSEC * 1000)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_QUANTUM_NSEC</name></cpp:macro> <cpp:value>(TIME_QUANTUM_USEC * 1000)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>rb_hrtime_t</name></type> <name>native_cond_timeout</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>rb_hrtime_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>designate_timer_thread</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>waitq</name></name></expr></argument>, <argument><expr><name>native_thread_data_t</name></expr></argument>, <argument><expr><name><name>node</name><operator>.</operator><name>ubf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_gvl_timer</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_hrtime_t</name></type> <name>abs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_timer_disarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer_err</name></name> <operator>==</operator> <name>ETIMEDOUT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>abs</name> <operator>=</operator> <call><name>native_cond_timeout</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>, <argument><expr><name>TIME_QUANTUM_NSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer_err</name></name> <operator>=</operator> <call><name>native_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_wakeup_all_threads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_sigchld_handler</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>rb_signal_buff_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>th</name> <operator>==</operator> <name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_VM_SET_TRAP_INTERRUPT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>threadptr_trap_interrupt</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>timer_thread_function</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_acquire_common</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<literal type="string">"we must not be in ubf_list and GVL waitq at the same time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>waitq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>gvl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>do_gvl_timer</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block> while <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>list_del_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>gvl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>need_yield</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>need_yield</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer_err</name></name> <operator>=</operator> <name>ETIMEDOUT</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>designate_timer_thread</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ubf_threads_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_acquire</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gvl_acquire_common</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>native_thread_data_t</name> <modifier>*</modifier></type>

<name>gvl_release_common</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>list_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>waitq</name></name></expr></argument>, <argument><expr><name>native_thread_data_t</name></expr></argument>, <argument><expr><name><name>node</name><operator>.</operator><name>ubf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>next</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_release</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gvl_release_common</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_yield</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>native_thread_data_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ubf_wakeup_all_threads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>gvl_release_common</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>wait_yield</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>wait_yield</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_wait_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>next</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>need_yield</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>wait_yield</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>need_yield</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>wait_yield</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_thread_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gvl_acquire_common</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_init</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>waitq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer_err</name></name> <operator>=</operator> <name>ETIMEDOUT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>need_yield</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>wait_yield</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_destroy</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>switch_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>clear_thread_cache_altstack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>thread_cache_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_atfork</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>thread_cache_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gvl_init</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gvl_acquire</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_MUTEX_LOCK_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mutex_debug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>NATIVE_MUTEX_LOCK_DEBUG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>dbglock</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbglock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content><expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s: %p\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbglock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content><expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_lock</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mutex_debug</name><argument_list>(<argument><expr><literal type="string">"lock"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_mutex_lock"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mutex_debug</name><argument_list>(<argument><expr><literal type="string">"unlock"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_mutex_unlock"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>native_mutex_trylock</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mutex_debug</name><argument_list>(<argument><expr><literal type="string">"trylock"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>pthread_mutex_trylock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>EBUSY</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>EBUSY</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_mutex_trylock"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_initialize</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mutex_debug</name><argument_list>(<argument><expr><literal type="string">"init"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_mutex_init"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mutex_debug</name><argument_list>(<argument><expr><literal type="string">"destroy"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_mutex_destroy"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>condattr_monotonic</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_cond_init"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_cond_destroy"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_signal</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pthread_cond_signal</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_cond_signal"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_broadcast</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pthread_cond_broadcast</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"rb_native_cond_broadcast"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_wait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_cond_wait"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_cond_timedwait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>abs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><call><name>rb_hrtime2timespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>abs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>ETIMEDOUT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"pthread_cond_timedwait"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_hrtime_t</name></type>

<name>native_cond_timeout</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name></type> <name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>condattr_monotonic</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_hrtime_add</name><argument_list>(<argument><expr><call><name>rb_hrtime_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_timespec_now</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_hrtime_add</name><argument_list>(<argument><expr><call><name>rb_timespec2hrtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_cleanup_push</name></cpp:macro> <cpp:value>pthread_cleanup_push</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_cleanup_pop</name></cpp:macro> <cpp:value>pthread_cleanup_pop</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_key_t</name></type> <name>ruby_native_thread_key</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>null_func</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type>

<name>ruby_thread_from_native</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>pthread_getspecific</name><argument_list>(<argument><expr><name>ruby_native_thread_key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_thread_set_native</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>pthread_setspecific</name><argument_list>(<argument><expr><name>ruby_native_thread_key</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>native_thread_init</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>

<name>Init_native_thread</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_CONDATTR_SETCLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>condattr_monotonic</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>pthread_condattr_init</name><argument_list>(<argument><expr><name>condattr_monotonic</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pthread_condattr_setclock</name><argument_list>(<argument><expr><name>condattr_monotonic</name></expr></argument>, <argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>condattr_monotonic</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ruby_native_thread_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_thread_id_str</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_thread_init</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>posix_signal</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>, <argument><expr><name>null_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_init</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UBF_LIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>list_node_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>ubf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_thread_set_native</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_THREAD_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_THREAD_CACHE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_destroy</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>gvlq</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nd</name><operator>-&gt;</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>USE_THREAD_CACHE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ruby_thread_set_native</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>register_cached_thread_and_wait</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_PTHREAD_GETATTR_NP</name> <operator>||</operator> <name>defined</name> <name>HAVE_PTHREAD_ATTR_GET_NP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_PTHREAD_GET_STACKADDR_NP</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_PTHREAD_GET_STACKSIZE_NP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAINSTACKADDR_AVAILABLE</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAINSTACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>pthread_get_stackaddr_np</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>pthread_get_stacksize_np</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_THR_STKSEGMENT</name> <operator>||</operator> <name>defined</name> <name>HAVE_PTHREAD_STACKSEG_NP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_PTHREAD_GETTHRDS_NP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__HAIKU__</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAINSTACKADDR_AVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACKADDR_AVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAINSTACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAINSTACKADDR_AVAILABLE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAINSTACKADDR_AVAILABLE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>get_main_stack</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_main_stack</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>get_stack(addr, size)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACKADDR_AVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_stack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ERR</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{int err = (expr); if (err) return err;}</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_GETATTR_NP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>guard</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>STACK_GROW_DIR_DETECTION</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_getattr_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_ATTR_GETSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><operator>*</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>addr</name> <operator>+</operator> <operator>*</operator><name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstackaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstacksize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_ATTR_GETGUARDSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getguardsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>guard</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>-=</operator> <name>guard</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>-=</operator> <call><name>getpagesize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_PTHREAD_ATTR_GET_NP</name></expr></cpp:elif> 

<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_get_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_ATTR_GETSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstackaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_getstacksize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><operator>*</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>addr</name> <operator>+</operator> <operator>*</operator><name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>HAVE_PTHREAD_GET_STACKADDR_NP</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_PTHREAD_GET_STACKSIZE_NP</name><operator>)</operator></expr></cpp:elif> 

<decl_stmt><decl><type><name>pthread_t</name></type> <name>th</name> <init>= <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <call><name>pthread_get_stackaddr_np</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <call><name>pthread_get_stacksize_np</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_THR_STKSEGMENT</name> <operator>||</operator> <name>defined</name> <name>HAVE_PTHREAD_STACKSEG_NP</name></expr></cpp:elif>

<decl_stmt><decl><type><name>stack_t</name></type> <name>stk</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_THR_STKSEGMENT</name></expr></cpp:if> 

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>thr_stksegment</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_stackseg_np</name><argument_list>(<argument><expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>stk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <name><name>stk</name><operator>.</operator><name>ss_sp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>stk</name><operator>.</operator><name>ss_size</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_PTHREAD_GETTHRDS_NP</name></expr></cpp:elif> 

<decl_stmt><decl><type><name>pthread_t</name></type> <name>th</name> <init>= <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>__pthrdsinfo</name></name></type> <name>thinfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>reg</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regsiz</name><init>=<expr><sizeof>sizeof<argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_getthrds_np</name><argument_list>(<argument><expr><operator>&amp;</operator><name>th</name></expr></argument>, <argument><expr><name>PTHRDSINFO_QUERY_ALL</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>thinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>thinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><operator>&amp;</operator><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsiz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <name><name>thinfo</name><operator>.</operator><name>__pi_stackaddr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>thinfo</name><operator>.</operator><name>__pi_stackend</name></name> <operator>-</operator> <name><name>thinfo</name><operator>.</operator><name>__pi_stackaddr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><operator>*</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>addr</name> <operator>+</operator> <operator>*</operator><name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__HAIKU__</name></expr></cpp:elif>

<decl_stmt><decl><type><name>thread_info</name></type> <name>info</name></decl>;</decl_stmt>

<expr_stmt><expr><name>STACK_GROW_DIR_DETECTION</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>get_thread_info</name><argument_list>(<argument><expr><call><name>find_thread</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>stack_base</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>info</name><operator>.</operator><name>stack_end</name></name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>info</name><operator>.</operator><name>stack_base</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><operator>*</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>addr</name> <operator>+</operator> <operator>*</operator><name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> STACKADDR_AVAILABLE is defined but not implemented.</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_ERR</name></cpp:undef>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><name>rb_nativethread_id_t</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>stack_maxsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl>;</decl_stmt>

}</block> <decl><name>native_main_thread</name></decl>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACK_END_ADDRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>void</name> <modifier>*</modifier></type><name>STACK_END_ADDRESS</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <block>{

<decl><name>RUBY_STACK_SPACE_LIMIT</name> <init>= <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>, 

<decl><name>RUBY_STACK_SPACE_RATIO</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>

}</block>;</enum>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>space_size</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>stack_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>space_size</name> <init>= <expr><name>stack_size</name> <operator>/</operator> <name>RUBY_STACK_SPACE_RATIO</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>space_size</name> <operator>&gt;</operator> <name>RUBY_STACK_SPACE_LIMIT</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>RUBY_STACK_SPACE_LIMIT</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>space_size</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><specifier>static</specifier> <macro><name>__attribute__</name><argument_list>(<argument>(noinline)</argument>)</argument_list></macro> <name>void</name>

<macro><name>reserve_stack</name><argument_list>(<argument>volatile char *limit</argument>, <argument>size_t size</argument>)</argument_list></macro>

<block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>C_ALLOCA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> needs alloca()</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

struct <expr><name>rlimit</name> <name>rl</name></expr>;

<expr><specifier>volatile</specifier> <name>char</name> <name><name>buf</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></expr>;

enum <expr><block>{<expr><name>stack_check_margin</name> <operator>=</operator> <literal type="number">0x1000</literal></expr>}</block></expr>; 

<expr><name>STACK_GROW_DIR_DETECTION</name></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rl</name><operator>.</operator><name>rlim_cur</name></name> <operator>==</operator> <name>RLIM_INFINITY</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>stack_check_margin</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>stack_check_margin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>IS_STACK_DIR_UPPER</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <specifier>volatile</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>limit</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name>limit</name> <operator>-</operator> <name>end</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>limit</name><index>[<expr><name>sz</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>limit</name> <operator>-=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name>buf</name> <operator>-</operator> <name>limit</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>limit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>reserve_stack</name><parameter_list>(<parameter><type><name>limit</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)(limit), (void)(size))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_init_stack</name></cpp:undef>

void

<macro><name>ruby_init_stack</name><argument_list>(<argument>volatile VALUE *addr</argument>)</argument_list></macro>

<block>{<block_content>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAINSTACKADDR_AVAILABLE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>stackaddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_main_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stackaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <name>stackaddr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reserve_stack</name><argument_list>(<argument><expr><name>stackaddr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>bound_check</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACK_END_ADDRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <name>STACK_END_ADDRESS</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>||</operator>

<call><name>STACK_UPPER</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>,

<argument><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>&gt;</operator> <name>addr</name></expr></argument>,

<argument><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>&lt;</operator> <name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTHREAD_STACK_DEFAULT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PTHREAD_STACK_DEFAULT</name> <operator>&lt;</operator> <name>RUBY_STACK_SPACE</name><operator>*</operator><literal type="number">5</literal></expr></cpp:if>

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"PTHREAD_STACK_DEFAULT is too small"</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>PTHREAD_STACK_DEFAULT</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>RUBY_VM_THREAD_VM_STACK_SIZE</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>size_t</name></type> <name>space</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pagesize</name> <init>= <expr><call><name>getpagesize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>

<expr_stmt><expr><name>STACK_GROW_DIR_DETECTION</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_STACK_DIR_UPPER</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>space</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>addr</name> <operator>+</operator> <name>size</name><operator>)</operator> <operator>/</operator> <name>pagesize</name><operator>)</operator> <operator>*</operator> <name>pagesize</name> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>addr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>space</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>addr</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>addr</name> <operator>-</operator> <name>size</name><operator>)</operator> <operator>/</operator> <name>pagesize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>pagesize</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name>space</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAINSTACKADDR_AVAILABLE</name></expr></cpp:if>

<label><name>bound_check</name>:</label>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>STACK_GROW_DIR_DETECTION</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_STACK_DIR_UPPER</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>+</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>-</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>addr</name> <argument_list type="generic">&lt; <argument><expr><name>start</name> <operator>||</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></argument> &gt;</argument_list></name> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ERR</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{int err = (expr); if (err) {rb_bug_errno(#expr, err);}}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_thread_init_stack</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_nativethread_id_t</name></type> <name>curr</name> <init>= <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_equal</name><argument_list>(<argument><expr><name>curr</name></expr></argument>, <argument><expr><name><name>native_main_thread</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name><name>native_main_thread</name><operator>.</operator><name>stack_maxsize</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACKADDR_AVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>diff</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>start</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>curr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>curr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>diff</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>, <argument><expr><literal type="string">"ruby engine can initialize only in the main thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NATIVE_THREAD_INIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>thread_start_func_1</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>th_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>th_ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_ALTSTACK_INIT</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>altstack</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>altstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<label><name>thread_start</name>:</label>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>USE_NATIVE_THREAD_INIT</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>stack_start</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>fill_thread_id_str</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>USE_NATIVE_THREAD_INIT</name></expr></cpp:if>

<expr_stmt><expr><call><name>native_thread_init_stack</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>native_thread_init</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>USE_NATIVE_THREAD_INIT</name></expr></cpp:if>

<expr_stmt><expr><call><name>thread_start_func_2</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>thread_start_func_2</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>th</name> <operator>=</operator> <call><name>register_cached_thread_and_wait</name><argument_list>(<argument><expr><call><name>RB_ALTSTACK</name><argument_list>(<argument><expr><name>altstack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>thread_start</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>RB_ALTSTACK_FREE</name><argument_list>(<argument><expr><name>altstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>cached_thread_entry</name> <block>{

<decl_stmt><decl><type><name>rb_nativethread_cond_t</name></type> <name>cond</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_nativethread_id_t</name></type> <name>thread_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>altstack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>node</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_lock_t</name></type> <name>thread_cache_lock</name> <init>= <expr><name>RB_NATIVETHREAD_LOCK_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><specifier>static</specifier> <call><name>LIST_HEAD</name><argument_list>(<argument><expr><name>cached_thread_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>thread_cache_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_thread_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>THREAD_CACHE_TIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THREAD_CACHE_TIME</name></cpp:macro> <cpp:value>((rb_hrtime_t)3 * RB_HRTIME_PER_SEC)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type>

<name>register_cached_thread_and_wait</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>altstack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_hrtime_t</name></type> <name>end</name> <init>= <expr><name>THREAD_CACHE_TIME</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cached_thread_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_native_cond_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>altstack</name></name> <operator>=</operator> <name>altstack</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>th</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>thread_id</name></name> <operator>=</operator> <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>native_cond_timeout</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>cond</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>list_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_thread_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>th</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>.</operator><name>th</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_ALTSTACK_FREE</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>altstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>entry</name><operator>.</operator><name>th</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>thread_cache_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>use_cached_thread</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>cached_thread_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>list_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_thread_head</name></expr></argument>, <argument><expr>struct <name>cached_thread_entry</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>th</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>thread_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_thread_id_str</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><operator>!</operator><name>entry</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>clear_thread_cache_altstack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_THREAD_CACHE</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>cached_thread_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;cached_thread_head</argument>, <argument>entry</argument>, <argument>node</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>void</name></type> <name>MAYBE_UNUSED</name><argument_list>(<argument><expr><operator>*</operator><name>altstack</name></expr></argument>)</argument_list> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>altstack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>altstack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_ALTSTACK_FREE</name><argument_list>(<argument><expr><name>altstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread_cache_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_thread_create</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>use_cached_thread</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"create (use cached thread): %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>stack_size</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_machine_stack_size</name></name> <operator>+</operator> <name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_vm_stack_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>space</name> <init>= <expr><call><name>space_size</name><argument_list>(<argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>altstack</name></name> <operator>=</operator> <call><name>rb_allocate_sigaltstack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name>stack_size</name> <operator>-</operator> <name>space</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTHREAD_STACK_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"create - stack size: %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_setstacksize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_ATTR_SETINHERITSCHED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_setinheritsched</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_INHERIT_SCHED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_DETACHED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>thread_start_func_1</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"create: %p (%d)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>th</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_thread_id_str</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>err</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NATIVE_THREAD_PRIORITY</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_apply_priority</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_PRIORITY_SCHEDULING</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_POSIX_PRIORITY_SCHEDULING</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>sched_param</name></name></type> <name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>policy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>priority</name> <init>= <expr><literal type="number">0</literal> <operator>-</operator> <name><name>th</name><operator>-&gt;</operator><name>priority</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pthread_getschedparam</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>policy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>sched_get_priority_max</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>sched_get_priority_min</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>priority</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>priority</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name>priority</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>priority</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sp</name><operator>.</operator><name>sched_priority</name></name> <operator>=</operator> <name>priority</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_setschedparam</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><name>policy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_fd_select</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>readfds</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>writefds</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>exceptfds</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_fd_select</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>, <argument><expr><name>writefds</name></expr></argument>, <argument><expr><name>exceptfds</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_pthread_cond_signal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><operator>(</operator><name>rb_thread_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"ubf_pthread_cond_signal (%p)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_cond_sleep</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>cond</name><operator>.</operator><name>intr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name></type> <name>max</name> <init>= <expr><operator>(</operator><name>rb_hrtime_t</name><operator>)</operator><literal type="number">100000000</literal> <operator>*</operator> <name>RB_HRTIME_PER_SEC</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_BEGIN</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ubf_pthread_cond_signal</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_sleep: interrupted before sleep\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_cond_wait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_hrtime_t</name></type> <name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rel</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rel</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>native_cond_timeout</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><operator>*</operator><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_cond_timedwait</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>GVL_UNLOCK_END</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_sleep done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UBF_LIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><specifier>static</specifier> <call><name>LIST_HEAD</name><argument_list>(<argument><expr><name>ubf_list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_nativethread_lock_t</name></type> <name>ubf_list_lock</name> <init>= <expr><name>RB_NATIVETHREAD_LOCK_INIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_list_atfork</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>register_ubf_list</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>node</name><operator>.</operator><name>ubf</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>(</operator>struct <name>list_head</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_head</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unregister_ubf_list</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>node</name><operator>.</operator><name>ubf</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><operator>(</operator>struct <name>list_head</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_del_init</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_head</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_signal_buff_size</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ubf_timer_disarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_wakeup_thread</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"thread_wait_queue_wakeup (%"</literal><name>PRI_THREAD_ID</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><call><name>thread_id_str</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_select</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><operator>(</operator><name>rb_thread_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><call><name>ruby_thread_from_native</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>register_ubf_list</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>!=</operator> <name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name> <operator>&amp;&amp;</operator> <name>cur</name> <operator>!=</operator> <name>sigwait_th</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>native_mutex_trylock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>timer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ubf_wakeup_thread</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ubf_threads_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_head</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_wakeup_all_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>native_thread_data_t</name> <modifier>*</modifier></type><name>dat</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ubf_threads_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;ubf_list_head</argument>, <argument>dat</argument>, <argument>node.ubf</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>th</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>dat</name></expr></argument>, <argument><expr><name>rb_thread_t</name></expr></argument>, <argument><expr><name>native_thread_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_wakeup_thread</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ubf_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>register_ubf_list</name><parameter_list>(<parameter><type><name>th</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(th)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unregister_ubf_list</name><parameter_list>(<parameter><type><name>th</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(th)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_select</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ubf_wakeup_all_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ubf_threads_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_list_atfork</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CONST</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(write((fd),(str),sizeof(str)-1)&lt;0)</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name><name>normal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name><name>ub_main</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>volatile</specifier> <name>rb_pid_t</name></type> <name>owner_process</name></decl>;</decl_stmt>

}</block> <decl><name>signal_self_pipe</name> <init>= <expr><block>{

<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>,

}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_thread_wakeup_timer_thread_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EVENTFD</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>buff</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>buff</name> <init>= <expr><literal type="char">'!'</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<label><name>retry</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EINTR</name></expr>:</case> <goto>goto <name>retry</name>;</goto>

<case>case <expr><name>EAGAIN</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>async_bug_fd</name><argument_list>(<argument><expr><literal type="string">"rb_thread_wakeup_timer_thread: write"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>TT_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>WRITE_CONST</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"rb_thread_wakeup_timer_thread: write\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_arm</name><parameter_list>(<parameter><decl><type><name>rb_pid_t</name></type> <name>current</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_POSIX</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>current</name> <operator>||</operator> <name><name>timer_posix</name><operator>.</operator><name>owner</name></name> <operator>==</operator> <name>current</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_DISARM</name></expr></argument>, <argument><expr><name>RTIMER_ARMING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>itimerspec</name></name></type> <name>it</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>it</name><operator>.</operator><name>it_interval</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>it</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>it</name><operator>.</operator><name>it_interval</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>it</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name>TIME_QUANTUM_NSEC</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>timer_settime</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_async_bug_errno</name><argument_list>(<argument><expr><literal type="string">"timer_settime (arm)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_ARMING</name></expr></argument>, <argument><expr><name>RTIMER_ARMED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>RTIMER_DISARM</name></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>timer_settime</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>RTIMER_ARMING</name></expr>:</case> <return>return;</return> 

<case>case <expr><name>RTIMER_ARMED</name></expr>:</case>

<return>return;</return>

<case>case <expr><name>RTIMER_DEAD</name></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>timer_settime</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_async_bug_errno</name><argument_list>(<argument><expr><literal type="string">"UBF_TIMER_POSIX unknown state"</literal></expr></argument>, <argument><expr><name>ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:elif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current</name> <operator>||</operator> <name>current</name> <operator>==</operator> <name><name>timer_pthread</name><operator>.</operator><name>owner</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>armed</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread_fd</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>low</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_thread_wakeup_timer_thread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>current</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread_fd</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ubf_timer_arm</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>signal_self_pipe</name><operator>.</operator><name>owner_process</name></name> <operator>==</operator> <name>current</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread_fd</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>system_working</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>mth</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vm</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mth</name> <operator>=</operator> <name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mth</name> <operator>||</operator> <name>system_working</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>ACCESS_ONCE</name><argument_list>(<argument><expr><name>rb_execution_context_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>mth</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_VM_SET_TRAP_INTERRUPT</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_timer_arm</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>ubf_async_safe</name></name> <operator>&amp;&amp;</operator> <name><name>mth</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name><name>mth</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name><operator>)</operator><operator>(</operator><name><name>mth</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>arg</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSE_INVALIDATE_PAIR</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>close_invalidate_pair(expr,"close_invalidate: "#expr)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>close_invalidate</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fdp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>*</operator><name>fdp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>fdp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>async_bug_fd</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>close_invalidate_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>USE_EVENTFD</name> <operator>&amp;&amp;</operator> <name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close_invalidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>close_invalidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_invalidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_nonblock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>oflags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>oflags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oflags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_NONBLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>oflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>setup_communication_pipe_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>pipes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EVENTFD</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EFD_NONBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>eventfd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EFD_NONBLOCK</name><operator>|</operator><name>EFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>rb_cloexec_pipe</name><argument_list>(<argument><expr><name>pipes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"pipe creation failed for timer: %s, scheduling broken"</literal></expr></argument>,

<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_nonblock</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_nonblock</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SET_CURRENT_THREAD_NAME</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PR_SET_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CURRENT_THREAD_NAME</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>prctl(PR_SET_NAME, name)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>threadptr_invoke_proc_location</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_set_thread_name</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SET_CURRENT_THREAD_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>loc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>loc</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SET_CURRENT_THREAD_NAME</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>loc</name> <operator>=</operator> <call><name>threadptr_invoke_proc_location</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s:%d"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SET_CURRENT_THREAD_NAME</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>native_set_another_thread_name</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_id_t</name></type> <name>thread_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SET_ANOTHER_THREAD_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SET_ANOTHER_THREAD_NAME</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_invalidate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:if>

<expr_stmt><expr><call><name>CLOSE_INVALIDATE_PAIR</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_pthread_create</name><parameter_list>(<parameter><decl><type><name>rb_pid_t</name></type> <name>current</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>timer_pthread</name><operator>.</operator><name>owner</name></name> <operator>==</operator> <name>current</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>setup_communication_pipe_internal</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>low</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timer_pthread</name><operator>.</operator><name>thid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>timer_pthread_fn</name></expr></argument>, <argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>timer_pthread</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"pthread_create failed for timer: %s, signals racy"</literal></expr></argument>,

<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_create</name><parameter_list>(<parameter><decl><type><name>rb_pid_t</name></type> <name>current</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_POSIX</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER_CLOCK</name></cpp:macro> <cpp:value>CLOCK_REALTIME</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UBF_TIMER_CLOCK</name></cpp:macro> <cpp:value>CLOCK_MONOTONIC</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>sigevent</name></name></type> <name>sev</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sev</name><operator>.</operator><name>sigev_notify</name></name> <operator>=</operator> <name>SIGEV_SIGNAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sev</name><operator>.</operator><name>sigev_signo</name></name> <operator>=</operator> <name>SIGVTALRM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sev</name><operator>.</operator><name>sigev_value</name><operator>.</operator><name>sival_ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name>timer_posix</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>timer_create</name><argument_list>(<argument><expr><name>UBF_TIMER_CLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>prev</name> <init>= <expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_DISARM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>RTIMER_DEAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"timer_posix was not dead: %u\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>timer_posix</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"timer_create failed: %s, signals racy"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ubf_timer_pthread_create</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_thread_create_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>current</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>owner</name> <init>= <expr><name><name>signal_self_pipe</name><operator>.</operator><name>owner_process</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>&amp;&amp;</operator> <name>owner</name> <operator>!=</operator> <name>current</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CLOSE_INVALIDATE_PAIR</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLOSE_INVALIDATE_PAIR</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_timer_invalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>setup_communication_pipe_internal</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>setup_communication_pipe_internal</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ubf_timer_create</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>!=</operator> <name>current</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sigwait_th</name> <operator>=</operator> <name>THREAD_INVALID</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>signal_self_pipe</name><operator>.</operator><name>owner_process</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_disarm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_POSIX</name></expr></cpp:if>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>prev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_ARMED</name></expr></argument>, <argument><expr><name>RTIMER_DISARM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>prev</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>RTIMER_DISARM</name></expr>:</case> <return>return;</return> 

<case>case <expr><name>RTIMER_ARMING</name></expr>:</case> <return>return;</return> 

<case>case <expr><name>RTIMER_ARMED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>timer_settime</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_DISARM</name></expr></argument>, <argument><expr><name>RTIMER_DISARM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>RTIMER_DEAD</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"timer_settime (disarm)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return;</return>

<case>case <expr><name>RTIMER_DEAD</name></expr>:</case> <return>return;</return> 

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"UBF_TIMER_POSIX bad state: %u\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:elif>

<expr_stmt><expr><call><name>ATOMIC_SET</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>armed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_timer_destroy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_POSIX</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>timer_posix</name><operator>.</operator><name>owner</name></name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>expect</name> <init>= <expr><name>RTIMER_DISARM</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">10000000</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>expect</name></expr></argument>, <argument><expr><name>RTIMER_DEAD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>RTIMER_DISARM</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>expect</name> <operator>==</operator> <name>RTIMER_DISARM</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>expect</name> <operator>=</operator> <name>RTIMER_DISARM</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>RTIMER_ARMING</name></expr>:</case>

<expr_stmt><expr><call><name>native_thread_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>expect</name> <operator>=</operator> <name>RTIMER_ARMED</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>RTIMER_ARMED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>expect</name> <operator>==</operator> <name>RTIMER_ARMED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>timer_settime</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><literal type="string">"timer_settime (destroy)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>expect</name> <operator>=</operator> <name>RTIMER_ARMED</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>RTIMER_DEAD</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"RTIMER_DEAD unexpected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"timed out waiting for timer to arm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>timer_delete</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>timerid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="string">"timer_delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name><name>timer_posix</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>RTIMER_DEAD</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RTIMER_DEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:elif>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>timer_pthread</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_timer_disarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread_fd</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>low</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_join</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>thid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eThreadError</name></expr></argument>, <argument><expr><literal type="string">"native_thread_join() failed (%d)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_stop_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stopped</name></decl>;</decl_stmt>

<expr_stmt><expr><name>stopped</name> <operator>=</operator> <operator>--</operator><name>system_working</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>stopped</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ubf_timer_destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>TT_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"stop timer thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>stopped</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_reset_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>TT_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"reset timer thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>

<name>ruby_stack_overflowed_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>water_mark</name> <init>= <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>STACK_GROW_DIR_DETECTION</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STACKADDR_AVAILABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>get_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>pthread_equal</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><name><name>native_main_thread</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>base</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>base</name> <operator>+</operator> <call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><operator>+</operator><name>size</name></expr></argument>, <argument><expr><operator>-</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_maxsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name> <operator>-</operator> <call><name>STACK_DIR_UPPER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>size</name> <operator>/=</operator> <name>RUBY_STACK_SPACE_RATIO</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>water_mark</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>=</operator> <name>water_mark</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_STACK_DIR_UPPER</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>base</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;</operator> <name>base</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>base</name> <operator>+</operator> <name>size</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>base</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>base</name> <operator>-</operator> <name>size</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;=</operator> <name>base</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_reserved_fd_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name><name>timer_pthread</name><operator>.</operator><name>low</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name>fd</name> <operator>==</operator> <name><name>timer_pthread</name><operator>.</operator><name>low</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>check_pid</name>;</goto></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name>fd</name> <operator>==</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>check_pid</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name>fd</name> <operator>==</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>check_pid</name>;</goto></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>check_pid</name>:</label>

<if_stmt><if>if <condition>(<expr><name><name>signal_self_pipe</name><operator>.</operator><name>owner_process</name></name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_nativethread_id_t</name></type>

<name>rb_nativethread_self</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_MJIT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>mjit_worker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>worker_func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>void</name><operator>)</operator></call><operator>)</operator><name>arg</name></expr></init>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SET_CURRENT_THREAD_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>SET_CURRENT_THREAD_NAME</name><argument_list>(<argument><expr><literal type="string">"ruby-mjitworker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>worker_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_thread_create_mjit_thread</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>worker_func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_t</name></type> <name>worker_pid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_DETACHED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>mjit_worker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>worker_func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_sigwait_fd_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>owner_process</name></name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ubf_timer_disarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_PTR_CAS</name><argument_list>(<argument><expr><name>sigwait_th</name></expr></argument>, <argument><expr><name>THREAD_INVALID</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>THREAD_INVALID</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_sigwait_fd_put</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>old</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>ATOMIC_PTR_EXCHANGE</name><argument_list>(<argument><expr><name>sigwait_th</name></expr></argument>, <argument><expr><name>THREAD_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old</name> <operator>!=</operator> <name>th</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old</name> <operator>==</operator> <name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_ppoll</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name>nfds_t</name></type> <name>nfds</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>ts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sigset_t</name> <modifier>*</modifier></type><name>sigmask</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>timeout_ms</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ts</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>tmp2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&gt;</operator> <name>INT_MAX</name><operator>/</operator><literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>ts</name><operator>-&gt;</operator><name>tv_nsec</name></name> <operator>+</operator> <literal type="number">999999L</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1000L</literal> <operator>*</operator> <literal type="number">1000L</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>INT_MAX</name> <operator>-</operator> <name>tmp</name> <operator>&lt;</operator> <name>tmp2</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tmp</name> <operator>+</operator> <name>tmp2</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><call><name>poll</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ppoll</name><parameter_list>(<parameter><type><name>fds</name></type></parameter>,<parameter><type><name>nfds</name></type></parameter>,<parameter><type><name>ts</name></type></parameter>,<parameter><type><name>sigmask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ruby_ppoll((fds),(nfds),(ts),(sigmask))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_sigwait_sleep</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sigwait_fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>sigwait_fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BUSY_WAIT_SIGNALS</name> <operator>&amp;&amp;</operator> <call><name>ubf_threads_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ppoll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>rb_hrtime2timespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_signals_nogvl</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_hrtime_t</name></type> <name>to</name> <init>= <expr><name>RB_HRTIME_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <operator>*</operator><name>rel</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>rb_hrtime_add</name><argument_list>(<argument><expr><call><name>rb_hrtime_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>sto</name> <init>= <expr><call><name>sigwait_timeout</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ppoll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>rb_hrtime2timespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>sto</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_signals_nogvl</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>||</operator> <operator>(</operator><name>th</name> <operator>&amp;&amp;</operator> <call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&amp;&amp;</operator> <call><name>hrtime_update_expire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>to</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_ppoll_sleep</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ignore</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread_fd</name><argument_list>(<argument><expr><name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GVL_UNLOCK_BEGIN_YIELD</name><parameter_list>(<parameter><type><name>th</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const native_thread_data_t *next; rb_vm_t *vm = th-&gt;vm; RB_GC_SAVE_MACHINE_CONTEXT(th); rb_native_mutex_lock(&amp;vm-&gt;gvl.lock); next = gvl_release_common(vm); rb_native_mutex_unlock(&amp;vm-&gt;gvl.lock); if (!next &amp;&amp; vm_living_thread_num(vm) &gt; 1) { native_thread_yield(); }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_ppoll_sleep</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ubf_ppoll_sleep</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_BEGIN_YIELD</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name><name>pfd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pfd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>normal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>pfd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>signal_self_pipe</name><operator>.</operator><name>ub_main</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name><name>pfd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ppoll</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_hrtime2timespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pfd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>consume_communication_pipe</name><argument_list>(<argument><expr><name><name>pfd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>unblock_function_clear</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_END</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_sleep</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sigwait_fd</name> <init>= <expr><call><name>rb_sigwait_fd_get</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sigwait_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ubf_sigwait</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_BEGIN_YIELD</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sigwait_sleep</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>check_signals_nogvl</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>unblock_function_clear</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_END</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_sigwait_fd_put</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sigwait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_sigwait_fd_migrate</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>th</name> <operator>==</operator> <name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>native_ppoll_sleep</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>native_cond_sleep</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UBF_TIMER</name> <operator>==</operator> <name>UBF_TIMER_PTHREAD</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>timer_pthread_fn</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pthread_t</name></type> <name>main_thread_id</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name><operator>-&gt;</operator><name>thread_id</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ccp</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>timer_pthread</name><operator>.</operator><name>low</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>system_working</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ccp</name> <operator>=</operator> <call><name>consume_communication_pipe</name><argument_list>(<argument><expr><name><name>pfd</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>system_working</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>armed</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name>main_thread_id</name></expr></argument>, <argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_signal_buff_size</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ubf_threads_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>TIME_QUANTUM_MSEC</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ATOMIC_SET</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>armed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>timeout</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>ccp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr><name>main_thread_id</name></expr></argument>, <argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ATOMIC_SET</name><argument_list>(<argument><expr><name><name>timer_pthread</name><operator>.</operator><name>armed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>timeout</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ubf_caller</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ignore</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_sleep_forever</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_thread_start_unblock_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_thread_create</name><argument_list>(<argument><expr><name>ubf_caller</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
