<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\gc.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_data_object_alloc</name></cpp:macro> <cpp:value>rb_data_object_alloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_data_typed_object_alloc</name></cpp:macro> <cpp:value>rb_data_typed_object_alloc</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_USABLE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MALLOC_USABLE_SIZE</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_usable_size</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_msize(a)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_MALLOC_SIZE</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MALLOC_USABLE_SIZE</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_usable_size</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>malloc_size(a)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_USABLE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_ALTERNATIVE_MALLOC_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> RUBY_ALTERNATIVE_MALLOC_HEADER</cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_MALLOC_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_NP_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc_np.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_MALLOC_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc/malloc.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_RESOURCE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_umul128</name><name>)</name></cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"constant.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id_table.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/complex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/cont.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/imemo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/rational.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/struct.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/warnings.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regint.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/debug.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_atomic.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transient_heap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_callinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_setjmp</name><parameter_list>(<parameter><type><name>env</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUBY_SETJMP(env)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_jmp_buf</name></cpp:macro> <cpp:value>rb_jmpbuf_t</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_data_object_wrap</name></cpp:undef>

<struct>struct <name>optional</name> <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>left</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>right</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>optional</name></name></type>

<name>size_mul_overflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>z</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_MUL_OVERFLOW</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__builtin_mul_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DSIZE_T</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dy</name> <init>= <expr><name>y</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dz</name> <init>= <expr><name>dx</name> <operator>*</operator> <name>dy</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>dz</name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>dz</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><name>unsigned</name> <name>__int64</name></type> <name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>__int64</name></type> <name>dz</name> <init>= <expr><call><name>_umul128</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><name>dp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>dz</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>x</name> <operator>&gt;</operator> <name>SIZE_MAX</name> <operator>/</operator> <name>y</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <name>x</name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator>struct <name>optional</name><operator>)</operator> <block>{ <expr><name>p</name></expr>, <expr><name>z</name></expr>, }</block></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>optional</name></name></type>

<name>size_add_overflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>p</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_ADD_OVERFLOW</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__builtin_add_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DSIZE_T</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dy</name> <init>= <expr><name>y</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RB_GNUC_EXTENSION</name> <name>DSIZE_T</name></type> <name>dz</name> <init>= <expr><name>dx</name> <operator>+</operator> <name>dy</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>dz</name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>dz</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>z</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator>struct <name>optional</name><operator>)</operator> <block>{ <expr><name>p</name></expr>, <expr><name>z</name></expr>, }</block></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>optional</name></name></type>

<name>size_mul_add_overflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>t</name> <init>= <expr><call><name>size_mul_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>u</name> <init>= <expr><call><name>size_add_overflow</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator>struct <name>optional</name><operator>)</operator> <block>{ <expr><name><name>t</name><operator>.</operator><name>left</name></name> <operator>||</operator> <name><name>u</name><operator>.</operator><name>left</name></name></expr>, <expr><name><name>u</name><operator>.</operator><name>right</name></name></expr> }</block></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>optional</name></name></type>

<name>size_mul_add_mul_overflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>w</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>t</name> <init>= <expr><call><name>size_mul_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>u</name> <init>= <expr><call><name>size_mul_overflow</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>v</name> <init>= <expr><call><name>size_add_overflow</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator>struct <name>optional</name><operator>)</operator> <block>{ <expr><name><name>t</name><operator>.</operator><name>left</name></name> <operator>||</operator> <name><name>u</name><operator>.</operator><name>left</name></name> <operator>||</operator> <name><name>v</name><operator>.</operator><name>left</name></name></expr>, <expr><name><name>v</name><operator>.</operator><name>right</name></name></expr> }</block></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><call><name>PRINTF_ARGS</name><argument_list>(<argument><expr><macro><name>NORETURN</name><argument_list>(<argument>static void gc_raise(VALUE, const char*, ...)</argument>)</argument_list></macro></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>size_mul_or_raise</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>t</name> <init>= <expr><call><name>size_mul_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><name><name>t</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>t</name><operator>.</operator><name>right</name></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_during_gc</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_raise</name><argument_list>(

<argument><expr><name>exc</name></expr></argument>,

<argument><expr><literal type="string">"integer overflow: %"</literal><name>PRIuSIZE</name>

<literal type="string">" * %"</literal><name>PRIuSIZE</name>

<literal type="string">" &gt; %"</literal><name>PRIuSIZE</name></expr></argument>,

<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_size_mul_or_raise</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>size_mul_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>size_mul_add_or_raise</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>t</name> <init>= <expr><call><name>size_mul_add_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><name><name>t</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>t</name><operator>.</operator><name>right</name></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_during_gc</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_raise</name><argument_list>(

<argument><expr><name>exc</name></expr></argument>,

<argument><expr><literal type="string">"integer overflow: %"</literal><name>PRIuSIZE</name>

<literal type="string">" * %"</literal><name>PRIuSIZE</name>

<literal type="string">" + %"</literal><name>PRIuSIZE</name>

<literal type="string">" &gt; %"</literal><name>PRIuSIZE</name></expr></argument>,

<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_size_mul_add_or_raise</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>size_mul_add_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>size_mul_add_mul_or_raise</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>optional</name></name></type> <name>t</name> <init>= <expr><call><name>size_mul_add_mul_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><name><name>t</name><operator>.</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>t</name><operator>.</operator><name>right</name></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_during_gc</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_raise</name><argument_list>(

<argument><expr><name>exc</name></expr></argument>,

<argument><expr><literal type="string">"integer overflow: %"</literal><name>PRIdSIZE</name>

<literal type="string">" * %"</literal><name>PRIdSIZE</name>

<literal type="string">" + %"</literal><name>PRIdSIZE</name>

<literal type="string">" * %"</literal><name>PRIdSIZE</name>

<literal type="string">" &gt; %"</literal><name>PRIdSIZE</name></expr></argument>,

<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RB_GC_GUARDED_PTR_VAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_RB_GC_GUARDED_PTR_VAL</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>rb_gc_guarded_val</name></decl>;</decl_stmt>

<function><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>rb_gc_guarded_ptr_val</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_gc_guarded_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_INIT_SLOTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_INIT_SLOTS</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_FREE_SLOTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_FREE_SLOTS</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_GROWTH_FACTOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_GROWTH_FACTOR</name></cpp:macro> <cpp:value>1.8</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_GROWTH_MAX_SLOTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_GROWTH_MAX_SLOTS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_OLDOBJECT_LIMIT_FACTOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_OLDOBJECT_LIMIT_FACTOR</name></cpp:macro> <cpp:value>2.0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_FREE_SLOTS_MIN_RATIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_FREE_SLOTS_MIN_RATIO</name></cpp:macro> <cpp:value>0.20</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_FREE_SLOTS_GOAL_RATIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_FREE_SLOTS_GOAL_RATIO</name></cpp:macro> <cpp:value>0.40</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_HEAP_FREE_SLOTS_MAX_RATIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_HEAP_FREE_SLOTS_MAX_RATIO</name></cpp:macro> <cpp:value>0.65</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_MALLOC_LIMIT_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_MALLOC_LIMIT_MIN</name></cpp:macro> <cpp:value>(16 * 1024 * 1024 )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_MALLOC_LIMIT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_MALLOC_LIMIT_MAX</name></cpp:macro> <cpp:value>(32 * 1024 * 1024 )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_MALLOC_LIMIT_GROWTH_FACTOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_MALLOC_LIMIT_GROWTH_FACTOR</name></cpp:macro> <cpp:value>1.4</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_OLDMALLOC_LIMIT_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_OLDMALLOC_LIMIT_MIN</name></cpp:macro> <cpp:value>(16 * 1024 * 1024 )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_OLDMALLOC_LIMIT_GROWTH_FACTOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_OLDMALLOC_LIMIT_GROWTH_FACTOR</name></cpp:macro> <cpp:value>1.2</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_OLDMALLOC_LIMIT_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_OLDMALLOC_LIMIT_MAX</name></cpp:macro> <cpp:value>(128 * 1024 * 1024 )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PRINT_MEASURE_LINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_MEASURE_LINE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PRINT_ENTER_EXIT_TICK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_ENTER_EXIT_TICK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PRINT_ROOT_TICKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_ROOT_TICKS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_TICK_T</name></cpp:macro> <cpp:value>(PRINT_ENTER_EXIT_TICK || PRINT_MEASURE_LINE || PRINT_ROOT_TICKS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TICK_TYPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_init_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_free_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>growth_factor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>growth_max_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>heap_free_slots_min_ratio</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>heap_free_slots_goal_ratio</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>heap_free_slots_max_ratio</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>oldobject_limit_factor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>malloc_limit_min</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>malloc_limit_max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>malloc_limit_growth_factor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldmalloc_limit_min</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldmalloc_limit_max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>oldmalloc_limit_growth_factor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>gc_stress</name></decl>;</decl_stmt>

}</block></struct></type> <name>ruby_gc_params_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ruby_gc_params_t</name></type> <name>gc_params</name> <init>= <expr><block>{

<expr><name>GC_HEAP_INIT_SLOTS</name></expr>,

<expr><name>GC_HEAP_FREE_SLOTS</name></expr>,

<expr><name>GC_HEAP_GROWTH_FACTOR</name></expr>,

<expr><name>GC_HEAP_GROWTH_MAX_SLOTS</name></expr>,

<expr><name>GC_HEAP_FREE_SLOTS_MIN_RATIO</name></expr>,

<expr><name>GC_HEAP_FREE_SLOTS_GOAL_RATIO</name></expr>,

<expr><name>GC_HEAP_FREE_SLOTS_MAX_RATIO</name></expr>,

<expr><name>GC_HEAP_OLDOBJECT_LIMIT_FACTOR</name></expr>,

<expr><name>GC_MALLOC_LIMIT_MIN</name></expr>,

<expr><name>GC_MALLOC_LIMIT_MAX</name></expr>,

<expr><name>GC_MALLOC_LIMIT_GROWTH_FACTOR</name></expr>,

<expr><name>GC_OLDMALLOC_LIMIT_MIN</name></expr>,

<expr><name>GC_OLDMALLOC_LIMIT_MAX</name></expr>,

<expr><name>GC_OLDMALLOC_LIMIT_GROWTH_FACTOR</name></expr>,

<expr><name>FALSE</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_DEVEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_DEBUG</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_DEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_DEBUG_ENABLED</name><parameter_list>(<parameter><type><name>level</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(-(RGENGC_DEBUG) &gt;= (level) &amp;&amp; ruby_rgengc_debug &gt;= (level))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_DEBUG_ENABLED</name><parameter_list>(<parameter><type><name>level</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RGENGC_DEBUG) &gt;= (level))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>ruby_rgengc_debug</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_CHECK_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_CHECK_MODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUBY_ASSERT_MESG_WHEN(RGENGC_CHECK_MODE &gt; 0, expr, #expr)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_OLD_NEWOBJ_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_OLD_NEWOBJ_CHECK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_PROFILE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_ESTIMATE_OLDMALLOC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_FORCE_MAJOR_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_FORCE_MAJOR_GC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_PROFILE_MORE_DETAIL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_PROFILE_MORE_DETAIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_PROFILE_DETAIL_MEMORY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ENABLE_INCREMENTAL_MARK</name></cpp:macro> <cpp:value>USE_RINCGC</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_ENABLE_LAZY_SWEEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ENABLE_LAZY_SWEEP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALC_EXACT_MALLOC_SIZE</name></cpp:macro> <cpp:value>USE_GC_MALLOC_OBJ_INFO_DETAILS</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_USABLE_SIZE</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>CALC_EXACT_MALLOC_SIZE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_ALLOCATED_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALLOCATED_SIZE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALLOCATED_SIZE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MALLOC_ALLOCATED_SIZE_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALLOCATED_SIZE_CHECK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_DEBUG_STRESS_TO_CLASS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_OBJ_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RGENGC_OBJ_INFO</name></cpp:macro> <cpp:value>(RGENGC_DEBUG | RGENGC_CHECK_MODE)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <block>{

<decl><name>GPR_FLAG_NONE</name> <init>= <expr><literal type="number">0x000</literal></expr></init></decl>,

<decl><name>GPR_FLAG_MAJOR_BY_NOFREE</name> <init>= <expr><literal type="number">0x001</literal></expr></init></decl>,

<decl><name>GPR_FLAG_MAJOR_BY_OLDGEN</name> <init>= <expr><literal type="number">0x002</literal></expr></init></decl>,

<decl><name>GPR_FLAG_MAJOR_BY_SHADY</name> <init>= <expr><literal type="number">0x004</literal></expr></init></decl>,

<decl><name>GPR_FLAG_MAJOR_BY_FORCE</name> <init>= <expr><literal type="number">0x008</literal></expr></init></decl>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl><name>GPR_FLAG_MAJOR_BY_OLDMALLOC</name> <init>= <expr><literal type="number">0x020</literal></expr></init></decl>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl><name>GPR_FLAG_MAJOR_MASK</name> <init>= <expr><literal type="number">0x0ff</literal></expr></init></decl>,

<decl><name>GPR_FLAG_NEWOBJ</name> <init>= <expr><literal type="number">0x100</literal></expr></init></decl>,

<decl><name>GPR_FLAG_MALLOC</name> <init>= <expr><literal type="number">0x200</literal></expr></init></decl>,

<decl><name>GPR_FLAG_METHOD</name> <init>= <expr><literal type="number">0x400</literal></expr></init></decl>,

<decl><name>GPR_FLAG_CAPI</name> <init>= <expr><literal type="number">0x800</literal></expr></init></decl>,

<decl><name>GPR_FLAG_STRESS</name> <init>= <expr><literal type="number">0x1000</literal></expr></init></decl>,

<decl><name>GPR_FLAG_IMMEDIATE_SWEEP</name> <init>= <expr><literal type="number">0x2000</literal></expr></init></decl>,

<decl><name>GPR_FLAG_HAVE_FINALIZE</name> <init>= <expr><literal type="number">0x4000</literal></expr></init></decl>,

<decl><name>GPR_FLAG_IMMEDIATE_MARK</name> <init>= <expr><literal type="number">0x8000</literal></expr></init></decl>,

<decl><name>GPR_FLAG_FULL_MARK</name> <init>= <expr><literal type="number">0x10000</literal></expr></init></decl>,

<decl><name>GPR_DEFAULT_REASON</name> <init>=

<expr><operator>(</operator><name>GPR_FLAG_FULL_MARK</name> <operator>|</operator> <name>GPR_FLAG_IMMEDIATE_MARK</name> <operator>|</operator>

<name>GPR_FLAG_IMMEDIATE_SWEEP</name> <operator>|</operator> <name>GPR_FLAG_CAPI</name><operator>)</operator></expr></init></decl>,

}</block></enum></type> <name>gc_profile_record_flag</name>;</typedef>

<typedef>typedef <type><struct>struct <name>gc_profile_record</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>gc_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>gc_invoke_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_total_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_use_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_total_size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<decl_stmt><decl><type><name>double</name></type> <name>gc_mark_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>gc_sweep_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_use_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_live_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_free_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocate_increase</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocate_limit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>prepare_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>removing_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>empty_objects</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></cpp:if>

<decl_stmt><decl><type><name>long</name></type> <name>maxrss</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>minflt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>majflt</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>remembered_normal_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>remembered_shady_objects</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>gc_profile_record</name>;</typedef>

<struct>struct <name>RMoved</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>destination</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name><name>(</name><name>push</name><name>,</name> <name>1</name><name>)</name></cpp:pragma> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>RVALUE</name> <block>{

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>RVALUE</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block> <decl><name>free</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>RMoved</name></name></type> <name>moved</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RBasic</name></name></type> <name>basic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RObject</name></name></type> <name>object</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RClass</name></name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RFloat</name></name></type> <name>flonum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RString</name></name></type> <name>string</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RArray</name></name></type> <name>array</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RRegexp</name></name></type> <name>regexp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RHash</name></name></type> <name>hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RData</name></name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RTypedData</name></name></type> <name>typeddata</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RStruct</name></name></type> <name>rstruct</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RBignum</name></name></type> <name>bignum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RFile</name></name></type> <name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RMatch</name></name></type> <name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RRational</name></name></type> <name>rational</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>RComplex</name></name></type> <name>complex</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>rb_cref_t</name></type> <name>cref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_svar</name></name></type> <name>svar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_throw_data</name></name></type> <name>throw_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_ifunc</name></name></type> <name>ifunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>MEMO</name></name></type> <name>memo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_entry_struct</name></name></type> <name>ment</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name></type> <name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_env_t</name></type> <name>env</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_imemo_tmpbuf_struct</name></name></type> <name>alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ast_t</name></type> <name>ast</name></decl>;</decl_stmt>

}</block> <decl><name>imemo</name></decl>;</union>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>RBasic</name></name></type> <name>basic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v3</name></decl>;</decl_stmt>

}</block> <decl><name>values</name></decl>;</struct>

}</block> <decl><name>as</name></decl>;</union>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>RVALUE</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>uintptr_t</name></type> <name>bits_t</name>;</typedef>

<enum>enum <block>{

<decl><name>BITS_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>bits_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>,

<decl><name>BITS_BITLENGTH</name> <init>= <expr><operator>(</operator> <name>BITS_SIZE</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>)</operator></expr></init></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>popcount_bits</name></cpp:macro> <cpp:value>rb_popcount_intptr</cpp:value></cpp:define>

<struct>struct <name>heap_page_header</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>heap_page_body</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page_header</name></name></type> <name>header</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gc_list</name> <block>{

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>varptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_CHUNK_SIZE</name></cpp:macro> <cpp:value>500</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>stack_chunk</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>data</name><index>[<expr><name>STACK_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stack_chunk</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block></struct></type> <name>stack_chunk_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>mark_stack</name> <block>{

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cache_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>unused_cache_size</name></decl>;</decl_stmt>

}</block></struct></type> <name>mark_stack_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_heap_struct</name> <block>{

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>freelist</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>free_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>using_page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>sweeping_page</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>pooled_pages</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_pages</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>total_slots</name></decl>;</decl_stmt> 

}</block></struct></type> <name>rb_heap_t</name>;</typedef>

<enum>enum <name>gc_mode</name> <block>{

<decl><name>gc_mode_none</name></decl>,

<decl><name>gc_mode_marking</name></decl>,

<decl><name>gc_mode_sweeping</name></decl>

}</block>;</enum>

<typedef>typedef <type><struct>struct <name>rb_objspace</name> <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>increase</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocations</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block> <decl><name>malloc_params</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>immediate_sweep</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dont_gc</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dont_incremental</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>during_gc</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>during_compacting</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>gc_stressful</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_hook</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>during_minor_gc</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>during_incremental_marking</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block> <decl><name>flags</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>hook_events</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_allocated_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next_object_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_heap_t</name></type> <name>eden_heap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_heap_t</name></type> <name>tomb_heap</name></decl>;</decl_stmt> 

<struct>struct <block>{

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>finalizing</name></decl>;</decl_stmt>

}</block> <decl><name>atomic_flags</name></decl>;</struct>

<struct>struct <name>mark_func_data_struct</name> <block>{

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>mark_func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

}</block> <decl><modifier>*</modifier><name>mark_func_data</name></decl>;</struct>

<decl_stmt><decl><type><name>mark_stack_t</name></type> <name>mark_stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>marked_slots</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocatable_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sorted_length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name><name>range</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>freeable_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>final_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>deferred_final</name></decl>;</decl_stmt>

}</block> <decl><name>heap_pages</name></decl>;</struct>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>finalizer_table</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>run</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>latest_gc_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>records</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>current_record</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>next_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<decl_stmt><decl><type><name>double</name></type> <name>prepare_time</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>double</name></type> <name>invoke_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>minor_gc_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>major_gc_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>compact_count</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_generated_normal_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_generated_shady_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_shade_operation_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_promoted_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_remembered_normal_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_remembered_shady_object_count</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>generated_normal_object_count_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>generated_shady_object_count_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>shade_operation_count_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>promoted_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>remembered_normal_object_count_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>remembered_shady_object_count_types</name><index>[<expr><name>RUBY_T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<decl_stmt><decl><type><name>double</name></type> <name>gc_sweep_start_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_allocated_objects_at_gc_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>heap_used_at_gc_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_freed_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_allocated_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_freed_pages</name></decl>;</decl_stmt>

}</block> <decl><name>profile</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>global_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>gc_stress_mode</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>parent_object</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_major_gc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>last_major_gc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>uncollectible_wb_unprotected_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>uncollectible_wb_unprotected_objects_limit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_objects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_objects_limit</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldmalloc_increase</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>oldmalloc_increase_limit</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>allrefs_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>error_count</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block> <decl><name>rgengc</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name><name>considered_count_table</name><index>[<expr><name>T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>moved_count_table</name><index>[<expr><name>T_MASK</name></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name>rcompactor</name></decl>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>pooled_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>step_slots</name></decl>;</decl_stmt>

}</block> <decl><name>rincgc</name></decl>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>id_to_obj_tbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>obj_to_id_tbl</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>stress_to_class</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>rb_objspace_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP_PAGE_ALIGN_LOG</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CEILDIV</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>mod</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) + (mod) - 1)/(mod))</cpp:value></cpp:define>

<enum>enum <block>{

<decl><name>HEAP_PAGE_ALIGN</name> <init>= <expr><operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <name>HEAP_PAGE_ALIGN_LOG</name><operator>)</operator></expr></init></decl>,

<decl><name>HEAP_PAGE_ALIGN_MASK</name> <init>= <expr><operator>(</operator><operator>~</operator><operator>(</operator><operator>~</operator><literal type="number">0UL</literal> <operator>&lt;&lt;</operator> <name>HEAP_PAGE_ALIGN_LOG</name><operator>)</operator><operator>)</operator></expr></init></decl>,

<decl><name>REQUIRED_SIZE_BY_MALLOC</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">5</literal><operator>)</operator></expr></init></decl>,

<decl><name>HEAP_PAGE_SIZE</name> <init>= <expr><operator>(</operator><name>HEAP_PAGE_ALIGN</name> <operator>-</operator> <name>REQUIRED_SIZE_BY_MALLOC</name><operator>)</operator></expr></init></decl>,

<decl><name>HEAP_PAGE_OBJ_LIMIT</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>HEAP_PAGE_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page_header</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>RVALUE</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>,

<decl><name>HEAP_PAGE_BITMAP_LIMIT</name> <init>= <expr><call><name>CEILDIV</name><argument_list>(<argument><expr><call><name>CEILDIV</name><argument_list>(<argument><expr><name>HEAP_PAGE_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BITS_BITLENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><name>HEAP_PAGE_BITMAP_SIZE</name> <init>= <expr><operator>(</operator><name>BITS_SIZE</name> <operator>*</operator> <name>HEAP_PAGE_BITMAP_LIMIT</name><operator>)</operator></expr></init></decl>,

<decl><name>HEAP_PAGE_BITMAP_PLANES</name> <init>= <expr><literal type="number">4</literal></expr></init></decl> 

}</block>;</enum>

<struct>struct <name>heap_page</name> <block>{

<decl_stmt><decl><type><name>short</name></type> <name>total_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>free_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>pinned_slots</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>final_slots</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_sweep</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_remembered_objects</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_uncollectible_shady_objects</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>in_tomb</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block> <decl><name>flags</name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>free_next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>freelist</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>page_node</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name><name>wb_unprotected_bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name><name>mark_bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name><name>uncollectible_bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name><name>marking_bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name><name>pinned_bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PAGE_BODY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((struct heap_page_body *)((bits_t)(x) &amp; ~(HEAP_PAGE_ALIGN_MASK)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PAGE_HEADER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_PAGE_BODY(x)-&gt;header)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_PAGE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GET_PAGE_HEADER(x)-&gt;page)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_IN_PAGE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((bits_t)(p) &amp; HEAP_PAGE_ALIGN_MASK)/sizeof(RVALUE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITMAP_INDEX</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NUM_IN_PAGE(p) / BITS_BITLENGTH )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITMAP_OFFSET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NUM_IN_PAGE(p) &amp; (BITS_BITLENGTH-1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITMAP_BIT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((bits_t)1 &lt;&lt; BITMAP_OFFSET(p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARKED_IN_BITMAP</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((bits)[BITMAP_INDEX(p)] &amp; BITMAP_BIT(p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_IN_BITMAP</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((bits)[BITMAP_INDEX(p)] = (bits)[BITMAP_INDEX(p)] | BITMAP_BIT(p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_IN_BITMAP</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((bits)[BITMAP_INDEX(p)] = (bits)[BITMAP_INDEX(p)] &amp; ~BITMAP_BIT(p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_MARK_BITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_HEAP_PAGE(x)-&gt;mark_bits[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_PINNED_BITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_HEAP_PAGE(x)-&gt;pinned_bits[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_HEAP_PAGE(x)-&gt;uncollectible_bits[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_WB_UNPROTECTED_BITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_HEAP_PAGE(x)-&gt;wb_unprotected_bits[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HEAP_MARKING_BITS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;GET_HEAP_PAGE(x)-&gt;marking_bits[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_objspace</name></cpp:macro> <cpp:value>(*rb_objspace_of(GET_VM()))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_objspace_of</name><parameter_list>(<parameter><type><name>vm</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((vm)-&gt;objspace)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_initial_gc_stress</name></cpp:macro> <cpp:value>gc_params.gc_stress</cpp:value></cpp:define>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ruby_initial_gc_stress_ptr</name> <init>= <expr><operator>&amp;</operator><name>ruby_initial_gc_stress</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_limit</name></cpp:macro> <cpp:value>objspace-&gt;malloc_params.limit</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_increase</name></cpp:macro> <cpp:value>objspace-&gt;malloc_params.increase</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_allocated_size</name></cpp:macro> <cpp:value>objspace-&gt;malloc_params.allocated_size</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_sorted</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.sorted</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_allocated_pages</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.allocated_pages</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_sorted_length</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.sorted_length</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_lomem</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.range[0]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_himem</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.range[1]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_allocatable_pages</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.allocatable_pages</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_freeable_pages</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.freeable_pages</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_final_slots</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.final_slots</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_pages_deferred_final</name></cpp:macro> <cpp:value>objspace-&gt;heap_pages.deferred_final</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_eden</name></cpp:macro> <cpp:value>(&amp;objspace-&gt;eden_heap)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>heap_tomb</name></cpp:macro> <cpp:value>(&amp;objspace-&gt;tomb_heap)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dont_gc</name></cpp:macro> <cpp:value>objspace-&gt;flags.dont_gc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>during_gc</name></cpp:macro> <cpp:value>objspace-&gt;flags.during_gc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>finalizing</name></cpp:macro> <cpp:value>objspace-&gt;atomic_flags.finalizing</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>finalizer_table</name></cpp:macro> <cpp:value>objspace-&gt;finalizer_table</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>global_list</name></cpp:macro> <cpp:value>objspace-&gt;global_list</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_gc_stressful</name></cpp:macro> <cpp:value>objspace-&gt;flags.gc_stressful</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_gc_stress_mode</name></cpp:macro> <cpp:value>objspace-&gt;gc_stress_mode</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stress_to_class</name></cpp:macro> <cpp:value>objspace-&gt;stress_to_class</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stress_to_class</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>enum</name> <name>gc_mode</name></name></type>

<name>gc_mode_verify</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gc_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>gc_mode_none</name></expr>:</case>

<case>case <expr><name>gc_mode_marking</name></expr>:</case>

<case>case <expr><name>gc_mode_sweeping</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_mode_verify: unreachable (%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>mode</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_mode</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gc_mode_verify((enum gc_mode)(objspace)-&gt;flags.mode)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_mode_set</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;flags.mode = (unsigned int)gc_mode_verify(mode))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(gc_mode(objspace) == gc_mode_marking)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_sweeping</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(gc_mode(objspace) == gc_mode_sweeping)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_full_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;flags.during_minor_gc == FALSE)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_incremental_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;flags.during_incremental_marking != FALSE)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_incremental_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>will_be_incremental_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;rgengc.need_major_gc != GPR_FLAG_NONE)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>will_be_incremental_marking</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_sweeping_pages</name><parameter_list>(<parameter><type><name>heap</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((heap)-&gt;sweeping_page != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_lazy_sweeping</name><parameter_list>(<parameter><type><name>heap</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GC_ENABLE_LAZY_SWEEP &amp;&amp; has_sweeping_pages(heap))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nonspecial_obj_id</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VALUE)((SIGNED_VALUE)(obj)|FIXNUM_FLAG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>obj_id_to_ref</name><parameter_list>(<parameter><type><name>objid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objid) ^ FIXNUM_FLAG)</cpp:value></cpp:define> 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nonspecial_obj_id</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LL2NUM((SIGNED_VALUE)(obj) / 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>obj_id_to_ref</name><parameter_list>(<parameter><type><name>objid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FIXNUM_P(objid) ? ((objid) ^ FIXNUM_FLAG) : (NUM2PTR(objid) &lt;&lt; 1))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> not supported</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANY</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RVALUE*)(o))</cpp:value></cpp:define>

<struct>struct <name>RZombie</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>RBasic</name></name></type> <name>basic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>dfree</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RZOMBIE</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((struct RZombie *)(o))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nomem_error</name></cpp:macro> <cpp:value>GET_VM()-&gt;special_exceptions[ruby_error_nomemory]</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_MARK_FREE_DEBUG</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>ruby_gc_debug_indent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mGC</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ruby_disable_gc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>rb_iseq_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_iseq_update_references</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_iseq_free</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>rb_iseq_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_vm_update_references</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_gcdebug_print_obj_condition</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>define_final0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NORETURN</name><argument_list>(<argument>static void negative_size_allocation_error(const char *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ready_to_gc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>garbage_collect</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_enter</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_exit</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_marks</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>full_mark</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_marks_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>full</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_marks_finish</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_marks_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_marks_step</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slots</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_marks_continue</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_sweep</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_sweep_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_sweep_finish</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_sweep_step</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_sweep_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_sweep_continue</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_mark</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_pin</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_mark_and_pin</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_ptr</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"memory"</literal></argument>, <argument>static void gc_mark_maybe(rb_objspace_t *objspace, VALUE ptr)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_mark_children</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_mark_stacked_objects_incremental</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_mark_stacked_objects_all</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_grey</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>gc_mark_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NO_SANITIZE</name><argument_list>(<argument><literal type="string">"memory"</literal></argument>, <argument>static inline int is_pointer_to_heap(rb_objspace_t *objspace, void *ptr)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pop_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>mark_stack_size</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shrink_stack_chunk_cache</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>obj_memsize_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_all_types</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_verify_internal_consistency</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_verify_heap_page</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gc_verify_heap_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_stress_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>gc_disable_no_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>getrusage_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_setup_new_record</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_mark_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_mark_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_sweep_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_sweep_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_set_malloc_info</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>gc_prof_set_heap_info</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPED_UPDATE_IF_MOVED</name><parameter_list>(<parameter><type><name>_objspace</name></type></parameter>, <parameter><type><name>_type</name></type></parameter>, <parameter><type><name>_thing</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (gc_object_moved_p(_objspace, (VALUE)_thing)) { *((_type *)(&amp;_thing)) = (_type)RMOVED((_thing))-&gt;destination; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_IF_MOVED</name><parameter_list>(<parameter><type><name>_objspace</name></type></parameter>, <parameter><type><name>_thing</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPED_UPDATE_IF_MOVED(_objspace, VALUE, _thing)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_prof_record</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(objspace)-&gt;profile.current_record</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_prof_enabled</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;profile.run &amp;&amp; (objspace)-&gt;profile.current_record)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_VA_ARGS_MACRO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_report</name><parameter_list>(<parameter><type><name>level</name></type></parameter>, <parameter><type><name>objspace</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (!RGENGC_DEBUG_ENABLED(level)) {} else gc_report_body(level, objspace, __VA_ARGS__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_report</name></cpp:macro> <cpp:value>if (!RGENGC_DEBUG_ENABLED(0)) {} else gc_report_body</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PRINTF_ARGS</name><argument_list>(<argument>static void gc_report_body(int level, rb_objspace_t *objspace, const char *fmt, ...)</argument>, <argument><literal type="number">3</literal></argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obj_info</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_MARK_FUNC_DATA</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { struct mark_func_data_struct *prev_mark_func_data = objspace-&gt;mark_func_data; objspace-&gt;mark_func_data = (v);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP_MARK_FUNC_DATA</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>objspace-&gt;mark_func_data = prev_mark_func_data;} while (0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TICK_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TICK_TYPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TICK_T</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TICK_TYPE</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"llu"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>__volatile__</specifier> ("rdtsc" : "=A" (x));</asm>

<return>return <expr><name>x</name></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"llu"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>__inline__</name> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

<asm>__asm__ <specifier>__volatile__</specifier> ("rdtsc" : "=a"(lo), "=d"(hi));</asm>

<return>return <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>lo</name><operator>)</operator><operator>|</operator><operator>(</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>hi</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc64__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GCC_VERSION_SINCE</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">8</literal><operator>,</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></cpp:elif>

<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"llu"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>__inline__</name> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>val</name> <init>= <expr><call><name>__builtin_ppc_get_timebase</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><name>unsigned</name> <name>__int64</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"llu"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>__rdtsc</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<typedef>typedef <type><name>clock_t</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"llu"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>clock</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>TICK_TYPE</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>

<typedef>typedef <type><name>double</name></type> <name>tick_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItick</name></cpp:macro> <cpp:value>"4.9f"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>tick_t</name></type>

<name>tick</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"choose tick type"</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEASURE_LINE</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { volatile tick_t start_time = tick(); volatile tick_t end_time; expr; end_time = tick(); fprintf(stderr, "0\t%"PRItick"\t%s\n", end_time - start_time, #expr); } while (0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEASURE_LINE</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>expr</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_CHECK2</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>pred</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RGENGC_CHECK_MODE &amp;&amp; SPECIAL_CONST_P(x)) ? (rb_bug(name": SPECIAL_CONST (%p)", (void *)(x)), 0) : (pred))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_TEST2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_CHECK2("FL_TEST2", x, FL_TEST_RAW((x),(f)) != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_SET2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_CHECK2("FL_SET2", x, RBASIC(x)-&gt;flags |= (f))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_UNSET2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_CHECK2("FL_UNSET2", x, RBASIC(x)-&gt;flags &amp;= ~(f))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_MARK_BITMAP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP(GET_HEAP_MARK_BITS(obj), (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_PIN_BITMAP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP(GET_HEAP_PINNED_BITS(obj), (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_PAGE_MARKED</name><parameter_list>(<parameter><type><name>page</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP((page)-&gt;mark_bits, (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_WB_UNPROTECTED_BITMAP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP(GET_HEAP_WB_UNPROTECTED_BITS(obj), (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_UNCOLLECTIBLE_BITMAP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP(GET_HEAP_UNCOLLECTIBLE_BITS(obj), (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_MARKING_BITMAP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP(GET_HEAP_MARKING_BITS(obj), (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_PAGE_WB_UNPROTECTED</name><parameter_list>(<parameter><type><name>page</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP((page)-&gt;wb_unprotected_bits, (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_PAGE_UNCOLLECTIBLE</name><parameter_list>(<parameter><type><name>page</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP((page)-&gt;uncollectible_bits, (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_PAGE_MARKING</name><parameter_list>(<parameter><type><name>page</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MARKED_IN_BITMAP((page)-&gt;marking_bits, (obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_OLD_AGE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVALUE_AGE_SHIFT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rgengc_remembered</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rgengc_remembered_sweep</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rgengc_remember</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rgengc_mark_and_rememberset_clear</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rgengc_rememberset_mark</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_FLAGS_AGE</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>FL_PROMOTED0</name> <operator>|</operator> <name>FL_PROMOTED1</name><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <name>RVALUE_AGE_SHIFT</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_rvalue_consistency_force</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>terminate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %p is a special const.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap_tomb-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %p is in a tomb_heap (%p).\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

<goto>goto <name>skip</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %p is not a Ruby object.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

<label><name>skip</name>:</label>

<empty_stmt>;</empty_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>wb_unprotected_bit</name> <init>= <expr><call><name>RVALUE_WB_UNPROTECTED_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>uncollectible_bit</name> <init>= <expr><call><name>RVALUE_UNCOLLECTIBLE_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mark_bit</name> <init>= <expr><call><name>RVALUE_MARK_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>marking_bit</name> <init>= <expr><call><name>RVALUE_MARKING_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>remembered_bit</name> <init>= <expr><name>marking_bit</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>age</name> <init>= <expr><call><name>RVALUE_FLAGS_AGE</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>flags</name><operator>.</operator><name>in_tomb</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is in tomb page.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is T_NONE.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ZOMBIE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is T_ZOMBIE.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>obj_memsize_of</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>age</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wb_unprotected_bit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is not WB protected, but age is %d &gt; 0.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>uncollectible_bit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mark_bit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is uncollectible, but is not marked while !gc.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>uncollectible_bit</name> <operator>&amp;&amp;</operator> <name>age</name> <operator>!=</operator> <name>RVALUE_OLD_AGE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>wb_unprotected_bit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is uncollectible, but not old (age: %d) and not WB unprotected.\n"</literal></expr></argument>,

<argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>remembered_bit</name> <operator>&amp;&amp;</operator> <name>age</name> <operator>!=</operator> <name>RVALUE_OLD_AGE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is remembered, but not old (age: %d).\n"</literal></expr></argument>,

<argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>marking_bit</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>mark_bit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_rvalue_consistency: %s is marking, but not marked.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>terminate</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_rvalue_consistency_force: there is %d errors."</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>err</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>check_rvalue_consistency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_rvalue_consistency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency_force</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>gc_object_moved_p</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MOVED</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_MARKED</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_MARK_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_PINNED</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_PIN_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_WB_UNPROTECTED</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_WB_UNPROTECTED_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_MARKING</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_MARKING_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_REMEMBERED</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_MARKING_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_UNCOLLECTIBLE</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_UNCOLLECTIBLE_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_OLD_P_RAW</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>promoted</name> <init>= <expr><name>FL_PROMOTED0</name> <operator>|</operator> <name>FL_PROMOTED1</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>promoted</name><operator>)</operator> <operator>==</operator> <name>promoted</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_OLD_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_OLD_P_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>||</operator> <name>GC_DEBUG</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_AGE</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RVALUE_FLAGS_AGE</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_PAGE_OLD_UNCOLLECTIBLE_SET</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>uncollectible_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_transient_heap_promote</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_promoted_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>promoted_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_OLD_UNCOLLECTIBLE_SET</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_promote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_PAGE_OLD_UNCOLLECTIBLE_SET</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>RVALUE_FLAGS_AGE_SET</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>age</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>FL_PROMOTED0</name> <operator>|</operator> <name>FL_PROMOTED1</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><name>age</name> <operator>&lt;&lt;</operator> <name>RVALUE_AGE_SHIFT</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>flags</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_AGE_INC</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>age</name> <init>= <expr><call><name>RVALUE_FLAGS_AGE</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <name>age</name> <operator>==</operator> <name>RVALUE_OLD_AGE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"RVALUE_AGE_INC: can not increment age of OLD object %s."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>age</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <call><name>RVALUE_FLAGS_AGE_SET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>age</name> <operator>==</operator> <name>RVALUE_OLD_AGE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RVALUE_OLD_UNCOLLECTIBLE_SET</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_AGE_SET_OLD</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <call><name>RVALUE_FLAGS_AGE_SET</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>RVALUE_OLD_AGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_OLD_UNCOLLECTIBLE_SET</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_AGE_SET_CANDIDATE</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <call><name>RVALUE_FLAGS_AGE_SET</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>RVALUE_OLD_AGE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_DEMOTE_RAW</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <call><name>RVALUE_FLAGS_AGE_SET</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_DEMOTE</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RVALUE_REMEMBERED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RVALUE_DEMOTE_RAW</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_AGE_RESET_RAW</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <call><name>RVALUE_FLAGS_AGE_SET</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>RVALUE_AGE_RESET</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_RESET_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_BLACK_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static inline int

RVALUE_GREY_P(VALUE obj)

{

return RVALUE_MARKED(obj) &amp;&amp; RVALUE_MARKING(obj);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>RVALUE_WHITE_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>calloc1</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_objspace_t</name> <modifier>*</modifier></type>

<name>rb_objspace_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><call><name>calloc1</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_objspace_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>malloc_limit</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_min</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>eden_heap</name><operator>.</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>tomb_heap</name><operator>.</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>objspace</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_stack_chunks</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>heap_page_free</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>

<name>rb_objspace_free</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"lazy sweeping underway when freeing object space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>global_list</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <name>global_list</name></expr>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_sorted</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>heap_page_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>heap_pages_sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_allocated_pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_pages_sorted_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_pages_lomem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_pages_himem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>eden_heap</name><operator>.</operator><name>total_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>eden_heap</name><operator>.</operator><name>total_slots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_stack_chunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_pages_expand_sorted_to</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>next_length</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>size_mul_or_raise</name><argument_list>(<argument><expr><name>next_length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"heap_pages_expand_sorted: next_length: %d, size: %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>next_length</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_sorted_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sorted</name> <operator>=</operator> <operator>(</operator>struct <name>heap_page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>heap_pages_sorted</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sorted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>heap_pages_sorted</name> <operator>=</operator> <name>sorted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sorted</name> <operator>=</operator> <name>heap_pages_sorted</name> <operator>=</operator> <operator>(</operator>struct <name>heap_page</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sorted</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>heap_pages_sorted_length</name> <operator>=</operator> <name>next_length</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_pages_expand_sorted</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>next_length</name> <init>= <expr><name>heap_allocatable_pages</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>next_length</name> <operator>+=</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>next_length</name> <operator>+=</operator> <name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>next_length</name> <operator>&gt;</operator> <name>heap_pages_sorted_length</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_pages_expand_sorted_to</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>next_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name> <operator>+</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocated_pages</name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_allocatable_pages_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>heap_allocatable_pages</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_pages_expand_sorted</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>heap_page_add_freeobj</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>]</index></name> <operator>&amp;&amp;</operator>

<name>obj</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"heap_page_add_freeobj: %p is not rvalue."</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"heap_page_add_freeobj: add %p to freelist\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>heap_add_freepage</name><parameter_list>(<parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>heap_add_poolpage</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>pooled_slots</name></name> <operator>+=</operator> <name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_unlink_page</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>page_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>total_pages</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>-=</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rb_aligned_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_page_free</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>heap_allocated_pages</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_pages</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_aligned_free</name><argument_list>(<argument><expr><call><name>GET_PAGE_BODY</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_pages_free_unused_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heap_tomb</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>in_tomb</name></name> <operator>&amp;&amp;</operator> <name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>==</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_unlink_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_tomb</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>j</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>heap_pages_sorted</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>j</name> <operator>==</operator> <name>heap_allocated_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type>

<name>heap_page_allocate</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page_body</name></name> <modifier>*</modifier></type><name>page_body</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><name>HEAP_PAGE_OBJ_LIMIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>page_body</name> <operator>=</operator> <operator>(</operator>struct <name>heap_page_body</name> <operator>*</operator><operator>)</operator><call><name>rb_aligned_malloc</name><argument_list>(<argument><expr><name>HEAP_PAGE_ALIGN</name></expr></argument>, <argument><expr><name>HEAP_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>page_body</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>calloc1</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_aligned_free</name><argument_list>(<argument><expr><name>page_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>RVALUE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>page_body</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page_header</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>start</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>start</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>RVALUE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>start</name> <operator>+</operator> <name>delta</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>HEAP_PAGE_SIZE</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>start</name> <operator>-</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>page_body</name><operator>)</operator><operator>)</operator><operator>/</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>limit</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>heap_allocated_pages</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>mid_page</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mid_page</name> <operator>=</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>mid</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mid_page</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>mid_page</name><operator>-&gt;</operator><name>start</name></name> <operator>&gt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"same heap page is allocated: %p at %"</literal><name>PRIuVALUE</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page_body</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heap_pages_sorted</name><index>[<expr><name>hi</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heap_pages_sorted</name><index>[<expr><name>hi</name></expr>]</index></name></expr></argument>, <argument><expr>struct <name>heap_page_header</name><operator>*</operator></expr></argument>, <argument><expr><name>heap_allocated_pages</name> <operator>-</operator> <name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>heap_pages_sorted</name><index>[<expr><name>hi</name></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_allocated_pages</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name> <operator>+</operator> <name>heap_allocatable_pages</name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name> <operator>+</operator> <name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name> <operator>==</operator> <name>heap_allocated_pages</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocated_pages</name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_allocated_pages</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_allocated_pages</name> <operator>&gt;</operator> <name>heap_pages_sorted_length</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"heap_page_allocate: allocated(%"</literal><name>PRIdSIZE</name><literal type="string">") &gt; sorted(%"</literal><name>PRIdSIZE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><name>heap_allocated_pages</name></expr></argument>, <argument><expr><name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_lomem</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>heap_pages_lomem</name> <operator>&gt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>heap_pages_lomem</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_himem</name> <operator>&lt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>heap_pages_himem</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page_body</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"assign_heap_page: %p is added to freelist\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>page</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type>

<name>heap_page_resurrect</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<macro><name>list_for_each_safe</name><argument_list>(<argument>&amp;heap_tomb-&gt;pages</argument>, <argument>page</argument>, <argument>next</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_unlink_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_tomb</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>page</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type>

<name>heap_page_create</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>method</name> <init>= <expr><literal type="string">"recycle"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>heap_allocatable_pages</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>heap_page_resurrect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>heap_page_allocate</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <literal type="string">"allocate"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"heap_page_create: %s - %p, heap_allocated_pages: %d, heap_allocated_pages: %d, tomb-&gt;total_pages: %d\n"</literal></expr></argument>,

<argument><expr><name>method</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_pages_sorted_length</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_allocated_pages</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>page</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_add_page</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>in_tomb</name></name> <operator>=</operator> <operator>(</operator><name>heap</name> <operator>==</operator> <name>heap_tomb</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heap</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>page_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>total_pages</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>+=</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_assign_page</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>heap_page_create</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>heap_add_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_add_freepage</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_add_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>add</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>heap_allocatable_pages_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>add</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>heap_assign_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>heap_extend_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>free_slots</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>total_slots</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>goal_ratio</name> <init>= <expr><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_goal_ratio</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>used</name> <init>= <expr><name>heap_allocated_pages</name> <operator>+</operator> <name>heap_allocatable_pages</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>next_used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>goal_ratio</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next_used</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>used</name> <operator>*</operator> <name><name>gc_params</name><operator>.</operator><name>growth_factor</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>f</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>total_slots</name> <operator>-</operator> <name>free_slots</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>goal_ratio</name><operator>)</operator> <operator>*</operator> <name>total_slots</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&gt;</operator> <name><name>gc_params</name><operator>.</operator><name>growth_factor</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>growth_factor</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">1.1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next_used</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>*</operator> <name>used</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,

<argument><expr><literal type="string">"free_slots(%8"</literal><name>PRIuSIZE</name><literal type="string">")/total_slots(%8"</literal><name>PRIuSIZE</name><literal type="string">")=%1.2f,"</literal>

<literal type="string">" G(%1.2f), f(%1.2f),"</literal>

<literal type="string">" used(%8"</literal><name>PRIuSIZE</name><literal type="string">") =&gt; next_used(%8"</literal><name>PRIuSIZE</name><literal type="string">")\n"</literal></expr></argument>,

<argument><expr><name>free_slots</name></expr></argument>, <argument><expr><name>total_slots</name></expr></argument>, <argument><expr><name>free_slots</name><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name>total_slots</name></expr></argument>,

<argument><expr><name>goal_ratio</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>used</name></expr></argument>, <argument><expr><name>next_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gc_params</name><operator>.</operator><name>growth_max_slots</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>max_used</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>used</name> <operator>+</operator> <name><name>gc_params</name><operator>.</operator><name>growth_max_slots</name></name><operator>/</operator><name>HEAP_PAGE_OBJ_LIMIT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>next_used</name> <operator>&gt;</operator> <name>max_used</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next_used</name> <operator>=</operator> <name>max_used</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>next_used</name> <operator>-</operator> <name>used</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_set_increment</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>additional_pages</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>used</name> <init>= <expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>next_used_limit</name> <init>= <expr><name>used</name> <operator>+</operator> <name>additional_pages</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>next_used_limit</name> <operator>==</operator> <name>heap_allocated_pages</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next_used_limit</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>heap_allocatable_pages_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>next_used_limit</name> <operator>-</operator> <name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"heap_set_increment: heap_allocatable_pages is %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_allocatable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>heap_increment</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>heap_allocatable_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"heap_increment: heap_pages_sorted_length: %d, heap_pages_inc: %d, heap-&gt;total_pages: %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_pages_sorted_length</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_allocatable_pages</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>heap</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name> <operator>+</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_allocated_pages</name> <operator>&lt;=</operator> <name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_assign_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_prepare</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_sweep_continue</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_marks_continue</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>will_be_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>gc_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>GPR_FLAG_NEWOBJ</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RVALUE</name> <modifier>*</modifier></type>

<name>heap_get_freeobj_from_next_freepage</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_prepare</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>free_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>using_page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>heap_get_freeobj_head</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>heap_get_freeobj</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>heap_get_freeobj_from_next_freepage</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_set_event_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_event_flag_t</name></type> <name>event</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>hook_events</name></name> <operator>=</operator> <name>event</name> <operator>&amp;</operator> <name>RUBY_INTERNAL_EVENT_OBJSPACE_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_hook</name></name> <operator>=</operator> <operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>hook_events</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_event_hook_body</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_event_flag_t</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>&amp;&amp;</operator> <call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_event_hook_available_p</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;flags.has_hook)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_event_hook_needed_p</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>, <parameter><type><name>event</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((objspace)-&gt;hook_events &amp; (event))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_event_hook</name><parameter_list>(<parameter><type><name>objspace</name></type></parameter>, <parameter><type><name>event</name></type></parameter>, <parameter><type><name>data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (UNLIKELY(gc_event_hook_needed_p(objspace, event))) { gc_event_hook_body(GET_EC(), (objspace), (event), (data)); } } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>newobj_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wb_protected</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>__has_feature</name><argument_list>(<argument><expr><name>memory_sanitizer</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FL_WB_PROTECTED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>RVALUE</name></name></type> <name>buf</name> <init>= <expr><block>{

<expr><operator>.</operator><name>as</name> <operator>=</operator> <block>{

<expr><operator>.</operator><name>values</name> <operator>=</operator> <block>{

<expr><operator>.</operator><name>basic</name> <operator>=</operator> <block>{

<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>flags</name></expr>,

<expr><operator>.</operator><name>klass</name> <operator>=</operator> <name>klass</name></expr>,

}</block></expr>,

<expr><operator>.</operator><name>v1</name> <operator>=</operator> <name>v1</name></expr>,

<expr><operator>.</operator><name>v2</name> <operator>=</operator> <name>v2</name></expr>,

<expr><operator>.</operator><name>v3</name> <operator>=</operator> <name>v3</name></expr>,

}</block></expr>,

}</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>RVALUE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name></expr></cpp:if>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FL_PROMOTED1</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_AGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"newobj: %s of age (%d) != 2."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RVALUE_AGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_AGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"newobj: %s of age (%d) &gt; 0."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RVALUE_AGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rgengc_remembered</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"newobj: %s is remembered."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>wb_protected</name> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>wb_protected</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_generated_normal_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>generated_normal_object_count_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_generated_shady_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>generated_shady_object_count_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>file</name> <operator>=</operator> <call><name>rb_source_location_cstr</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>total_allocated_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"newobj: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_OLD_NEWOBJ_CHECK</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>newobj_cnt</name> <init>= <expr><name>RGENGC_OLD_NEWOBJ_CHECK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>flags</name> <operator>&amp;</operator> <name>FL_WB_PROTECTED</name> <operator>&amp;&amp;</operator> 

<operator>!</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>newobj_cnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newobj_cnt</name> <operator>=</operator> <name>RGENGC_OLD_NEWOBJ_CHECK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_SET_OLD</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>newobj_slowpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wb_protected</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>during_gc</name> <operator>||</operator> <name>ruby_gc_stressful</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>during_gc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>during_gc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"object allocation during garbage collection phase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ruby_gc_stressful</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>garbage_collect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>GPR_FLAG_NEWOBJ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>heap_get_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>newobj_init</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>wb_protected</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_NEWOBJ</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static VALUE newobj_slowpath_wb_protected(VALUE klass, VALUE flags, VALUE v1, VALUE v2, VALUE v3, rb_objspace_t *objspace)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>NOINLINE</name><argument_list>(<argument>static VALUE newobj_slowpath_wb_unprotected(VALUE klass, VALUE flags, VALUE v1, VALUE v2, VALUE v3, rb_objspace_t *objspace)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>newobj_slowpath_wb_protected</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>newobj_slowpath</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>newobj_slowpath_wb_unprotected</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>newobj_slowpath</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>newobj_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wb_protected</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>obj_newobj_wb_unprotected</name></expr></argument>, <argument><expr><operator>!</operator><name>wb_protected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>during_gc</name> <operator>||</operator>

<name>ruby_gc_stressful</name> <operator>||</operator>

<call><name>gc_event_hook_available_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>obj</name> <operator>=</operator> <call><name>heap_get_freeobj_head</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>newobj_init</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>wb_protected</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_newobj_slowpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>wb_protected</name></expr> ?</condition><then>

<expr><call><name>newobj_slowpath_wb_protected</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>newobj_slowpath_wb_unprotected</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_wb_unprotected_newobj_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FL_WB_PROTECTED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_wb_protected_newobj_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FL_WB_PROTECTED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_newobj</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>T_NONE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_newobj_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>FL_WB_PROTECTED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>FL_WB_PROTECTED</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNEXPECTED_NODE</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_bug(#func"(): GC does not handle T_NODE 0x%x(%p) 0x%"PRIxVALUE, BUILTIN_TYPE(obj), (void*)(obj), RBASIC(obj)-&gt;flags)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_imemo_new</name></cpp:undef>

<function><type><name>VALUE</name></type>

<name>rb_imemo_new</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>imemo_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v0</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><name>T_IMEMO</name> <operator>|</operator> <operator>(</operator><name>type</name> <operator>&lt;&lt;</operator> <name>FL_USHIFT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>v0</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_imemo_tmpbuf_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v0</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><name>T_IMEMO</name> <operator>|</operator> <operator>(</operator><name>imemo_tmpbuf</name> <operator>&lt;&lt;</operator> <name>FL_USHIFT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>v0</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_imemo_tmpbuf_auto_free_maybe_mark_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_imemo_tmpbuf_new</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cnt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_imemo_tmpbuf_t</name> <modifier>*</modifier></type>

<name>rb_imemo_tmpbuf_parser_heap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_imemo_tmpbuf_t</name> <modifier>*</modifier></type><name>old_heap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_imemo_tmpbuf_t</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_tmpbuf_new</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>old_heap</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cnt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>imemo_memsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ment</name><operator>.</operator><name>def</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_iseq</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_iseq_memsize</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_env</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>env</name><operator>.</operator><name>env_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_tmpbuf</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>alloc</name><operator>.</operator><name>cnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ast</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_ast_memsize</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<case>case <expr><name>imemo_throw_data</name></expr>:</case>

<case>case <expr><name>imemo_ifunc</name></expr>:</case>

<case>case <expr><name>imemo_memo</name></expr>:</case>

<case>case <expr><name>imemo_parser_strterm</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IMEMO_DEBUG</name></expr></cpp:if>

<function><type><name>VALUE</name></type>

<name>rb_imemo_new_debug</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>imemo_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"memo %p (type: %d) @ %s:%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>memo</name></expr></argument>, <argument><expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>memo</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name></type>

<name>rb_data_object_wrap</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datap</name></decl></parameter>, <parameter><decl><type><name>RUBY_DATA_FUNC</name></type> <name>dmark</name></decl></parameter>, <parameter><decl><type><name>RUBY_DATA_FUNC</name></type> <name>dfree</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>klass</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_DATA</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dmark</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dfree</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>datap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_data_object_alloc</name></cpp:undef>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_data_object_alloc(VALUE klass, void *datap,

RUBY_DATA_FUNC dmark, RUBY_DATA_FUNC dfree)</argument>,

<argument>rb_data_object_wrap</argument>, <argument>(klass, datap, dmark, dfree)</argument>)</argument_list></macro>

<function><type><name>VALUE</name></type>

<name>rb_data_object_zalloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>RUBY_DATA_FUNC</name></type> <name>dmark</name></decl></parameter>, <parameter><decl><type><name>RUBY_DATA_FUNC</name></type> <name>dfree</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_data_object_wrap</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dmark</name></expr></argument>, <argument><expr><name>dfree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_data_typed_object_wrap</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>klass</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>newobj_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_DATA</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>type</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>datap</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RUBY_FL_WB_PROTECTED</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_data_typed_object_alloc</name></cpp:undef>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_data_typed_object_alloc(VALUE klass, void *datap,

const rb_data_type_t *type)</argument>,

<argument>rb_data_typed_object_wrap</argument>, <argument>(klass, datap, type)</argument>)</argument_list></macro>

<function><type><name>VALUE</name></type>

<name>rb_data_typed_object_zalloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_data_typed_object_wrap</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_objspace_data_type_memsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>RTYPEDDATA_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <name><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dsize</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dsize</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_objspace_data_type_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>RTYPEDDATA_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>wrap_struct_name</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<macro><name>PUREFUNC</name><argument_list>(<argument>static inline int is_pointer_to_heap(rb_objspace_t *objspace, void *ptr);</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_pointer_to_heap</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>register</specifier> <name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RANY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>size_t</name></type> <name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>gc_isptr_trial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name> <argument_list type="generic">&lt; <argument><expr><name>heap_pages_lomem</name> <operator>||</operator> <name>p</name></expr></argument> &gt;</argument_list></name> <name>heap_pages_himem</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>gc_isptr_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>gc_isptr_align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>heap_allocated_pages</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>mid</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;=</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>gc_isptr_maybe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>in_tomb</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>free_const_entry_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_free_const_table</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>free_const_entry_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_ccs_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>alive</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alive</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>cc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>klass</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_cc_invalidate</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_ccs_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccs_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>cc_tbl_i_data</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>alive</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>cc_table_mark_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ccs_ptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cc_tbl_i_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>data_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><operator>(</operator>struct <name>rb_class_cc_entries</name> <operator>*</operator><operator>)</operator><name>ccs_ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_p</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>==</operator> <name><name>ccs</name><operator>-&gt;</operator><name>cme</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_DELETE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name> <operator>==</operator> <call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>cc_table_mark</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cc_tbl_i_data</name></name></type> <name>data</name> <init>= <expr><block>{

<expr><operator>.</operator><name>objspace</name> <operator>=</operator> <name>objspace</name></expr>,

<expr><operator>.</operator><name>klass</name> <operator>=</operator> <name>klass</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>cc_table_mark_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>cc_table_free_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ccs_ptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cc_tbl_i_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>data_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><operator>(</operator>struct <name>rb_class_cc_entries</name> <operator>*</operator><operator>)</operator><name>ccs_ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_p</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>alive</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>cc_table_free</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alive</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cc_tbl_i_data</name></name></type> <name>data</name> <init>= <expr><block>{

<expr><operator>.</operator><name>objspace</name> <operator>=</operator> <name>objspace</name></expr>,

<expr><operator>.</operator><name>klass</name> <operator>=</operator> <name>klass</name></expr>,

<expr><operator>.</operator><name>alive</name> <operator>=</operator> <name>alive</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>cc_table_free_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_cc_table_free</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>cc_table_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>make_zombie</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>dfree</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RZombie</name></name> <modifier>*</modifier></type><name>zombie</name> <init>= <expr><call><name>RZOMBIE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>zombie</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>T_ZOMBIE</name> <operator>|</operator> <operator>(</operator><name><name>zombie</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>FL_SEEN_OBJ_ID</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zombie</name><operator>-&gt;</operator><name>dfree</name></name> <operator>=</operator> <name>dfree</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zombie</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zombie</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>heap_pages_deferred_final</name></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_pages_deferred_final</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>zombie</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>make_io_zombie</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>make_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>rb_io_fptr_finalize</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>obj_free_object_id</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>o</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></init></decl>, <decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"Object ID seen, but not in mapping table: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>obj_free</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_FREEOBJ</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NIL</name></expr>:</case>

<case>case <expr><name>T_FIXNUM</name></expr>:</case>

<case>case <expr><name>T_TRUE</name></expr>:</case>

<case>case <expr><name>T_FALSE</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"obj_free() called for broken object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_free_generic_ivar</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>obj_free_object_id</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (x(obj) != FALSE) rb_bug("obj_free: " #x "(%s) != FALSE", obj_info(obj))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>RVALUE_WB_UNPROTECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>RVALUE_MARKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>RVALUE_MARKING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>RVALUE_UNCOLLECTIBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>ROBJECT_EMBED</name><operator>)</operator> <operator>||</operator>

<call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>object</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_obj_embed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ROBJ_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_obj_transient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>object</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_obj_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<expr_stmt><expr><call><name>mjit_remove_class_serial</name><argument_list>(<argument><expr><call><name>RCLASS_SERIAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cc_table_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_free_const_table</name><argument_list>(<argument><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subclasses</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MODULE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_class_detach_module_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_class_detach_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subclasses</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_remove_from_module_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_class_remove_from_super_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>klass</name><operator>.</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>klass</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>klass</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>obj_module_ptr</name></expr></argument>, <argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>obj_class_ptr</name></expr></argument>, <argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><call><name>rb_str_free</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ary_free</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_HASH</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>

<switch>switch <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<case>case <expr><literal type="number">8</literal></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_5_8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_g8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>( <expr><operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RHASH_ST_TABLE_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ar_table_struct</name></name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><call><name>RHASH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ar</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tab</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_transient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>regexp</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>regexp</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_regexp_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_DATA</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>free_immediately</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>dfree</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>free_immediately</name> <operator>=</operator> <operator>(</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>RUBY_TYPED_FREE_IMMEDIATELY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dfree</name> <operator>=</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dfree</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>free_immediately</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"not immediate -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>wrap_struct_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>dfree</name> <operator>=</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dfree</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dfree</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dfree</name> <operator>==</operator> <name>RUBY_DEFAULT_FREE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_data_xfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>free_immediately</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>dfree</name>)<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_data_imm_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>make_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dfree</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_data_zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_data_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_MATCH</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>rmatch</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rmatch</name></name> <modifier>*</modifier></type><name>rm</name> <init>= <expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>rmatch</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_match_ge8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_match_ge4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_match_under4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>onig_region_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>rm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_match_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_FILE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_io_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_file_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_RATIONAL</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_rational</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_COMPLEX</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_complex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subclasses</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_class_detach_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subclasses</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>cc_table_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_class_remove_from_module_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_class_remove_from_super_subclasses</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>klass</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>klass</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_iclass_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIGNUM_EMBED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BIGNUM_DIGITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>BIGNUM_DIGITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_bignum_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_bignum_embed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>obj_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRUCT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>RSTRUCT_EMBED_LEN_MASK</name><operator>)</operator> <operator>||</operator>

<call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>rstruct</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_struct_embed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RSTRUCT_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_struct_transient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>rstruct</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_struct_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_free_dsymbol</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<expr_stmt><expr><call><name>rb_free_method_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_ment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_iseq</name></expr>:</case>

<expr_stmt><expr><call><name>rb_iseq_free</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_env</name></expr>:</case>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>env</name><operator>.</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>env</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_tmpbuf</name></expr>:</case>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>alloc</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ast</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ast_free</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_svar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_throw_data</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_throw_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ifunc</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_memo</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_parser_strterm</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_parser_strterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_callinfo</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_callinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_callcache</name></expr>:</case>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_imemo_callcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_sweep(): unknown data type 0x%x(%p) 0x%"</literal><name>PRIxVALUE</name></expr></argument>,

<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_ID_INCREMENT</name></cpp:macro> <cpp:value>(sizeof(RVALUE) / 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_ID_INITIAL</name></cpp:macro> <cpp:value>(OBJ_ID_INCREMENT * 2)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>object_id_cmp</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>rb_big_eql</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>x</name> <operator>!=</operator> <name>y</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>

<name>object_id_hash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><call><name>rb_big_hash</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><call><name>st_numhash</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>object_id_hash_type</name> <init>= <expr><block>{

<expr><name>object_id_cmp</name></expr>,

<expr><name>object_id_hash</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>Init_heap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>next_object_id</name></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>OBJ_ID_INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name> <operator>=</operator> <call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object_id_hash_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_min</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>heap_add_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name> <operator>/</operator> <name>HEAP_PAGE_OBJ_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>invoke_time</name></name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>finalizer_table</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_gc_stress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_stress_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ruby_initial_gc_stress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> <name>each_obj_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>objspace_each_objects</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>objspace_reachable_objects_from_root</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>each_obj_args</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_each_objects_without_setup</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>pstart</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>pstart</name> <operator>&lt;</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>start</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>heap_allocated_pages</name> <operator>&amp;&amp;</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>start</name> <operator>&lt;=</operator> <name>pstart</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>heap_allocated_pages</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pstart</name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>pstart</name> <operator>+</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>callback</name>)<argument_list>(<argument><expr><name>pstart</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>objspace_each_objects_protected</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>each_obj_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator>struct <name>each_obj_args</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>objspace_each_objects_without_setup</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>incremental_enable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_each_objects</name><parameter_list>(<parameter><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>objspace_each_objects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_each_objects</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>prev_dont_incremental</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_dont_incremental</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>objspace_each_objects_without_setup</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>each_obj_args</name></name></type> <name>args</name> <init>= <expr><block>{<expr><name>objspace</name></expr>, <expr><name>callback</name></expr>, <expr><name>data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>objspace_each_objects_protected</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>incremental_enable</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_each_objects_without_setup</name><parameter_list>(<parameter><decl><type><name>each_obj_callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>objspace_each_objects_without_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>os_each_struct</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>of</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>internal_object_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>__asan_region_is_poisoned</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SIZEOF_VALUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>used_p</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>used_p</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>internal_object_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_NONE</name></expr>:</case>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>klass</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_singleton_class_internal_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>klass</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>||</operator> <operator>!</operator> <name>used_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_objspace_internal_object_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>internal_object_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>os_obj_of_i</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>os_each_struct</name></name> <modifier>*</modifier></type><name>oes</name> <init>= <expr><operator>(</operator>struct <name>os_each_struct</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>vstart</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>vend</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>pend</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>internal_object_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oes</name><operator>-&gt;</operator><name>of</name></name> <operator>||</operator> <call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>oes</name><operator>-&gt;</operator><name>of</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oes</name><operator>-&gt;</operator><name>num</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>os_obj_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>of</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>os_each_struct</name></name></type> <name>oes</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>oes</name><operator>.</operator><name>num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oes</name><operator>.</operator><name>of</name></name> <operator>=</operator> <name>of</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_objspace_each_objects</name><argument_list>(<argument><expr><name>os_obj_of_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>oes</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>os_each_obj</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>os</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>of</name></decl>;</decl_stmt>

<expr_stmt><expr><name>of</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>of</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>os_obj_of</name><argument_list>(<argument><expr><name>of</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>undefine_final</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>os</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_undefine_finalizer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_undefine_finalizer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name> <init>= <expr><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>should_be_callable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_respond_to</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"wrong type argument %"</literal><name>PRIsVALUE</name><literal type="string">" (should be callable)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>should_be_finalizable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"cannot define finalizer for %s"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>define_final</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>os</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>, <decl><type ref="prev"/><name>block</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>should_be_finalizable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>should_be_callable</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>define_final0</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>define_final0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>FL_FINALIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>table</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>idEq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>recv</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>block</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_define_finalizer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>should_be_finalizable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>should_be_callable</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>define_final0</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_copy_finalizer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>table</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>run_single_final</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>final</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>objid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>cmd</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>final</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>objid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>run_finalizer</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>table</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>

<struct><specifier>volatile</specifier> struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>errinfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>objid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>finished</name></decl>;</decl_stmt>

}</block> <decl><name>saved</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_FINALIZER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(ec-&gt;cfp = saved.cfp, rb_set_errinfo(saved.errinfo))</cpp:value></cpp:define>

<expr_stmt><expr><name><name>saved</name><operator>.</operator><name>errinfo</name></name> <operator>=</operator> <call><name>rb_errinfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>saved</name><operator>.</operator><name>objid</name></name> <operator>=</operator> <call><name>rb_obj_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>saved</name><operator>.</operator><name>cfp</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>saved</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>saved</name><operator>.</operator><name>finished</name></name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>saved</name><operator>.</operator><name>finished</name></name></expr>;</init>

<condition><expr><call><name>RESTORE_FINALIZER</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition>

<incr><expr><name><name>saved</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>run_single_final</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>saved</name><operator>.</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RESTORE_FINALIZER</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>run_final</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>zombie</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>table</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RZOMBIE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>dfree</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RZOMBIE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>dfree</name><argument_list>(<argument><expr><call><name>RZOMBIE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>zombie</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>run_finalizer</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>zombie</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>finalize_list</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>zombie</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>zombie</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next_zombie</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next_zombie</name> <operator>=</operator> <call><name>RZOMBIE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>run_final</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ZOMBIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>obj_free_object_id</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RZOMBIE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>basic</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>heap_pages_final_slots</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>heap_pages_final_slots</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>final_slots</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>zombie</name> <operator>=</operator> <name>next_zombie</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>finalize_deferred</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>zombie</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>zombie</name> <operator>=</operator> <call><name>ATOMIC_VALUE_EXCHANGE</name><argument_list>(<argument><expr><name>heap_pages_deferred_final</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>finalize_list</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>zombie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_finalize_deferred</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dmy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name>dmy</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name>finalizing</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>finalize_deferred</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ATOMIC_SET</name><argument_list>(<argument><expr><name>finalizing</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_finalize_deferred_register</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_postponed_job_register_one</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>gc_finalize_deferred</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_finalize_deferred_register: can't register finalizer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>force_finalize_list</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>force_finalize_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>force_chain_object</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>force_finalize_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>prev</name> <init>= <expr><operator>(</operator>struct <name>force_finalize_list</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>force_finalize_list</name></name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>force_finalize_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_call_finalizer</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name>finalizing</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>finalize_deferred</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>heap_pages_deferred_final</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>finalizer_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>force_finalize_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>force_chain_object</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>force_finalize_list</name></name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>curr</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>run_finalizer</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>curr</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name><name>curr</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></while>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_enter</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_objspace_call_finalizer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>start</name></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>total_slots</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_DATA</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dfree</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_thread</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_mutex</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_fiber</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RDATA</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>dfree</name> <operator>=</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dfree</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dfree</name></name> <operator>==</operator> <name>RUBY_DEFAULT_FREE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dfree</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dfree</name></name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_FILE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_io_zombie</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></for>

<expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_objspace_call_finalizer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_deferred_final</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>finalize_list</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_pages_deferred_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>finalizer_table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ATOMIC_SET</name><argument_list>(<argument><expr><name>finalizing</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>PUREFUNC</name><argument_list>(<argument>static inline int is_id_value(rb_objspace_t *objspace, VALUE ptr)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_id_value</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>T_FIXNUM</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ICLASS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>heap_is_swept_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>before_sweep</name></name></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_swept_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>heap_is_swept_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_garbage_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>is_swept_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_live_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NONE</name></expr>:</case>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_garbage_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_markable_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_special_const_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_objspace_markable_object_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_live_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_objspace_garbage_object_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>is_garbage_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>id2ref_obj_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>objid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name></expr></argument>, <argument><expr><name>objid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>orig</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>id2ref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>objid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2ULONG(x)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2ULL(x)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p0</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_big_size</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SIZEOF_VOIDP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>NUM2PTR</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>Qtrue</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ptr</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FLONUM_P</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>obj_id_to_ref</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>==</operator> <operator>(</operator><literal type="number">4</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>symid</name> <init>= <expr><name>ptr</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>symid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%p is not symbol id value"</literal></expr></argument>, <argument><expr><name>p0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>symid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>orig</name> <operator>=</operator> <call><name>id2ref_obj_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator>

<call><name>is_live_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>orig</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_int_ge</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>next_object_id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%+"</literal><name>PRIsVALUE</name><literal type="string">" is not id value"</literal></expr></argument>, <argument><expr><call><name>rb_int2str</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%+"</literal><name>PRIsVALUE</name><literal type="string">" is recycled object"</literal></expr></argument>, <argument><expr><call><name>rb_int2str</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>os_id2ref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>os</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>objid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>id2ref</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_find_object_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>get_heap_object_id</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STATIC_SYM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><literal type="number">4</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <name>FIXNUM_FLAG</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:if>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>LL2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>get_heap_object_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>cached_object_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>id</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>next_object_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>next_object_id</name></name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>OBJ_ID_INCREMENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_SEEN_OBJ_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>id</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nonspecial_obj_id_</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>nonspecial_obj_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_memory_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_find_object_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>nonspecial_obj_id_</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_find_object_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>cached_object_id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>obj_memsize_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_all_types</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_generic_ivar_memsize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>ROBJECT_EMBED</name><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>numiv</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_id_table_memsize</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ptr</name><operator>-&gt;</operator><name>iv_tbl</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ptr</name><operator>-&gt;</operator><name>iv_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ptr</name><operator>-&gt;</operator><name>const_tbl</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_id_table_memsize</name><argument_list>(<argument><expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ptr</name><operator>-&gt;</operator><name>const_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rb_classext_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_id_table_memsize</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_str_memsize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_ary_memsize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_HASH</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<function_decl><type><name>size_t</name></type> <name>rb_hash_ar_table_size</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_hash_ar_table_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>onig_memsize</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_DATA</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>use_all_types</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_objspace_data_type_memsize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_MATCH</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rmatch</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rmatch</name></name> <modifier>*</modifier></type><name>rm</name> <init>= <expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rmatch</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>onig_region_memsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rmatch_offset</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rmatch</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_FILE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RFILE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_io_memsize</name><argument_list>(<argument><expr><call><name>RFILE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_RATIONAL</name></expr>:</case>

<case>case <expr><name>T_COMPLEX</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>imemo_memsize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>BIGNUM_EMBED_FLAG</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>BIGNUM_DIGITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BDIGIT</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>obj_memsize_of</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRUCT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>RSTRUCT_EMBED_LEN_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>RSTRUCT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>RSTRUCT_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"objspace/memsize_of(): unknown data type 0x%x(%p)"</literal></expr></argument>,

<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_obj_memsize_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>obj_memsize_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>set_zero</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>type_sym</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COUNT_TYPE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (t): return ID2SYM(rb_intern(#t)); break;</cpp:value></cpp:define>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_STRUCT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_RATIONAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_FIXNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_ZOMBIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COUNT_TYPE</name><argument_list>(<argument><expr><name>T_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COUNT_TYPE</name></cpp:undef>

<default>default:</default> <return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>count_objects</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>os</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name><name>counts</name><index>[<expr><name>T_MASK</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>freed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>T_MASK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>heap_allocated_pages</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name><name>heap_pages_sorted</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition><expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>flags</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>counts</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>freed</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_stlike_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>set_zero</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"TOTAL"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"FREE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>freed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>T_MASK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>type</name> <init>= <expr><call><name>type_sym</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>objspace_available_slots</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>+</operator> <name><name>heap_tomb</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>objspace_live_slots</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>total_allocated_objects</name></name> <operator>-</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name><operator>)</operator> <operator>-</operator> <name>heap_pages_final_slots</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>objspace_free_slots</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>objspace_available_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>objspace_live_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>heap_pages_final_slots</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_setup_mark_bits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>mark_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>uncollectible_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>gc_page_sweep</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>sweep_page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>empty_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>freed_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>final_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>bits</name></decl>, <decl><type ref="prev"/><name>bitset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"page_sweep: start.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sweep_page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>before_sweep</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>sweep_page</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>sweep_page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>p</name> <operator>-</operator> <call><name>NUM_IN_PAGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>sweep_page</name><operator>-&gt;</operator><name>mark_bits</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bits</name><index>[<expr><call><name>BITMAP_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>|=</operator> <call><name>BITMAP_BIT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bits</name><index>[<expr><call><name>BITMAP_INDEX</name><argument_list>(<argument><expr><name>pend</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>|=</operator> <operator>~</operator><operator>(</operator><call><name>BITMAP_BIT</name><argument_list>(<argument><expr><name>pend</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HEAP_PAGE_BITMAP_LIMIT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>bitset</name> <operator>=</operator> <operator>~</operator><name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bitset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>BITS_BITLENGTH</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bitset</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<default>default:</default> <block>{<block_content> 

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"page_sweep: free %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page_sweep: %p - old while minor GC."</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rgengc_remembered_sweep</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page_sweep: %p - remembered."</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>obj_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>final_slots</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"page_sweep: %s is added to freelist\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>freed_slots</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_NONE</name></expr>:</case>

<expr_stmt><expr><name>empty_slots</name><operator>++</operator></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bitset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>bitset</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>gc_setup_mark_bits</name><argument_list>(<argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>removing_objects</name></name> <operator>+=</operator> <name>final_slots</name> <operator>+</operator> <name>freed_slots</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>empty_objects</name></name> <operator>+=</operator> <name>empty_slots</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gc_page_sweep(%d): total_slots: %d, freed_slots: %d, empty_slots: %d, final_slots: %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_gc_count</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sweep_page</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>,

<argument><expr><name>freed_slots</name></expr></argument>, <argument><expr><name>empty_slots</name></expr></argument>, <argument><expr><name>final_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>sweep_page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>=</operator> <name>freed_slots</name> <operator>+</operator> <name>empty_slots</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name> <operator>+=</operator> <name>freed_slots</name></expr>;</expr_stmt>

<expr_stmt><expr><name>heap_pages_final_slots</name> <operator>+=</operator> <name>final_slots</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sweep_page</name><operator>-&gt;</operator><name>final_slots</name></name> <operator>+=</operator> <name>final_slots</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_deferred_final</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>finalizing</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_finalize_deferred_register</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"page_sweep: end.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>freed_slots</name> <operator>+</operator> <name>empty_slots</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_heap_prepare_minimum_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>&amp;&amp;</operator> <call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_set_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>gc_mode_name</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gc_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>gc_mode_none</name></expr>:</case> <return>return <expr><literal type="string">"none"</literal></expr>;</return>

<case>case <expr><name>gc_mode_marking</name></expr>:</case> <return>return <expr><literal type="string">"marking"</literal></expr>;</return>

<case>case <expr><name>gc_mode_sweeping</name></expr>:</case> <return>return <expr><literal type="string">"sweeping"</literal></expr>;</return>

<default>default:</default> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_mode_name: unknown mode: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mode_transition</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>gc_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>enum</name> <name>gc_mode</name></name></type> <name>prev_mode</name> <init>= <expr><call><name>gc_mode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>prev_mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>gc_mode_none</name></expr>:</case> <expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>gc_mode_marking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>gc_mode_marking</name></expr>:</case> <expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>gc_mode_sweeping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>gc_mode_sweeping</name></expr>:</case> <expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>gc_mode_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gc_mode_transition: %s-&gt;%s\n"</literal></expr></argument>, <argument><expr><call><name>gc_mode_name</name><argument_list>(<argument><expr><call><name>gc_mode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gc_mode_name</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_mode_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep_start_heap</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>sweeping_page</name></name> <operator>=</operator> <call><name>list_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heap</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr>struct <name>heap_page</name></expr></argument>, <argument><expr><name>page_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>pooled_slots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>using_page</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name><name>heap</name><operator>-&gt;</operator><name>using_page</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>next</name></name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>using_page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__GNUC__</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>__GNUC_MINOR__</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>

<macro><name>__attribute__</name><argument_list>(<argument>(noinline)</argument>)</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mode_transition</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>gc_mode_sweeping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_sweep_start_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep_finish</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_sweep_finish\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_prof_set_heap_info</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_pages_free_unused_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_allocatable_pages</name> <operator>&lt;</operator> <name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_allocatable_pages_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_GC_END_SWEEP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mode_transition</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>gc_mode_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_sweep_step</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>sweep_page</name> <init>= <expr><name><name>heap</name><operator>-&gt;</operator><name>sweeping_page</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>unlink_limit</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>need_pool</name> <init>= <expr><ternary><condition><expr><call><name>will_be_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_sweep_step (need_pool: %d)\n"</literal></expr></argument>, <argument><expr><name>need_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_sweep_step\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>sweep_page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_LAZY_SWEEP</name></expr></cpp:if>

<expr_stmt><expr><call><name>gc_prof_sweep_timer_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>free_slots</name> <init>= <expr><call><name>gc_page_sweep</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>sweeping_page</name></name> <operator>=</operator> <call><name>list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heap</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>, <argument><expr><name>page_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sweep_page</name><operator>-&gt;</operator><name>final_slots</name></name> <operator>+</operator> <name>free_slots</name> <operator>==</operator> <name><name>sweep_page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>&amp;&amp;</operator>

<name>heap_pages_freeable_pages</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<name>unlink_limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>heap_pages_freeable_pages</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>unlink_limit</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_unlink_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_add_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_tomb</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>free_slots</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>need_pool</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>heap_add_poolpage</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>need_pool</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>heap_add_freepage</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>heap_add_freepage</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>sweep_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>sweep_page</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>sweep_page</name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>sweeping_page</name></name><operator>)</operator></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>sweeping_page</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_sweep_finish</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_LAZY_SWEEP</name></expr></cpp:if>

<expr_stmt><expr><call><name>gc_prof_sweep_timer_stop</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name> <init>= <expr><name>heap_eden</name></expr></init></decl>;</decl_stmt> 

<while>while <condition>(<expr><call><name>has_sweeping_pages</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_sweep_step</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep_continue</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>dont_gc</name> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>GC_ENABLE_LAZY_SWEEP</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_enter</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"sweep_continue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>==</operator> <name>GPR_FLAG_NONE</name> <operator>&amp;&amp;</operator> <call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_sweep_continue: success heap_increment().\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_sweep_step</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"sweep_continue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_sweep</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>immediate_sweep</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_sweep: immediate: %d\n"</literal></expr></argument>, <argument><expr><name>immediate_sweep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>immediate_sweep</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GC_ENABLE_LAZY_SWEEP</name></expr></cpp:if>

<expr_stmt><expr><call><name>gc_prof_sweep_timer_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_sweep_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_sweep_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GC_ENABLE_LAZY_SWEEP</name></expr></cpp:if>

<expr_stmt><expr><call><name>gc_prof_sweep_timer_stop</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_sweep_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap_eden-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>before_sweep</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>gc_sweep_step</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_heap_prepare_minimum_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>stack_chunk_t</name> <modifier>*</modifier></type>

<name>stack_chunk_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stack_chunk_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>is_mark_stack_empty</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name> <operator>==</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>mark_stack_size</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><ternary><condition><expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name></expr> ?</condition><then> <expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>chunk</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>add_stack_chunk_cache</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>shrink_stack_chunk_cache</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>unused_cache_size</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>unused_cache_size</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>push_mark_stack_chunk</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>unused_cache_size</name></name> <operator>&gt;</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>unused_cache_size</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>stack_chunk_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>pop_mark_stack_chunk</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_stack_chunk_cache</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_stack_chunks</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>push_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NIL</name></expr>:</case>

<case>case <expr><name>T_FIXNUM</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"push_mark_stack() called for broken object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>push_mark_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>push_mark_stack_chunk</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>pop_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_mark_stack_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pop_mark_stack_chunk</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>invalidate_mark_stack_chunk</name><parameter_list>(<parameter><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>obj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>invalidate_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>stack_chunk_t</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>chunk</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>chunk</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>invalidate_mark_stack_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"invalid_mark_stack: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>init_mark_stack</name><parameter_list>(<parameter><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>mark_stack_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name>STACK_CHUNK_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>add_stack_chunk_cache</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>stack_chunk_alloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>unused_cache_size</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>cache_size</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_STACK_END</name></cpp:macro> <cpp:value>SET_MACHINE_STACK_END(&amp;ec-&gt;machine.stack_end)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_START</name></cpp:macro> <cpp:value>(ec-&gt;machine.stack_start)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_END</name></cpp:macro> <cpp:value>(ec-&gt;machine.stack_end)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LEVEL_MAX</name></cpp:macro> <cpp:value>(ec-&gt;machine.stack_maxsize/sizeof(VALUE))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STACK_GROW_DIRECTION</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_GROW_DIRECTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STACK_GROW_DIRECTION</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LENGTH</name></cpp:macro> <cpp:value>(size_t)(STACK_START - STACK_END)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>STACK_GROW_DIRECTION</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LENGTH</name></cpp:macro> <cpp:value>(size_t)(STACK_END - STACK_START + 1)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LENGTH</name></cpp:macro> <cpp:value>((STACK_END &lt; STACK_START) ? (size_t)(STACK_START - STACK_END) : (size_t)(STACK_END - STACK_START + 1))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>STACK_GROW_DIRECTION</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>ruby_stack_grow_direction</name></decl>;</decl_stmt>

<function><type><name>int</name></type>

<name>ruby_get_stack_grow_direction</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SET_MACHINE_STACK_END</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>addr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ruby_stack_grow_direction</name> <operator>=</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ruby_stack_grow_direction</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type>

<name>ruby_stack_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>SET_STACK_END</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>STACK_UPPER</name><argument_list>(<argument><expr><name>STACK_END</name></expr></argument>, <argument><expr><name>STACK_START</name></expr></argument>, <argument><expr><name>STACK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>STACK_LENGTH</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREVENT_STACK_OVERFLOW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PREVENT_STACK_OVERFLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_SIGNAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGALTSTACK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREVENT_STACK_OVERFLOW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREVENT_STACK_OVERFLOW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PREVENT_STACK_OVERFLOW</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>stack_check</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>water_mark</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>SET_STACK_END</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><name>STACK_LENGTH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>maximum_length</name> <init>= <expr><name>STACK_LEVEL_MAX</name> <operator>-</operator> <name>water_mark</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>length</name> <operator>&gt;</operator> <name>maximum_length</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stack_check</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>, <parameter><type><name>water_mark</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKFRAME_FOR_CALL_CFUNC</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>

<name>rb_ec_stack_check</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>STACKFRAME_FOR_CALL_CFUNC</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_stack_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stack_check</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STACKFRAME_FOR_CALL_CFUNC</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS</name><argument_list>(<argument>static void mark_locations_array(rb_objspace_t *objspace, register const VALUE *x, register long n)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_locations_array</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>*</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_maybe</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_locations</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;=</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_locations_array</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_locations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_locations</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_values</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_values</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_and_pin_stack_values</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>T_MOVED</name> <operator>!=</operator> <call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_vm_stack_values</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin_stack_values</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mark_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mark_value_pin</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_tbl_no_pin</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name> <operator>||</operator> <name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_value</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name> <operator>||</operator> <name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_value_pin</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mark_key</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_finalizer_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_value</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mark_set</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>mark_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mark_keyvalue</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>pin_key_pin_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>pin_key_mark_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_hash</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_compare_by_id_p</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_stlike_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>pin_key_mark_value</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_stlike_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>mark_keyvalue</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transient_heap_mark</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_st</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>pin_key_pin_value</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mark_hash</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>mark_st</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_method_entry</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>def</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hook_list_mark</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>mark_method_entry_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>me</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_m_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>tbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_method_entry_i</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>mark_const_entry_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_const_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>mark_const_entry_i</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STACK_GROW_DIRECTION</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_STACK_BOUNDS</name><parameter_list>(<parameter><type><name>start</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>appendix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((start) = STACK_END, (end) = STACK_START)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>STACK_GROW_DIRECTION</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_STACK_BOUNDS</name><parameter_list>(<parameter><type><name>start</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>appendix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((start) = STACK_START, (end) = STACK_END+(appendix))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_STACK_BOUNDS</name><parameter_list>(<parameter><type><name>start</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>appendix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((STACK_END &lt; STACK_START) ? ((start) = STACK_END, (end) = STACK_START) : ((start) = STACK_START, (end) = STACK_END+(appendix)))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mark_stack_locations</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>stack_end</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_current_machine_context</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<union>union <block>{

<decl_stmt><decl><type><name>rb_jmp_buf</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>v</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_jmp_buf</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name>save_regs_gc_mark</name></decl>;</union>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stack_end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>FLUSH_REGISTER_WINDOWS</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_regs_gc_mark</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>save_regs_gc_mark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_setjmp</name><argument_list>(<argument><expr><name><name>save_regs_gc_mark</name><operator>.</operator><name>j</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>SET_STACK_END</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_STACK_BOUNDS</name><argument_list>(<argument><expr><name>stack_start</name></expr></argument>, <argument><expr><name>stack_end</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_locations_array</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>save_regs_gc_mark</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name><name>save_regs_gc_mark</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_stack_locations</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name>stack_start</name></expr></argument>, <argument><expr><name>stack_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_machine_stack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stack_end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GET_STACK_BOUNDS</name><argument_list>(<argument><expr><name>stack_start</name></expr></argument>, <argument><expr><name>stack_end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_stack_locations</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name>stack_start</name></expr></argument>, <argument><expr><name>stack_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mark_stack_locations</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>stack_start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>stack_end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_locations</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>stack_start</name></expr></argument>, <argument><expr><name>stack_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mc68000__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>gc_mark_locations</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>stack_start</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>stack_end</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mark_tbl</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>mark_tbl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mark_tbl_no_pin</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>mark_tbl_no_pin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_maybe</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>__asan_region_is_poisoned</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><name>SIZEOF_VALUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<case>case <expr><name>T_NONE</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_maybe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_maybe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>gc_mark_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_remember_unprotected</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>uncollectible_bits</name> <init>= <expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>uncollectible_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><name>uncollectible_bits</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><name>uncollectible_bits</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_remembered_shady_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>remembered_shady_object_count_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rgengc_check_relation</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>old_parent</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>parent_object</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_parent</name></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_remember_unprotected</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"relation: (O-&gt;S) %s -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>old_parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"relation: (O-&gt;unmarked Y) %s -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>old_parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_SET_OLD</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_grey</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rgengc_remember</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"relation: (O-&gt;Y) %s -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>old_parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_SET_CANDIDATE</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>old_parent</name> <operator>==</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>parent_object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_grey</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_grey: %s is not marked."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TRUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_grey: %s is marking/remembered."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>push_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_aging</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_PAGE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_aging: YOUNG: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_INC</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_PAGE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_PAGE_OLD_UNCOLLECTIBLE_SET</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static void gc_mark_ptr(rb_objspace_t *objspace, VALUE obj)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_ptr</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rgengc_check_relation</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gc_mark_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_NONE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"try to mark T_NONE object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_aging</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_grey</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name><operator>-&gt;</operator><name>mark_func</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_pin</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_compacting</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_PINNED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_mark_and_pin</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_ptr</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_mark</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_mark_ptr</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark_movable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_mark</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_and_pin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_objspace_marked_object_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_mark_set_parent</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>parent_object</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>parent_object</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_imemo</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_env</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_values</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_WB_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_vm_env_prev_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return;</return>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>refinements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>cref_or_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>backref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>others</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_throw_data</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>throw_data</name><operator>.</operator><name>throw_obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_ifunc</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark_maybe</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ifunc</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_memo</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>memo</name><operator>.</operator><name>v1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>memo</name><operator>.</operator><name>v2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_maybe</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>memo</name><operator>.</operator><name>u3</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<expr_stmt><expr><call><name>mark_method_entry</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_iseq</name></expr>:</case>

<expr_stmt><expr><call><name>rb_iseq_mark</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_tmpbuf</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_imemo_tmpbuf_t</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>alloc</name></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_locations</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>m</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

</block_content>}</block>

<return>return;</return>

<case>case <expr><name>imemo_ast</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ast_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_parser_strterm</name></expr>:</case>

<expr_stmt><expr><call><name>rb_strterm_mark</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>imemo_callinfo</name></expr>:</case>

<return>return;</return>

<case>case <expr><name>imemo_callcache</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<default>default:</default>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>gc_mark_imemo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_children</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>register</specifier> <name>RVALUE</name> <modifier>*</modifier></type><name>any</name> <init>= <expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark_set_parent</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_mark_generic_ivar</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<return>return;</return>

<case>case <expr><name>T_NIL</name></expr>:</case>

<case>case <expr><name>T_FIXNUM</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_mark() called for broken object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>rb_gc_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark_imemo</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mark_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cc_table_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_tbl_no_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_const_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mark_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mark_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cc_table_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>root</name> <init>= <expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>array</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RARRAY_EMBED_FLAG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transient_heap_mark</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_HASH</name></expr>:</case>

<expr_stmt><expr><call><name>mark_hash</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRING</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>string</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_DATA</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RUBY_DATA_FUNC</name></type> <name>mark_func</name> <init>= <expr><ternary><condition><expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dmark</name></name></expr> </then><else>:

<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>data</name><operator>.</operator><name>dmark</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mark_func</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>mark_func</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<call><name>ROBJ_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transient_heap_mark</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>T_FILE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>regexp</name><operator>.</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_MATCH</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>regexp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>str</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_RATIONAL</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>rational</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>rational</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_COMPLEX</name></expr>:</case>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>complex</name><operator>.</operator><name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>complex</name><operator>.</operator><name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRUCT</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRUCT_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name>RSTRUCT_CONST_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<call><name>RSTRUCT_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transient_heap_mark</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_gcdebug_print_obj_condition</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MOVED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_mark(): %p is T_MOVED"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_mark(): %p is T_NONE"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ZOMBIE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_mark(): %p is T_ZOMBIE"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_mark(): unknown data type 0x%x(%p) %s"</literal></expr></argument>,

<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>any</name></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>any</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"corrupted object"</literal></expr> </then><else>: <expr><literal type="string">"non object"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>gc_mark_stacked_objects</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>incremental</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mark_stack_t</name> <modifier>*</modifier></type><name>mstack</name> <init>= <expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>marked_slots_at_the_beginning</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>popped_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><call><name>pop_mark_stack</name><argument_list>(<argument><expr><name>mstack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_mark_stacked_objects: %s is not marked."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_mark_children</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>incremental</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_mark_stacked_objects: incremental, but marking bit is 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>popped_count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped_count</name> <operator>+</operator> <operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name> <operator>-</operator> <name>marked_slots_at_the_beginning</name><operator>)</operator> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mark_stack_empty</name><argument_list>(<argument><expr><name>mstack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>shrink_stack_chunk_cache</name><argument_list>(<argument><expr><name>mstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_mark_stacked_objects_incremental</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>gc_mark_stacked_objects</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_mark_stacked_objects_all</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>gc_mark_stacked_objects</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PRINT_ROOT_TICKS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TICKS</name></cpp:macro> <cpp:value>0x100</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>tick_t</name></type> <name><name>mark_ticks</name><index>[<expr><name>MAX_TICKS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>mark_ticks_categories</name><index>[<expr><name>MAX_TICKS</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>show_mark_ticks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"mark ticks result:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MAX_TICKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name> <init>= <expr><name><name>mark_ticks_categories</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>category</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\t%8lu\n"</literal></expr></argument>, <argument><expr><name>category</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>mark_ticks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_roots</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>categoryp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PRINT_ROOT_TICKS</name></expr></cpp:if>

<decl_stmt><decl><type><name>tick_t</name></type> <name>start_tick</name> <init>= <expr><call><name>tick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tick_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_category</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mark_ticks_categories</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>show_mark_ticks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>categoryp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>categoryp</name> <operator>=</operator> <literal type="string">"xxx"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>parent_object</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PRINT_ROOT_TICKS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_CHECKPOINT_PRINT_TICK</name><parameter_list>(<parameter><type><name>category</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (prev_category) { tick_t t = tick(); mark_ticks[tick_count] = t - start_tick; mark_ticks_categories[tick_count] = prev_category; tick_count++; } prev_category = category; start_tick = tick(); } while (0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_CHECKPOINT_PRINT_TICK</name><parameter_list>(<parameter><type><name>category</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_CHECKPOINT</name><parameter_list>(<parameter><type><name>category</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (categoryp) *categoryp = category; MARK_CHECKPOINT_PRINT_TICK(category); } while (0)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"vm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>SET_STACK_END</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_mark</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>self</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>vm</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"finalizers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_finalizer_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>finalizer_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"machine_context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_current_machine_context</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"global_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <name>global_list</name></expr>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_maybe</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>*</operator><name><name>list</name><operator>-&gt;</operator><name>varptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"end_proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mark_end_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"global_tbl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_global_tbl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"object_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>next_object_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mark_tbl_no_pin</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>stress_to_class</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MARK_CHECKPOINT</name><argument_list>(<argument><expr><literal type="string">"finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MARK_CHECKPOINT</name></cpp:undef>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKE_ROOTSIG</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((VALUE)(obj) &lt;&lt; 1) | 0x01)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ROOTSIG</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((VALUE)(obj) &amp; 0x01)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ROOTSIG</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((const char *)((VALUE)(obj) &gt;&gt; 1))</cpp:value></cpp:define>

<struct>struct <name>reflist</name> <block>{

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type>

<name>reflist_create</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>reflist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>refs</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>refs</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reflist_destruct</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>refs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reflist_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>refs</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <name><name>refs</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><name><name>refs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>refs</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>refs</name><operator>-&gt;</operator><name>size</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>refs</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>refs</name><operator>-&gt;</operator><name>pos</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reflist_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>refs</name><operator>-&gt;</operator><name>pos</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name><name>refs</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_ROOTSIG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;root@%s&gt;"</literal></expr></argument>, <argument><expr><call><name>GET_ROOTSIG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;%s&gt;"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>refs</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reflist_referred_from_machine_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>refs</name><operator>-&gt;</operator><name>pos</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name><name>refs</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_ROOTSIG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>GET_ROOTSIG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"machine_context"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>allrefs</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>references</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>root_obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mark_stack_t</name></type> <name>mark_stack</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>allrefs_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>allrefs</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>references</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>refs</name> <operator>=</operator> <operator>(</operator>struct <name>reflist</name> <operator>*</operator><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reflist_add</name><argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>root_obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>reflist_create</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>root_obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>references</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>allrefs_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>allrefs</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>allrefs</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>allrefs_add</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>push_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>allrefs_roots_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>allrefs</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>allrefs</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>category</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"!!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>root_obj</name></name> <operator>=</operator> <call><name>MAKE_ROOTSIG</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>category</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>allrefs_add</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>push_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>

<name>objspace_allrefs</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>allrefs</name></name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>mark_func_data_struct</name></name></type> <name>mfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_dont_gc</name> <init>= <expr><name>dont_gc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>objspace</name></name> <operator>=</operator> <name>objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>references</name></name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>mark_func</name></name> <operator>=</operator> <name>allrefs_roots_i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>mark_func_data</name></name> <operator>=</operator> <operator>&amp;</operator><name>mfd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_roots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>category</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>pop_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>mark_stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_reachable_objects_from</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>root_obj</name></name> <operator>=</operator> <name>obj</name></expr></argument>, <argument><expr><name>allrefs_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free_stack_chunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <name>prev_dont_gc</name></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>.</operator><name>references</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>objspace_allrefs_destruct_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><operator>(</operator>struct <name>reflist</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>reflist_destruct</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_allrefs_destruct</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>refs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><name>objspace_allrefs_destruct_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>allrefs_dump_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>k</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><operator>(</operator>struct <name>reflist</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[allrefs_dump_i] %s &lt;- "</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reflist_dump</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>allrefs_dump</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[all refs] (size: %d)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name></name></expr></argument>, <argument><expr><name>allrefs_dump_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_check_after_marks_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name>k</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>reflist</name></name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><operator>(</operator>struct <name>reflist</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gc_check_after_marks_i: %s is not marked and not oldgen.\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gc_check_after_marks_i: %p is referred from "</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reflist_dump</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>reflist_referred_from_machine_context</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" (marked from machine stack).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>error_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_check</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>checker_func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>checker_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>saved_malloc_increase</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>increase</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>saved_oldmalloc_increase</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>VALUE</name></type> <name>already_disabled</name> <init>= <expr><call><name>rb_objspace_gc_disable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name></name> <operator>=</operator> <call><name>objspace_allrefs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>checker_func</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name></name></expr></argument>, <argument><expr><name>checker_func</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>error_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr></cpp:if>

<expr_stmt><expr><call><name>allrefs_dump</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>checker_name</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"%s: GC has problem."</literal></expr></argument>, <argument><expr><name>checker_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>objspace_allrefs_destruct</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>allrefs_table</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>already_disabled</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_objspace_gc_enable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>increase</name></name> <operator>=</operator> <name>saved_malloc_increase</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name> <operator>=</operator> <name>saved_oldmalloc_increase</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<struct>struct <name>verify_internal_consistency_struct</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>live_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>zombie_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>parent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_object_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>remembered_shady_count</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_generation_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>verify_internal_consistency_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>verify_internal_consistency_struct</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>parent</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_REMEMBERED</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>RVALUE_REMEMBERED</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>RVALUE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"verify_internal_consistency_reachable_i: WB miss (O-&gt;Y) %s -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>err_count</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_color_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>verify_internal_consistency_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>verify_internal_consistency_struct</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>parent</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RVALUE_WHITE_P</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"verify_internal_consistency_reachable_i: WB miss (B-&gt;W) - %s -&gt; %s\n"</literal></expr></argument>,

<argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>err_count</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_children_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>verify_internal_consistency_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>verify_internal_consistency_struct</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_rvalue_consistency_force</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"check_children_i: %s has error (referenced from %s)"</literal></expr></argument>,

<argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_print_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>err_count</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>verify_internal_consistency_i</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>page_start</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>page_end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>verify_internal_consistency_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>verify_internal_consistency_struct</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>objspace</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>obj</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>page_start</name></expr>;</init> <condition><expr><name>obj</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>page_end</name></expr>;</condition> <incr><expr><name>obj</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_live_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>live_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_reachable_objects_from</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>check_children_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>old_object_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RVALUE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>remembered_shady_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_objspace_reachable_objects_from</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>check_generation_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_BLACK_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_objspace_reachable_objects_from</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>check_color_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ZOMBIE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>FL_SEEN_OBJ_ID</name><operator>)</operator> <operator>==</operator> <name>T_ZOMBIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>zombie_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_verify_heap_page</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_remembered_shady</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>has_remembered_old</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>remembered_old_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>free_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>zombie_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>free_objects</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ZOMBIE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zombie_objects</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_PAGE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RVALUE_PAGE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>has_remembered_shady</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_PAGE_MARKING</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>has_remembered_old</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>remembered_old_objects</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator> <name>has_remembered_old</name> <operator>==</operator> <name>TRUE</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_PAGE_MARKING</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"marking -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page %p's has_remembered_objects should be false, but there are remembered old objects (%d). %s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><name>remembered_old_objects</name></expr></argument>, <argument><expr><ternary><condition><expr><name>obj</name></expr> ?</condition><then> <expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator> <name>has_remembered_shady</name> <operator>==</operator> <name>TRUE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page %p's has_remembered_shady should be false, but there are remembered shady objects. %s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><ternary><condition><expr><name>obj</name></expr> ?</condition><then> <expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>!=</operator> <name>free_objects</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page %p's free_slots should be %d, but %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name></expr></argument>, <argument><expr><name>free_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>final_slots</name></name> <operator>!=</operator> <name>zombie_objects</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"page %p's final_slots should be %d, but %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>page</name><operator>-&gt;</operator><name>final_slots</name></name></expr></argument>, <argument><expr><name>zombie_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>remembered_old_objects</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_verify_heap_pages_</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>list_head</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>remembered_old_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>head</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"freelist slot expected to be T_NONE but was: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>free</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>remembered_old_objects</name> <operator>+=</operator> <call><name>gc_verify_heap_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>remembered_old_objects</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_verify_heap_pages</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>remembered_old_objects</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>remembered_old_objects</name> <operator>+=</operator> <call><name>gc_verify_heap_pages_</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heap_eden</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>remembered_old_objects</name> <operator>+=</operator> <call><name>gc_verify_heap_pages_</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heap_tomb</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>remembered_old_objects</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_verify_internal_consistency_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_verify_internal_consistency</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>verify_internal_consistency_struct</name></name></type> <name>data</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>objspace</name></name> <operator>=</operator> <name>objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_verify_internal_consistency: start\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>objspace_each_objects_without_setup</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>verify_internal_consistency_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>err_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>error_count</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>err_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_check</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>allrefs_dump</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_verify_internal_consistency: found internal inconsistency."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_verify_heap_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>finalizing</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>objspace_live_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>data</name><operator>.</operator><name>live_object_count</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"heap_pages_final_slots: %d, objspace-&gt;profile.total_freed_objects: %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_pages_final_slots</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"inconsistent live slot number: expect %"</literal><name>PRIuSIZE</name><literal type="string">", but %"</literal><name>PRIuSIZE</name><literal type="string">"."</literal></expr></argument>, <argument><expr><call><name>objspace_live_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>live_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>!=</operator> <name><name>data</name><operator>.</operator><name>old_object_count</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"inconsistent old slot number: expect %"</literal><name>PRIuSIZE</name><literal type="string">", but %"</literal><name>PRIuSIZE</name><literal type="string">"."</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>old_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name> <operator>!=</operator> <name><name>data</name><operator>.</operator><name>remembered_shady_count</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"inconsistent old slot number: expect %"</literal><name>PRIuSIZE</name><literal type="string">", but %"</literal><name>PRIuSIZE</name><literal type="string">"."</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>remembered_shady_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finalizing</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>list_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name> <init>= <expr><name>heap_pages_deferred_final</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>z</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list_count</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>RZOMBIE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>heap_pages_final_slots</name> <operator>!=</operator> <name><name>data</name><operator>.</operator><name>zombie_object_count</name></name> <operator>||</operator>

<name>heap_pages_final_slots</name> <operator>!=</operator> <name>list_count</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"inconsistent finalizing object count:\n"</literal>

<literal type="string">" expect %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal>

<literal type="string">" but %"</literal><name>PRIuSIZE</name><literal type="string">" zombies\n"</literal>

<literal type="string">" heap_pages_deferred_final list has %"</literal><name>PRIuSIZE</name><literal type="string">" items."</literal></expr></argument>,

<argument><expr><name>heap_pages_final_slots</name></expr></argument>,

<argument><expr><name><name>data</name><operator>.</operator><name>zombie_object_count</name></name></expr></argument>,

<argument><expr><name>list_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_verify_internal_consistency: OK\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_verify_internal_consistency</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_verify_transient_heap_internal_consistency</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dmy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_transient_heap_verify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>full_mark</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_start: (%s)\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>full_mark</name></expr> ?</condition><then> <expr><literal type="string">"full"</literal></expr> </then><else>: <expr><literal type="string">"minor"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mode_transition</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>gc_mode_marking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>full_mark</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>step_slots</name></name> <operator>=</operator> <operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>pooled_slots</name></name> <operator>/</operator> <name>HEAP_PAGE_OBJ_LIMIT</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"objspace-&gt;marked_slots: %d, objspace-&gt;rincgc.pooled_page_num: %d, objspace-&gt;rincgc.step_slots: %d, \n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>pooled_slots</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>step_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_minor_gc</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>major_gc_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>last_major_gc</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rgengc_mark_and_rememberset_clear</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_minor_gc</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name> <operator>=</operator>

<name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>+</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>minor_gc_count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rgengc_rememberset_mark</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_mark_roots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_start: (%s) end, stack in %d\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>full_mark</name></expr> ?</condition><then> <expr><literal type="string">"full"</literal></expr> </then><else>: <expr><literal type="string">"minor"</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>mark_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_wb_unprotected_objects</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap_eden-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>mark_bits</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>mark_bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>wbun_bits</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>wb_unprotected_bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>offset</name> <init>= <expr><name>p</name> <operator>-</operator> <call><name>NUM_IN_PAGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>bits_t</name></type> <name>bits</name> <init>= <expr><name><name>mark_bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name><name>wbun_bits</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>BITS_BITLENGTH</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_wb_unprotected_objects: marked shady: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_children</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bits</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>bits</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block>

<expr_stmt><expr><call><name>gc_mark_stacked_objects_all</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type>

<name>heap_move_pooled_pages_to_free_pages</name><parameter_list>(<parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>page</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>free_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_add_freepage</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>page</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_marks_finish</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>heap_eden</name><operator>-&gt;</operator><name>pooled_pages</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_move_pooled_pages_to_free_pages</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_finish: pooled pages are exists. retry.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <call><name>is_mark_stack_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_marks_finish: mark stack is not empty (%d)."</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>mark_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_mark_roots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mark_stack_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_finish: not empty (%d). retry.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>mark_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_verify_heap_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_marks_finish (incremental): there are remembered old objects."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_incremental_marking</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_wb_unprotected_objects</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>r</name> <init>= <expr><name><name>gc_params</name><operator>.</operator><name>oldobject_limit_factor</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects_limit</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name> <operator>*</operator> <name>r</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects_limit</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>*</operator> <name>r</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></cpp:if>

<expr_stmt><expr><call><name>gc_marks_check</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>gc_check_after_marks_i</name></expr></argument>, <argument><expr><literal type="string">"after_marks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name> <init>= <expr><name>heap_eden</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_slots</name> <init>= <expr><name>heap_allocatable_pages</name> <operator>*</operator> <name>HEAP_PAGE_OBJ_LIMIT</name> <operator>+</operator> <name><name>heap</name><operator>-&gt;</operator><name>total_slots</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sweep_slots</name> <init>= <expr><name>total_slots</name> <operator>-</operator> <name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>max_free_slots</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>total_slots</name> <operator>*</operator> <name><name>gc_params</name><operator>.</operator><name>heap_free_slots_max_ratio</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>min_free_slots</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>total_slots</name> <operator>*</operator> <name><name>gc_params</name><operator>.</operator><name>heap_free_slots_min_ratio</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>full_marking</name> <init>= <expr><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>heap</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>&gt;=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_free_slots</name> <operator>&lt;</operator> <name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_free_slots</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sweep_slots</name> <operator>&gt;</operator> <name>max_free_slots</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>heap_pages_freeable_pages</name> <operator>=</operator> <operator>(</operator><name>sweep_slots</name> <operator>-</operator> <name>max_free_slots</name><operator>)</operator> <operator>/</operator> <name>HEAP_PAGE_OBJ_LIMIT</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>heap_pages_freeable_pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min_free_slots</name> <operator>&lt;</operator> <name><name>gc_params</name><operator>.</operator><name>heap_free_slots</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min_free_slots</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>heap_free_slots</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sweep_slots</name> <operator>&lt;</operator> <name>min_free_slots</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>full_marking</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name> <operator>-</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>last_major_gc</name></name> <operator>&lt;</operator> <name>RVALUE_OLD_AGE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>full_marking</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<goto>goto <name>increment</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_finish: next is full GC!!)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>|=</operator> <name>GPR_FLAG_MAJOR_BY_NOFREE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<label><name>increment</name>:</label>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_finish: heap_set_increment!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_set_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>heap_extend_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>sweep_slots</name></expr></argument>, <argument><expr><name>total_slots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>full_marking</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>r</name> <init>= <expr><name><name>gc_params</name><operator>.</operator><name>oldobject_limit_factor</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects_limit</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name> <operator>*</operator> <name>r</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects_limit</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>*</operator> <name>r</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name> <operator>&gt;</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects_limit</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>|=</operator> <name>GPR_FLAG_MAJOR_BY_SHADY</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name> <operator>&gt;</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects_limit</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>|=</operator> <name>GPR_FLAG_MAJOR_BY_OLDGEN</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_FORCE_MAJOR_GC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>=</operator> <name>GPR_FLAG_MAJOR_BY_FORCE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_finish (marks %d objects, old %d objects, total %d slots, sweep %d slots, increment: %d, next GC: %s)\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>heap</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sweep_slots</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>heap_allocatable_pages</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name></expr> ?</condition><then> <expr><literal type="string">"major"</literal></expr> </then><else>: <expr><literal type="string">"minor"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_transient_heap_finish_marking</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_GC_END_MARK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_step</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slots</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_mark_stacked_objects_incremental</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_marks_finish</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_sweep</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"objspace-&gt;marked_slots: %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_rest\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>pooled_pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<while>while <condition>(<expr><call><name>gc_mark_stacked_objects_incremental</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

</block_content>}</block> while <condition>(<expr><call><name>gc_marks_finish</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition>;</do>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_stacked_objects_all</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_finish</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_sweep</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks_continue</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>dont_gc</name> <operator>==</operator> <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<expr_stmt><expr><call><name>gc_enter</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"marks_continue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>pooled_pages</name></name> <operator>&amp;&amp;</operator> <name>slots</name> <operator>&lt;</operator> <name>HEAP_PAGE_OBJ_LIMIT</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>heap_move_pooled_pages_to_free_pages</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>slots</name> <operator>+=</operator> <name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>from</name> <operator>=</operator> <literal type="string">"pooled-pages"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>slots</name> <operator>=</operator> <name><name>heap</name><operator>-&gt;</operator><name>free_pages</name><operator>-&gt;</operator><name>free_slots</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <literal type="string">"incremented-pages"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>slots</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_continue: provide %d slots from %s.\n"</literal></expr></argument>, <argument><expr><name>slots</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_step</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rincgc</name><operator>.</operator><name>step_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_marks_continue: no more pooled pages (stack depth: %d).\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>mark_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"marks_continue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_marks</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>full_mark</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_prof_mark_timer_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_marks_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>full_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_marks_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>old_objects</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_prof_mark_timer_stop</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_report_body</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;=</operator> <name>RGENGC_DEBUG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>stderr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>during_gc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <ternary><condition><expr><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"S"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"M"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s|"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_remembersetbits_get</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>RVALUE_REMEMBERED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_remembersetbits_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>bits</name> <init>= <expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>marking_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_remember</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rgengc_remember: %s %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>rgengc_remembersetbits_get</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"was already remembered"</literal></expr> </then><else>: <expr><literal type="string">"is remembered now"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rgengc_remember: %s is not wb protected."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rgengc_remembered</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_remembered_normal_object_count</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>remembered_normal_object_count_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<return>return <expr><call><name>rgengc_remembersetbits_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_remembered_sweep</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>rgengc_remembersetbits_get</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_remembered</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rgengc_remembered: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rgengc_remembered_sweep</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROFILE_REMEMBERSET_MARK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROFILE_REMEMBERSET_MARK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rgengc_rememberset_mark</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROFILE_REMEMBERSET_MARK</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>has_old</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>has_shady</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>has_both</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rgengc_rememberset_mark: start\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>|</operator> <name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>offset</name> <init>= <expr><name>p</name> <operator>-</operator> <call><name>NUM_IN_PAGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name></type> <name>bitset</name></decl>, <decl><type ref="prev"/><name><name>bits</name><index>[<expr><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>marking_bits</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>marking_bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>uncollectible_bits</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>uncollectible_bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bits_t</name> <modifier>*</modifier></type><name>wb_unprotected_bits</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>wb_unprotected_bits</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROFILE_REMEMBERSET_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>&amp;&amp;</operator> <name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>has_both</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>has_old</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>has_shady</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>HEAP_PAGE_BITMAP_LIMIT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>marking_bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>uncollectible_bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name><name>wb_unprotected_bits</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>marking_bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HEAP_PAGE_BITMAP_LIMIT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>bitset</name> <operator>=</operator> <name><name>bits</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bitset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>BITS_BITLENGTH</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bitset</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rgengc_rememberset_mark: mark %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_children</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bitset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>bitset</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROFILE_REMEMBERSET_MARK</name></expr></cpp:if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>skip</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PROFILE_REMEMBERSET_MARK</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d\t%d\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>has_both</name></expr></argument>, <argument><expr><name>has_old</name></expr></argument>, <argument><expr><name>has_shady</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rgengc_rememberset_mark: finished\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rgengc_mark_and_rememberset_clear</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>mark_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>uncollectible_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>marking_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>pinned_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static void gc_writebarrier_generational(VALUE a, VALUE b, rb_objspace_t *objspace)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_writebarrier_generational</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_writebarrier_generational: %s is not an old object."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_writebarrier_generational: %s is an old object."</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_writebarrier_generational: called while incremental marking: %s -&gt; %s"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rgengc_remembered</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rgengc_remember</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_generational: %s (remembered) -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_remember_unprotected</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RVALUE_AGE_SET_OLD</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rgengc_remember</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_generational: %s -&gt; %s (remembered)\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_mark_from</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>parent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_mark_set_parent</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rgengc_check_relation</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_mark_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_aging</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_grey</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static void gc_writebarrier_incremental(VALUE a, VALUE b, rb_objspace_t *objspace)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_writebarrier_incremental</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_incremental: [LG] %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_BLACK_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WHITE_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_incremental: [IN] %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_from</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_incremental: [GN] %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_SET_OLD</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_BLACK_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_grey</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_writebarrier_incremental: [LL] %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_remember_unprotected</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_writebarrier_incremental</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>objspace</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_gc_writebarrier</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_writebarrier: a is special const"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&amp;&amp;</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_gc_writebarrier: b is special const"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_writebarrier_generational</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>gc_writebarrier_incremental</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_writebarrier_unprotect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_gc_writebarrier_unprotect: %s %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>rgengc_remembered</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">" (already remembered)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_gc_writebarrier_unprotect: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_DEMOTE</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_remember_unprotected</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_shade_operation_count</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>shade_operation_count_types</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RVALUE_AGE_RESET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_wb_unprotect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_gc_writebarrier_remember</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_gc_writebarrier_remember: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_BLACK_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_grey</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rgengc_remember</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>rgengc_unprotect_logging_table</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rgengc_unprotect_logging_exit_func_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\t%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rgengc_unprotect_logging_exit_func</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>rgengc_unprotect_logging_table</name></expr></argument>, <argument><expr><name>rgengc_unprotect_logging_exit_func_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_unprotect_logging</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>objptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>objptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rgengc_unprotect_logging_table</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rgengc_unprotect_logging_table</name> <operator>=</operator> <call><name>st_init_strtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>rgengc_unprotect_logging_exit_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buff</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0x100</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s|%s:%d"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>rgengc_unprotect_logging_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>strdup</name><operator>)</operator><operator>(</operator><name>buff</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>rgengc_unprotect_logging_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_copy_wb_protected_attribute</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RVALUE_AGE_RESET_RAW</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RVALUE_DEMOTE</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_rvalue_consistency</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_rgengc_writebarrier_protected_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_rgengc_promoted_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>OBJ_PROMOTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_obj_gc_flags</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name><modifier>*</modifier></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>ID_marked</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>ID_wb_protected</name></decl>, <decl><type ref="prev"/><name>ID_old</name></decl>, <decl><type ref="prev"/><name>ID_marking</name></decl>, <decl><type ref="prev"/><name>ID_uncollectible</name></decl>, <decl><type ref="prev"/><name>ID_pinned</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ID_marked</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ID_##s = rb_intern(#s);</cpp:value></cpp:define>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>marked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>wb_protected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>marking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>uncollectible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>I</name><argument_list>(<argument><expr><name>pinned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>I</name></cpp:undef>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_wb_protected</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_old</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_uncollectible</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_marking</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_marked</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_PINNED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>flags</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ID_pinned</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_force_recycle</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_old</name> <init>= <expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_gc_force_recycle: %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_old</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_MARKED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>invalidate_mark_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>mark_stack</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>is_old</name> <operator>||</operator> <operator>!</operator><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>flags</name><operator>.</operator><name>before_sweep</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MARK_OBJECT_ARY_BUCKET_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_OBJECT_ARY_BUCKET_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_gc_register_mark_object</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary_ary</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>mark_object_ary</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_last</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ary</name> <operator>==</operator> <name>Qnil</name> <operator>||</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MARK_OBJECT_ARY_BUCKET_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>MARK_OBJECT_ARY_BUCKET_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary_ary</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_register_address</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>gc_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>global_list</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>varptr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>global_list</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_unregister_address</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>global_list</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>varptr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>global_list</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>varptr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_list</name></name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_global_variable</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_register_address</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_NOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<enum>enum <block>{

<decl><name>gc_stress_no_major</name></decl>,

<decl><name>gc_stress_no_immediate_sweep</name></decl>,

<decl><name>gc_stress_full_mark_after_malloc</name></decl>,

<decl><name>gc_stress_max</name></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gc_stress_full_mark_after_malloc_p</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(FIXNUM_P(ruby_gc_stress_mode) &amp;&amp; (FIX2LONG(ruby_gc_stress_mode) &amp; (1&lt;&lt;gc_stress_full_mark_after_malloc)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>heap_ready_to_gc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_heap_t</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>freelist</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>free_pages</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_set_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_increment</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ready_to_gc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dont_gc</name> <operator>||</operator> <name>during_gc</name> <operator>||</operator> <name>ruby_disable_gc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_ready_to_gc</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_reset_malloc_info</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_prof_set_malloc_info</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>inc</name> <init>= <expr><call><name>ATOMIC_SIZE_EXCHANGE</name><argument_list>(<argument><expr><name>malloc_increase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_limit</name> <init>= <expr><name>malloc_limit</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inc</name> <operator>&gt;</operator> <name>malloc_limit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>malloc_limit</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>inc</name> <operator>*</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_growth_factor</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>malloc_limit</name> <operator>&gt;</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_max</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>malloc_limit</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_max</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>malloc_limit</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>malloc_limit</name> <operator>*</operator> <literal type="number">0.98</literal><operator>)</operator></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>malloc_limit</name> <operator>&lt;</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_min</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>malloc_limit</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>malloc_limit_min</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>old_limit</name> <operator>!=</operator> <name>malloc_limit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%"</literal><name>PRIuSIZE</name><literal type="string">"] malloc_limit: %"</literal><name>PRIuSIZE</name><literal type="string">" -&gt; %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><call><name>rb_gc_count</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>old_limit</name></expr></argument>, <argument><expr><name>malloc_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%"</literal><name>PRIuSIZE</name><literal type="string">"] malloc_limit: not changed (%"</literal><name>PRIuSIZE</name><literal type="string">")\n"</literal></expr></argument>,

<argument><expr><call><name>rb_gc_count</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>malloc_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name> <operator>&gt;</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>|=</operator> <name>GPR_FLAG_MAJOR_BY_OLDMALLOC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator>

<operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>*</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_growth_factor</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>&gt;</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_max</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_max</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d\t%d\t%u\t%u\t%d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_gc_count</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_OLDMALLOC</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator>

<operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>/</operator> <operator>(</operator><operator>(</operator><name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_growth_factor</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>&lt;</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_min</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_min</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>garbage_collect</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>prepare_time</name></name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>prepare_time</name></name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>prepare_time</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>gc_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>do_full_mark</name> <init>= <expr><operator>!</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_FULL_MARK</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>immediate_mark</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_IMMEDIATE_MARK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_IMMEDIATE_SWEEP</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>heap_allocated_pages</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_METHOD</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ready_to_gc</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>gc_mode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>gc_mode_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>gc_enter</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ruby_gc_stressful</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><ternary><condition><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>ruby_gc_stress_mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>ruby_gc_stress_mode</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>gc_stress_no_major</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>do_full_mark</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name> <operator>=</operator> <operator>!</operator><operator>(</operator><name>flag</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>gc_stress_no_immediate_sweep</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reason</name> <operator>|=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>do_full_mark</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>RGENGC_FORCE_MAJOR_GC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reason</name> <operator>=</operator> <name>GPR_FLAG_MAJOR_BY_FORCE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>do_full_mark</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>need_major_gc</name></name> <operator>=</operator> <name>GPR_FLAG_NONE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_full_mark</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reason</name> <operator>|=</operator> <name>GPR_FLAG_MAJOR_BY_FORCE</name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>GC_ENABLE_INCREMENTAL_MARK</name> <operator>||</operator> <name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name> <operator>||</operator> <name>immediate_mark</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_incremental_marking</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_incremental_marking</name></name> <operator>=</operator> <name>do_full_mark</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>GC_ENABLE_LAZY_SWEEP</name> <operator>||</operator> <name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>dont_incremental</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reason</name> <operator>|=</operator> <name>GPR_FLAG_IMMEDIATE_SWEEP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_start(reason: %d) =&gt; %u, %d, %d\n"</literal></expr></argument>,

<argument><expr><name>reason</name></expr></argument>,

<argument><expr><name>do_full_mark</name></expr></argument>, <argument><expr><operator>!</operator><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>immediate_sweep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>gc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_MASK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_major_nofree</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_NOFREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_major_oldgen</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_OLDGEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_major_shady</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_SHADY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_major_force</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_major_oldmalloc</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_OLDMALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_minor_newobj</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_NEWOBJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_minor_malloc</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_MALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_minor_method</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_minor_capi</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_CAPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>gc_minor_stress</name></expr></argument>, <argument><expr><name>reason</name> <operator>&amp;</operator> <name>GPR_FLAG_STRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_allocated_objects_at_gc_start</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>total_allocated_objects</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>heap_used_at_gc_start</name></name> <operator>=</operator> <name>heap_allocated_pages</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_prof_setup_new_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_reset_malloc_info</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_transient_heap_start_marking</name><argument_list>(<argument><expr><name>do_full_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_GC_START</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>during_gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_prof_timer_start</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_marks</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>do_full_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>gc_prof_timer_stop</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>marking</name> <init>= <expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sweeping</name> <init>= <expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>marking</name> <operator>||</operator> <name>sweeping</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_enter</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_rest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_marks_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_sweep_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_rest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>objspace_and_reason</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reason</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_current_status_fill</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'M'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_full_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'F'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_ENABLE_INCREMENTAL_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>is_incremental_marking</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'I'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>is_sweeping</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'L'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>gc_current_status</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x10</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_current_status_fill</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buff</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PRINT_ENTER_EXIT_TICK</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>tick_t</name></type> <name>last_exit_tick</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>tick_t</name></type> <name>enter_tick</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>enter_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>last_gc_status</name><index>[<expr><literal type="number">0x10</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_record</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>enter_count</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>enter_tick</name> <operator>=</operator> <call><name>tick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_current_status_fill</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>last_gc_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<decl_stmt><decl><type><name>tick_t</name></type> <name>exit_tick</name> <init>= <expr><call><name>tick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>current_gc_status</name><index>[<expr><literal type="number">0x10</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_current_status_fill</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>current_gc_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRItick</name><literal type="string">"\t%"</literal><name>PRItick</name><literal type="string">"\t%s\t[%s-&gt;%s|%c]\n"</literal></expr></argument>,

<argument><expr><name>enter_tick</name> <operator>-</operator> <name>last_exit_tick</name></expr></argument>,

<argument><expr><name>exit_tick</name> <operator>-</operator> <name>enter_tick</name></expr></argument>,

<argument><expr><name>event</name></expr></argument>,

<argument><expr><name>last_gc_status</name></expr></argument>, <argument><expr><name>current_gc_status</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_MASK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_exit_tick</name> <operator>=</operator> <name>exit_tick</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRItick</name><literal type="string">"\t%"</literal><name>PRItick</name><literal type="string">"\t%s\t[%s-&gt;%s|%c]\n"</literal></expr></argument>,

<argument><expr><name>enter_tick</name></expr></argument>,

<argument><expr><name>exit_tick</name> <operator>-</operator> <name>enter_tick</name></expr></argument>,

<argument><expr><name>event</name></expr></argument>,

<argument><expr><name>last_gc_status</name></expr></argument>, <argument><expr><name>current_gc_status</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_MASK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_record</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_enter</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>during_gc</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>RGENGC_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mjit_gc_start_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>during_gc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_enter: %s [%s]\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><call><name>gc_current_status</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_GC_ENTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_exit</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>during_gc</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_event_hook</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>RUBY_INTERNAL_EVENT_GC_EXIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>gc_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"gc_exit: %s [%s]\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><call><name>gc_current_status</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>during_gc</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mjit_gc_exit_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>gc_with_gvl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>objspace_and_reason</name></name> <modifier>*</modifier></type><name>oar</name> <init>= <expr><operator>(</operator>struct <name>objspace_and_reason</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>garbage_collect</name><argument_list>(<argument><expr><name><name>oar</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>, <argument><expr><name><name>oar</name><operator>-&gt;</operator><name>reason</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>garbage_collect_with_gvl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dont_gc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ruby_thread_has_gvl_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>garbage_collect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ruby_native_thread_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>objspace_and_reason</name></name></type> <name>oar</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>oar</name><operator>.</operator><name>objspace</name></name> <operator>=</operator> <name>objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oar</name><operator>.</operator><name>reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_with_gvl</name><argument_list>(<argument><expr><name>gc_with_gvl</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>oar</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[FATAL] failed to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_start_internal</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>full_mark</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>immediate_mark</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>immediate_sweep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reason</name> <init>= <expr><name>GPR_FLAG_FULL_MARK</name> <operator>|</operator>

<name>GPR_FLAG_IMMEDIATE_MARK</name> <operator>|</operator>

<name>GPR_FLAG_IMMEDIATE_SWEEP</name> <operator>|</operator>

<name>GPR_FLAG_METHOD</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>full_mark</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reason</name> <operator>&amp;=</operator> <operator>~</operator><name>GPR_FLAG_FULL_MARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>immediate_mark</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reason</name> <operator>&amp;=</operator> <operator>~</operator><name>GPR_FLAG_IMMEDIATE_MARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>immediate_sweep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reason</name> <operator>&amp;=</operator> <operator>~</operator><name>GPR_FLAG_IMMEDIATE_SWEEP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>garbage_collect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_finalize_deferred</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_is_moveable_obj</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NONE</name></expr>:</case>

<case>case <expr><name>T_NIL</name></expr>:</case>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<return>return <expr><name>FALSE</name></expr>;</return>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>DYNAMIC_SYM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>RSYMBOL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>id</name> <operator>&amp;</operator> <operator>~</operator><name>ID_SCOPE_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>T_STRING</name></expr>:</case>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<case>case <expr><name>T_DATA</name></expr>:</case>

<case>case <expr><name>T_MATCH</name></expr>:</case>

<case>case <expr><name>T_STRUCT</name></expr>:</case>

<case>case <expr><name>T_HASH</name></expr>:</case>

<case>case <expr><name>T_FILE</name></expr>:</case>

<case>case <expr><name>T_COMPLEX</name></expr>:</case>

<case>case <expr><name>T_RATIONAL</name></expr>:</case>

<case>case <expr><name>T_NODE</name></expr>:</case>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FINALIZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>st_is_member</name><argument_list>(<argument><expr><name>finalizer_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>!</operator><call><name>RVALUE_PINNED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_is_moveable_obj: unreachable (%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_move</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>free</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>moved_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>marked</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wb_unprotected</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>uncollectible</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>marking</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>free</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator><name>RVALUE</name> <operator>*</operator><operator>)</operator><name>scan</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"Moving object: %p -&gt; %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>scan</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>marked</name> <operator>=</operator> <call><name>rb_objspace_marked_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wb_unprotected</name> <operator>=</operator> <call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uncollectible</name> <operator>=</operator> <call><name>RVALUE_UNCOLLECTIBLE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>marking</name> <operator>=</operator> <call><name>RVALUE_MARKING</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>total_allocated_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_mv_generic_ivar</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>srcid</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>src</name></expr></init></decl>, <decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><name>srcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"Moving object with seen id: %p -&gt; %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>marking</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARKING_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>marked</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wb_unprotected</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_WB_UNPROTECTED_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>uncollectible</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MARK_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_UNCOLLECTIBLE_BITS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>moved</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>T_MOVED</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>moved</name><operator>.</operator><name>destination</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>moved</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>moved_list</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dest</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>src</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>heap_cursor</name> <block>{

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>advance_cursor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>free</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>page_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>free</name><operator>-&gt;</operator><name>slot</name></name> <operator>==</operator> <name><name>free</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>free</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name><name>page_list</name><index>[<expr><name><name>free</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>free</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>slot</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>retreat_cursor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>page_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>slot</name></name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>index</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name><name>page_list</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>scan</name><operator>-&gt;</operator><name>page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>slot</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>not_met</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>free</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>free</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>free</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>free</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>slot</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>init_cursors</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>free</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_cursor</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>page_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_pages</name> <init>= <expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>page_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>objspace</name></name> <operator>=</operator> <name>objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>page_list</name><index>[<expr><name>total_pages</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>total_pages</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>objspace</name></name> <operator>=</operator> <name>objspace</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>count_pinned</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pinned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HEAP_PAGE_BITMAP_LIMIT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>pinned</name> <operator>+=</operator> <call><name>popcount_bits</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>pinned_bits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>pinned</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compare_pinned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>left_page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>right_page</name></decl>;</decl_stmt>

<expr_stmt><expr><name>left_page</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>heap_page</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_page</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>heap_page</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>right</name></expr>;</expr_stmt>

<return>return <expr><name><name>right_page</name><operator>-&gt;</operator><name>pinned_slots</name></name> <operator>-</operator> <name><name>left_page</name><operator>-&gt;</operator><name>pinned_slots</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compare_free_slots</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>left_page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>right_page</name></decl>;</decl_stmt>

<expr_stmt><expr><name>left_page</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>heap_page</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_page</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>heap_page</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>right</name></expr>;</expr_stmt>

<return>return <expr><name><name>right_page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>-</operator> <name><name>left_page</name><operator>-&gt;</operator><name>free_slots</name></name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> <name>page_compare_func_t</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type>

<name>allocate_page_list</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>page_compare_func_t</name> <modifier>*</modifier></type><name>comparator</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>total_pages</name> <init>= <expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>size_mul_or_raise</name><argument_list>(<argument><expr><name>total_pages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>page_list</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap_eden-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>page_list</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>pinned_slots</name></name> <operator>=</operator> <call><name>count_pinned</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>page</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>total_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>==</operator> <name>total_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_qsort</name><argument_list>(<argument><expr><name>page_list</name></expr></argument>, <argument><expr><name>total_pages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>heap_page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comparator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>page_list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_compact_heap</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>page_compare_func_t</name> <modifier>*</modifier></type><name>comparator</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_cursor</name></name></type> <name>free_cursor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_cursor</name></name></type> <name>scan_cursor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>page_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>moved_list</name></decl>;</decl_stmt>

<expr_stmt><expr><name>moved_list</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>considered_count_table</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>T_MASK</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>moved_count_table</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>T_MASK</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>page_list</name> <operator>=</operator> <call><name>allocate_page_list</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_cursors</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>, <argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>not_met</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>free_slot_poison</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name> <operator>&amp;&amp;</operator> <call><name>not_met</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>free_slot_poison</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>advance_cursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>free_slot_poison</name> <operator>=</operator> <call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>scan_slot_poison</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>considered_count_table</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>gc_is_moveable_obj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>not_met</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>scan_slot_poison</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>retreat_cursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>, <argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scan_slot_poison</name> <operator>=</operator> <call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>considered_count_table</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>not_met</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>moved_count_table</name><index>[<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>moved_list</name> <operator>=</operator> <call><name>gc_move</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>, <argument><expr><name>moved_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>free_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name><name>scan_cursor</name><operator>.</operator><name>slot</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>advance_cursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_cursor</name></expr></argument>, <argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>retreat_cursor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_cursor</name></expr></argument>, <argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>page_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>moved_list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_ref_update_array</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_ref_update_object</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>hash_replace_ref</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>hash_foreach_replace</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<expr_stmt><expr><name>objspace</name> <operator>=</operator> <operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>argp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ST_REPLACE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ST_REPLACE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>hash_replace_ref_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>hash_foreach_replace_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<expr_stmt><expr><name>objspace</name> <operator>=</operator> <operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>argp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ST_REPLACE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_update_tbl_refs</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name> <operator>||</operator> <name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_foreach_with_replace</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>hash_foreach_replace_value</name></expr></argument>, <argument><expr><name>hash_replace_ref_value</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"hash modified during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_update_table_refs</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name> <operator>||</operator> <name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_foreach_with_replace</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>hash_foreach_replace</name></expr></argument>, <argument><expr><name>hash_replace_ref</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"hash modified during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc_update_tbl_refs</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_update_table_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_ref_update_hash</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_stlike_foreach_with_replace</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>hash_foreach_replace</name></expr></argument>, <argument><expr><name>hash_replace_ref</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_ref_update_method_entry</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>def</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>rb_iseq_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>rb_cref_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr>struct <name>rb_method_entry_struct</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr>struct <name>rb_method_entry_struct</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_update_values</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_ref_update_imemo</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_env</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>(</operator><name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>rb_iseq_t</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_values</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>env_size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr>struct <name>rb_cref_struct</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>cref</name><operator>.</operator><name>refinements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>cref_or_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>backref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>svar</name><operator>.</operator><name>others</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_throw_data</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>throw_data</name><operator>.</operator><name>throw_obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ifunc</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>imemo_memo</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>memo</name><operator>.</operator><name>v1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>memo</name><operator>.</operator><name>v2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<expr_stmt><expr><call><name>gc_ref_update_method_entry</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_iseq</name></expr>:</case>

<expr_stmt><expr><call><name>rb_iseq_update_references</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_ast</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ast_update_references</name><argument_list>(<argument><expr><operator>(</operator><name>rb_ast_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>imemo_callcache</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPED_UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr>struct <name>rb_callable_method_entry_struct</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>cme_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>imemo_parser_strterm</name></expr>:</case>

<case>case <expr><name>imemo_tmpbuf</name></expr>:</case>

<case>case <expr><name>imemo_callinfo</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"not reachable %d"</literal></expr></argument>, <argument><expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>check_id_table_move</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ID_TABLE_REPLACE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>destination</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MOVED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>destination</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>RMOVED</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>destination</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>destination</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>destination</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>destination</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>update_id_table</name><parameter_list>(<parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_m_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>tbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_foreach_with_replace</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>check_id_table_move</name></expr></argument>, <argument><expr><name>update_id_table</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>update_cc_tbl_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ccs_ptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><operator>(</operator>struct <name>rb_class_cc_entries</name> <operator>*</operator><operator>)</operator><name>ccs_ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_p</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name> <operator>=</operator> <operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name> <operator>=</operator> <operator>(</operator>struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_cc_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_foreach_with_replace</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>update_cc_tbl_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>update_const_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_const_tbl</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>update_const_table</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_subclass_entries</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_subclass_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_class_ext</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>rb_classext_t</name> <modifier>*</modifier></type><name>ext</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ext</name><operator>-&gt;</operator><name>origin_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ext</name><operator>-&gt;</operator><name>refined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_subclass_entries</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ext</name><operator>-&gt;</operator><name>subclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_update_object_references</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>RVALUE</name> <modifier>*</modifier></type><name>any</name> <init>= <expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"update-refs: %p -&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>update_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_cc_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_tbl_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_class_ext</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_const_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>update_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_update_tbl_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>update_class_ext</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_m_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_cc_tbl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_IMEMO</name></expr>:</case>

<expr_stmt><expr><call><name>gc_ref_update_imemo</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>T_NIL</name></expr>:</case>

<case>case <expr><name>T_FIXNUM</name></expr>:</case>

<case>case <expr><name>T_NODE</name></expr>:</case>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<case>case <expr><name>T_NONE</name></expr>:</case>

<return>return;</return>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>array</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_ref_update_array</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_HASH</name></expr>:</case>

<expr_stmt><expr><call><name>gc_ref_update_hash</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>hash</name><operator>.</operator><name>ifnone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRING</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>string</name><operator>.</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_DATA</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RUBY_DATA_FUNC</name></type> <name>compact_func</name> <init>= <expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>typeddata</name><operator>.</operator><name>type</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>dcompact</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>compact_func</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>compact_func</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<expr_stmt><expr><call><name>gc_ref_update_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_FILE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>file</name><operator>.</operator><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>regexp</name><operator>.</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>DYNAMIC_SYM_P</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>any</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RSYMBOL</name><argument_list>(<argument><expr><name>any</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_MATCH</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>regexp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>str</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>match</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>T_RATIONAL</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>rational</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>rational</name><operator>.</operator><name>den</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_COMPLEX</name></expr>:</case>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>complex</name><operator>.</operator><name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>any</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>complex</name><operator>.</operator><name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_STRUCT</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RSTRUCT_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RSTRUCT_CONST_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_gcdebug_print_obj_condition</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_info_dump</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>UPDATE_IF_MOVED</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_report</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"update-refs: %p &lt;-"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_ref_update</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>free_slots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vstart</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>objspace</name> <operator>=</operator> <operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_unpoison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_memory_region</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>vend</name></expr>;</condition> <incr><expr><name>v</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NONE</name></expr>:</case>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>free_slots</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_MOVED</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_uncollectible_shady_objects</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RVALUE_PAGE_MARKING</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>has_remembered_objects</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gc_update_object_references</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>=</operator> <name>free_slots</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <name>rb_symbols_t</name></type> <name>ruby_global_symbols</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>global_symbols</name></cpp:macro> <cpp:value>ruby_global_symbols</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_update_references</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type> <name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>objspace_each_objects_without_setup</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>gc_ref_update</name></expr></argument>, <argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_update_references</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_transient_heap_update_references</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>global_symbols</name><operator>.</operator><name>ids</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>global_symbols</name><operator>.</operator><name>ids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>global_symbols</name><operator>.</operator><name>dsymbol_fstr_hash</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>global_symbols</name><operator>.</operator><name>dsymbol_fstr_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_tbl_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>obj_to_id_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_table_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>id_to_obj_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_table_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name><name>global_symbols</name><operator>.</operator><name>str_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_table_refs</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>finalizer_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>type_sym</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_compact_stats</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>h</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>considered</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>moved</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>T_MASK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>considered</name></expr></argument>, <argument><expr><call><name>type_sym</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>considered_count_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>T_MASK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>moved</name></expr></argument>, <argument><expr><call><name>type_sym</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rcompactor</name><operator>.</operator><name>moved_count_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"considered"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>considered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"moved"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>moved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>h</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gc_compact_after_gc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_toward_empty</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_double_pages</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_verifier</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_compact</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_toward_empty</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_double_pages</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_verifier</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_compacting</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>garbage_collect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>GPR_DEFAULT_REASON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_compact_after_gc</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>use_toward_empty</name></expr></argument>, <argument><expr><name>use_double_pages</name></expr></argument>, <argument><expr><name>use_verifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>during_compacting</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_gc_compact</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dont_gc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gc_compact</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>gc_compact_stats</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>root_obj_check_moved_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"ROOT %s points to MOVED: %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><name>category</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><call><name>rb_gc_location</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reachable_object_check_moved_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>parent</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"Object %s points to MOVED: %p -&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ref</name></expr></argument>, <argument><expr><call><name>obj_info</name><argument_list>(<argument><expr><call><name>rb_gc_location</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>heap_check_moved_i</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vstart</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>vend</name></expr>;</condition> <incr><expr><name>v</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_object_moved_p</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>poisoned</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NONE</name></expr>:</case>

<case>case <expr><name>T_ZOMBIE</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_objspace_reachable_objects_from</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>reachable_object_check_moved_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>poisoned</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asan_poison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_check_references_for_moved</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>objspace_reachable_objects_from_root</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>root_obj_check_moved_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>objspace_each_objects</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_check_moved_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_compact_after_gc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_toward_empty</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_double_pages</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_verifier</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gc_compact_after_gc: %d,%d,%d\n"</literal></expr></argument>, <argument><expr><name>use_toward_empty</name></expr></argument>, <argument><expr><name>use_double_pages</name></expr></argument>, <argument><expr><name>use_verifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mjit_gc_start_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>compact_count</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_verifier</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_double_pages</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_add_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name>heap_allocated_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>moved_list_head</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>disabled</name> <init>= <expr><call><name>rb_objspace_gc_disable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_toward_empty</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>moved_list_head</name> <operator>=</operator> <call><name>gc_compact_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>compare_free_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>moved_list_head</name> <operator>=</operator> <call><name>gc_compact_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>compare_pinned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_update_references</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>disabled</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_objspace_gc_enable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_verifier</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_check_references_for_moved</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>using_page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>moved_list_head</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next_moved</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GET_HEAP_PAGE</name><argument_list>(<argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next_moved</name> <operator>=</operator> <call><name>RMOVED</name><argument_list>(<argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMOVED</name><argument_list>(<argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMOVED</name><argument_list>(<argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>destination</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMOVED</name><argument_list>(<argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_page_add_freeobj</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>moved_list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>==</operator> <name><name>page</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>&amp;&amp;</operator> <name>heap_pages_freeable_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>heap_pages_freeable_pages</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_unlink_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>heap_add_page</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_tomb</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>moved_list_head</name> <operator>=</operator> <name>next_moved</name></expr>;</expr_stmt>

</block_content>}</block></while>

<decl_stmt><decl><type><name><name>struct</name> <name>heap_page</name></name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;heap_eden-&gt;pages</argument>, <argument>page</argument>, <argument>page_node</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>free_slots</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_add_freepage</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>heap_eden</name><operator>-&gt;</operator><name>free_pages</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>using_page</name></name> <operator>=</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>free_pages</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>free_pages</name><operator>-&gt;</operator><name>free_next</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_verifier</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_verify_internal_consistency</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mjit_gc_exit_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_verify_compaction_references</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>toward</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>double_heap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_empty</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"empty"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>use_toward_empty</name> <init>= <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>toward</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>:

<expr><operator>(</operator><call><name>Check_Type</name><argument_list>(<argument><expr><name>toward</name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call>, <name>toward</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>id_empty</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>use_double_pages</name> <init>= <expr><call><name>RTEST</name><argument_list>(<argument><expr><name>double_heap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_compact</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>use_toward_empty</name></expr></argument>, <argument><expr><name>use_double_pages</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>gc_compact_stats</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_gc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reason</name> <init>= <expr><name>GPR_DEFAULT_REASON</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>garbage_collect</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_during_gc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>during_gc</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_count_add_each_types</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><name>T_MASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>T_MASK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>type_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type>

<name>rb_gc_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>rb_objspace</name><operator>.</operator><name>profile</name><operator>.</operator><name>count</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_count</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><call><name>rb_gc_count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_info_decode</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>hash_or_key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>orig_flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_major_by</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>sym_gc_by</name></decl>, <decl><type ref="prev"/><name>sym_immediate_sweep</name></decl>, <decl><type ref="prev"/><name>sym_have_finalizer</name></decl>, <decl><type ref="prev"/><name>sym_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_nofree</name></decl>, <decl><type ref="prev"/><name>sym_oldgen</name></decl>, <decl><type ref="prev"/><name>sym_shady</name></decl>, <decl><type ref="prev"/><name>sym_force</name></decl>, <decl><type ref="prev"/><name>sym_stress</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_oldmalloc</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_newobj</name></decl>, <decl><type ref="prev"/><name>sym_malloc</name></decl>, <decl><type ref="prev"/><name>sym_method</name></decl>, <decl><type ref="prev"/><name>sym_capi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_none</name></decl>, <decl><type ref="prev"/><name>sym_marking</name></decl>, <decl><type ref="prev"/><name>sym_sweeping</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>key</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>major_by</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><ternary><condition><expr><name>orig_flags</name></expr> ?</condition><then> <expr><name>orig_flags</name></expr> </then><else>: <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>hash_or_key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>hash_or_key</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hash_or_key</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash_or_key</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash or symbol given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_major_by</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sym_##s = ID2SYM(rb_intern_const(#s))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>major_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>gc_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>immediate_sweep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>have_finalizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>stress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>nofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldgen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>shady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>malloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>capi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>marking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>sweeping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S</name></cpp:undef>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (key == sym_##name) return (attr); else if (hash != Qnil) rb_hash_aset(hash, sym_##name, (attr));</cpp:value></cpp:define>

<expr_stmt><expr><name>major_by</name> <operator>=</operator>

<ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_NOFREE</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_nofree</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_OLDGEN</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_oldgen</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_SHADY</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_shady</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_FORCE</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_force</name></expr> </then><else>:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></condition></ternary></expr></cpp:if>

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_BY_OLDMALLOC</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_oldmalloc</name></expr> </then><else>:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>Qnil</name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>major_by</name></expr></argument>, <argument><expr><name>major_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>gc_by</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_NEWOBJ</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_newobj</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MALLOC</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_malloc</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_METHOD</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_method</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_CAPI</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_capi</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_STRESS</name><operator>)</operator></expr> ?</condition><then> <expr><name>sym_stress</name></expr> </then><else>:

<expr><name>Qnil</name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>have_finalizer</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_HAVE_FINALIZE</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>immediate_sweep</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_IMMEDIATE_SWEEP</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orig_flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>gc_mode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>gc_mode_none</name></expr> ?</condition><then> <expr><name>sym_none</name></expr> </then><else>:

<expr><ternary><condition><expr><call><name>gc_mode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>gc_mode_marking</name></expr> ?</condition><then> <expr><name>sym_marking</name></expr> </then><else>: <expr><name>sym_sweeping</name></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown key: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_latest_gc_info</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>gc_info_decode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_latest_gc_info</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash or symbol given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>gc_info_decode</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>gc_stat_sym</name> <block>{

<decl><name>gc_stat_sym_count</name></decl>,

<decl><name>gc_stat_sym_heap_allocated_pages</name></decl>,

<decl><name>gc_stat_sym_heap_sorted_length</name></decl>,

<decl><name>gc_stat_sym_heap_allocatable_pages</name></decl>,

<decl><name>gc_stat_sym_heap_available_slots</name></decl>,

<decl><name>gc_stat_sym_heap_live_slots</name></decl>,

<decl><name>gc_stat_sym_heap_free_slots</name></decl>,

<decl><name>gc_stat_sym_heap_final_slots</name></decl>,

<decl><name>gc_stat_sym_heap_marked_slots</name></decl>,

<decl><name>gc_stat_sym_heap_eden_pages</name></decl>,

<decl><name>gc_stat_sym_heap_tomb_pages</name></decl>,

<decl><name>gc_stat_sym_total_allocated_pages</name></decl>,

<decl><name>gc_stat_sym_total_freed_pages</name></decl>,

<decl><name>gc_stat_sym_total_allocated_objects</name></decl>,

<decl><name>gc_stat_sym_total_freed_objects</name></decl>,

<decl><name>gc_stat_sym_malloc_increase_bytes</name></decl>,

<decl><name>gc_stat_sym_malloc_increase_bytes_limit</name></decl>,

<decl><name>gc_stat_sym_minor_gc_count</name></decl>,

<decl><name>gc_stat_sym_major_gc_count</name></decl>,

<decl><name>gc_stat_sym_compact_count</name></decl>,

<decl><name>gc_stat_sym_remembered_wb_unprotected_objects</name></decl>,

<decl><name>gc_stat_sym_remembered_wb_unprotected_objects_limit</name></decl>,

<decl><name>gc_stat_sym_old_objects</name></decl>,

<decl><name>gc_stat_sym_old_objects_limit</name></decl>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl><name>gc_stat_sym_oldmalloc_increase_bytes</name></decl>,

<decl><name>gc_stat_sym_oldmalloc_increase_bytes_limit</name></decl>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<decl><name>gc_stat_sym_total_generated_normal_object_count</name></decl>,

<decl><name>gc_stat_sym_total_generated_shady_object_count</name></decl>,

<decl><name>gc_stat_sym_total_shade_operation_count</name></decl>,

<decl><name>gc_stat_sym_total_promoted_count</name></decl>,

<decl><name>gc_stat_sym_total_remembered_normal_object_count</name></decl>,

<decl><name>gc_stat_sym_total_remembered_shady_object_count</name></decl>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl><name>gc_stat_sym_last</name></decl>

}</block>;</enum>

<enum>enum <name>gc_stat_compat_sym</name> <block>{

<decl><name>gc_stat_compat_sym_gc_stat_heap_used</name></decl>,

<decl><name>gc_stat_compat_sym_heap_eden_page_length</name></decl>,

<decl><name>gc_stat_compat_sym_heap_tomb_page_length</name></decl>,

<decl><name>gc_stat_compat_sym_heap_increment</name></decl>,

<decl><name>gc_stat_compat_sym_heap_length</name></decl>,

<decl><name>gc_stat_compat_sym_heap_live_slot</name></decl>,

<decl><name>gc_stat_compat_sym_heap_free_slot</name></decl>,

<decl><name>gc_stat_compat_sym_heap_final_slot</name></decl>,

<decl><name>gc_stat_compat_sym_heap_swept_slot</name></decl>,

<decl><name>gc_stat_compat_sym_remembered_shady_object</name></decl>,

<decl><name>gc_stat_compat_sym_remembered_shady_object_limit</name></decl>,

<decl><name>gc_stat_compat_sym_old_object</name></decl>,

<decl><name>gc_stat_compat_sym_old_object_limit</name></decl>,

<decl><name>gc_stat_compat_sym_total_allocated_object</name></decl>,

<decl><name>gc_stat_compat_sym_total_freed_object</name></decl>,

<decl><name>gc_stat_compat_sym_malloc_increase</name></decl>,

<decl><name>gc_stat_compat_sym_malloc_limit</name></decl>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<decl><name>gc_stat_compat_sym_oldmalloc_increase</name></decl>,

<decl><name>gc_stat_compat_sym_oldmalloc_limit</name></decl>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl><name>gc_stat_compat_sym_last</name></decl>

}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name><name>gc_stat_symbols</name><index>[<expr><name>gc_stat_sym_last</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name><name>gc_stat_compat_symbols</name><index>[<expr><name>gc_stat_compat_sym_last</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>gc_stat_compat_table</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>setup_gc_stat_symbols</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gc_stat_symbols</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gc_stat_symbols[gc_stat_sym_##s] = ID2SYM(rb_intern_const(#s))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_allocated_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_available_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_live_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_free_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_final_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_marked_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_eden_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_tomb_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_allocated_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_freed_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_allocated_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_freed_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>malloc_increase_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>malloc_increase_bytes_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>minor_gc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>major_gc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>compact_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>old_objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>old_objects_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_generated_normal_object_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_generated_shady_object_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_shade_operation_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_promoted_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_remembered_normal_object_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_remembered_shady_object_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gc_stat_compat_symbols[gc_stat_compat_sym_##s] = ID2SYM(rb_intern_const(#s))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>gc_stat_heap_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_eden_page_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_tomb_page_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_increment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_live_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_free_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_final_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>heap_swept_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>remembered_shady_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>remembered_shady_object_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>old_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>old_object_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_allocated_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>total_freed_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>malloc_increase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>malloc_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldmalloc_increase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>oldmalloc_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S</name></cpp:undef>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>table</name> <init>= <expr><name>gc_stat_compat_table</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLD_SYM</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gc_stat_compat_symbols[gc_stat_compat_sym_##s]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_SYM</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gc_stat_symbols[gc_stat_sym_##s]</cpp:value></cpp:define>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>gc_stat_heap_used</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_allocated_pages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_eden_page_length</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_eden_pages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_tomb_page_length</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_tomb_pages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_increment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_length</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_sorted_length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_live_slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_live_slots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_free_slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_free_slots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>heap_final_slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>heap_final_slots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>remembered_shady_object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>remembered_shady_object_limit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>old_object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>old_objects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>old_object_limit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>old_objects_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>total_allocated_object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>total_allocated_objects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>total_freed_object</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>total_freed_objects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>malloc_increase</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>malloc_increase_bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>malloc_limit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>malloc_increase_bytes_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>oldmalloc_increase</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>OLD_SYM</name><argument_list>(<argument><expr><name>oldmalloc_limit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEW_SYM</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OLD_SYM</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NEW_SYM</name></cpp:undef>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>compat_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new_key</name> <init>= <expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>gc_stat_compat_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>new_key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>warned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>warned</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"GC.stat keys were changed from Ruby 2.1. "</literal>

<literal type="string">"In this case, you refer to obsolete `%"</literal><name>PRIsVALUE</name><literal type="string">"' (new key is `%"</literal><name>PRIsVALUE</name><literal type="string">"'). "</literal>

<literal type="string">"Please check &lt;https://bugs.ruby-lang.org/issues/9924&gt; for more information."</literal></expr></argument>,

<argument><expr><name>key</name></expr></argument>, <argument><expr><name>new_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>warned</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>new_key</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>default_proc_for_compat_func</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>new_key</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_key</name> <operator>=</operator> <call><name>compat_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>new_key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>gc_stat_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash_or_sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>key</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_gc_stat_symbols</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hash_or_sym</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash_or_sym</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>default_proc_for_compat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>default_proc_for_compat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>default_proc_for_compat</name> <operator>=</operator> <call><name>rb_proc_new</name><argument_list>(<argument><expr><name>default_proc_for_compat_func</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>default_proc_for_compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_set_default_proc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>default_proc_for_compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>hash_or_sym</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>hash_or_sym</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash or symbol argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (key == gc_stat_symbols[gc_stat_sym_##name]) return attr; else if (hash != Qnil) rb_hash_aset(hash, gc_stat_symbols[gc_stat_sym_##name], SIZET2NUM(attr));</cpp:value></cpp:define>

<label><name>again</name>:</label>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_allocated_pages</name></expr></argument>, <argument><expr><name>heap_allocated_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_sorted_length</name></expr></argument>, <argument><expr><name>heap_pages_sorted_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_allocatable_pages</name></expr></argument>, <argument><expr><name>heap_allocatable_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_available_slots</name></expr></argument>, <argument><expr><call><name>objspace_available_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_live_slots</name></expr></argument>, <argument><expr><call><name>objspace_live_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_free_slots</name></expr></argument>, <argument><expr><call><name>objspace_free_slots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_final_slots</name></expr></argument>, <argument><expr><name>heap_pages_final_slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_marked_slots</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>marked_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_eden_pages</name></expr></argument>, <argument><expr><name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>heap_tomb_pages</name></expr></argument>, <argument><expr><name><name>heap_tomb</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_allocated_pages</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_allocated_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_freed_pages</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_allocated_objects</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>total_allocated_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_freed_objects</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>malloc_increase_bytes</name></expr></argument>, <argument><expr><name>malloc_increase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>malloc_increase_bytes_limit</name></expr></argument>, <argument><expr><name>malloc_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>minor_gc_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>minor_gc_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>major_gc_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>major_gc_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compact_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>compact_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>remembered_wb_unprotected_objects_limit</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>uncollectible_wb_unprotected_objects_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>old_objects</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>old_objects_limit</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>old_objects_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>oldmalloc_increase_bytes_limit</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_generated_normal_object_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_generated_normal_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_generated_shady_object_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_generated_shady_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_shade_operation_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_shade_operation_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_promoted_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_promoted_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_remembered_normal_object_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_remembered_normal_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>total_remembered_shady_object_count</name></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_remembered_shady_object_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>new_key</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_key</name> <operator>=</operator> <call><name>compat_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>new_key</name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown key: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RGENGC_PROFILE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>RGENGC_PROFILE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hash</name> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"generated_normal_object_count_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>generated_normal_object_count_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"generated_shady_object_count_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>generated_shady_object_count_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"shade_operation_count_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>shade_operation_count_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"promoted_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>promoted_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"remembered_normal_object_count_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>remembered_normal_object_count_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_count_add_each_types</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="string">"remembered_shady_object_count_types"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>remembered_shady_object_count_types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_stat</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>value</name> <init>= <expr><call><name>gc_stat_internal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash or symbol given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>gc_stat_internal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_gc_stat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>value</name> <init>= <expr><call><name>gc_stat_internal</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>gc_stat_internal</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_stress_get</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>ruby_gc_stress_mode</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_stress_set</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>gc_stressful</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>gc_stress_mode</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_stress_set_m</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_stress_set</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>flag</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_enable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_objspace_gc_enable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_objspace_gc_enable</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>old</name> <init>= <expr><name>dont_gc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>old</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_enable</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_gc_enable</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_disable_no_rest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>gc_disable_no_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_disable_no_rest</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>old</name> <init>= <expr><name>dont_gc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dont_gc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>old</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_gc_disable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_objspace_gc_disable</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_objspace_gc_disable</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>gc_disable_no_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_disable</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_gc_disable</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_envparam_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>default_value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lower_bound</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>unit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> <operator>==</operator> <name>SIZEOF_LONG_LONG</name></expr></cpp:if>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><operator>*</operator><name>end</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> <case>case <expr><literal type="char">'K'</literal></expr>:</case>

<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>end</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'M'</literal></expr>:</case>

<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>end</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> <case>case <expr><literal type="char">'G'</literal></expr>:</case>

<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>end</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<while>while <condition>(<expr><operator>*</operator><name>end</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid string for %s: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><name>ssize_t</name><operator>)</operator><operator>(</operator><name>SIZE_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>/</operator> <name>unit</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><operator>(</operator><name>SIZE_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>/</operator> <name>unit</name><operator>)</operator> <operator>&lt;</operator> <name>val</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%s is ignored because it overflows\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>*=</operator> <name>unit</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>val</name> <operator>&gt;</operator> <name>lower_bound</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%"</literal><name>PRIdSIZE</name><literal type="string">" (default value: %"</literal><name>PRIuSIZE</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>*</operator><name>default_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>default_value</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>val</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%"</literal><name>PRIdSIZE</name><literal type="string">" (default value: %"</literal><name>PRIuSIZE</name><literal type="string">") is ignored because it must be greater than %"</literal><name>PRIuSIZE</name><literal type="string">".\n"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>*</operator><name>default_value</name></expr></argument>, <argument><expr><name>lower_bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_envparam_double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>default_value</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lower_bound</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>upper_bound</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>accept_zero</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ptr</name> <operator>||</operator> <operator>*</operator><name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid string for %s: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>accept_zero</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>accept</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>val</name> <operator>&lt;=</operator> <name>lower_bound</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%f (default value: %f) is ignored because it must be greater than %f.\n"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>*</operator><name>default_value</name></expr></argument>, <argument><expr><name>lower_bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>upper_bound</name> <operator>!=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> 

<name>val</name> <operator>&gt;</operator> <name>upper_bound</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%f (default value: %f) is ignored because it must be lower than %f.\n"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>*</operator><name>default_value</name></expr></argument>, <argument><expr><name>upper_bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<label><name>accept</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s=%f (default value: %f)\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><operator>*</operator><name>default_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>default_value</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_set_initial_pages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>min_pages</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>min_pages</name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name> <operator>/</operator> <name>HEAP_PAGE_OBJ_LIMIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_pages</name> <operator>&gt;</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>heap_add_pages</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>heap_eden</name></expr></argument>, <argument><expr><name>min_pages</name> <operator>-</operator> <name><name>heap_eden</name><operator>-&gt;</operator><name>total_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_gc_set_params</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_envparam_size</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_FREE_SLOTS"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_free_slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>get_envparam_size</name><argument_list>(<argument><expr><literal type="string">"RUBY_FREE_MIN"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_free_slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"RUBY_FREE_MIN is obsolete. Use RUBY_GC_HEAP_FREE_SLOTS instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_envparam_size</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_INIT_SLOTS"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_set_initial_pages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>get_envparam_size</name><argument_list>(<argument><expr><literal type="string">"RUBY_HEAP_MIN_SLOTS"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_init_slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"RUBY_HEAP_MIN_SLOTS is obsolete. Use RUBY_GC_HEAP_INIT_SLOTS instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_set_initial_pages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_GROWTH_FACTOR"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>growth_factor</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_size</name> <argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_GROWTH_MAX_SLOTS"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>growth_max_slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_FREE_SLOTS_MIN_RATIO"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_min_ratio</name></name></expr></argument>,

<argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_FREE_SLOTS_MAX_RATIO"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_max_ratio</name></name></expr></argument>,

<argument><expr><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_min_ratio</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_FREE_SLOTS_GOAL_RATIO"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_goal_ratio</name></name></expr></argument>,

<argument><expr><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_min_ratio</name></name></expr></argument>, <argument><expr><name><name>gc_params</name><operator>.</operator><name>heap_free_slots_max_ratio</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>oldobject_limit_factor</name></name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_size</name> <argument_list>(<argument><expr><literal type="string">"RUBY_GC_MALLOC_LIMIT"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>malloc_limit_min</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_size</name> <argument_list>(<argument><expr><literal type="string">"RUBY_GC_MALLOC_LIMIT_MAX"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>malloc_limit_max</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gc_params</name><operator>.</operator><name>malloc_limit_max</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>gc_params</name><operator>.</operator><name>malloc_limit_max</name></name> <operator>=</operator> <name>SIZE_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>malloc_limit_growth_factor</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>get_envparam_size</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_OLDMALLOC_LIMIT"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_min</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase_limit</name></name> <operator>=</operator> <name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_min</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>get_envparam_size</name> <argument_list>(<argument><expr><literal type="string">"RUBY_GC_OLDMALLOC_LIMIT_MAX"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_max</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_envparam_double</name><argument_list>(<argument><expr><literal type="string">"RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gc_params</name><operator>.</operator><name>oldmalloc_limit_growth_factor</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_reachable_objects_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_markable_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>mark_func_data_struct</name></name></type> <name>mfd</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>mark_func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_children</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>root_objects_data</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>root_objects_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>root_objects_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>root_objects_data</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>data</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>category</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_objspace_reachable_objects_from_root</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passing_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>objspace_reachable_objects_from_root</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>passing_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_reachable_objects_from_root</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>category</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passing_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>root_objects_data</name></name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>mark_func_data_struct</name></name></type> <name>mfd</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>passing_data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>mark_func</name></name> <operator>=</operator> <name>root_objects_from</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mfd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUSH_MARK_FUNC_DATA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_mark_roots</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>category</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POP_MARK_FUNC_DATA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>gc_raise_tag</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>gc_vraise</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_raise_tag</name></name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_vraise</name><argument_list>(<argument><expr><name><name>argv</name><operator>-&gt;</operator><name>exc</name></name></expr></argument>, <argument><expr><name><name>argv</name><operator>-&gt;</operator><name>fmt</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>argv</name><operator>-&gt;</operator><name>ap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_raise</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gc_raise_tag</name></name></type> <name>argv</name> <init>= <expr><block>{

<expr><name>exc</name></expr>, <expr><name>fmt</name></expr>, <expr><operator>&amp;</operator><name>ap</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ruby_thread_has_gvl_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_vraise</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ruby_native_thread_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_call_with_gvl</name><argument_list>(<argument><expr><name>gc_vraise</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"[FATAL] "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>objspace_xfree</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>negative_size_allocation_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gc_raise</name><argument_list>(<argument><expr><name>rb_eNoMemError</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>ruby_memerror_body</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ruby_memerror</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ruby_thread_has_gvl_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ruby_native_thread_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_call_with_gvl</name><argument_list>(<argument><expr><name>ruby_memerror_body</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[FATAL] failed to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_memerror</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><call><name>rb_objspace_of</name><argument_list>(<argument><expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"rb_memerror pid=%"</literal><name>PRI_PIDT_PREFIX</name><literal type="string">"d\n"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>during_gc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>gc_exit</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="string">"rb_memerror"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <name>nomem_error</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exc</name> <operator>||</operator>

<call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_NOMEMORY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[FATAL] failed to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_NOMEMORY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_clear</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_NOMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>ruby_vm_special_exception_copy</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>exc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_RAISE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_aligned_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__MINGW32__</name></expr></cpp:if>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>__mingw_aligned_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:elif>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>_aligned_malloc</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_aligned_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<if_stmt><if>if <condition>(<expr><call><name>posix_memalign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memalign</name><argument_list>(<argument><expr><name>alignment</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>aligned</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>alignment</name> <operator>+</operator> <name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>aligned</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>res</name> <operator>+</operator> <name>alignment</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>aligned</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>aligned</name> <operator>&amp;</operator> <operator>(</operator><name>alignment</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>aligned</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>aligned</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>alignment</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>alignment</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name>alignment</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_aligned_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__MINGW32__</name></expr></cpp:if>

<expr_stmt><expr><call><name>__mingw_aligned_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:elif>

<expr_stmt><expr><call><name>_aligned_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMALIGN</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>objspace_malloc_size</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>hint</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MALLOC_USABLE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>malloc_usable_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>hint</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<enum>enum <name>memop_type</name> <block>{

<decl><name>MEMOP_TYPE_MALLOC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>MEMOP_TYPE_FREE</name></decl>,

<decl><name>MEMOP_TYPE_REALLOC</name></decl>

}</block>;</enum>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>atomic_sub_nounderflow</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sub</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>val</name> <init>= <expr><operator>*</operator><name>var</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <name>sub</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sub</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ATOMIC_SIZE_CAS</name><argument_list>(<argument><expr><operator>*</operator><name>var</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>val</name><operator>-</operator><name>sub</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_malloc_gc_stress</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_gc_stressful</name> <operator>&amp;&amp;</operator> <call><name>ruby_native_thread_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>reason</name> <init>= <expr><name>GPR_FLAG_IMMEDIATE_MARK</name> <operator>|</operator> <name>GPR_FLAG_IMMEDIATE_SWEEP</name> <operator>|</operator>

<name>GPR_FLAG_STRESS</name> <operator>|</operator> <name>GPR_FLAG_MALLOC</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_stress_full_mark_after_malloc_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reason</name> <operator>|=</operator> <name>GPR_FLAG_FULL_MARK</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>garbage_collect_with_gvl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_malloc_increase</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_size</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>memop_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;</operator> <name>old_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ATOMIC_SIZE_ADD</name><argument_list>(<argument><expr><name>malloc_increase</name></expr></argument>, <argument><expr><name>new_size</name> <operator>-</operator> <name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>ATOMIC_SIZE_ADD</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name></expr></argument>, <argument><expr><name>new_size</name> <operator>-</operator> <name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>atomic_sub_nounderflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>malloc_increase</name></expr></argument>, <argument><expr><name>old_size</name> <operator>-</operator> <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>atomic_sub_nounderflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>rgengc</name><operator>.</operator><name>oldmalloc_increase</name></name></expr></argument>, <argument><expr><name>old_size</name> <operator>-</operator> <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>MEMOP_TYPE_MALLOC</name></expr>)</condition> <block>{<block_content>

<label><name>retry</name>:</label>

<if_stmt><if>if <condition>(<expr><name>malloc_increase</name> <operator>&gt;</operator> <name>malloc_limit</name> <operator>&amp;&amp;</operator> <call><name>ruby_native_thread_p</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>dont_gc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ruby_thread_has_gvl_p</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_rest</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<goto>goto <name>retry</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>garbage_collect_with_gvl</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>GPR_FLAG_MALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;=</operator> <name>old_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ATOMIC_SIZE_ADD</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocated_size</name></name></expr></argument>, <argument><expr><name>new_size</name> <operator>-</operator> <name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>dec_size</name> <init>= <expr><name>old_size</name> <operator>-</operator> <name>new_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocated_size</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE_CHECK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>allocated_size</name> <operator>&lt;</operator> <name>dec_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"objspace_malloc_increase: underflow malloc_params.allocated_size."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>atomic_sub_nounderflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocated_size</name></name></expr></argument>, <argument><expr><name>dec_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"increase - ptr: %p, type: %s, new_size: %d, old_size: %d\n"</literal></expr></argument>,

<argument><expr><name>mem</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>MEMOP_TYPE_MALLOC</name></expr> ?</condition><then> <expr><literal type="string">"malloc"</literal></expr> </then><else>:

<expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>MEMOP_TYPE_FREE</name></expr> ?</condition><then> <expr><literal type="string">"free "</literal></expr> </then><else>:

<expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>MEMOP_TYPE_REALLOC</name></expr> ?</condition><then> <expr><literal type="string">"realloc"</literal></expr></then><else>: <expr><literal type="string">"error"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>new_size</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MEMOP_TYPE_MALLOC</name></expr>:</case>

<expr_stmt><expr><call><name>ATOMIC_SIZE_INC</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MEMOP_TYPE_FREE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>allocations</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocations</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>allocations</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>atomic_sub_nounderflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocations</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE_CHECK</name></expr></cpp:if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>GC_ASSERT</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>malloc_params</name><operator>.</operator><name>allocations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>MEMOP_TYPE_REALLOC</name></expr>:</case> <break>break;</break>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<struct>struct <name>malloc_obj_info</name> <block>{ 

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<decl_stmt><decl><type><name>size_t</name></type> <name>gen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>line</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ruby_malloc_info_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ruby_malloc_info_line</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>objspace_malloc_prepare</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_obj_info</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>objspace_malloc_fixup</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>objspace_malloc_size</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>objspace_malloc_increase</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MEMOP_TYPE_MALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>mem</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>gen</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>ruby_malloc_info_file</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <ternary><condition><expr><name><name>info</name><operator>-&gt;</operator><name>file</name></name></expr> ?</condition><then> <expr><name>ruby_malloc_info_line</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <name>info</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_WITH_GC</name><parameter_list>(<parameter><type><name>alloc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { objspace_malloc_gc_stress(objspace); if (!(alloc) &amp;&amp; (!garbage_collect_with_gvl(objspace, GPR_FLAG_FULL_MARK | GPR_FLAG_IMMEDIATE_MARK | GPR_FLAG_IMMEDIATE_SWEEP | GPR_FLAG_MALLOC) || !(alloc))) { ruby_memerror(); } } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>objspace_xmalloc0</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>objspace_malloc_prepare</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_WITH_GC</name><argument_list>(<argument><expr><name>mem</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>heap_xmalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>objspace_malloc_fixup</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>xmalloc2_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>elsize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>size_mul_or_raise</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>elsize</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>objspace_xrealloc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>objspace_xmalloc0</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mem</name> <operator>=</operator> <call><name>objspace_xmalloc0</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>objspace_xfree</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>new_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator>struct <name>malloc_obj_info</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_obj_info</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_size</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>old_size</name> <operator>=</operator> <call><name>objspace_malloc_size</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_WITH_GC</name><argument_list>(<argument><expr><name>mem</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_size</name> <operator>=</operator> <call><name>objspace_malloc_size</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>mem</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <name>info</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>objspace_malloc_increase</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>, <argument><expr><name>MEMOP_TYPE_REALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>heap_xrealloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name> <operator>&amp;&amp;</operator> <name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_INFO_GEN_SIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_INFO_SIZE_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name><name>malloc_info_gen_cnt</name><index>[<expr><name>MALLOC_INFO_GEN_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name><name>malloc_info_gen_size</name><index>[<expr><name>MALLOC_INFO_GEN_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name><name>malloc_info_size</name><index>[<expr><name>MALLOC_INFO_SIZE_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>malloc_info_file_table</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mmalloc_info_file_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>dmy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<macro><name>__attribute__</name><argument_list>(<argument>(destructor)</argument>)</argument_list></macro>

<function><type><name>void</name></type>

<name>rb_malloc_info_show_results</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"* malloc_info gen statistics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MALLOC_INFO_GEN_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>MALLOC_INFO_GEN_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"more\t%d\t%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_gen_cnt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_gen_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_gen_cnt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_gen_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"* malloc_info size statistics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MALLOC_INFO_SIZE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">16</literal> <operator>&lt;&lt;</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d\t%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"more\t%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>malloc_info_size</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>malloc_info_file_table</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"* malloc_info file statistics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>malloc_info_file_table</name></expr></argument>, <argument><expr><name>mmalloc_info_file_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>void</name></type>

<name>rb_malloc_info_show_results</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>objspace_xfree</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator>struct <name>malloc_obj_info</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_size</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>gen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name> <operator>-</operator> <name><name>info</name><operator>-&gt;</operator><name>gen</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>gen_index</name> <init>= <expr><ternary><condition><expr><name>gen</name> <operator>&gt;=</operator> <name>MALLOC_INFO_GEN_SIZE</name></expr> ?</condition><then> <expr><name>MALLOC_INFO_GEN_SIZE</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>gen</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>malloc_info_gen_cnt</name><index>[<expr><name>gen_index</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>malloc_info_gen_size</name><index>[<expr><name>gen_index</name></expr>]</index></name> <operator>+=</operator> <name><name>info</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MALLOC_INFO_SIZE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>s</name> <init>= <expr><literal type="number">16</literal> <operator>&lt;&lt;</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>malloc_info_size</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<goto>goto <name>found</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>malloc_info_size</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<label><name>found</name>:</label><empty_stmt>;</empty_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>info</name><operator>-&gt;</operator><name>file</name></name></expr></init></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>malloc_info_file_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>malloc_info_file_table</name> <operator>=</operator> <call><name>st_init_numtable_with_size</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>malloc_info_file_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>d</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"objspace_xfree: can not allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>malloc_info_file_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>info</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

if (gen &gt;= 2) {

if (info-&gt;file) {

fprintf(stderr, "free - size:%d, gen:%d, pos: %s:%d\n", (int)info-&gt;size, gen, info-&gt;file, (int)info-&gt;line);

}

else {

fprintf(stderr, "free - size:%d, gen:%d\n", (int)info-&gt;size, gen);

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>old_size</name> <operator>=</operator> <call><name>objspace_malloc_size</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>heap_xfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>objspace_malloc_increase</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>old_size</name></expr></argument>, <argument><expr><name>MEMOP_TYPE_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>ruby_xmalloc0</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>objspace_xmalloc0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xmalloc_body</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssize_t</name><operator>)</operator><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>negative_size_allocation_error</name><argument_list>(<argument><expr><literal type="string">"too large allocation size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ruby_xmalloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_malloc_size_overflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elsize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>,

<argument><expr><literal type="string">"malloc: possible integer overflow (%"</literal><name>PRIuSIZE</name><literal type="string">"*%"</literal><name>PRIuSIZE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><name>count</name></expr></argument>, <argument><expr><name>elsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xmalloc2_body</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>objspace_xmalloc0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>objspace_xcalloc</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>objspace_malloc_prepare</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_WITH_GC</name><argument_list>(<argument><expr><name>mem</name> <operator>=</operator> <call><name>calloc1</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>objspace_malloc_fixup</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xcalloc_body</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>objspace_xcalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_sized_xrealloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_sized_xrealloc</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_sized_xrealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssize_t</name><operator>)</operator><name>new_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>negative_size_allocation_error</name><argument_list>(<argument><expr><literal type="string">"too large allocation size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>objspace_xrealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xrealloc_body</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ruby_sized_xrealloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_sized_xrealloc2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_sized_xrealloc2</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_sized_xrealloc2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>old_n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>objspace_xrealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>old_n</name> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xrealloc2_body</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ruby_sized_xrealloc2</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_sized_xfree</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_sized_xfree</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>ruby_sized_xfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>objspace_xfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_xfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_xmalloc_mul_add</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>w</name> <init>= <expr><call><name>size_mul_add_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_xmalloc</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_xrealloc_mul_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>w</name> <init>= <expr><call><name>size_mul_add_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_xrealloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_xmalloc_mul_add_mul</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>w</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>u</name> <init>= <expr><call><name>size_mul_add_mul_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_xmalloc</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_xcalloc_mul_add_mul</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>w</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>u</name> <init>= <expr><call><name>size_mul_add_mul_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_xcalloc</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_mimmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_obj_info</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>mem</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <name>info</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>mem</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_mimfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>malloc_obj_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator>struct <name>malloc_obj_info</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_alloc_tmp_buffer_with_count</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>store</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>imemo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_imemo_tmpbuf_t</name> <modifier>*</modifier></type><name>tmpbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>imemo</name> <operator>=</operator> <call><name>rb_imemo_tmpbuf_auto_free_maybe_mark_buffer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>store</name> <operator>=</operator> <name>imemo</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ruby_xmalloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpbuf</name> <operator>=</operator> <operator>(</operator><name>rb_imemo_tmpbuf_t</name> <operator>*</operator><operator>)</operator><name>imemo</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmpbuf</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmpbuf</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_alloc_tmp_buffer</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>store</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>cnt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cnt</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>roomof</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative buffer size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_alloc_tmp_buffer_with_count</name><argument_list>(<argument><expr><name>store</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_free_tmp_buffer</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>store</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_imemo_tmpbuf_t</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>rb_imemo_tmpbuf_t</name><operator>*</operator><operator>)</operator><call><name>ATOMIC_VALUE_EXCHANGE</name><argument_list>(<argument><expr><operator>*</operator><name>store</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ATOMIC_PTR_EXCHANGE</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_malloc_allocated_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>rb_objspace</name><operator>.</operator><name>malloc_params</name><operator>.</operator><name>allocated_size</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_malloc_allocations</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>rb_objspace</name><operator>.</operator><name>malloc_params</name><operator>.</operator><name>allocations</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_gc_adjust_memory_usage</name><parameter_list>(<parameter><decl><type><name>ssize_t</name></type> <name>diff</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>objspace_malloc_increase</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MEMOP_TYPE_REALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>objspace_malloc_increase</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><name>diff</name></expr></argument>, <argument><expr><name>MEMOP_TYPE_REALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>weakmap</name> <block>{

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>obj2wmap</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>wmap2obj</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>final</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WMAP_DELETE_DEAD_OBJECT_IN_MARK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WMAP_DELETE_DEAD_OBJECT_IN_MARK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_mark_map</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_live_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_DELETE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>wmap_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_update_tbl_refs</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_update_tbl_refs</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>wmap_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WMAP_DELETE_DEAD_OBJECT_IN_MARK</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><name>wmap_mark_map</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>rb_objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_free_map</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>wmap_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><name>wmap_free_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_memsize_map</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>arg</name> <operator>+=</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>wmap_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>w</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><name>wmap_memsize_map</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>weakmap_type</name> <init>= <expr><block>{

<expr><literal type="string">"weakmap"</literal></expr>,

<expr><block>{

<expr><name>wmap_mark</name></expr>,

<expr><name>wmap_free</name></expr>,

<expr><name>wmap_memsize</name></expr>,

<expr><name>wmap_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>rb_hashtype_ident</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>wmap_finalize</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name> <operator>=</operator> <call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_hashtype_ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name> <operator>=</operator> <call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_hashtype_ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <call><name>rb_func_lambda_new</name><argument_list>(<argument><expr><name>wmap_finalize</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_live_p</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_id_value</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_live_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_final_func</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>wmap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wmap</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>value</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>size</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>wmap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_DELETE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_finalize</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>orig</name></decl>, <decl><type ref="prev"/><name>wmap</name></decl>, <decl><type ref="prev"/><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rids</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>obj</name> <operator>=</operator> <call><name>id2ref_obj_tbl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"wmap_finalize: objid is not found."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>orig</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rids</name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>*</operator><name>rids</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>wmap</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>rids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wmap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>size</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>wmap</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wmap</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>wmap_final_func</name></expr></argument>, <argument><expr><name>wmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<struct>struct <name>wmap_iter_arg</name> <block>{

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_inspect_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></init></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="char">'#'</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <ternary><condition><expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" =&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"-&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":%p"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_inspect_i</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="char">'#'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_each_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_each_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_each_key_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_each_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_each_key_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_each_value_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><name>rb_objspace_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_each_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_each_value_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_keys_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>wmap_iter_arg</name></name> <modifier>*</modifier></type><name>argp</name> <init>= <expr><operator>(</operator>struct <name>wmap_iter_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name><name>argp</name><operator>-&gt;</operator><name>objspace</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>argp</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_keys</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>wmap_iter_arg</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>objspace</name></name> <operator>=</operator> <operator>&amp;</operator><name>rb_objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_keys_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>args</name><operator>.</operator><name>value</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_values_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>wmap_iter_arg</name></name> <modifier>*</modifier></type><name>argp</name> <init>= <expr><operator>(</operator>struct <name>wmap_iter_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name><name>argp</name><operator>-&gt;</operator><name>objspace</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>argp</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>wmap_iter_arg</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>objspace</name></name> <operator>=</operator> <operator>&amp;</operator><name>rb_objspace</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><name>wmap_values_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>args</name><operator>.</operator><name>value</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>wmap_aset_update</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>optr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>ptr</name> <operator>=</operator> <name>optr</name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>val</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>optr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ruby_xmalloc0</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>size</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>optr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>wmap</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>define_final0</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>wmap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>define_final0</name><argument_list>(<argument><expr><name>wmap</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>obj2wmap</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>orig</name></expr></argument>, <argument><expr><name>wmap_aset_update</name></expr></argument>, <argument><expr><name>wmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>wmap</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>nonspecial_obj_id</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>wmap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>wmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>wmap_live_p</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_has_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>wmap_aref</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>wmap_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>weakmap</name></name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>weakmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>weakmap_type</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>wmap2obj</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_ST_INDEX_T</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<return>return <expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>ULL2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_PROFILE_RECORD_DEFAULT_SIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>double</name></type>

<name>getrusage_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_GETTIME</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_PROCESS_CPUTIME_ID</name></expr></argument>)</argument_list></call></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_clock_gettime</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>try_clock_gettime</name> <operator>&amp;&amp;</operator> <call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_PROCESS_CPUTIME_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>*</operator> <literal type="number">1e-9</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>try_clock_gettime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>usage</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>time</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usage</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>usage</name><operator>.</operator><name>ru_utime</name></name></expr>;</expr_stmt>

<return>return <expr><name><name>time</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>time</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1e-6</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>FILETIME</name></type> <name>creation_time</name></decl>, <decl><type ref="prev"/><name>exit_time</name></decl>, <decl><type ref="prev"/><name>kernel_time</name></decl>, <decl><type ref="prev"/><name>user_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>ui</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LONG_LONG</name></type> <name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GetProcessTimes</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><operator>&amp;</operator><name>creation_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exit_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kernel_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_time</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_time</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FILETIME</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name><name>ui</name><operator>.</operator><name>QuadPart</name></name> <operator>/</operator> <literal type="number">10L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>q</name> <operator>%</operator> <literal type="number">1000000L</literal><operator>)</operator> <operator>*</operator> <literal type="number">1e-6</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>/=</operator> <literal type="number">1000000L</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>q</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>q</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>~</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>t</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0.0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_setup_new_record</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>index</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>GC_PROFILE_RECORD_DEFAULT_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gc_profile_record</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name> <operator>+=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr></argument>, <argument><expr><call><name>xmalloc2_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gc_profile_record</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"gc_profile malloc or realloc miss"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>record</name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>current_record</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name><index>[<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>gc_profile_record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>reason</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>ruby_gc_stressful</name></expr> ?</condition><then> <expr><name>GPR_FLAG_STRESS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>allocated_size</name></name> <operator>=</operator> <name>malloc_allocated_size</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name> <operator>&amp;&amp;</operator> <name>GC_PROFILE_DETAIL_MEMORY</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>usage</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usage</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>maxrss</name></name> <operator>=</operator> <name><name>usage</name><operator>.</operator><name>ru_maxrss</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>minflt</name></name> <operator>=</operator> <name><name>usage</name><operator>.</operator><name>ru_minflt</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>majflt</name></name> <operator>=</operator> <name><name>usage</name><operator>.</operator><name>ru_majflt</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>prepare_time</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>prepare_time</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_invoke_time</name></name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>

<name>elapsed_time_from</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>time</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>now</name> <init>= <expr><call><name>getrusage_time</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;</operator> <name>time</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>now</name> <operator>-</operator> <name>time</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name> <operator>=</operator> <call><name>elapsed_time_from</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_invoke_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_invoke_time</name></name> <operator>-=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>invoke_time</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_DTRACE_GC_HOOK</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (RUBY_DTRACE_GC_##name##_ENABLED()) RUBY_DTRACE_GC_##name();} while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_mark_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_GC_HOOK</name><argument_list>(<argument><expr><name>MARK_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gc_mark_time</name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_mark_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_GC_HOOK</name><argument_list>(<argument><expr><name>MARK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_mark_time</name></name> <operator>=</operator> <call><name>elapsed_time_from</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_mark_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_sweep_timer_start</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_GC_HOOK</name><argument_list>(<argument><expr><name>SWEEP_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>GC_PROFILE_MORE_DETAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>gc_sweep_start_time</name></name> <operator>=</operator> <call><name>getrusage_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_sweep_timer_stop</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_GC_HOOK</name><argument_list>(<argument><expr><name>SWEEP_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>sweep_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sweep_time</name> <operator>=</operator> <call><name>elapsed_time_from</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>gc_sweep_start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name> <operator>+=</operator> <name>sweep_time</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>GC_PROFILE_MORE_DETAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sweep_time</name> <operator>=</operator> <call><name>elapsed_time_from</name><argument_list>(<argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>gc_sweep_start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>gc_sweep_time</name></name> <operator>+=</operator> <name>sweep_time</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>heap_pages_deferred_final</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>GPR_FLAG_HAVE_FINALIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>heap_pages_deferred_final</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>latest_gc_info</name></name> <operator>|=</operator> <name>GPR_FLAG_HAVE_FINALIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_set_malloc_info</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_increase</name></name> <operator>=</operator> <name>malloc_increase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_limit</name></name> <operator>=</operator> <name>malloc_limit</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>gc_prof_set_heap_info</name><parameter_list>(<parameter><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gc_prof_enabled</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>gc_prof_record</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>live</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_allocated_objects_at_gc_start</name></name> <operator>-</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>total_freed_objects</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>total</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>heap_used_at_gc_start</name></name> <operator>*</operator> <name>HEAP_PAGE_OBJ_LIMIT</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_pages</name></name> <operator>=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>heap_used_at_gc_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_live_objects</name></name> <operator>=</operator> <name>live</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_free_objects</name></name> <operator>=</operator> <name>total</name> <operator>-</operator> <name>live</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_objects</name></name> <operator>=</operator> <name>total</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_size</name></name> <operator>=</operator> <name>live</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_size</name></name> <operator>=</operator> <name>total</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>current_record</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_record_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>prof</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>gc_profile</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>(</operator><operator>&amp;</operator><name>rb_objspace</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>prof</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_FLAGS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gc_info_decode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_TIME"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_INVOKE_TIME"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_invoke_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_USE_SIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_TOTAL_SIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_TOTAL_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_IS_MARKED"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_MARK_TIME"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_mark_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"GC_SWEEP_TIME"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_sweep_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ALLOCATE_INCREASE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_increase</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ALLOCATE_LIMIT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_limit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_USE_PAGES"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_pages</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_LIVE_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_live_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_FREE_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_free_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"REMOVING_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>removing_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"EMPTY_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>empty_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HAVE_FINALIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_HAVE_FINALIZE</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"OLD_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>old_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"REMEMBERED_NORMAL_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>remembered_normal_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>prof</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"REMEMBERED_SHADY_OBJECTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>remembered_shady_objects</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>gc_profile</name></expr></argument>, <argument><expr><name>prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>gc_profile</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAJOR_REASON_MAX</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>gc_profile_dump_major_reason</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>reason</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>GPR_FLAG_MAJOR_MASK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>GPR_FLAG_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (reason &amp; GPR_FLAG_MAJOR_BY_##x) { buff[i++] = #x[0]; if (i &gt;= MAJOR_REASON_MAX) rb_bug("gc_profile_dump_major_reason: overflow"); buff[i] = 0; }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>NOFREE</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>OLDGEN</name></expr></argument>, <argument><expr><name>O</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>SHADY</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></cpp:if>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>OLDMALLOC</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>C</name></cpp:undef>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>buff</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gc_profile_dump_on</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>out</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>append</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAJOR_REASON_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>reason_str</name><index>[<expr><name>MAJOR_REASON_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name> <operator>&amp;&amp;</operator> <name>count</name></expr> )</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>gc_profile_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"GC %"</literal><name>PRIuSIZE</name><literal type="string">" invokes.\n"</literal></expr></argument>, <argument><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"Index Invoke Time(sec) Use Size(byte) Total Size(byte) Total Object GC Time(ms)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%5"</literal><name>PRIuSIZE</name><literal type="string">" %19.3f %20"</literal><name>PRIuSIZE</name><literal type="string">" %20"</literal><name>PRIuSIZE</name><literal type="string">" %20"</literal><name>PRIuSIZE</name><literal type="string">" %30.20f\n"</literal></expr></argument>,

<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_invoke_time</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_size</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_size</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_total_objects</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_time</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_MORE_DETAIL</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><literal type="string">"\n\n"</literal> \

<literal type="string">"More detail.\n"</literal> \

<literal type="string">"Prepare Time = Previously GC's rest sweep time\n"</literal>

<literal type="string">"Index Flags Allocate Inc. Allocate Limit"</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<literal type="string">" Allocated Size"</literal>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="string">" Use Page Mark Time(ms) Sweep Time(ms) Prepare Time(ms) LivingObj FreeObj RemovedObj EmptyObj"</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<literal type="string">" OldgenObj RemNormObj RemShadObj"</literal>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></cpp:if>

<literal type="string">" MaxRSS(KB) MinorFLT MajorFLT"</literal>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="string">"\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>&amp;</operator><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%5"</literal><name>PRIuSIZE</name><literal type="string">" %4s/%c/%6s%c %13"</literal><name>PRIuSIZE</name><literal type="string">" %15"</literal><name>PRIuSIZE</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<literal type="string">" %15"</literal><name>PRIuSIZE</name>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="string">" %9"</literal><name>PRIuSIZE</name><literal type="string">" %17.12f %17.12f %17.12f %10"</literal><name>PRIuSIZE</name><literal type="string">" %10"</literal><name>PRIuSIZE</name><literal type="string">" %10"</literal><name>PRIuSIZE</name><literal type="string">" %10"</literal><name>PRIuSIZE</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

<literal type="string">"%10"</literal><name>PRIuSIZE</name><literal type="string">" %10"</literal><name>PRIuSIZE</name><literal type="string">" %10"</literal><name>PRIuSIZE</name>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></cpp:if>

<literal type="string">"%11ld %8ld %8ld"</literal>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>,

<argument><expr><call><name>gc_profile_dump_major_reason</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>reason_str</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_HAVE_FINALIZE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'F'</literal></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_NEWOBJ</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"NEWOBJ"</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_MALLOC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"MALLOC"</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_METHOD</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"METHOD"</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_CAPI</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"CAPI__"</literal></expr> </then><else>: <expr><literal type="string">"??????"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GPR_FLAG_STRESS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'!'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_increase</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>allocate_limit</name></name></expr></argument>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></cpp:if>

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>allocated_size</name></name></expr></argument>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_use_pages</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_mark_time</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>gc_sweep_time</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>prepare_time</name></name><operator>*</operator><literal type="number">1000</literal></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_live_objects</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>heap_free_objects</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>removing_objects</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>empty_objects</name></name></expr></argument>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_PROFILE</name></expr></cpp:if>

,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>old_objects</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>remembered_normal_objects</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>remembered_shady_objects</name></name></expr></argument>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></cpp:if>

,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>maxrss</name></name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>minflt</name></name></expr></argument>,

<argument><expr><name><name>record</name><operator>-&gt;</operator><name>majflt</name></name></expr></argument>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_result</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gc_profile_dump_on</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rb_str_buf_append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_report</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>out</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>rb_stdout</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gc_profile_dump_on</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>rb_io_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_total_time</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name> <operator>&amp;&amp;</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>next_index</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>time</name> <operator>+=</operator> <name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>records</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gc_time</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_enable_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_enable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>current_record</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gc_profile_disable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>run</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>objspace</name><operator>-&gt;</operator><name>profile</name><operator>.</operator><name>current_record</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>type_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_NAME</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case (t): return #t;</cpp:value></cpp:define>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_STRUCT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_RATIONAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_FIXNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TYPE_NAME</name><argument_list>(<argument><expr><name>T_ZOMBIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>T_DATA</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>&amp;&amp;</operator> <call><name>rb_objspace_data_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_objspace_data_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="string">"T_DATA"</literal></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPE_NAME</name></cpp:undef>

</block_content>}</block></switch>

<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>obj_type_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>type_name</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_method_type_name</name><parameter_list>(<parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case> <return>return <expr><literal type="string">"iseq"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case> <return>return <expr><literal type="string">"attrest"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case> <return>return <expr><literal type="string">"ivar"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case> <return>return <expr><literal type="string">"bmethod"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case> <return>return <expr><literal type="string">"alias"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case> <return>return <expr><literal type="string">"refined"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case> <return>return <expr><literal type="string">"cfunc"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case> <return>return <expr><literal type="string">"zsuper"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case> <return>return <expr><literal type="string">"missing"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case> <return>return <expr><literal type="string">"optimized"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case> <return>return <expr><literal type="string">"undef"</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case> <return>return <expr><literal type="string">"notimplemented"</literal></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_method_type_name: unreachable (type: %d)"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_P</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GC_ASSERT(!FL_TEST((ary), ELTS_SHARED) || !FL_TEST((ary), RARRAY_EMBED_FLAG)), FL_TEST((ary),ELTS_SHARED)!=0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_EMBED_P</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(GC_ASSERT(!FL_TEST((ary), ELTS_SHARED) || !FL_TEST((ary), RARRAY_EMBED_FLAG)), FL_TEST((ary), RARRAY_EMBED_FLAG)!=0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_raw_iseq_info</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>buff_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>buff_size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name></name> <operator>&amp;&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>, <argument><expr><name>T_MOVED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>n</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">" %s@%s:%d"</literal></expr></argument>,

<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>n</name></expr> ?</condition><then> <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_raw_obj_info</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>buff_size</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFF_ARGS</name></cpp:macro> <cpp:value>buff + pos, buff_size - pos</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPENDF</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if ((pos += snprintf f) &gt;= buff_size) goto end</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>obj_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">" %ld"</literal><operator>,</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">" %s"</literal><operator>,</operator> <call><name>rb_id2name</name><argument_list>(<argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TF</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) != 0 ? "true" : "false")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) != 0 ? (s) : " ")</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>type</name> <init>= <expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>age</name> <init>= <expr><call><name>RVALUE_FLAGS_AGE</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%p [%d%s%s%s%s%s] %s "</literal><operator>,</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>,</operator> <name>age</name><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RVALUE_UNCOLLECTIBLE_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"L"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RVALUE_MARK_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"M"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RVALUE_PIN_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"P"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RVALUE_MARKING_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"R"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RVALUE_WB_UNPROTECTED_BITMAP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"U"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>obj_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%p [%dXXXX] %s"</literal><operator>,</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>,</operator> <name>age</name><operator>,</operator>

<call><name>obj_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>internal_object_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(temporary internal)"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>class_path</name> <init>= <expr><call><name>rb_class_path_cached</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(%s)"</literal><operator>,</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"@%s:%d"</literal><operator>,</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>file</name><operator>,</operator> <call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>line</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_NODE</name></expr>:</case>

<expr_stmt><expr><call><name>UNEXPECTED_NODE</name><argument_list>(<argument><expr><name>rb_raw_obj_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"shared -&gt; %s"</literal><operator>,</operator>

<call><name>rb_obj_info</name><argument_list>(<argument><expr><call><name>RARRAY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RARRAY_EMBED_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"[%s%s] len: %d (embed)"</literal><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"E"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<operator>(</operator><name>int</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"[%s%s%s] len: %d, capa:%d ptr:%p"</literal><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"E"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"T"</literal></expr></argument>)</argument_list></call><operator>,</operator>

<operator>(</operator><name>int</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>,</operator>

<ternary><condition><expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>RARRAY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr></else></ternary><operator>,</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>T_STRING</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_MOVED</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"-&gt; %p"</literal><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_HASH</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"[%c%c] %d"</literal><operator>,</operator>

<ternary><condition><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'A'</literal></expr> </then><else>: <expr><literal type="char">'S'</literal></expr></else></ternary><operator>,</operator>

<ternary><condition><expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary><operator>,</operator>

<operator>(</operator><name>int</name><operator>)</operator><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>class_path</name> <init>= <expr><call><name>rb_class_path_cached</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(annon)"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>class_path</name> <init>= <expr><call><name>rb_class_path_cached</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"src:%s"</literal><operator>,</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_OBJECT</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name> <init>= <expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>ROBJECT_EMBED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(embed) len:%d"</literal><operator>,</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"len:%d ptr:%p"</literal><operator>,</operator> <name>len</name><operator>,</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>T_DATA</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>block</name> <operator>=</operator> <call><name>vm_proc_block</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>block_type_iseq</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>iseq</name> <operator>=</operator> <call><name>vm_block_iseq</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raw_iseq_info</name><argument_list>(<argument><expr><name>BUFF_ARGS</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>type_name</name> <init>= <expr><call><name>rb_objspace_data_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <name>type_name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>T_IMEMO</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>imemo_name</name> <init>= <expr><literal type="string">"\0"</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMEMO_NAME</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case imemo_##x: imemo_name = #x; break;</cpp:value></cpp:define>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>svar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>throw_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>ment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>parser_strterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>callinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IMEMO_NAME</name><argument_list>(<argument><expr><name>callcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IMEMO_NAME</name></cpp:undef>

<default>default:</default> <expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"&lt;%s&gt; "</literal><operator>,</operator> <name>imemo_name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_ment</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><operator>&amp;</operator><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>imemo</name><operator>.</operator><name>ment</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">":%s (%s%s%s%s) type:%s alias:%d owner:%p defined_class:%p"</literal><operator>,</operator>

<call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call><operator>,</operator>

<ternary><condition><expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PUBLIC</name></expr> ?</condition><then> <expr><literal type="string">"pub"</literal></expr> </then><else>:

<expr><ternary><condition><expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PRIVATE</name></expr> ?</condition><then> <expr><literal type="string">"pri"</literal></expr> </then><else>: <expr><literal type="string">"pro"</literal></expr></else></ternary></expr></else></ternary><operator>,</operator>

<ternary><condition><expr><call><name>METHOD_ENTRY_COMPLEMENTED</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">",cmp"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>,</operator>

<ternary><condition><expr><call><name>METHOD_ENTRY_CACHED</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">",cc"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>,</operator>

<ternary><condition><expr><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">",inv"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>,</operator>

<call><name>rb_method_type_name</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>,</operator>

<name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>alias_count</name></name><operator>,</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>me</name><operator>-&gt;</operator><name>owner</name></name><operator>,</operator> 

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_ISEQ</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">" (iseq:%s)"</literal><operator>,</operator> <call><name>obj_info</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"%s"</literal><operator>,</operator> <call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>imemo_iseq</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_raw_iseq_info</name><argument_list>(<argument><expr><name>BUFF_ARGS</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>imemo_callinfo</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(mid:%s, flag:%x argc:%d, kwarg:%s)"</literal><operator>,</operator>

<call><name>rb_id2name</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>,</operator>

<ternary><condition><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"available"</literal></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>imemo_callcache</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>class_path</name> <init>= <expr><ternary><condition><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr> ?</condition><then> <expr><call><name>rb_class_path_cached</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>APPENDF</name><argument_list>(<argument><expr><operator>(</operator><name>BUFF_ARGS</name><operator>,</operator> <literal type="string">"(klass:%s, cme:%s (%p) call:%p"</literal><operator>,</operator>

<ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"??"</literal></expr> </then><else>: <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>class_path</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>

<ternary><condition><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"&lt;NULL&gt;"</literal></expr></else></ternary><operator>,</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>,</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>vm_cc_call</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TF</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>C</name></cpp:undef>

</block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>

<return>return <expr><name>buff</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPENDF</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUFF_ARGS</name></cpp:undef>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RGENGC_OBJ_INFO</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_INFO_BUFFERS_NUM</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ_INFO_BUFFERS_SIZE</name></cpp:macro> <cpp:value>0x100</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>obj_info_buffers_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>obj_info_buffers</name><index>[<expr><name>OBJ_INFO_BUFFERS_NUM</name></expr>]</index><index>[<expr><name>OBJ_INFO_BUFFERS_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>obj_info</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name> <init>= <expr><name>obj_info_buffers_index</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buff</name> <init>= <expr><operator>&amp;</operator><name><name>obj_info_buffers</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj_info_buffers_index</name> <operator>&gt;=</operator> <name>OBJ_INFO_BUFFERS_NUM</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>obj_info_buffers_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>OBJ_INFO_BUFFERS_SIZE</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>obj_info</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>obj_type_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_obj_info</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_obj_info_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"rb_obj_info_dump: %s\n"</literal></expr></argument>, <argument><expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_obj_info_dump_loc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;OBJ_INFO:%s@%s:%d&gt; %s\n"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG</name></expr></cpp:if>

<function><type><name>void</name></type>

<name>rb_gcdebug_print_obj_condition</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"created at: %s:%d\n"</literal></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>file</name></expr></argument>, <argument><expr><call><name>RANY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MOVED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"moved?: true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"moved?: false\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_pointer_to_heap</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pointer to heap?: true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pointer to heap?: false\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"marked? : %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_MARK_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pinned? : %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>MARKED_IN_BITMAP</name><argument_list>(<argument><expr><call><name>GET_HEAP_PINNED_BITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"age? : %d\n"</literal></expr></argument>, <argument><expr><call><name>RVALUE_AGE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"old? : %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RVALUE_OLD_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WB-protected?: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RVALUE_WB_UNPROTECTED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"false"</literal></expr> </then><else>: <expr><literal type="string">"true"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"remembered? : %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RVALUE_REMEMBERED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_lazy_sweeping</name><argument_list>(<argument><expr><name>heap_eden</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lazy sweeping?: true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"swept?: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>is_swept_object</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"done"</literal></expr> </then><else>: <expr><literal type="string">"not yet"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lazy sweeping?: false\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>gcdebug_sentinel</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: object %s(%p) is inadvertently collected\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>

<name>rb_gcdebug_sentinel</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_define_finalizer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_proc_new</name><argument_list>(<argument><expr><name>gcdebug_sentinel</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_gcdebug_add_stress_to_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stress_to_class</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stress_to_class</name> <operator>=</operator> <call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_gcdebug_remove_stress_to_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_objspace_t</name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><operator>&amp;</operator><name>rb_objspace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stress_to_class</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_delete_same</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stress_to_class</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stress_to_class</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.rbinc"</cpp:file></cpp:include>

<function><type><name>void</name></type>

<name>Init_GC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mObjSpace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mProfiler</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>gc_constants</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rb_mGC</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"GC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gc_constants</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>GC_DEBUG</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"RVALUE_SIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RVALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_PAGE_OBJ_LIMIT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>HEAP_PAGE_OBJ_LIMIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_PAGE_BITMAP_SIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>HEAP_PAGE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"HEAP_PAGE_BITMAP_PLANES"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>HEAP_PAGE_BITMAP_PLANES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>gc_constants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"INTERNAL_CONSTANTS"</literal></expr></argument>, <argument><expr><name>gc_constants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mProfiler</name> <operator>=</operator> <call><name>rb_define_module_under</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"Profiler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"enabled?"</literal></expr></argument>, <argument><expr><name>gc_profile_enable_get</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"enable"</literal></expr></argument>, <argument><expr><name>gc_profile_enable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"raw_data"</literal></expr></argument>, <argument><expr><name>gc_profile_record_get</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>, <argument><expr><name>gc_profile_disable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"clear"</literal></expr></argument>, <argument><expr><name>gc_profile_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"result"</literal></expr></argument>, <argument><expr><name>gc_profile_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"report"</literal></expr></argument>, <argument><expr><name>gc_profile_report</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mProfiler</name></expr></argument>, <argument><expr><literal type="string">"total_time"</literal></expr></argument>, <argument><expr><name>gc_profile_total_time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mObjSpace</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"ObjectSpace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"each_object"</literal></expr></argument>, <argument><expr><name>os_each_obj</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"define_finalizer"</literal></expr></argument>, <argument><expr><name>define_final</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"undefine_finalizer"</literal></expr></argument>, <argument><expr><name>undefine_final</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"_id2ref"</literal></expr></argument>, <argument><expr><name>os_id2ref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_register_special_exception</name><argument_list>(<argument><expr><name>ruby_error_nomemory</name></expr></argument>, <argument><expr><name>rb_eNoMemError</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cBasicObject</name></expr></argument>, <argument><expr><literal type="string">"__id__"</literal></expr></argument>, <argument><expr><name>rb_obj_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"object_id"</literal></expr></argument>, <argument><expr><name>rb_obj_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"count_objects"</literal></expr></argument>, <argument><expr><name>count_objects</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cWeakMap</name> <init>= <expr><call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_mObjSpace</name></expr></argument>, <argument><expr><literal type="string">"WeakMap"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><name>wmap_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>wmap_aset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>wmap_aref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"include?"</literal></expr></argument>, <argument><expr><name>wmap_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"member?"</literal></expr></argument>, <argument><expr><name>wmap_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"key?"</literal></expr></argument>, <argument><expr><name>wmap_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>wmap_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>wmap_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"each_pair"</literal></expr></argument>, <argument><expr><name>wmap_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"each_key"</literal></expr></argument>, <argument><expr><name>wmap_each_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"each_value"</literal></expr></argument>, <argument><expr><name>wmap_each_value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"keys"</literal></expr></argument>, <argument><expr><name>wmap_keys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>, <argument><expr><name>wmap_values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>wmap_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>wmap_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cWeakMap</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"verify_internal_consistency"</literal></expr></argument>, <argument><expr><name>gc_verify_internal_consistency_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"verify_transient_heap_internal_consistency"</literal></expr></argument>, <argument><expr><name>gc_verify_transient_heap_internal_consistency</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MALLOC_ALLOCATED_SIZE</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"malloc_allocated_size"</literal></expr></argument>, <argument><expr><name>gc_malloc_allocated_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"malloc_allocations"</literal></expr></argument>, <argument><expr><name>gc_malloc_allocations</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GC_DEBUG_STRESS_TO_CLASS</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"add_stress_to_class"</literal></expr></argument>, <argument><expr><name>rb_gcdebug_add_stress_to_class</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"remove_stress_to_class"</literal></expr></argument>, <argument><expr><name>rb_gcdebug_remove_stress_to_class</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mGC</name></expr></argument>, <argument><expr><literal type="string">"OPTS"</literal></expr></argument>, <argument><expr><name>opts</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (o) rb_ary_push(opts, rb_fstring_lit(#o))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>GC_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>USE_RGENGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>RGENGC_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>RGENGC_CHECK_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>RGENGC_PROFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>RGENGC_ESTIMATE_OLDMALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>GC_PROFILE_MORE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>GC_ENABLE_LAZY_SWEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>CALC_EXACT_MALLOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>MALLOC_ALLOCATED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>MALLOC_ALLOCATED_SIZE_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPT</name><argument_list>(<argument><expr><name>GC_PROFILE_DETAIL_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT</name></cpp:undef>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_xmalloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_xmalloc</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_xmalloc2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_xmalloc2</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_xcalloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_xcalloc</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_xrealloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_xrealloc</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_xrealloc2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ruby_xrealloc2</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name>ruby_malloc_info_file</name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_malloc_info_line</name> <operator>=</operator> <name>__LINE__</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_xmalloc_body</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xmalloc2</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name>ruby_malloc_info_file</name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_malloc_info_line</name> <operator>=</operator> <name>__LINE__</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_xmalloc2_body</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xcalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name>ruby_malloc_info_file</name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_malloc_info_line</name> <operator>=</operator> <name>__LINE__</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_xcalloc_body</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xrealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name>ruby_malloc_info_file</name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_malloc_info_line</name> <operator>=</operator> <name>__LINE__</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_xrealloc_body</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>ruby_xrealloc2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_GC_MALLOC_OBJ_INFO_DETAILS</name></expr></cpp:if>

<expr_stmt><expr><name>ruby_malloc_info_file</name> <operator>=</operator> <name>__FILE__</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_malloc_info_line</name> <operator>=</operator> <name>__LINE__</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_xrealloc2_body</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

</unit>
