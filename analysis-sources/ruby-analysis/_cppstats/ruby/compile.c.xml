<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\compile.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id_table.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/complex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iseq.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_callinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_debug.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns.inc"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns_info.inc"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_UNTYPED_DATA_WARNING</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_UNTYPED_DATA_WARNING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIXNUM_INC</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n)+(INT2FIX(i)&amp;~FIXNUM_FLAG))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIXNUM_OR</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n)|INT2FIX(i))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>iseq_link_element</name> <block>{

<enum>enum <block>{

<decl><name>ISEQ_ELEMENT_ANCHOR</name></decl>,

<decl><name>ISEQ_ELEMENT_LABEL</name></decl>,

<decl><name>ISEQ_ELEMENT_INSN</name></decl>,

<decl><name>ISEQ_ELEMENT_ADJUST</name></decl>,

<decl><name>ISEQ_ELEMENT_TRACE</name></decl>,

}</block> <decl><name>type</name></decl>;</enum>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_link_element</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_link_element</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

}</block></struct></type> <name>LINK_ELEMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>iseq_link_anchor</name> <block>{

<decl_stmt><decl><type><name>LINK_ELEMENT</name></type> <name>anchor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

}</block></struct></type> <name>LINK_ANCHOR</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>LABEL_RESCUE_NONE</name></decl>,

<decl><name>LABEL_RESCUE_BEG</name></decl>,

<decl><name>LABEL_RESCUE_END</name></decl>,

<decl><name>LABEL_RESCUE_TYPE_MAX</name></decl>

}</block></enum></type> <name>LABEL_RESCUE_TYPE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>iseq_label_data</name> <block>{

<decl_stmt><decl><type><name>LINK_ELEMENT</name></type> <name>link</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>label_no</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>position</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sc_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>refcnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>set</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rescued</name><range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>unremovable</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block></struct></type> <name>LABEL</name>;</typedef>

<typedef>typedef <type><struct>struct <name>iseq_insn_data</name> <block>{

<decl_stmt><decl><type><name>LINK_ELEMENT</name></type> <name>link</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>insn_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>operand_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sc_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>line_no</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name></decl>;</decl_stmt>

}</block> <decl><name>insn_info</name></decl>;</struct>

}</block></struct></type> <name>INSN</name>;</typedef>

<typedef>typedef <type><struct>struct <name>iseq_adjust_data</name> <block>{

<decl_stmt><decl><type><name>LINK_ELEMENT</name></type> <name>link</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line_no</name></decl>;</decl_stmt>

}</block></struct></type> <name>ADJUST</name>;</typedef>

<typedef>typedef <type><struct>struct <name>iseq_trace_data</name> <block>{

<decl_stmt><decl><type><name>LINK_ELEMENT</name></type> <name>link</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>event</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>data</name></decl>;</decl_stmt>

}</block></struct></type> <name>TRACE</name>;</typedef>

<struct>struct <name>ensure_range</name> <block>{

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>begin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>iseq_compile_data_ensure_node_stack</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>ensure_node</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>erange</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name><name>rb_iseq_shared_exc_local_tbl</name><index>[]</index></name> <init>= <expr><block>{<expr><name>idERROR_INFO</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CPDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPDEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compile_debug</name></cpp:macro> <cpp:value>CPDEBUG</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compile_debug</name></cpp:macro> <cpp:value>ISEQ_COMPILE_DATA(iseq)-&gt;option-&gt;debug_level</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compile_debug_print_indent</name><parameter_list>(<parameter><type><name>level</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ruby_debug_print_indent((level), compile_debug, gl_node_level * 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void) (compile_debug_print_indent(1) &amp;&amp; ruby_debug_print_value(1, compile_debug, (header), (value)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugi</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void) (compile_debug_print_indent(1) &amp;&amp; ruby_debug_print_id(1, compile_debug, (header), (id)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_param</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void) (compile_debug_print_indent(1) &amp;&amp; ruby_debug_print_value(1, compile_debug, (header), (value)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_verbose</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void) (compile_debug_print_indent(2) &amp;&amp; ruby_debug_print_value(2, compile_debug, (header), (value)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_verbose_node</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void) (compile_debug_print_indent(10) &amp;&amp; ruby_debug_print_value(10, compile_debug, (header), (value)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_node_start</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) (compile_debug_print_indent(1) &amp;&amp; (ruby_debug_print_node(1, CPDEBUG, "", (const NODE *)(node)), gl_node_level)), gl_node_level++)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_node_end</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>gl_node_level --</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugi</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_verbose</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_verbose_node</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugp_param</name><parameter_list>(<parameter><type><name>header</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_node_start</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_node_end</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>printf</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>printf</name></cpp:macro> <cpp:value>ruby_debug_printf</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugs</name></cpp:macro> <cpp:value>if (compile_debug_print_indent(1)) ruby_debug_printf</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_compile</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)(compile_debug_print_indent(1) &amp;&amp; fputs((msg), stderr)), (v))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugs</name></cpp:macro> <cpp:value>if(0)printf</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_compile</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LVAR_ERRINFO</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_LABEL</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>new_label_body(iseq, (l))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LABEL_FORMAT</name></cpp:macro> <cpp:value>"&lt;L%03d&gt;"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_ISEQ</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>line_no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>new_child_iseq(iseq, (node), rb_fstring(name), 0, (type), (line_no))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_CHILD_ISEQ</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>line_no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>new_child_iseq(iseq, (node), rb_fstring(name), iseq, (type), (line_no))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SEQ</name><parameter_list>(<parameter><type><name>seq1</name></type></parameter>, <parameter><type><name>seq2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>APPEND_LIST((seq1), (seq2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INSN</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_BEFORE_INSN</name><parameter_list>(<parameter><type><name>next</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ELEM_INSERT_PREV(&amp;(next)-&gt;link, (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_AFTER_INSN</name><parameter_list>(<parameter><type><name>prev</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ELEM_INSERT_NEXT(&amp;(prev)-&gt;link, (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INSN1</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>op1</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 1, (VALUE)(op1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_BEFORE_INSN1</name><parameter_list>(<parameter><type><name>next</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>op1</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ELEM_INSERT_PREV(&amp;(next)-&gt;link, (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 1, (VALUE)(op1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_AFTER_INSN1</name><parameter_list>(<parameter><type><name>prev</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>op1</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ELEM_INSERT_NEXT(&amp;(prev)-&gt;link, (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 1, (VALUE)(op1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LABEL_REF</name><parameter_list>(<parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((label)-&gt;refcnt++)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INSNL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ADD_INSN1(seq, line, insn, label), LABEL_REF(label))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INSN2</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>op1</name></type></parameter>, <parameter><type><name>op2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 2, (VALUE)(op1), (VALUE)(op2)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_INSN3</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>, <parameter><type><name>op1</name></type></parameter>, <parameter><type><name>op2</name></type></parameter>, <parameter><type><name>op3</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_insn_body(iseq, (line), BIN(insn), 3, (VALUE)(op1), (VALUE)(op2), (VALUE)(op3)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SEND</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_SEND_R((seq), (line), (id), (argc), NULL, (VALUE)INT2FIX(0), NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SEND_WITH_FLAG</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_SEND_R((seq), (line), (id), (argc), NULL, (VALUE)(flag), NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SEND_WITH_BLOCK</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>block</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_SEND_R((seq), (line), (id), (argc), (block), (VALUE)INT2FIX(0), NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_CALL_RECEIVER</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_INSN((seq), (line), putself)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_CALL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_SEND_R((seq), (line), (id), (argc), NULL, (VALUE)INT2FIX(VM_CALL_FCALL), NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_CALL_WITH_BLOCK</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>block</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_SEND_R((seq), (line), (id), (argc), (block), (VALUE)INT2FIX(VM_CALL_FCALL), NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SEND_R</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>block</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>, <parameter><type><name>keywords</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_insn_send(iseq, (line), (id), (VALUE)(argc), (block), (VALUE)(flag), (keywords)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_TRACE</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>event</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *)new_trace_body(iseq, (event), 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_TRACE_WITH_DATA</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>event</name></type></parameter>, <parameter><type><name>data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *)new_trace_body(iseq, (event), (data)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_BRANCH_BASE</name><parameter_list>(<parameter><type><name>branches</name></type></parameter>, <parameter><type><name>first_line</name></type></parameter>, <parameter><type><name>first_column</name></type></parameter>, <parameter><type><name>last_line</name></type></parameter>, <parameter><type><name>last_column</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ISEQ_COVERAGE(iseq) &amp;&amp; ISEQ_BRANCH_COVERAGE(iseq) &amp;&amp; (first_line) &gt; 0) { VALUE structure = RARRAY_AREF(ISEQ_BRANCH_COVERAGE(iseq), 0); branches = rb_ary_tmp_new(5); rb_ary_push(structure, branches); rb_ary_push(branches, ID2SYM(rb_intern(type))); rb_ary_push(branches, INT2FIX(first_line)); rb_ary_push(branches, INT2FIX(first_column)); rb_ary_push(branches, INT2FIX(last_line)); rb_ary_push(branches, INT2FIX(last_column)); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_TRACE_BRANCH_COVERAGE</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>first_line</name></type></parameter>, <parameter><type><name>first_column</name></type></parameter>, <parameter><type><name>last_line</name></type></parameter>, <parameter><type><name>last_column</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>branches</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ISEQ_COVERAGE(iseq) &amp;&amp; ISEQ_BRANCH_COVERAGE(iseq) &amp;&amp; (first_line) &gt; 0) { VALUE counters = RARRAY_AREF(ISEQ_BRANCH_COVERAGE(iseq), 1); long counter_idx = RARRAY_LEN(counters); rb_ary_push(counters, INT2FIX(0)); rb_ary_push(branches, ID2SYM(rb_intern(type))); rb_ary_push(branches, INT2FIX(first_line)); rb_ary_push(branches, INT2FIX(first_column)); rb_ary_push(branches, INT2FIX(last_line)); rb_ary_push(branches, INT2FIX(last_column)); rb_ary_push(branches, INT2FIX(counter_idx)); ADD_TRACE_WITH_DATA(seq, RUBY_EVENT_COVERAGE_BRANCH, counter_idx); ADD_INSN(seq, last_line, nop); } } while (0)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iseq_add_getlocal</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iseq_add_setlocal</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_GETLOCAL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>, <parameter><type><name>level</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>iseq_add_getlocal(iseq, (seq), (line), (idx), (level))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_SETLOCAL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>, <parameter><type><name>level</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>iseq_add_setlocal(iseq, (seq), (line), (idx), (level))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_LABEL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) (label))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_LABEL</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>before</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>APPEND_ELEM((seq), (before), (LINK_ELEMENT *) (label))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ADJUST</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_adjust_body(iseq, (label), (line)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ADJUST_RESTORE</name><parameter_list>(<parameter><type><name>seq</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM((seq), (LINK_ELEMENT *) new_adjust_body(iseq, (label), -1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LABEL_UNREMOVABLE</name><parameter_list>(<parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((label) ? (LABEL_REF(label), (label)-&gt;unremovable=1) : 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_CATCH_ENTRY</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>ls</name></type></parameter>, <parameter><type><name>le</name></type></parameter>, <parameter><type><name>iseqv</name></type></parameter>, <parameter><type><name>lc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { VALUE _e = rb_ary_new3(5, (type), (VALUE)(ls) | 1, (VALUE)(le) | 1, (VALUE)(iseqv), (VALUE)(lc) | 1); LABEL_UNREMOVABLE(ls); LABEL_REF(le); LABEL_REF(lc); if (NIL_P(ISEQ_COMPILE_DATA(iseq)-&gt;catch_table_ary)) RB_OBJ_WRITE(iseq, &amp;ISEQ_COMPILE_DATA(iseq)-&gt;catch_table_ary, rb_ary_tmp_new(3)); rb_ary_push(ISEQ_COMPILE_DATA(iseq)-&gt;catch_table_ary, freeze_hide_obj(_e)); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>, <parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(debug_compile("== " desc "\n", iseq_compile_each(iseq, (anchor), (node), 0)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_POPPED</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>, <parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(debug_compile("== " desc "\n", iseq_compile_each(iseq, (anchor), (node), 1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>popped</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(debug_compile("== " desc "\n", iseq_compile_each(iseq, (anchor), (node), (popped))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_RECV</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>, <parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(private_recv_p(node) ? (ADD_INSN(anchor, nd_line(node), putself), VM_CALL_FCALL) : COMPILE(anchor, desc, node-&gt;nd_recv) ? 0 : -1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPERAND_AT</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((INSN*)(insn))-&gt;operands[(idx)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSN_OF</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((INSN*)(insn))-&gt;insn_id)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INSN</name><parameter_list>(<parameter><type><name>link</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((link)-&gt;type == ISEQ_ELEMENT_INSN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LABEL</name><parameter_list>(<parameter><type><name>link</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((link)-&gt;type == ISEQ_ELEMENT_LABEL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ADJUST</name><parameter_list>(<parameter><type><name>link</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((link)-&gt;type == ISEQ_ELEMENT_ADJUST)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_TRACE</name><parameter_list>(<parameter><type><name>link</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((link)-&gt;type == ISEQ_ELEMENT_TRACE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INSN_ID</name><parameter_list>(<parameter><type><name>iobj</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(INSN_OF(iobj) == BIN(insn))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NEXT_INSN_ID</name><parameter_list>(<parameter><type><name>link</name></type></parameter>, <parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((link)-&gt;next &amp;&amp; IS_INSN((link)-&gt;next) &amp;&amp; IS_INSN_ID((link)-&gt;next, insn))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<macro><name>NORETURN</name><argument_list>(<argument>static void append_compile_error(const rb_iseq_t *iseq, int line, const char *fmt, ...)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>append_compile_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err_info</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>file</name> <init>= <expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err</name> <init>= <expr><ternary><condition><expr><name>err_info</name> <operator>==</operator> <name>Qtrue</name></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>err_info</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>rb_syntax_error_append</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>err_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_set_errinfo</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>err_info</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>err</name> <operator>=</operator> <name>rb_eSyntaxError</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_exc_fatal</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static void

compile_bug(rb_iseq_t *iseq, int line, const char *fmt, ...)

{

va_list args;

va_start(args, fmt);

rb_report_bug_valist(rb_iseq_path(iseq), line, fmt, args);

va_end(args);

abort();

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_ERROR</name></cpp:macro> <cpp:value>append_compile_error</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_ARGS_AT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>iseq, nd_line(n),</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_ARGS</name></cpp:macro> <cpp:value>ERROR_ARGS_AT(node)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NODE</name><parameter_list>(<parameter><type><name>prefix</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>ndtype</name></type></parameter>, <parameter><type><name>errval</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const NODE *error_node = (node); enum node_type error_type = nd_type(error_node); if (error_type != (ndtype)) { COMPILE_ERROR(ERROR_ARGS_AT(error_node) prefix ": " #ndtype " is expected, but %s", ruby_node_name(error_type)); return errval; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NODE_NONULL</name><parameter_list>(<parameter><type><name>prefix</name></type></parameter>, <parameter><type><name>parent</name></type></parameter>, <parameter><type><name>ndtype</name></type></parameter>, <parameter><type><name>errval</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { COMPILE_ERROR(ERROR_ARGS_AT(parent) prefix ": must be " #ndtype ", but 0"); return errval; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNKNOWN_NODE</name><parameter_list>(<parameter><type><name>prefix</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>errval</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const NODE *error_node = (node); COMPILE_ERROR(ERROR_ARGS_AT(error_node) prefix ": unknown node (%s)", ruby_node_name(nd_type(error_node))); return errval; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_OK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_NG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>sub</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (!(sub)) {BEFORE_RETURN;return COMPILE_NG;}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_CHECK</name><parameter_list>(<parameter><type><name>sub</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(sub)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEFORE_RETURN</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_ANCHOR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LINK_ANCHOR name[1] = {{{ISEQ_ELEMENT_ANCHOR,},}}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ANCHOR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(name-&gt;last = &amp;name-&gt;anchor)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>freeze_hide_obj</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optinsn.inc"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INSTRUCTIONS_UNIFICATION</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optunifs.inc"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEQ_ARG</name></cpp:macro> <cpp:value>iseq,</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEQ_ARG_DECLARE</name></cpp:macro> <cpp:value>rb_iseq_t *iseq,</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEQ_ARG</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEQ_ARG_DECLARE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gl_node_level</name></cpp:macro> <cpp:value>ISEQ_COMPILE_DATA(iseq)-&gt;node_level</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_disasm_list_with_cursor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>curr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LABEL</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_disasm_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>insn_data_length</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>calc_sp_depth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type><name>new_insn_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>insn_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>LABEL</name> <modifier>*</modifier></type><name>new_label_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ADJUST</name> <modifier>*</modifier></type><name>new_adjust_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TRACE</name> <modifier>*</modifier></type><name>new_trace_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_compile_each</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>anchor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_setup</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_setup_insn</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_optimize</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_insns_unification</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_local_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_exception_local_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_arguments</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_sequence_stackcaching</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_sequence</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_exception_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_set_optargs_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_defined_expr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>verify_list</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plist</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>compile_debug</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>anchor</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>plist</name> <operator>=</operator> <operator>&amp;</operator><name><name>anchor</name><operator>-&gt;</operator><name>anchor</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>plist</name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flag</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name> <operator>!=</operator> <name>plist</name> <operator>&amp;&amp;</operator> <name><name>anchor</name><operator>-&gt;</operator><name>last</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <literal type="number">0x70000</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"list verify error: %08x (%s)"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>verify_list</name><parameter_list>(<parameter><type><name>info</name></type></parameter>, <parameter><type><name>anchor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>verify_list(iseq, (info), (anchor))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>verify_call_cache</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>original</name> <init>= <expr><call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><name><name>original</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>TS_CALLDATA</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator>struct <name>rb_call_data</name> <operator>*</operator><operator>)</operator><name><name>original</name><index>[<expr><name>i</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_ci_dump</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"call cache is not initialized by vm_cc_empty()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>call_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_ci_dump</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"call cache is not initialized by vm_cc_empty()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ADD_ELEM</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>anchor</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verify_list</name><argument_list>(<argument><expr><literal type="string">"add"</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>APPEND_ELEM</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>before</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>before</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>before</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>before</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>before</name> <operator>==</operator> <name><name>anchor</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>verify_list</name><argument_list>(<argument><expr><literal type="string">"add"</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ELEM</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>elem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ADD_ELEM(iseq, (anchor), (elem))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_ELEM</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>before</name></type></parameter>, <parameter><type><name>elem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>APPEND_ELEM(iseq, (anchor), (before), (elem))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEQ_LAST_LINE</name><parameter_list>(<parameter><type><name>iseq</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ISEQ_COMPILE_DATA(iseq)-&gt;last_line)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>validate_label</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>label</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>label</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>position</name></name></expr></argument>,

<argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">": undefined label"</literal></expr></argument>,

<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>validate_labels</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>labels_table</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>validate_label</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_compile_callback</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type> <name>ifunc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>ifunc</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>ifunc</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_setup_insn</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseq_setup</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_compile_node</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>imemo_ifunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected imemo_ifunc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"nil"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_set_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_SCOPE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>iseq_set_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_set_arguments</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_BLOCK</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_BEG</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_END</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"block body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_REDO</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_NEXT</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_TYPE_CLASS</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"scoped node"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_TYPE_METHOD</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"scoped node"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"scoped node"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_ISEQ_TYPE</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ISEQ_TYPE_##type: m = #type; goto invalid_iseq_type</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>METHOD</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>CLASS</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>BLOCK</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>EVAL</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>MAIN</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>INVALID_ISEQ_TYPE</name><argument_list>(<argument><expr><name>TOP</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INVALID_ISEQ_TYPE</name></cpp:undef> 

<case>case <expr><name>ISEQ_TYPE_RESCUE</name></expr>:</case>

<expr_stmt><expr><call><name>iseq_set_exception_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rescue"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISEQ_TYPE_ENSURE</name></expr>:</case>

<expr_stmt><expr><call><name>iseq_set_exception_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"ensure"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISEQ_TYPE_PLAIN</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"ensure"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unknown scope: %d"</literal></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

<label><name>invalid_iseq_type</name>:</label>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"compile/ISEQ_TYPE_%s should not be reached"</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</case></case></case></case></case></case></block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name> <operator>||</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUPPORT_JOKE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>labels_table</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>labels_table</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>labels_table</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>labels_table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>validate_labels</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_setup_insn</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseq_setup</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_iseq_translate_threaded_code</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>rb_vm_get_insns_address_table</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>encoded</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>insn</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>encoded</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name><name>table</name><index>[<expr><name>insn</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_TRANSLATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name> <modifier>*</modifier></type>

<name>rb_iseq_original_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>original_code</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_ORIGINAL_ISEQ</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ISEQ_ORIGINAL_ISEQ</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>original_code</name> <operator>=</operator> <call><name>ISEQ_ORIGINAL_ISEQ_ALLOC</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>original_code</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>original_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>insn</name> <init>= <expr><call><name>rb_vm_insn_addr2insn</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>original_code</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>insn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>original_code</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRICT_ALIGNMENT</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/endian.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRICT_ALIGNMENT</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TRUE_LONG_LONG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SIZEOF_LONG_LONG</name> <operator>&gt;</operator> <name>SIZEOF_VALUE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT_SIZE</name></cpp:macro> <cpp:value>SIZEOF_LONG_LONG</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT_SIZE</name></cpp:macro> <cpp:value>SIZEOF_VALUE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PADDING_SIZE_MAX</name></cpp:macro> <cpp:value>((size_t)((ALIGNMENT_SIZE) - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNMENT_SIZE_MASK</name></cpp:macro> <cpp:value>PADDING_SIZE_MAX</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PADDING_SIZE_MAX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>calc_padding</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>mis</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>mis</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ptr</name> <operator>&amp;</operator> <name>ALIGNMENT_SIZE_MASK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mis</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>padding</name> <operator>=</operator> <name>ALIGNMENT_SIZE</name> <operator>-</operator> <name>mis</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALIGNMENT_SIZE</name> <operator>&gt;</operator> <name>SIZEOF_VALUE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>padding</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>padding</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>compile_data_alloc_with_arena</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>arena</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>*</operator><name>arena</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>padding</name> <init>= <expr><call><name>calc_padding</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>storage</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>-</operator> <name>padding</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name>size</name> <operator>+</operator> <name>padding</name> <operator>&gt;</operator> <name><name>storage</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>alloc_size</name> <init>= <expr><name><name>storage</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>alloc_size</name> <operator>&lt;</operator> <name>size</name> <operator>+</operator> <name>PADDING_SIZE_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>alloc_size</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>alloc_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>alloc_size</name> <operator>+</operator>

<call><name>offsetof</name><argument_list>(<argument><expr>struct <name>iseq_compile_data_storage</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>storage</name> <operator>=</operator> <operator>*</operator><name>arena</name> <operator>=</operator> <name><name>storage</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>alloc_size</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>padding</name> <operator>=</operator> <call><name>calc_padding</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>storage</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>padding</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>storage</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>storage</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr>;</expr_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>compile_data_alloc</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier><modifier>*</modifier></type> <name>arena</name> <init>= <expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>storage_current</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>compile_data_alloc_with_arena</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>compile_data_alloc2</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>rb_size_mul_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>compile_data_calloc2</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>rb_size_mul_or_raise</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type>

<name>compile_data_alloc_insn</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier><modifier>*</modifier></type> <name>arena</name> <init>= <expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>insn</name><operator>.</operator><name>storage_current</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>compile_data_alloc_with_arena</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>INSN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LABEL</name> <modifier>*</modifier></type>

<name>compile_data_alloc_label</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LABEL</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ADJUST</name> <modifier>*</modifier></type>

<name>compile_data_alloc_adjust</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ADJUST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TRACE</name> <modifier>*</modifier></type>

<name>compile_data_alloc_trace</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>TRACE</name> <operator>*</operator><operator>)</operator><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRACE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ELEM_INSERT_NEXT</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem1</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>elem1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elem1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem1</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem2</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ELEM_INSERT_PREV</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem1</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>elem1</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem1</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem2</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ELEM_REPLACE</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem1</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>elem1</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem2</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>elem1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem1</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elem1</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem1</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elem1</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elem2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ELEM_REMOVE</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>FIRST_ELEMENT</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>anchor</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>LAST_ELEMENT</name><parameter_list>(<parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>POP_ELEMENT</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>anchor</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verify_list</name><argument_list>(<argument><expr><literal type="string">"pop"</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>elem</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP_ELEMENT</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>POP_ELEMENT(iseq, (anchor))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>ELEM_FIRST_INSN</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>elem</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<return>return <expr><name>elem</name></expr>;</return>

<default>default:</default>

<expr_stmt><expr><name>elem</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>LIST_INSN_SIZE_ONE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>first_insn</name> <init>= <expr><call><name>ELEM_FIRST_INSN</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>first_insn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<call><name>ELEM_FIRST_INSN</name><argument_list>(<argument><expr><name><name>first_insn</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>LIST_INSN_SIZE_ZERO</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ELEM_FIRST_INSN</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>APPEND_LIST</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anc1</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anc2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>anc2</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>anc1</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>anc2</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>anc2</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>anc1</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>anc1</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>anc2</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>verify_list</name><argument_list>(<argument><expr><literal type="string">"append"</literal></expr></argument>, <argument><expr><name>anc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_LIST</name><parameter_list>(<parameter><type><name>anc1</name></type></parameter>, <parameter><type><name>anc2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>APPEND_LIST(iseq, (anc1), (anc2))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>debug_list</name><parameter_list>(<parameter><decl><type><name>ISEQ_ARG_DECLARE</name> <name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"----\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"anch: %p, frst: %p, last: %p\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>anchor</name><operator>-&gt;</operator><name>anchor</name></name></expr></argument>,

<argument><expr><name><name>anchor</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>anchor</name><operator>-&gt;</operator><name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"curr: %p, next: %p, prev: %p, type: %d\n"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></argument>,

<argument><expr><name><name>list</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"----\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><name><name>anchor</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verify_list</name><argument_list>(<argument><expr><literal type="string">"debug list"</literal></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CPDEBUG</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_list</name><parameter_list>(<parameter><type><name>anc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>debug_list(iseq, (anc))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_list</name><parameter_list>(<parameter><type><name>anc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>TRACE</name> <modifier>*</modifier></type>

<name>new_trace_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>TRACE</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><call><name>compile_data_alloc_trace</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>ISEQ_ELEMENT_TRACE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<return>return <expr><name>trace</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LABEL</name> <modifier>*</modifier></type>

<name>new_label_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>labelobj</name> <init>= <expr><call><name>compile_data_alloc_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>ISEQ_ELEMENT_LABEL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>label_no</name></name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>label_no</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>labelobj</name><operator>-&gt;</operator><name>unremovable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>labelobj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ADJUST</name> <modifier>*</modifier></type>

<name>new_adjust_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name> <init>= <expr><call><name>compile_data_alloc_adjust</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>adjust</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>ISEQ_ELEMENT_ADJUST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>adjust</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>label</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LABEL_UNREMOVABLE</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>adjust</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type>

<name>new_insn_core</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>insn_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><call><name>compile_data_alloc_insn</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>ISEQ_ELEMENT_INSN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <name>insn_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name> <operator>=</operator> <name>line_no</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>iobj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type>

<name>new_insn_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>insn_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>argv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_init_list</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>operands</name> <operator>=</operator> <call><name>compile_data_alloc2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>operands</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>, <argument><expr><name>insn_id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>operands</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type>

<name>new_callinfo</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_blockiseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>VM_CALL_ARGS_SPLAT</name> <operator>|</operator> <name>VM_CALL_ARGS_BLOCKARG</name> <operator>|</operator> <name>VM_CALL_KW_SPLAT</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>

<name>kw_arg</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_blockiseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_ARGS_SIMPLE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kw_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_KWARG</name></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>+=</operator> <name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>ci_size</name></name><operator>++</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><call><name>vm_ci_new</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>kw_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ci</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type>

<name>new_insn_send</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>blockiseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>keywords</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name> <init>= <expr><call><name>compile_data_calloc2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>operands</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>blockiseq</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>operands</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>blockiseq</name></expr>;</expr_stmt>

<return>return <expr><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>send</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>operands</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>new_child_iseq</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>ret_iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ast_body_t</name></type> <name>ast</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>compile_option</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>line_count</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[new_child_iseq]&gt; ---------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_iseq</name> <operator>=</operator> <call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ast</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,

<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line_no</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[new_child_iseq]&lt; ---------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret_iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>new_child_iseq_with_callback</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type><name>ifunc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_no</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>ret_iseq</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[new_child_iseq_with_callback]&gt; ---------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_iseq</name> <operator>=</operator> <call><name>rb_iseq_new_with_callback</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,

<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line_no</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[new_child_iseq_with_callback]&lt; ---------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret_iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_catch_except_p</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>catch_except_p</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_catch_except_p</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_catch_except_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>insn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<expr_stmt><expr><name>insn</name> <operator>=</operator> <call><name>rb_vm_insn_addr2insn</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>insn</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>insn</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>throw</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_catch_except_p</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ct</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>=

<expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>CATCH_TYPE_BREAK</name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>CATCH_TYPE_NEXT</name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>CATCH_TYPE_REDO</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>catch_except_p</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_insert_nop_between_end_and_cont</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>catch_table_ary</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>tlen</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>tptr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name><name>tptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>cont</name> <init>= <expr><operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>end</name></expr>;</init> <condition><expr><name>e</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IS_LABEL</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_TRACE</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>cont</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>nop</name> <init>= <expr><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nop</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_setup_insn</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 3.1 (iseq_optimize)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_optimize</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>instructions_unification</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 3.2 (iseq_insns_unification)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_insns_unification</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>stack_caching</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 3.3 (iseq_set_sequence_stackcaching)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_set_sequence_stackcaching</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 3.4 (iseq_insert_nop_between_end_and_cont)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_insert_nop_between_end_and_cont</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_setup</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 4.1 (iseq_set_sequence)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iseq_set_sequence</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dump_disasm_list</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 4.2 (iseq_set_exception_table)]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iseq_set_exception_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 4.3 (set_optargs_table)] \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iseq_set_optargs_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step 5 (iseq_translate_threaded_code)] \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_iseq_translate_threaded_code</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>update_catch_except_flags</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_debug</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>verify_call_cache</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"[compile step: finish]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_exception_local_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>rb_iseq_shared_exc_local_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name></name> <operator>=</operator> <name>rb_iseq_shared_exc_local_tbl</name></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_lvar_level</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>iseq</name> <operator>!=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lev</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>lev</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_dyna_var_idx_at_raw</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_local_var_idx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>get_dyna_var_idx_at_raw</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><call><name>ISEQ_LAST_LINE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"get_local_var_idx: %d"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>idx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_dyna_var_idx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>level</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>topmost_iseq</name> <init>= <expr><name>iseq</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_dyna_var_idx_at_raw</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lv</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>topmost_iseq</name></expr></argument>, <argument><expr><call><name>ISEQ_LAST_LINE</name><argument_list>(<argument><expr><name>topmost_iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"get_dyna_var_idx: -1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>level</name> <operator>=</operator> <name>lv</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ls</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</expr_stmt>

<return>return <expr><name>idx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_local_block_param_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>body</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>==</operator> <name>iseq</name> <operator>&amp;&amp;</operator> 

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>&amp;&amp;</operator>

<name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>==</operator> <name>idx</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_block_param_id_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pidx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>plevel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>, <decl><type ref="prev"/><name>ls</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>get_dyna_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>iseq_local_block_param_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ls</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pidx</name> <operator>=</operator> <name>ls</name> <operator>-</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>plevel</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_add_getlocal</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>iseq_local_block_param_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getblockparam</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name><operator>)</operator> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getlocal</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name><operator>)</operator> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_add_setlocal</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>iseq_local_block_param_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setblockparam</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name><operator>)</operator> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setlocal</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name><operator>)</operator> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_calc_param_size</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>+</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>+</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_arguments_keywords</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optargs</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_args_info</name></name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>kw_args</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>default_values</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>complex_mark</name> <init>= <expr><call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rkw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>di</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name> <operator>=</operator> <call><name>ZALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kw</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>arg_size</name> <operator>+=</operator> <name>kw</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>=</operator> <name>arg_size</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>kw_args</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>val_node</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name><operator>-&gt;</operator><name>nd_value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val_node</name> <operator>==</operator> <name>NODE_SPECIAL_REQUIRED_KEYWORD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>rkw</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>val_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIT</name></expr>:</case>

<expr_stmt><expr><name>dv</name> <operator>=</operator> <name><name>val_node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<expr_stmt><expr><name>dv</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<expr_stmt><expr><name>dv</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<expr_stmt><expr><name>dv</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><literal type="string">"kwarg"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>dv</name> <operator>=</operator> <name>complex_mark</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <operator>++</operator><name>di</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>default_values</name></expr></argument>, <argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name>kw</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>kw_rest_arg</name><operator>-&gt;</operator><name>nd_vid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name> <operator>=</operator> <name>arg_size</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name> <operator>=</operator> <name>rkw</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>]</index></name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>dvs</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>default_values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>default_values</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dv</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>default_values</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dv</name> <operator>==</operator> <name>complex_mark</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dv</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dvs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dv</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>default_values</name></name> <operator>=</operator> <name>dvs</name></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><name>arg_size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_arguments</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optargs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node_args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"iseq_set_arguments: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>node_args</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>node_args</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_args_info</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>node_args</name><operator>-&gt;</operator><name>nd_ainfo</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>rest_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_comma</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>block_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"iseq_set_arguments"</literal></expr></argument>, <argument><expr><name>node_args</name></expr></argument>, <argument><expr><name>NODE_ARGS</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>ruby2_keywords</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>=</operator> <name>arg_size</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>args</name><operator>-&gt;</operator><name>pre_args_num</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">" - argc: %d\n"</literal></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rest_id</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>rest_arg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rest_id</name> <operator>==</operator> <name>NODE_SPECIAL_EXCESSIVE_COMMA</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>last_comma</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>rest_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>block_id</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>block_arg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>opt_args</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>opt_args</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>labels</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opt_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>labels</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name> <operator>|</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><literal type="string">"optarg"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>labels</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name> <operator>|</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_table</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>opt_table</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>labels</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>opt_table</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_ary_clear</name><argument_list>(<argument><expr><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name> <operator>=</operator> <name>opt_table</name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg_size</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rest_id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>=</operator> <name>arg_size</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>first_post_arg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>=</operator> <name>arg_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>post_args_num</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg_size</name> <operator>+=</operator> <name><name>args</name><operator>-&gt;</operator><name>post_args_num</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>kw_args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg_size</name> <operator>=</operator> <call><name>iseq_set_arguments_keywords</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>optargs</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>kw_rest_arg</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>keyword</name> <init>= <expr><call><name>ZALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name> <operator>=</operator> <name>arg_size</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>no_kwarg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>block_id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>=</operator> <name>arg_size</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>iseq_calc_param_size</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arg_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pre_init</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><literal type="string">"init arguments (m)"</literal></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>pre_init</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>post_init</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>optargs</name></expr></argument>, <argument><expr><literal type="string">"init arguments (p)"</literal></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>post_init</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>last_comma</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_local_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>*</operator><name>tbl</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tbl</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><operator>(</operator><name>ID</name> <operator>*</operator><operator>)</operator><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ids</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name></name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"iseq_set_local_table: %u\n"</literal></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>cdhash_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tval</name></decl>, <decl><type ref="prev"/><name>tlit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>lit</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>tlit</name> <operator>=</operator> <call><name>OBJ_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>val</name> <operator>!=</operator> <name>lit</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>tval</name> <operator>=</operator> <call><name>OBJ_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>tlit</name> <operator>!=</operator> <name>tval</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>tlit</name> <operator>==</operator> <name>T_SYMBOL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>val</name> <operator>!=</operator> <name>lit</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>tlit</name> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_hash_cmp</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>tlit</name> <operator>==</operator> <name>T_BIGNUM</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><call><name>rb_big_cmp</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>x</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>x</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>x</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>x</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>tlit</name> <operator>==</operator> <name>T_FLOAT</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_float_cmp</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>

<name>cdhash_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>OBJ_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<return>return <expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name>a</name></expr>;</return>

<case>case <expr><name>T_STRING</name></expr>:</case>

<return>return <expr><call><name>rb_str_hash</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<return>return <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><call><name>rb_big_hash</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<return>return <expr><call><name>rb_dbl_long_hash</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>cdhash_type</name> <init>= <expr><block>{

<expr><name>cdhash_cmp</name></expr>,

<expr><name>cdhash_hash</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>cdhash_set_label_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>cdhash_set_label_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cdhash_set_label_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>cdhash_set_label_struct</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>val</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>position</name></name> <operator>-</operator> <operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>pos</name></name><operator>+</operator><name><name>data</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>get_ivar_ic_value</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ivar_cache_table</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tbl</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ivar_cache_table</name> <operator>=</operator> <name>tbl</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BADINSN_DUMP</name><parameter_list>(<parameter><type><name>anchor</name></type></parameter>, <parameter><type><name>list</name></type></parameter>, <parameter><type><name>dest</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dump_disasm_list_with_cursor(FIRST_ELEMENT(anchor), list, dest)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BADINSN_ERROR</name></cpp:macro> <cpp:value>(xfree(generated_iseq), xfree(insns_info), BADINSN_DUMP(anchor, list, NULL), COMPILE_ERROR)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fix_sp_depth</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stack_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>sp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>line</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_ELEMENT_LABEL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>insn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>calc_sp_depth</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"argument stack underflow (%d)"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&gt;</operator> <name>stack_max</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stack_max</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>operands</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>insn</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>!=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"operand size miss! (%d for %d)"</literal></expr></argument>,

<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>TS_OFFSET</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lobj</name><operator>-&gt;</operator><name>set</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"unknown label: "</literal><name>LABEL_FORMAT</name></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>label_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_TRACE</name></expr>:</case>

<block>{<block_content>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name> <init>= <expr><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>orig_sp</name> <init>= <expr><name>sp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name></expr> ?</condition><then> <expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>sp</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>orig_sp</name> <operator>-</operator> <name>sp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"iseq_set_sequence: adjust bug %d &lt; %d"</literal></expr></argument>,

<argument><expr><name>orig_sp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"unknown list type: %d"</literal></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></for>

<return>return <expr><name>stack_max</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>add_insn_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>insns_info_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>insns_info_index</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>

<name><name>insns_info</name><index>[<expr><name>insns_info_index</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>line_no</name> <operator>!=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name> <operator>||</operator>

<name><name>insns_info</name><index>[<expr><name>insns_info_index</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>!=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>insns_info</name><index>[<expr><name>insns_info_index</name></expr>]</index></name><operator>.</operator><name>line_no</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>insns_info</name><index>[<expr><name>insns_info_index</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>positions</name><index>[<expr><name>insns_info_index</name></expr>]</index></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>add_adjust_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>insns_info_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code_index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>insns_info_index</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>

<name><name>insns_info</name><index>[<expr><name>insns_info_index</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>line_no</name> <operator>!=</operator> <name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>insns_info</name><index>[<expr><name>insns_info_index</name></expr>]</index></name><operator>.</operator><name>line_no</name> <operator>=</operator> <name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>insns_info</name><index>[<expr><name>insns_info_index</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>positions</name><index>[<expr><name>insns_info_index</name></expr>]</index></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_sequence</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>generated_iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>insn_num</name></decl>, <decl><type ref="prev"/><name>code_index</name></decl>, <decl><type ref="prev"/><name>insns_info_index</name></decl>, <decl><type ref="prev"/><name>sp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stack_max</name> <init>= <expr><call><name>fix_sp_depth</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stack_max</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>insn_num</name> <operator>=</operator> <name>code_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>list</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>calc_sp_depth</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>insn_num</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>events</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>events</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_LINE_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_COVERAGE_LINE</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><call><name>rb_get_coverage_mode</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>COVERAGE_TARGET_ONESHOT_LINES</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RARRAY_ASET</name><argument_list>(<argument><expr><call><name>ISEQ_LINE_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_COVERAGE_BRANCH</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><call><name>ISEQ_PC2BRANCHINDEX</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>code_index</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><call><name>ISEQ_PC2BRANCHINDEX</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>RARRAY_ASET</name><argument_list>(<argument><expr><call><name>ISEQ_PC2BRANCHINDEX</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>code_index</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>code_index</name> <operator>+=</operator> <call><name>insn_data_length</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_TRACE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>TRACE</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><operator>(</operator><name>TRACE</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>events</name> <operator>|=</operator> <name><name>trace</name><operator>-&gt;</operator><name>event</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>trace</name><operator>-&gt;</operator><name>event</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_COVERAGE_BRANCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>trace</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name> <init>= <expr><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>orig_sp</name> <init>= <expr><name>sp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <ternary><condition><expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name></expr> ?</condition><then> <expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>sp</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orig_sp</name> <operator>-</operator> <name>sp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>orig_sp</name> <operator>-</operator> <name>sp</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>code_index</name><operator>++</operator></expr>;</expr_stmt> 

<expr_stmt><expr><name>insn_num</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><name>generated_iseq</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>code_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>insns_info</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr>struct <name>iseq_insn_info_entry</name></expr></argument>, <argument><expr><name>insn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>positions</name> <operator>=</operator> <macro><name>ALLOC_N</name><argument_list>(<argument>unsigned int</argument>, <argument>insn_num</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>is_entries</name></name> <operator>=</operator> <call><name>ZALLOC_N</name><argument_list>(<argument><expr>union <name>iseq_inline_storage_entry</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name> <operator>=</operator> <call><name>ZALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_call_data</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ci_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>insns_info_index</name> <operator>=</operator> <name>code_index</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>insn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>calc_sp_depth</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>operands</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>insn</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <name>insn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>types</name> <operator>=</operator> <call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>position</name></name> <operator>-</operator> <operator>(</operator><name>code_index</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>map</name> <init>= <expr><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cdhash_set_label_struct</name></name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>cdhash_set_label_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_rehash</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>freeze_hide_obj</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_LINDEX</name></expr>:</case>

<case>case <expr><name>TS_NUM</name></expr>:</case> 

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_VALUE</name></expr>:</case> 

<case>case <expr><name>TS_ISEQ</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ISE</name></expr>:</case> 

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TS_IC</name></expr>:</case> 

<case>case <expr><name>TS_IVC</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ic_index</name> <init>= <expr><call><name>FIX2UINT</name><argument_list>(<argument><expr><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IC</name></type> <name>ic</name> <init>= <expr><operator>(</operator><name>IC</name><operator>)</operator><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>is_entries</name><index>[<expr><name>ic_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>ic_index</name> <operator>&gt;=</operator> <name><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"iseq_set_sequence: ic_index overflow: index: %d, size: %d"</literal></expr></argument>,

<argument><expr><name>ic_index</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>ic</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>source_ci</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>call_data</name><index>[<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ci_index</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ci_index</name> <operator>&lt;=</operator> <name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>source_ci</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>cd</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ID</name></expr>:</case> 

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>SYM2ID</name><argument_list>(<argument><expr><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>=

<expr><operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>entry</name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>operands</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>BADINSN_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"unknown operand type: %c"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>add_insn_info</name><argument_list>(<argument><expr><name>insns_info</name></expr></argument>, <argument><expr><name>positions</name></expr></argument>, <argument><expr><name>insns_info_index</name></expr></argument>, <argument><expr><name>code_index</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>insns_info_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>code_index</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name> <init>= <expr><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>orig_sp</name> <init>= <expr><name>sp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>adjust</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>diff</name> <init>= <expr><name>orig_sp</name> <operator>-</operator> <name>sp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>add_adjust_info</name><argument_list>(<argument><expr><name>insns_info</name></expr></argument>, <argument><expr><name>positions</name></expr></argument>, <argument><expr><name>insns_info_index</name></expr></argument>, <argument><expr><name>code_index</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>insns_info_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>adjuststack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>orig_sp</name> <operator>-</operator> <name>sp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>generated_iseq</name><index>[<expr><name>code_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>label_no</name> <init>= <expr><ternary><condition><expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name></expr> ?</condition><then> <expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>label_no</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>generated_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>insns_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>positions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debug_list</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>adjust</name><operator>-&gt;</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"iseq_set_sequence: adjust bug to %d %d &lt; %d"</literal></expr></argument>,

<argument><expr><name>label_no</name></expr></argument>, <argument><expr><name>orig_sp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>generated_iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>stack_max</name></name> <operator>=</operator> <name>stack_max</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name>insns_info</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name> <operator>=</operator> <name>positions</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><name>insns_info</name></expr></argument>, <argument><expr>struct <name>iseq_insn_info_entry</name></expr></argument>, <argument><expr><name>insns_info_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name>insns_info</name></expr>;</expr_stmt>

<macro><name>REALLOC_N</name><argument_list>(<argument>positions</argument>, <argument>unsigned int</argument>, <argument>insns_info_index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name> <operator>=</operator> <name>positions</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>insns_info_index</name></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>label_get_position</name><parameter_list>(<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>lobj</name><operator>-&gt;</operator><name>position</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>label_get_sp</name><parameter_list>(<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_exception_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>tptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>no_catch_table</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><call><name>iseq_catch_table_bytes</name><argument_list>(<argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>tlen</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name><name>tptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator>enum <name>catch_type</name><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <call><name>label_get_position</name><argument_list>(<argument><expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <call><name>label_get_position</name><argument_list>(<argument><expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cont</name></name> <operator>=</operator> <call><name>label_get_position</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <call><name>label_get_sp</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_RESCUE</name> <operator>||</operator>

<name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_BREAK</name> <operator>||</operator>

<name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_NEXT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sp</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cont</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<label><name>no_catch_table</name>:</label>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_optargs_table</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opt_table</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>opt_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>label_get_position</name><argument_list>(<argument><expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name><name>opt_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>get_destination_insn</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<goto>goto <name>found</name>;</goto>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>ISEQ_ELEMENT_TRACE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>TRACE</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><operator>(</operator><name>TRACE</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>events</name> <operator>|=</operator> <name><name>trace</name><operator>-&gt;</operator><name>event</name></name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<label><name>found</name>:</label>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>events</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>get_next_insn</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_ADJUST</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type>

<name>get_prev_insn</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_ADJUST</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unref_destination</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>--</operator><name><name>lobj</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lobj</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>replace_destination</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>nobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>n</name> <init>= <expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>nobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>dl</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>--</operator><name><name>dl</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>nl</name><operator>-&gt;</operator><name>refcnt</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dl</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dl</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LABEL</name><modifier>*</modifier></type>

<name>find_destination</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name><name>i</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name><name>i</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call><index>[<expr><name>pos</name></expr>]</index> <operator>==</operator> <name>TS_OFFSET</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>remove_unreachable_chunk</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name>i</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>unref_counts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nlabels</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>label_no</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>unref_counts</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>nlabels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>unref_counts</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>nlabels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lab</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>lab</name> <operator>=</operator> <call><name>find_destination</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>lab</name><operator>-&gt;</operator><name>unremovable</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>unref_counts</name><index>[<expr><name><name>lab</name><operator>-&gt;</operator><name>label_no</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_LABEL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lab</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lab</name><operator>-&gt;</operator><name>unremovable</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lab</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&gt;</operator> <name><name>unref_counts</name><index>[<expr><name><name>lab</name><operator>-&gt;</operator><name>label_no</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>first</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_TRACE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_ADJUST</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><name>i</name><operator>)</operator><operator>-&gt;</operator><name>label</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>&amp;&amp;</operator> <name><name>dest</name><operator>-&gt;</operator><name>unremovable</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <name><name>i</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call><index>[<expr><name>pos</name></expr>]</index></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case>

<expr_stmt><expr><call><name>unref_destination</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>i</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<expr_stmt><expr><operator>--</operator><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>i</name> <operator>!=</operator> <name>end</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>=</operator> <name><name>i</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_pop_newarray</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>:</case> 

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case> 

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

<default>default:</default>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>adjuststack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>same_debug_pos_p</name><parameter_list>(<parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>iobj1</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>iobj2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug1</name> <init>= <expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug2</name> <init>= <expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug1</name> <operator>==</operator> <name>debug2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>debug1</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>debug2</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>debug1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>debug2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>debug1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>debug2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>debug1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>debug2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_frozen_putstring</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>insn</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><name>putstring</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><operator>*</operator><name>op</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>optimize_checktype</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>niobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ciobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>type</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>putstring</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>T_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>putobject</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> <return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>ciobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_next_insn</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ciobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_next_insn</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name><operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ciobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_next_insn</name><argument_list>(<argument><expr><name>dup</name> <operator>=</operator> <name>ciobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ciobj</name> <operator>||</operator> <operator>!</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><name>checktype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>niobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_next_insn</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>niobj</name></expr>)</condition> <block>{<block_content>

<label><name>no_branch</name>:</label>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>branchif</name></expr></argument>)</argument_list></call></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>branchunless</name></expr></argument>)</argument_list></call></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>ciobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<goto>goto <name>no_branch</name>;</goto>

</block_content>}</block></switch>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ciobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dest</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>niobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>&amp;&amp;</operator> <call><name>IS_LABEL</name><argument_list>(<argument><expr><name><name>niobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name><name>niobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>niobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>INSERT_AFTER_INSN1</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LABEL_REF</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>INSERT_AFTER_INSN</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type>

<name>ci_flag_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>add</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>nci</name> <init>= <expr><call><name>vm_ci_new</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>add</name></expr></argument>,

<argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>nci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>nci</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type>

<name>ci_argc_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>nci</name> <init>= <expr><call><name>vm_ci_new</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>argc</name></expr></argument>,

<argument><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>nci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>nci</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_peephole_optimize</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_tailcallopt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier><specifier>const</specifier></type> <name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<expr_stmt><expr><call><name>optimize_checktype</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>niobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>diobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>piobj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>diobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_destination_insn</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>niobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_next_insn</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>diobj</name> <operator>==</operator> <name>niobj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unref_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>iobj</name> <operator>!=</operator> <name>diobj</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>diobj</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>diobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>replace_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>diobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>remove_unreachable_chunk</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>diobj</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>pop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>unref_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name></name> <operator>=</operator> <name><name>diobj</name><operator>-&gt;</operator><name>insn_info</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pop</name> <operator>=</operator> <call><name>new_insn_body</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>diobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pop</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>piobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>pdiobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_destination_insn</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>niobj</name> <operator>==</operator> <name>pdiobj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>refcnt</name> <init>= <expr><ternary><condition><expr><call><name>IS_LABEL</name><argument_list>(<argument><expr><name><name>piobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><operator>(</operator><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name><name>piobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name><operator>)</operator><operator>-&gt;</operator><name>refcnt</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>piobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call><operator>)</operator></expr>

?</condition><then> <expr><call><name>BIN</name><argument_list>(<argument><expr><name>branchunless</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>BIN</name><argument_list>(<argument><expr><name>branchif</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>replace_destination</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>refcnt</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>diobj</name> <operator>==</operator> <name>pdiobj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>popiobj</name> <init>= <expr><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ELEM_REPLACE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>piobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>popiobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>remove_unreachable_chunk</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_prev_insn</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>beg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str_beg</name></decl>, <decl><type ref="prev"/><name>str_end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>range</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>newrange</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>end</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_prev_insn</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>is_frozen_putstring</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str_end</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>beg</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_prev_insn</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>is_frozen_putstring</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str_beg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>excl</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lit_range</name> <init>= <expr><call><name>rb_range_new</name><argument_list>(<argument><expr><name>str_beg</name></expr></argument>, <argument><expr><name>str_end</name></expr></argument>, <argument><expr><name>excl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>beg</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>end</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putobject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>lit_range</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>remove_unreachable_chunk</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchnil</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>nobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_destination_insn</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stop_optimization</name> <init>=

<expr><call><name>ISEQ_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISEQ_LINE_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>nobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>events</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stop_optimization</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>pobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_dup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pobj</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_INSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pobj</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prev_dup</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>nobj</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>replace_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>nobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>prev_dup</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>nobj</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>!</operator><operator>(</operator><name>nobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>nobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<name><name>nobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>==</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>replace_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>nobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>pobj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cond</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_dup</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN</name><argument_list>(<argument><expr><name><name>pobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>pobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Qfalse</name></expr> </then><else>:

<expr><ternary><condition><expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qfalse</name></expr> </then><else>:

<expr><name>FALSE</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>putstring</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>duparray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cond</name> <operator>=</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>!</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_dup</name> <operator>||</operator> <operator>!</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>iseq_pop_newarray</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pobj</name> <operator>=</operator> <call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>pobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_PREV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>prev_dup</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pobj</name> <operator>=</operator> <call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>pobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>unref_destination</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>

<expr_stmt><expr><name>nobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_destination_insn</name><argument_list>(<argument><expr><name>nobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>previ</name> <init>= <expr><operator>(</operator><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>prev</name><operator>)</operator><operator>-&gt;</operator><name>insn_id</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putobject</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putnil</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putself</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putstring</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getlocal</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getblockparam</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getblockparamproxy</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>duparray</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>iseq_pop_newarray</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>INSN</name><operator>*</operator><operator>)</operator><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>piobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>prev</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INSERT_BEFORE_INSN1</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name><name>piobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>previ</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>concatstrings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>adjuststack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>duparray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>expandarray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>)</argument_list></call> <operator>||</operator>

<literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>tostring</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>concatstrings</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>putstring</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>(</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>concatstrings</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>RSTRING_LEN</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>FIXNUM_INC</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>concatstrings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>freeze</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>freezestring</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><name>freeze</name> <operator>=</operator> <name>next</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get_destination_insn</name><argument_list>(<argument><expr><name>jump</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>concatstrings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>jump</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><operator>(</operator><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>jump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name><name>label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>label</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>jump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>refcnt</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>freeze</name> <operator>&amp;&amp;</operator> <call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>freezestring</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>same_debug_pos_p</name><argument_list>(<argument><expr><name>freeze</name></expr></argument>, <argument><expr><name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>freeze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>label</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_peephole_optimize</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><call><name>get_next_insn</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>do_tailcallopt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>freeze</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>freeze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>freezestring</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>NIL_P</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>send</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>niobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>idUPlus</name> <operator>||</operator> <call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>idUMinus</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ARGS_SIMPLE</name><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_tailcallopt</name> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>send</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>opt_aref_with</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>opt_aset_with</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>invokesuper</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>piobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_INSN</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>INSN_OF</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>get_destination_insn</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>:</case>

<expr_stmt><expr><name>piobj</name> <operator>=</operator> <name>iobj</name></expr>;</expr_stmt>

<default>default:</default>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block> while <condition>(<expr><name>next</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>piobj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>send</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><name>invokesuper</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>ci_flag_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>VM_CALL_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>ci_flag_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>VM_CALL_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>piobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>setlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>set1</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>set2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><name>setlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>set2</name> <operator>=</operator> <name><name>set1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>set1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name><name>set1</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>setlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>set2</name> <operator>=</operator> <name><name>set1</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name><name>set1</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>set2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>getlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>niobj</name> <init>= <expr><operator>&amp;</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>niobj</name> <operator>=</operator> <name><name>niobj</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><name>setlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>set1</name> <init>= <expr><name><name>niobj</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>set1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>set1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>opt_invokebuiltin_delegate</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_TRACE</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_NEXT_INSN_ID</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>opt_invokebuiltin_delegate_leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>insn_set_specialized_instruction</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>insn_id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <name>insn_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn_id</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>opt_neq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>old_operands</name> <init>= <expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name> <operator>=</operator> <call><name>compile_data_calloc2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idEq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>old_operands</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_specialized_instruction</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>&amp;&amp;</operator>

<call><name>IS_INSN</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>niobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><name>send</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>niobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ARGS_SIMPLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idMax</name></expr>:</case>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>opt_newarray_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>niobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idMin</name></expr>:</case>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>opt_newarray_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>niobj</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>send</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>blockiseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_INSN</name><parameter_list>(<parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>insn_set_specialized_instruction(iseq, iobj, BIN(opt_##opt))</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ARGS_SIMPLE</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idLength</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idSize</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idEmptyP</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>empty_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idNilP</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>nil_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idSucc</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>succ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idNot</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>not</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idPLUS</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>plus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idMINUS</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>minus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idMULT</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>mult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idDIV</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idMOD</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idEq</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idNeq</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>neq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idEqTilde</name></expr>:</case><expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>regexpmatch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idLT</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idLE</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idGT</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idGE</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idLTLT</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>ltlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idAREF</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>aref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idAnd</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>and</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

<case>case <expr><name>idOr</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idASET</name></expr>:</case> <expr_stmt><expr><call><name>SP_INSN</name><argument_list>(<argument><expr><name>aset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ARGS_BLOCKARG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>blockiseq</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>opt_send_without_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SP_INSN</name></cpp:undef>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>tailcallable_p</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_TOP</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_EVAL</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_MAIN</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_RESCUE</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_ENSURE</name></expr>:</case>

<return>return <expr><name>FALSE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_optimize</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_peepholeopt</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>peephole_optimization</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_tailcallopt</name> <init>= <expr><call><name>tailcallable_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>tailcall_optimization</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_si</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>specialized_instruction</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>do_ou</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>operands_unification</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rescue_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tailcallopt</name> <init>= <expr><name>do_tailcallopt</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>do_peepholeopt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>iseq_peephole_optimize</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>tailcallopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_si</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>iseq_specialized_instruction</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_ou</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>insn_operands_unification</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LABEL</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name><operator>)</operator><operator>-&gt;</operator><name>rescued</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>LABEL_RESCUE_BEG</name></expr>:</case>

<expr_stmt><expr><name>rescue_level</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>tailcallopt</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>LABEL_RESCUE_END</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>rescue_level</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tailcallopt</name> <operator>=</operator> <name>do_tailcallopt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INSTRUCTIONS_UNIFICATION</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>INSN</name> <modifier>*</modifier></type>

<name>new_unified_insn</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>insn_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>seq_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>seq_list</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>operands</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>+=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>operands</name> <operator>=</operator> <call><name>compile_data_alloc2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name>seq_list</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>operand_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>, <argument><expr><name>insn_id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>operands</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_insns_unification</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INSTRUCTIONS_UNIFICATION</name></expr></cpp:if>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>niobj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>intptr_t</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>unified_insns_data</name><index>[<expr><name>id</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>unified_insns_data</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>unified</name> <init>= <expr><name><name>entry</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>unified</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_INSN</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>li</name><operator>)</operator><operator>-&gt;</operator><name>insn_id</name> <operator>!=</operator> <name><name>unified</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>miss</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>li</name> <operator>=</operator> <name><name>li</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>niobj</name> <operator>=</operator>

<call><name>new_unified_insn</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>unified</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>unified</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>niobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name><name>iobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>niobj</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>li</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>li</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>niobj</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>niobj</name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>niobj</name></expr>;</expr_stmt>

<break>break;</break>

<label><name>miss</name>:</label><empty_stmt>;</empty_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SC_INSN</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>, <parameter><type><name>stat</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sc_insn_info[(insn)][(stat)]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SC_NEXT</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sc_insn_next[(insn)]</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opt_sc.inc"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>insn_set_sc_state</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>anchor</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nstate</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>insn_id</name></decl>;</decl_stmt>

<expr_stmt><expr><name>insn_id</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>SC_INSN</name><argument_list>(<argument><expr><name>insn_id</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nstate</name> <operator>=</operator> <call><name>SC_NEXT</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>branchif</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>branchunless</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>!=</operator> <name>nstate</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BADINSN_DUMP</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>lobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"insn_set_sc_state error: %d at "</literal><name>LABEL_FORMAT</name>

<literal type="string">", %d expected\n"</literal></expr></argument>,

<argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>label_no</name></name></expr></argument>, <argument><expr><name>nstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>=</operator> <name>nstate</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nstate</name> <operator>=</operator> <name>SCS_XX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>insn_id</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nstate</name> <operator>=</operator> <name>SCS_XX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>nstate</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>label_set_sc_state</name><parameter_list>(<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>!=</operator> <name>state</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>lobj</name><operator>-&gt;</operator><name>sc_state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>state</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_set_sequence_stackcaching</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>, <decl><type ref="prev"/><name>insn_id</name></decl>;</decl_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SCS_XX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<label><name>redo_point</name>:</label>

<switch>switch <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>insn_id</name> <operator>=</operator> <name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>insn_id</name></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>SCS_AX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>rpobj</name> <init>=

<expr><call><name>new_insn_body</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>reput</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ELEM_REPLACE</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>rpobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>rpobj</name></expr>;</expr_stmt>

<goto>goto <name>redo_point</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>SCS_AB</name> <operator>||</operator> <name>state</name> <operator>==</operator> <name>SCS_BA</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>state</name> <operator>==</operator> <name>SCS_AB</name></expr> ?</condition><then> <expr><name>SCS_BA</name></expr> </then><else>: <expr><name>SCS_AB</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<goto>goto <name>redo_point</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><call><name>BIN</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>:</case>

<block>{<block_content>

<switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SCS_AX</name></expr>:</case>

<case>case <expr><name>SCS_BX</name></expr>:</case>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SCS_XX</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SCS_AB</name></expr>:</case>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SCS_AX</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SCS_BA</name></expr>:</case>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SCS_BX</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SCS_XX</name></expr>:</case>

<goto>goto <name>normal_insn</name>;</goto>

<default>default:</default>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>,

<argument><expr><literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<goto>goto <name>redo_point</name>;</goto>

</block_content>}</block>

<default>default:</default><empty_stmt>;</empty_stmt>

</block_content>}</block></switch> 

<label><name>normal_insn</name>:</label>

<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>insn_set_sc_state</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lobj</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>label_set_sc_state</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>all_string_result_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_STR</name></expr>:</case> <case>case <expr><name>NODE_DSTR</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><name>NODE_IF</name></expr>:</case> <case>case <expr><name>NODE_UNLESS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name> <operator>||</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>all_string_result_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>all_string_result_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

<case>case <expr><name>NODE_AND</name></expr>:</case> <case>case <expr><name>NODE_OR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>all_string_result_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>all_string_result_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>all_string_result_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_dstr_fragments</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cntp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lit</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>first_lit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"nd_lit"</literal></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"dstr: must be string: %s"</literal></expr></argument>,

<argument><expr><call><name>rb_builtin_type_name</name><argument_list>(<argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_lit</name> <operator>=</operator> <call><name>LAST_ELEMENT</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>head</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_STR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"each string"</literal></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>first_lit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><name>first_lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>cnt</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>cntp</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_dstr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_dstr_fragments</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>concatstrings</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_dregx</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_dstr_fragments</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>toregexp</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cflag</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_flip_flop</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>again</name></decl></parameter>,

<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>then_label</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>cnt</name> <init>= <expr><call><name>ISEQ_FLIP_CNT_INCREMENT</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></argument>)</argument_list></call>

<operator>+</operator> <name>VM_SVAR_FLIPFLOP_START</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getspecial</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"flip2 beg"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_beg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setspecial</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>again</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"flip2 end"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_end</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setspecial</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_branch_condition</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>,

<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>then_label</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_AND</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>cond</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>,

<argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cond</name> <operator>=</operator> <name><name>cond</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block>

<case>case <expr><name>NODE_OR</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>cond</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>,

<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cond</name> <operator>=</operator> <name><name>cond</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block>

<case>case <expr><name>NODE_LIT</name></expr>:</case> 

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<case>case <expr><name>NODE_ZLIST</name></expr>:</case>

<case>case <expr><name>NODE_LAMBDA</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<case>case <expr><name>NODE_DREGX</name></expr>:</case>

<case>case <expr><name>NODE_DSTR</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"branch condition"</literal></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FLIP2</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_flip_flop</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FLIP3</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_flip_flop</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_DEFINED</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_defined_expr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>branch</name>;</goto>

<default>default:</default>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"branch condition"</literal></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>branch</name>:</label>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_NO_BRACE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BRACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_CALL_KEYWORDS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>keyword_node_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_HASH</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>nd_brace</name></name> <operator>&amp;</operator> <name>HASH_BRACE</name><operator>)</operator> <operator>!=</operator> <name>HASH_BRACE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_keyword_arg</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>root_node</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>kw_arg_ptr</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>kw_arg_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>root_node</name><operator>-&gt;</operator><name>nd_head</name></name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name><name>root_node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>root_node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>seen_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>key_node</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>seen_nodes</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key_node</name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>key_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>key_node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>seen_nodes</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT_MUT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>root_node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>nd_alen</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_arg</name> <init>=

<expr><call><name>rb_xmalloc_mul_add</name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_callinfo_kwarg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>keywords</name> <init>= <expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keywords</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>kw_arg_ptr</name> <operator>=</operator> <name>kw_arg</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>key_node</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>val_node</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key_node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"keyword values"</literal></expr></argument>, <argument><expr><name>val_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_args</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>node</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>CPDEBUG</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"compile_args"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>keyword_node_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>compile_keyword_arg</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>keywords_ptr</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_brace</name></name> <operator>=</operator> <name>METHOD_CALL_KEYWORDS</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"array element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_brace</name></name> <operator>=</operator> <name>HASH_NO_BRACE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"array element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>static_literal_node_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIT</name></expr>:</case>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<return>return <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>frozen_string_literal</name></name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>static_literal_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<return>return <expr><name>Qtrue</name></expr>;</return>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<return>return <expr><name>Qfalse</name></expr>;</return>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>debug_frozen_string_literal</name></name> <operator>||</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_debug</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug_info</name> <init>= <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>id_debug_created_info</name></expr></argument>, <argument><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_freeze</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

<default>default:</default>

<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_array</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_ZLIST</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"compile_array"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>node</name></expr>;</condition> <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"array element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_stack_len</name> <init>= <expr><literal type="number">0x100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_tmp_ary_len</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stack_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>first_chunk</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_CHUNK</name><parameter_list>(<parameter><type><name>newarrayinsn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (stack_len) { ADD_INSN1(ret, line, newarrayinsn, INT2FIX(stack_len)); if (!first_chunk) ADD_INSN(ret, line, concatarray); first_chunk = stack_len = 0; }</cpp:value></cpp:define>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>static_literal_node_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node_tmp</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>node_tmp</name> <operator>&amp;&amp;</operator> <call><name>static_literal_node_p</name><argument_list>(<argument><expr><name>node_tmp</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>node_tmp</name> <operator>=</operator> <name><name>node_tmp</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>first_chunk</name> <operator>&amp;&amp;</operator> <name>stack_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>node_tmp</name><operator>)</operator> <operator>||</operator> <name>count</name> <operator>&gt;=</operator> <name>min_tmp_ary_len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>count</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>static_literal_value</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first_chunk</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>duparray</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>first_chunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>count</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>CPDEBUG</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"compile_array"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"array element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stack_len</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name> <operator>&amp;&amp;</operator> <call><name>keyword_node_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>(<argument><expr><name>newarraykwsplat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stack_len</name> <operator>&gt;=</operator> <name>max_stack_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></while>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLUSH_CHUNK</name></cpp:undef>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>static_literal_node_pair_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name> <operator>&amp;&amp;</operator> <call><name>static_literal_node_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>static_literal_node_p</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_hash</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>method_call_keywords</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_brace</name></name> <operator>==</operator> <name>METHOD_CALL_KEYWORDS</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name> <operator>||</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_ZLIST</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newhash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"compile_hash"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>node</name></expr>;</condition> <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"hash element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_stack_len</name> <init>= <expr><literal type="number">0x100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_tmp_hash_len</name> <init>= <expr><literal type="number">0x800</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stack_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>first_chunk</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_CHUNK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>if (stack_len) { if (first_chunk) { APPEND_LIST(ret, anchor); ADD_INSN1(ret, line, newhash, INT2FIX(stack_len)); } else { ADD_INSN1(ret, line, putspecialobject, INT2FIX(VM_SPECIAL_OBJECT_VMCORE)); ADD_INSN(ret, line, swap); APPEND_LIST(ret, anchor); ADD_SEND(ret, line, id_core_hash_merge_ptr, INT2FIX(stack_len + 1)); } INIT_ANCHOR(anchor); first_chunk = stack_len = 0; }</cpp:value></cpp:define>

<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>static_literal_node_pair_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node_tmp</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>node_tmp</name> <operator>&amp;&amp;</operator> <call><name>static_literal_node_pair_p</name><argument_list>(<argument><expr><name>node_tmp</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>node_tmp</name> <operator>=</operator> <name><name>node_tmp</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>first_chunk</name> <operator>&amp;&amp;</operator> <name>stack_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>node_tmp</name><operator>)</operator> <operator>||</operator> <name>count</name> <operator>&gt;=</operator> <name>min_tmp_hash_len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>count</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>elem</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>elem</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>static_literal_value</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>static_literal_value</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_bulk_insert</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first_chunk</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>duphash</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>first_chunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_hash_merge_kwd</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>count</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>CPDEBUG</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"compile_hash"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="string">"hash key element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="string">"hash value element"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stack_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>stack_len</name> <operator>&gt;=</operator> <name>max_stack_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>empty_kw</name> <init>= <expr><call><name>nd_type</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>first_kw</name> <init>= <expr><name>first_chunk</name> <operator>&amp;&amp;</operator> <name>stack_len</name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>last_kw</name> <init>= <expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>only_kw</name> <init>= <expr><name>last_kw</name> <operator>&amp;&amp;</operator> <name>first_kw</name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>empty_kw</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>only_kw</name> <operator>&amp;&amp;</operator> <name>method_call_keywords</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"keyword splat"</literal></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>first_kw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newhash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>only_kw</name> <operator>&amp;&amp;</operator> <name>method_call_keywords</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"keyword splat"</literal></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first_kw</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newhash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"keyword splat"</literal></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_hash_merge_kwd</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>first_chunk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></while>

<expr_stmt><expr><call><name>FLUSH_CHUNK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLUSH_CHUNK</name></cpp:undef>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_node_case_when_optimizable_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIT</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>ival</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>modf</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>FIXABLE</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>ival</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_dbl2big</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rb_cNumeric</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>v</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<return>return <expr><name>Qtrue</name></expr>;</return>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<return>return <expr><name>Qfalse</name></expr>;</return>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<return>return <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>when_vals</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cond_seq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>,

<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>only_special_literals</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>literals</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lit</name> <init>= <expr><call><name>rb_node_case_when_optimizable_literal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lit</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>only_special_literals</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>literals</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>(</operator><name>l1</name><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_STR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"nd_lit"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>COMPILE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"when cond"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vals</name> <operator>=</operator> <name><name>vals</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>only_special_literals</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>when_splat_vals</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cond_seq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>,

<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>only_special_literals</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>literals</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>when_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"when splat"</literal></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name> <operator>|</operator> <name>VM_CHECKMATCH_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>when_splat_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>when_splat_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>when_splat_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"when argspush body"</literal></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"when val"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name> <operator>|</operator> <name>VM_CHECKMATCH_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_massign_lhs</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_ATTRASGN</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dupidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"masgn lhs (NODE_ATTRASGN)"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>get_prev_insn</name><argument_list>(<argument><expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><call><name>LAST_ELEMENT</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>ci_argc_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dupidx</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSERT_BEFORE_INSN1</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><name>dupidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>ci_argc_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSERT_BEFORE_INSN1</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSERT_BEFORE_INSN</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_MASGN</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="string">"nest masgn lhs"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="string">"masgn lhs"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_REMOVE</name><argument_list>(<argument><expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_massign_opt_lhs</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>lhsn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lhsn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_opt_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>lhsn</name><operator>-&gt;</operator><name>nd_next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>lhsn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_massign_opt</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>rhsn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>orig_lhsn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>mem</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>memsize</name> <init>= <expr><call><name>numberof</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>memindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>llen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>lhsn</name> <init>= <expr><name>orig_lhsn</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEMORY</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ int i; if (memindex == memsize) return 0; for (i=0; i&lt;memindex; i++) { if (mem[i] == (v)) return 0; } mem[memindex++] = (v); }</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><name>rhsn</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>rhsn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NODE_LIST</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>lhsn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>lhsn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LASGN</name></expr>:</case>

<expr_stmt><expr><call><name>MEMORY</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_DASGN</name></expr>:</case>

<case>case <expr><name>NODE_DASGN_CURR</name></expr>:</case>

<case>case <expr><name>NODE_IASGN</name></expr>:</case>

<case>case <expr><name>NODE_CVASGN</name></expr>:</case>

<expr_stmt><expr><call><name>MEMORY</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>lhsn</name> <operator>=</operator> <name><name>lhsn</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>llen</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name>rhsn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>llen</name> <operator>&lt;=</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"masgn val (popped)"</literal></expr></argument>, <argument><expr><name><name>rhsn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"masgn val"</literal></expr></argument>, <argument><expr><name><name>rhsn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>rhsn</name> <operator>=</operator> <name><name>rhsn</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>llen</name> <operator>&gt;</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>llen</name><operator>-</operator><name>rlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_lhsn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_massign_opt_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>orig_lhsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>adjust_stack</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>llen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&lt;</operator> <name>llen</name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content><expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block> while <condition>(<expr><operator>++</operator><name>rlen</name> <operator>&lt;</operator> <name>llen</name></expr>)</condition>;</do>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <name>llen</name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content><expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block> while <condition>(<expr><operator>--</operator><name>rlen</name> <operator>&gt;</operator> <name>llen</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_massign</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>rhsn</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>splatn</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>lhsn</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lhs_splat</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>splatn</name> <operator>&amp;&amp;</operator> <call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name>splatn</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name> <operator>||</operator> <name>splatn</name> <operator>||</operator> <operator>!</operator><call><name>compile_massign_opt</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>rhsn</name></expr></argument>, <argument><expr><name>lhsn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>llen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>expand</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>lhsseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>lhsseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lhsn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>lhsseq</name></expr></argument>, <argument><expr><name><name>lhsn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llen</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>lhsn</name> <operator>=</operator> <name><name>lhsn</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"normal masgn rhs"</literal></expr></argument>, <argument><expr><name>rhsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>lhs_splat</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><operator>(</operator><name>INSN</name><operator>*</operator><operator>)</operator><name><name>ret</name><operator>-&gt;</operator><name>last</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_INSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>last</name><operator>-&gt;</operator><name>operand_size</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rlen</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>llen</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>POP_ELEMENT</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>adjust_stack</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rlen</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>llen</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>llen</name> <operator>!=</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>POP_ELEMENT</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>adjust_stack</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rlen</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>llen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>llen</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expand</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expandarray</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>llen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>lhs_splat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lhsseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lhs_splat</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>splatn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_POSTARG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>postn</name> <init>= <expr><name><name>splatn</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>restn</name> <init>= <expr><name><name>splatn</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>postn</name><operator>-&gt;</operator><name>nd_alen</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0x02</literal> <operator>|</operator> <operator>(</operator><ternary><condition><expr><call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name>restn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0x01</literal></expr> </then><else>: <expr><literal type="number">0x00</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>splatn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expandarray</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name>restn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>restn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>postn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>postn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>postn</name> <operator>=</operator> <name><name>postn</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_massign_lhs</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splatn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_const_prefix</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>,

<parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pref</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_CONST</name></expr>:</case>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"compile_const_prefix - colon"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_COLON3</name></expr>:</case>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"compile_const_prefix - colon3"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_COLON2</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_const_prefix</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>pref</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"compile_const_prefix - colon2"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>pref</name></expr></argument>, <argument><expr><literal type="string">"const colon2 prefix"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_cpath</name><parameter_list>(<parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_COLON3</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>VM_DEFINECLASS_FLAG_SCOPED</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>nd_head</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"nd_else-&gt;nd_head"</literal></expr></argument>, <argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>VM_DEFINECLASS_FLAG_SCOPED</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_CONST_BASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>private_recv_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_SELF</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>NODE</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nd_state</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>

<name>defined_expr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier><modifier>*</modifier></type><name>lfinish</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>defined_expr0</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier><modifier>*</modifier></type><name>lfinish</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>defined_type</name></name></type> <name>expr_type</name> <init>= <expr><name>DEFINED_NOT_DEFINED</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>node_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name> <operator>=</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_NIL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_SELF</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_SELF</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_TRUE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_FALSE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_LIST</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>defined_expr0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>vals</name> <operator>=</operator> <name><name>vals</name><operator>-&gt;</operator><name>nd_next</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

</block_content>}</block>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<case>case <expr><name>NODE_LIT</name></expr>:</case>

<case>case <expr><name>NODE_ZLIST</name></expr>:</case>

<case>case <expr><name>NODE_AND</name></expr>:</case>

<case>case <expr><name>NODE_OR</name></expr>:</case>

<default>default:</default>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_EXPR</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_LVAR</name></expr>:</case>

<case>case <expr><name>NODE_DVAR</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_LVAR</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_IVAR</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_IVAR</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_GVAR</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_GVAR</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_CVAR</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_CVAR</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_CONST</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_CONST</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_COLON2</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>defined_expr0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"defined/colon2#nd_head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_CONST_FROM</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_METHOD</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_COLON3</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_CONST_FROM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_CALL</name></expr>:</case>

<case>case <expr><name>NODE_OPCALL</name></expr>:</case>

<case>case <expr><name>NODE_VCALL</name></expr>:</case>

<case>case <expr><name>NODE_FCALL</name></expr>:</case>

<case>case <expr><name>NODE_ATTRASGN</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>explicit_receiver</name> <init>=

<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>NODE_CALL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>NODE_OPCALL</name> <operator>||</operator>

<operator>(</operator><name>type</name> <operator>==</operator> <name>NODE_ATTRASGN</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>private_recv_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name> <operator>||</operator> <name>explicit_receiver</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>defined_expr0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>explicit_receiver</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>defined_expr0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"defined/recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_METHOD</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_FUNC</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block>

<case>case <expr><name>NODE_YIELD</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_YIELD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_BACK_REF</name></expr>:</case>

<case>case <expr><name>NODE_NTH_REF</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_REF</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>nd_nth</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>NODE_BACK_REF</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_SUPER</name></expr>:</case>

<case>case <expr><name>NODE_ZSUPER</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_ZSUPER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>NODE_OP_ASGN1</name></expr>:</case>

<case>case <expr><name>NODE_OP_ASGN2</name></expr>:</case>

<case>case <expr><name>NODE_OP_ASGN_OR</name></expr>:</case>

<case>case <expr><name>NODE_OP_ASGN_AND</name></expr>:</case>

<case>case <expr><name>NODE_MASGN</name></expr>:</case>

<case>case <expr><name>NODE_LASGN</name></expr>:</case>

<case>case <expr><name>NODE_DASGN</name></expr>:</case>

<case>case <expr><name>NODE_DASGN_CURR</name></expr>:</case>

<case>case <expr><name>NODE_GASGN</name></expr>:</case>

<case>case <expr><name>NODE_IASGN</name></expr>:</case>

<case>case <expr><name>NODE_CDECL</name></expr>:</case>

<case>case <expr><name>NODE_CVASGN</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_ASGN</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>expr_type</name> <operator>!=</operator> <name>DEFINED_NOT_DEFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>needstr</name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_iseq_defined_string</name><argument_list>(<argument><expr><name>expr_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>build_defined_rescue_iseq</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_set_exception_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>defined_expr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier><modifier>*</modifier></type><name>lfinish</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>lcur</name> <init>= <expr><name><name>ret</name><operator>-&gt;</operator><name>last</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>defined_expr0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>rescue</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>=

<expr><call><name>rb_iseq_new_with_callback_new_callback</name><argument_list>(<argument><expr><name>build_defined_rescue_iseq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rescue</name> <operator>=</operator> <call><name>new_child_iseq_with_callback</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ifunc</name></expr></argument>,

<argument><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"defined guard in "</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_RESCUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lstart</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_BEG</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lend</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_END</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>APPEND_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lcur</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_RESCUE</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><name>rescue</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_defined_expr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_iseq_defined_string</name><argument_list>(<argument><expr><name>DEFINED_NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name><name>lfinish</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name><name>ret</name><operator>-&gt;</operator><name>last</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>defined_expr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>needstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ELEM_INSERT_NEXT</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>new_insn_body</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>BIN</name><argument_list>(<argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>lfinish</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_name_for_block</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>orig_iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name>orig_iseq</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>orig_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name><name>orig_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>!=</operator> <name>iseq</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"block in %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"block (%d levels) in %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>push_ensure_entry</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name> <modifier>*</modifier></type><name>enl</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>er</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>enl</name><operator>-&gt;</operator><name>ensure_node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>enl</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>enl</name><operator>-&gt;</operator><name>erange</name></name> <operator>=</operator> <name>er</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name> <operator>=</operator> <name>enl</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>add_ensure_range</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>erange</name></decl></parameter>,

<parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>ne</name> <init>=

<expr><call><name>compile_data_alloc</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ensure_range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>erange</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>erange</name> <operator>=</operator> <name><name>erange</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>ne</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ne</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>lend</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ne</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>erange</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>erange</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>lstart</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>erange</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>ne</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>add_ensure_iseq</name><parameter_list>(<parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_return</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name> <modifier>*</modifier></type><name>enlp</name> <init>=

<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name> <modifier>*</modifier></type><name>prev_enlp</name> <init>= <expr><name>enlp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>ensure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>ensure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>enlp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>enlp</name><operator>-&gt;</operator><name>erange</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>ensure_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>ensure_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_range</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>enlp</name><operator>-&gt;</operator><name>erange</name></name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name> <operator>=</operator> <name><name>enlp</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ensure_part</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ensure_part</name></expr></argument>, <argument><expr><literal type="string">"ensure part"</literal></expr></argument>, <argument><expr><name><name>enlp</name><operator>-&gt;</operator><name>ensure_node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ensure_part</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ensure</name></expr></argument>, <argument><expr><name>ensure_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_return</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>enlp</name> <operator>=</operator> <name><name>enlp</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name> <operator>=</operator> <name>prev_enlp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ensure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_keyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>keyword_node_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>setup_args_core</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>argn</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dup_rest</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argn</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="string">"args (splat)"</literal></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><ternary><condition><expr><name>dup_rest</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>next_is_list</name> <init>= <expr><operator>(</operator><call><name>nd_type</name><argument_list>(<argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name> <init>= <expr><call><name>setup_args_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rest_len</name> <init>= <expr><call><name>compile_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>rest_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="string">"args (cat: splat)"</literal></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_keyword</name><argument_list>(<argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_ARGSCAT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>next_is_list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>argc</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>argc</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<case>case <expr><name>NODE_LIST</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>compile_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>argn</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"setup_arg"</literal></expr></argument>, <argument><expr><name>argn</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>setup_args</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>argn</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argn</name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>argn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_BLOCK_PASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>arg_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>arg_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>arg_block</name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>|=</operator> <name>VM_CALL_ARGS_BLOCKARG</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>setup_args_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argn</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIST_INSN_SIZE_ONE</name><argument_list>(<argument><expr><name>arg_block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>arg_block</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_ELEMENT_INSN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>elem</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getblockparam</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getblockparamproxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>setup_args_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>argn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>build_postexe_iseq</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ISEQ_TYPE_BLOCK</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL_WITH_BLOCK</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_set_postexe</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_set_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>compile_named_capture_assign</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>fail_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>NAMED_CAPTURE_BY_SVAR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NAMED_CAPTURE_BY_SVAR</name><operator>-</operator><literal type="number">0</literal><operator>)</operator></expr></cpp:if>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getglobal</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_global_entry</name><argument_list>(<argument><expr><name>idBACKREF</name></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getspecial</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> , <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>fail_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>vars</name> <operator>=</operator> <name>node</name></expr>;</init> <condition><expr><name>vars</name></expr>;</condition> <incr><expr><name>vars</name> <operator>=</operator> <name><name>vars</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>cap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vars</name><operator>-&gt;</operator><name>nd_next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>ret</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"capture"</literal></expr></argument>, <argument><expr><name><name>vars</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>cap</name> <operator>=</operator> <call><name>new_insn_send</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ELEM_INSERT_PREV</name><argument_list>(<argument><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><operator>(</operator><name>LINK_ELEMENT</name> <operator>*</operator><operator>)</operator><name>cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NAMED_CAPTURE_SINGLE_OPT</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>NAMED_CAPTURE_SINGLE_OPT</name><operator>-</operator><literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vars</name><operator>-&gt;</operator><name>nd_next</name></name> <operator>&amp;&amp;</operator> <name>vars</name> <operator>==</operator> <name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>nom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>nom</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>nom</name></expr></argument>, <argument><expr><name>fail_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

ADD_INSN(nom, line, pop);

ADD_INSN(nom, line, putnil);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>nom</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name><name>nom</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>cap</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name><operator>)</operator><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <name><name>nom</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name><name>cap</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>nom</name><operator>-&gt;</operator><name>anchor</name><operator>.</operator><name>next</name></name><operator>)</operator><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>cap</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>fail_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>vars</name> <operator>=</operator> <name>node</name></expr>;</init> <condition><expr><name>vars</name></expr>;</condition> <incr><expr><name>vars</name> <operator>=</operator> <name><name>vars</name><operator>-&gt;</operator><name>nd_next</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>ret</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NO_CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"capture"</literal></expr></argument>, <argument><expr><name><name>vars</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>INSN</name><operator>*</operator><operator>)</operator><name>last</name><operator>)</operator><operator>-&gt;</operator><name>insn_id</name> <operator>=</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>INSN</name><operator>*</operator><operator>)</operator><name>last</name><operator>)</operator><operator>-&gt;</operator><name>operand_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>optimizable_range_item_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIT</name></expr>:</case>

<return>return <expr><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_if</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>node_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node_body</name> <init>= <expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_IF</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node_else</name> <init>= <expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_IF</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lineno</name> <init>= <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>column</name> <init>= <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_lineno</name> <init>= <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_column</name> <init>= <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>then_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>else_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>then_label</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>else_label</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_label</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ci_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>catch_table</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>catch_table_size</name> <init>= <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>then_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>else_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>then_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>else_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end_label</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cond</name></name></expr></argument>,

<argument><expr><name>then_label</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ci_size</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>then_seq</name></expr></argument>, <argument><expr><literal type="string">"then"</literal></expr></argument>, <argument><expr><name>node_body</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>catch_table</name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>then_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name> <operator>=</operator> <name>ci_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_set_len</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>, <argument><expr><name>catch_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>catch_table_size</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ci_size</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>else_seq</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>node_else</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>catch_table</name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>else_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name> <operator>=</operator> <name>ci_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_set_len</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>, <argument><expr><name>catch_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>catch_table_size</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>catch_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>then_label</name><operator>-&gt;</operator><name>refcnt</name></name> <operator>&amp;&amp;</operator> <name><name>else_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>last_lineno</name></expr></argument>, <argument><expr><name>last_column</name></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_IF</name></expr> ?</condition><then> <expr><literal type="string">"if"</literal></expr> </then><else>: <expr><literal type="string">"unless"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>then_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>then_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>else_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>ret</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_body</name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node_body</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_body</name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node_body</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_body</name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node_body</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_body</name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node_body</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_IF</name></expr> ?</condition><then> <expr><literal type="string">"then"</literal></expr> </then><else>: <expr><literal type="string">"else"</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>then_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>then_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>else_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>then_label</name><operator>-&gt;</operator><name>refcnt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>ret</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_else</name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node_else</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_else</name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node_else</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_else</name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node_else</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node_else</name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node_else</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_IF</name></expr> ?</condition><then> <expr><literal type="string">"else"</literal></expr> </then><else>: <expr><literal type="string">"then"</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>else_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end_label</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_case</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vals</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>orig_node</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>endlabel</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elselabel</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>only_special_literals</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>literals</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>, <decl><type ref="prev"/><name>lineno</name></decl>, <decl><type ref="prev"/><name>column</name></decl>, <decl><type ref="prev"/><name>last_lineno</name></decl>, <decl><type ref="prev"/><name>last_column</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>node_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>literals</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>cdhash_type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><literal type="string">"case base"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_CASE"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_WHEN</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_lineno</name> <operator>=</operator> <call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_column</name> <operator>=</operator> <call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>endlabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>elselabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<while>while <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_WHEN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>body_seq</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"when"</literal></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><literal type="string">"when body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vals</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<expr_stmt><expr><name>only_special_literals</name> <operator>=</operator> <call><name>when_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>only_special_literals</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>COMPILE_NG</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case>

<expr_stmt><expr><name>only_special_literals</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>when_splat_vals</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>only_special_literals</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_CASE"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>EXPECT_NODE_NONULL</name><argument_list>(<argument><expr><literal type="string">"NODE_CASE"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_lineno</name> <operator>=</operator> <call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_column</name> <operator>=</operator> <call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"== else (implicit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>only_special_literals</name> <operator>&amp;&amp;</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>specialized_instruction</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opt_case_dispatch</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>, <argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>literals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LABEL_REF</name><argument_list>(<argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_case2</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>vals</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>orig_node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>endlabel</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>endlabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_WHEN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lineno</name> <init>= <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>column</name> <init>= <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_lineno</name> <init>= <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_column</name> <init>= <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>body_seq</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"when"</literal></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><literal type="string">"when"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vals</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vals</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXPECT_NODE_NONULL</name><argument_list>(<argument><expr><literal type="string">"NODE_WHEN"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LIST</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<while>while <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lnext</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>vals</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lnext</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debug_compile</name><argument_list>(<argument><expr><literal type="string">"== when2\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>lnext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vals</name> <operator>=</operator> <name><name>vals</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<break>break;</break>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"when2/cond splat"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_WHEN</name> <operator>|</operator> <name>VM_CHECKMATCH_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_WHEN"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>ret</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"else"</literal></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_compile_pattern_match</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>unmatched</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_alt_pattern</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_compile_pattern_each</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>matched</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>unmatched</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_alt_pattern</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_ARYPTN</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_ary_pattern_info</name></name> <modifier>*</modifier></type><name>apinfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_apinfo</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>apinfo</name><operator>-&gt;</operator><name>pre_args</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pre_args_num</name> <init>= <expr><ternary><condition><expr><name><name>apinfo</name><operator>-&gt;</operator><name>pre_args</name></name></expr> ?</condition><then> <expr><call><name>rb_long2int</name><argument_list>(<argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>pre_args</name><operator>-&gt;</operator><name>nd_alen</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>post_args_num</name> <init>= <expr><ternary><condition><expr><name><name>apinfo</name><operator>-&gt;</operator><name>post_args</name></name></expr> ?</condition><then> <expr><call><name>rb_long2int</name><argument_list>(<argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>post_args</name><operator>-&gt;</operator><name>nd_alen</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_argc</name> <init>= <expr><name>pre_args_num</name> <operator>+</operator> <name>post_args_num</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>use_rest_num</name> <init>= <expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>(</operator><operator>!</operator><call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>post_args_num</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>match_failed</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>type_error</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match_failed</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type_error</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_rest_num</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pconst</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"constant"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_pconst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"deconstruct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idRespond_to</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"deconstruct"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checktype</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>type_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idLength</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>min_argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr> ?</condition><then> <expr><name>idGE</name></expr> </then><else>: <expr><name>idEq</name></expr></else></ternary></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pre_args_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NODE_NAMED_REST_P</name><argument_list>(<argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>pre_args_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idLength</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>min_argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idMINUS</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>apinfo</name><operator>-&gt;</operator><name>rest_arg</name></name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>post_args_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idLength</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>min_argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idMINUS</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>apinfo</name><operator>-&gt;</operator><name>post_args</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>post_args_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>pre_args_num</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idPLUS</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_rest_num</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>type_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_eTypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"deconstruct must return Array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_raise</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_rest_num</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_HSHPTN</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>match_failed</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>type_error</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>match_failed</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type_error</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwargs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>kw_args</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwargs</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><ternary><condition><expr><name>kw_args</name></expr> ?</condition><then> <expr><name><name>kw_args</name><operator>-&gt;</operator><name>nd_alen</name></name><operator>/</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>kw_args</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name><name>kw_args</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_args</name> <operator>=</operator> <name><name>kw_args</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pconst</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"constant"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_pconst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"deconstruct_keys"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idRespond_to</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>duparray</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"deconstruct_keys"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checktype</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>type_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"dup"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwargs</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keys_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_pkwargs</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>args</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>match_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>match_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>keys_num</name> <operator>=</operator> <call><name>rb_long2int</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>nd_alen</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keys_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>NODE</name> <modifier>*</modifier></type><name>key_node</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NODE</name> <modifier>*</modifier></type><name>value_node</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>key_node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NODE_LIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_IN"</literal></expr></argument>, <argument><expr><name>key_node</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>key_node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"key?"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>match_values</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>match_values</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>match_values</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name></expr> ?</condition><then> <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>idAREF</name></expr></else></ternary></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>match_values</name></expr></argument>, <argument><expr><name>value_node</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>match_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idEmptyP</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name> <operator>==</operator> <name>NODE_SPECIAL_NO_REST_KEYWORD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idEmptyP</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_pkwrestarg</name></name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>type_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_eTypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"deconstruct_keys must return Hash"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_raise</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LIT</name></expr>:</case>

<case>case <expr><name>NODE_STR</name></expr>:</case>

<case>case <expr><name>NODE_XSTR</name></expr>:</case>

<case>case <expr><name>NODE_DSTR</name></expr>:</case>

<case>case <expr><name>NODE_DSYM</name></expr>:</case>

<case>case <expr><name>NODE_DREGX</name></expr>:</case>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<case>case <expr><name>NODE_ZLIST</name></expr>:</case>

<case>case <expr><name>NODE_LAMBDA</name></expr>:</case>

<case>case <expr><name>NODE_DOT2</name></expr>:</case>

<case>case <expr><name>NODE_DOT3</name></expr>:</case>

<case>case <expr><name>NODE_CONST</name></expr>:</case>

<case>case <expr><name>NODE_LVAR</name></expr>:</case>

<case>case <expr><name>NODE_DVAR</name></expr>:</case>

<case>case <expr><name>NODE_TRUE</name></expr>:</case>

<case>case <expr><name>NODE_FALSE</name></expr>:</case>

<case>case <expr><name>NODE_SELF</name></expr>:</case>

<case>case <expr><name>NODE_NIL</name></expr>:</case>

<case>case <expr><name>NODE_COLON2</name></expr>:</case>

<case>case <expr><name>NODE_COLON3</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"case in literal"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_LASGN</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <call><name>get_local_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>in_alt_pattern</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"illegal variable in alternative pattern (%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>get_lvar_level</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DASGN</name></expr>:</case>

<case>case <expr><name>NODE_DASGN_CURR</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>lv</name></decl>, <decl><type ref="prev"/><name>ls</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_dyna_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>in_alt_pattern</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"illegal variable in alternative pattern (%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"NODE_DASGN(_CURR): unknown id (%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>ls</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_IF</name></expr>:</case>

<case>case <expr><name>NODE_UNLESS</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>match_failed</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match_failed</name> <operator>=</operator> <name>unmatched</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"case in if"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cond</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_IF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_HASH</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>NODE</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>match_failed</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match_failed</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><call><name>nd_type</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>nd_alen</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unexpected node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_match</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_each</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>matched</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>match_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_OR</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>match_succeeded</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fin</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match_succeeded</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fin</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_each</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>, <argument><expr><name>match_succeeded</name></expr></argument>, <argument><expr><name>fin</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>match_succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_each</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr></argument>, <argument><expr><name>matched</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_IN"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_compile_pattern_match</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>unmatched</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_alt_pattern</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>fin</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_each</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>fin</name></expr></argument>, <argument><expr><name>unmatched</name></expr></argument>, <argument><expr><name>in_alt_pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>fin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_case3</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>orig_node</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>endlabel</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elselabel</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>, <decl><type ref="prev"/><name>lineno</name></decl>, <decl><type ref="prev"/><name>column</name></decl>, <decl><type ref="prev"/><name>last_lineno</name></decl>, <decl><type ref="prev"/><name>last_column</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>node_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><literal type="string">"case base"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXPECT_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_CASE3"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_IN</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_lineno</name> <operator>=</operator> <call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_column</name> <operator>=</operator> <call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>endlabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>elselabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<while>while <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_IN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>body_seq</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"in"</literal></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><literal type="string">"in body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>body_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pattern</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pat_line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>next_pat</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>pat_line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>pat_line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>iseq_compile_pattern_each</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>next_pat</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>next_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unexpected node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_lineno</name> <operator>=</operator> <call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_column</name> <operator>=</operator> <call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"== else (implicit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><name>elselabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_eNoMatchingPatternError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_core_raise</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>cond_seq</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>orig_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>cond_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>body_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>endlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_loop</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>node_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lineno</name> <init>= <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>column</name> <init>= <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_lineno</name> <init>= <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_column</name> <init>= <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>prev_start_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>prev_end_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>prev_redo_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_loopval_popped</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>loopval_popped</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name></type> <name>enl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>next_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>redo_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>break_label</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>adjust_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>next_catch_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>tmp_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>loopval_popped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>push_ensure_entry</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_state</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>next_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>tmp_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>tmp_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>adjust_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>next_catch_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>next_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_label</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>tmp_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>branches</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>last_lineno</name></expr></argument>, <argument><expr><name>last_column</name></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_WHILE</name></expr> ?</condition><then> <expr><literal type="string">"while"</literal></expr> </then><else>: <expr><literal type="string">"until"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(

<argument><expr><name>ret</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>column</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_lineno</name></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr> ?</condition><then> <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>last_column</name></expr></else></ternary></expr></argument>,

<argument><expr><literal type="string">"body"</literal></expr></argument>,

<argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"while body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>next_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_WHILE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cond</name></name></expr></argument>,

<argument><expr><name>redo_label</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>compile_branch_condition</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cond</name></name></expr></argument>,

<argument><expr><name>end_label</name></expr></argument>, <argument><expr><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>adjust_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_state</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unsupported: putundef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>break_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_BREAK</name></expr></argument>, <argument><expr><name>redo_label</name></expr></argument>, <argument><expr><name>break_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>break_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_NEXT</name></expr></argument>, <argument><expr><name>redo_label</name></expr></argument>, <argument><expr><name>break_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>next_catch_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_REDO</name></expr></argument>, <argument><expr><name>redo_label</name></expr></argument>, <argument><expr><name>break_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name> <operator>=</operator> <name>prev_start_label</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name> <operator>=</operator> <name>prev_end_label</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>=</operator> <name>prev_redo_label</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>loopval_popped</name> <operator>=</operator> <name>prev_loopval_popped</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ensure_node_stack</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_iter</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>prevblock</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>retry_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>retry_end_l</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>child_iseq</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>retry_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_FOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"iter caller (for)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_iter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>=</operator> <name>child_iseq</name> <operator>=</operator>

<call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_BLOCK</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_BLOCK</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idEach</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>=</operator> <name>child_iseq</name> <operator>=</operator>

<call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_BLOCK</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"iter caller"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_iter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>retry_end_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>=</operator> <name>prevblock</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_BREAK</name></expr></argument>, <argument><expr><name>retry_label</name></expr></argument>, <argument><expr><name>retry_end_l</name></expr></argument>, <argument><expr><name>child_iseq</name></expr></argument>, <argument><expr><name>retry_end_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_for_masgn</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_var</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>not_single</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>not_ary</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"for var"</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idLength</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idEq</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>not_single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"try_convert"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>not_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>not_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>not_single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_break</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>throw_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"break val (while/until)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></argument>,

<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>loopval_popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<label><name>break_by_insn</name>:</label>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"break val (block)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>throw_flag</name> <operator>|</operator> <name>TAG_BREAK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<label><name>break_in_eval</name>:</label>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Can't escape from eval with break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>throw_flag</name> <operator>=</operator> <name>VM_THROW_NO_ESCAPE_FLAG</name></expr>;</expr_stmt>

<goto>goto <name>break_by_insn</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>break_by_insn</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>break_in_eval</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Invalid break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_next</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>throw_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"next in while loop\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"next val/valid syntax?"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"next in block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"next val"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>splabel</name><operator>-&gt;</operator><name>unremovable</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<label><name>next_in_eval</name>:</label>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Can't escape from eval with next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>iseq</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>throw_flag</name> <operator>=</operator> <name>VM_THROW_NO_ESCAPE_FLAG</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>next_in_eval</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"next val"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>throw_flag</name> <operator>|</operator> <name>TAG_NEXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Invalid next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_redo</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"redo in while"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<label><name>redo_in_eval</name>:</label>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Can't escape from eval with redo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"redo in block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>iseq</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_label</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>redo_in_eval</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_THROW_NO_ESCAPE_FLAG</name> <operator>|</operator> <name>TAG_REDO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Invalid redo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_retry</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>TAG_RETRY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Invalid retry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_rescue</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lcont</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>rescue</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_resq</name></name></expr></argument>,

<argument><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"rescue in "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_RESCUE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lstart</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_BEG</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lend</name><operator>-&gt;</operator><name>rescued</name></name> <operator>=</operator> <name>LABEL_RESCUE_END</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rescue head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rescue else"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_RESCUE</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><name>rescue</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_RETRY</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_resbody</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>resq</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>narg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label_miss</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>label_hit</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>resq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>label_miss</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>label_hit</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>narg</name> <operator>=</operator> <name><name>resq</name><operator>-&gt;</operator><name>nd_args</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>narg</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_LIST</name></expr>:</case>

<while>while <condition>(<expr><name>narg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rescue arg"</literal></expr></argument>, <argument><expr><name><name>narg</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_RESCUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>label_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>narg</name> <operator>=</operator> <name><name>narg</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<break>break;</break>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rescue/cond splat"</literal></expr></argument>, <argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_RESCUE</name> <operator>|</operator> <name>VM_CHECKMATCH_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>label_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"NODE_RESBODY"</literal></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_CHECKMATCH_TYPE_RESCUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>label_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>label_miss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"resbody body"</literal></expr></argument>, <argument><expr><name><name>resq</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>tailcall_optimization</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>nop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label_miss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>resq</name> <operator>=</operator> <name><name>resq</name><operator>-&gt;</operator><name>nd_head</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_ensure</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>ensr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ensure</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_ensr</name></name></expr></argument>,

<argument><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><call><name>rb_str_new2</name> <argument_list>(<argument><expr><literal type="string">"ensure in "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_ENSURE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lcont</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_leave</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ensure_range</name></name></type> <name>er</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_ensure_node_stack</name></name></type> <name>enl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ensure_range</name></name> <modifier>*</modifier></type><name>erange</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>ensr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ensr</name></expr></argument>, <argument><expr><literal type="string">"ensure ensr"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_ensr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>ensr</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>last_leave</name> <operator>=</operator> <name>last</name> <operator>&amp;&amp;</operator> <call><name>IS_INSN</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_INSN_ID</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>er</name><operator>.</operator><name>begin</name></name> <operator>=</operator> <name>lstart</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>er</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>lend</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>er</name><operator>.</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>push_ensure_entry</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>er</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_ensr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"ensure head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><operator>(</operator><name>popped</name> <operator>|</operator> <name>last_leave</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ensr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name> <operator>&amp;&amp;</operator> <name>last_leave</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>last_leave</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>erange</name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ensure_node_stack</name><operator>-&gt;</operator><name>erange</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lstart</name><operator>-&gt;</operator><name>link</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>lend</name><operator>-&gt;</operator><name>link</name></name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>erange</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>CATCH_TYPE_ENSURE</name></expr></argument>, <argument><expr><name><name>erange</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>erange</name><operator>-&gt;</operator><name>end</name></name></expr></argument>,

<argument><expr><name>ensure</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>erange</name> <operator>=</operator> <name><name>erange</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ensure_node_stack</name> <operator>=</operator> <name><name>enl</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_return</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>is</name> <init>= <expr><name>iseq</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>t</name> <init>= <expr><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_stts</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>splabel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>t</name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>ISEQ_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>is</name> <operator>=</operator> <name><name>is</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>is</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_TOP</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_MAIN</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"argument of top-level return is ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is</name> <operator>==</operator> <name>iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>ISEQ_TYPE_METHOD</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>splabel</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"return nd_stts (return val)"</literal></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>add_ensure_iseq</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>leave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ADJUST_RESTORE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>splabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>throw</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>TAG_RETURN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_evstr</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"nd_body"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>all_string_result_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><name>VM_CALL_FCALL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>isstr</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checktype</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>isstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_R</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idTo_s</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tostring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>isstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LABEL</name> <modifier>*</modifier></type>

<name>qcall_branch_start</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>branches</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>first_lineno</name> <init>= <expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>first_column</name> <init>= <expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_lineno</name> <init>= <expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>last_column</name> <init>= <expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>br</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_BRANCH_BASE</name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><name>first_column</name></expr></argument>, <argument><expr><name>last_lineno</name></expr></argument>, <argument><expr><name>last_column</name></expr></argument>, <argument><expr><literal type="string">"&amp;."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>branches</name> <operator>=</operator> <name>br</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchnil</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><name>first_column</name></expr></argument>, <argument><expr><name>last_lineno</name></expr></argument>, <argument><expr><name>last_column</name></expr></argument>, <argument><expr><literal type="string">"then"</literal></expr></argument>, <argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>else_label</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qcall_branch_end</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>branches</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end_label</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>else_label</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end_label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_TRACE_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>nd_first_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_first_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_lineno</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nd_last_column</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"else"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_call_precheck_freeze</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_STR</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name> <operator>==</operator> <name>idFreeze</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name> <operator>==</operator> <name>idUMinus</name><operator>)</operator> <operator>&amp;&amp;</operator>

<name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>specialized_instruction</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name> <operator>==</operator> <name>idUMinus</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_str_uminus</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idUMinus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_str_freeze</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idFreeze</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name> <operator>==</operator> <name>idAREF</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>private_recv_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name> <operator>&amp;&amp;</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_alen</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_STR</name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>frozen_string_literal</name></name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>specialized_instruction</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_aref_with</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_has_builtin_function_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type>

<name>iseq_builtin_function_lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>iseq_builtin_function_name</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"__builtin_"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>prefix_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>name</name><index>[<expr><name>prefix_len</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>delegate_call_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pstart_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pstart_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>start</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>

<condition><expr><name>argc</name> <operator>+</operator> <name>start</name> <operator>&lt;=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition>

<incr><expr><name>start</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>FIRST_ELEMENT</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name><operator>-</operator><name>start</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_ELEMENT_INSN</name> <operator>&amp;&amp;</operator>

<call><name>INSN_OF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>getlocal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>local_index</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>local_level</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>local_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>(</operator><name>local_index</name> <operator>-</operator> <name>VM_ENV_DATA_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lvar:%s (%d), id:%s (%d) local_index:%d, local_size:%d\n"</literal></expr></argument>,

<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>,

<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>index</name></expr></argument>,

<argument><expr><name>local_index</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>index</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>elem</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<continue>continue;</continue> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<goto>goto <name>next</name>;</goto>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<goto>goto <name>fail</name>;</goto> 

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<goto>goto <name>fail</name>;</goto> 

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<goto>goto <name>success</name>;</goto>

<label><name>next</name>:</label><empty_stmt>;</empty_stmt>

</block_content>}</block></for>

<label><name>fail</name>:</label>

<return>return <expr><name>FALSE</name></expr>;</return>

<label><name>success</name>:</label>

<expr_stmt><expr><operator>*</operator><name>pstart_index</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_call</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>keywords</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent_block</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_SUPPORT_JOKE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_VCALL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id_bitblt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id_answer</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_bitblt</name></expr></argument>, <argument><expr><literal type="string">"bitblt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_answer</name></expr></argument>, <argument><expr><literal type="string">"the_answer_to_life_the_universe_and_everything"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>id_bitblt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>bitblt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>mid</name> <operator>==</operator> <name>id_answer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>goto_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>label_id</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>goto_id</name></expr></argument>, <argument><expr><literal type="string">"__goto__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>label_id</name></expr></argument>, <argument><expr><literal type="string">"__label__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_FCALL</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>mid</name> <operator>==</operator> <name>goto_id</name> <operator>||</operator> <name>mid</name> <operator>==</operator> <name>label_id</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>labels_table</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>labels_table</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>label_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>labels_table</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>labels_table</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>labels_table</name> <operator>=</operator> <name>labels_table</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name> <operator>&amp;&amp;</operator>

<call><name>SYMBOL_P</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>label_name</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>label_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>label_name</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"invalid goto/label format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>goto_id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>builtin_func</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NODE</name> <modifier>*</modifier></type><name>args_node</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>iseq_has_builtin_function_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>builtin_func</name> <operator>=</operator> <call><name>iseq_builtin_function_name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>parent_block</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"should not call builtins here."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>inline_func</name><index>[<expr><literal type="number">0x20</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>cconst</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>retry</name>:</label><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><call><name>iseq_builtin_function_lookup</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"cstmt!"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"cexpr!"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<label><name>inlinec</name>:</label><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inline_index</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>builtin_inline_index</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>inline_func</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><literal type="string">"_bi%d"</literal></expr></argument>, <argument><expr><name>inline_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>builtin_func</name> <operator>=</operator> <name>inline_func</name></expr>;</expr_stmt>

<expr_stmt><expr><name>args_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<goto>goto <name>retry</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"cconst!"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cconst</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>inlinec</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"cinit!"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>builtin_inline_index</name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"can't find builtin function:%s"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"can't find builtin function:%s"</literal></expr></argument>, <argument><expr><name>builtin_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cconst</name></expr>)</condition> <block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>builtin_func0</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><name>VALUE</name></type> <name>const_val</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>builtin_func0</name><operator>)</operator><name><name>bf</name><operator>-&gt;</operator><name>func_ptr</name></name><operator>)</operator><operator>(</operator><name>NULL</name>, <name>Qnil</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>const_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>args_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"argc is not match for builtin function:%s (expect %d but %d)"</literal></expr></argument>,

<argument><expr><name>builtin_func</name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>start_index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>delegate_call_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_invokebuiltin_delegate</name></expr></argument>, <argument><expr><name>bf</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>start_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>,<argument><expr><name>line</name></expr></argument>, <argument><expr><name>invokebuiltin</name></expr></argument>, <argument><expr><name>bf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_CALL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>NODE_OPCALL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>NODE_QCALL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>level</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>idCall</name> <operator>&amp;&amp;</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LVAR</name> <operator>&amp;&amp;</operator>

<call><name>iseq_block_param_id_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>level</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>getblockparamproxy</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>idx</name> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>private_recv_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>putself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_FCALL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><literal type="string">"recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_QCALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>else_label</name> <operator>=</operator> <call><name>qcall_branch_start</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>branches</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_FCALL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>NODE_VCALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_CALL_RECEIVER</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>NODE_VCALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"call args argc"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"call method"</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_VCALL</name></expr>:</case>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_VCALL</name></expr>;</expr_stmt>

<case>case <expr><name>NODE_FCALL</name></expr>:</case>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_FCALL</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>ADD_SEND_R</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>parent_block</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qcall_branch_end</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>, <argument><expr><name>branches</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iseq_compile_each0</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_compile_each</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lineno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"node: NODE_NIL(implicit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>iseq_compile_each0</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_yield_place</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_TOP</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_MAIN</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_CLASS</name></expr>:</case>

<return>return <expr><name>FALSE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_compile_each0</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>popped</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>node_type</name></name></type> <name>type</name> <init>= <expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name> <operator>==</operator> <name>line</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NODE_FL_NEWLINE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>event</name> <init>= <expr><name>RUBY_EVENT_LINE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>last_line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISEQ_LINE_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>event</name> <operator>|=</operator> <name>RUBY_EVENT_COVERAGE_LINE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>debug_node_start</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BEFORE_RETURN</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEFORE_RETURN</name></cpp:macro> <cpp:value>debug_node_end()</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_BLOCK</name></expr>:</case><block>{<block_content>

<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_BLOCK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"BLOCK body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>popped</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"BLOCK next"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_IF</name></expr>:</case>

<case>case <expr><name>NODE_UNLESS</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_if</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_CASE</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_case</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_CASE2</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_case2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_CASE3</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_case3</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_WHILE</name></expr>:</case>

<case>case <expr><name>NODE_UNTIL</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_loop</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FOR</name></expr>:</case>

<case>case <expr><name>NODE_ITER</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_iter</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_FOR_MASGN</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_for_masgn</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_BREAK</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_break</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_NEXT</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_next</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_REDO</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_redo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_RETRY</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_retry</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_BEGIN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_BEGIN"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_RESCUE</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_rescue</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_RESBODY</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_resbody</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_ENSURE</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_ensure</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_AND</name></expr>:</case>

<case>case <expr><name>NODE_OR</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"nd_1st"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_AND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"nd_2nd"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_MASGN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>compile_massign</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LASGN</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <call><name>get_local_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"lvar: %s idx: %d\n"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"rvalue"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>get_lvar_level</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DASGN</name></expr>:</case>

<case>case <expr><name>NODE_DASGN_CURR</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>lv</name></decl>, <decl><type ref="prev"/><name>ls</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"dvalue"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"dassn id"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>id</name></expr> </then><else>: <expr><literal type="char">'*'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_dyna_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"NODE_DASGN(_CURR): unknown id (%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>ls</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_GASGN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"lvalue"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setglobal</name></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>nd_entry</name></name> <operator>|</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_IASGN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"lvalue"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setinstancevariable</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>get_ivar_ic_value</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CDECL</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"lvalue"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_CONST_BASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>compile_cpath</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_else</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CVASGN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"cvasgn val"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setclassvariable</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_OP_ASGN1</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asgnflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>boff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>asgnflag</name> <operator>=</operator> <call><name>COMPILE_RECV</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN1 recv"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>asgnflag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_ZLIST</name></expr>:</case>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_BLOCK_PASS</name></expr>:</case>

<expr_stmt><expr><name>boff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<default>default:</default>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dupn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>boff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>asgnflag</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>idOROP</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>idANDOP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lfin</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>idOROP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN1 args-&gt;body: "</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>boff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dupn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idASET</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idASET</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>boff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>adjuststack</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>boff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN1 args-&gt;body: "</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>boff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dupn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idASET</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>boff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idASET</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_OP_ASGN2</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>atype</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>vid</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>, <decl><type ref="prev"/><name>aid</name> <init>= <expr><call><name>rb_id_attrset</name><argument_list>(<argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asgnflag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lfin</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lcfin</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lskip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>asgnflag</name> <operator>=</operator> <call><name>COMPILE_RECV</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN2#recv"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>asgnflag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_aid</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lskip</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchnil</name></expr></argument>, <argument><expr><name>lskip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>asgnflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>atype</name> <operator>==</operator> <name>idOROP</name> <operator>||</operator> <name>atype</name> <operator>==</operator> <name>idANDOP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>atype</name> <operator>==</operator> <name>idOROP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>lcfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>lcfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN2 val"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>aid</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>asgnflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lcfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lskip</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lskip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN2 val"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>atype</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>aid</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>asgnflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lskip</name> <operator>&amp;&amp;</operator> <name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lskip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lskip</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lskip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_OP_CDECL</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lfin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lassign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_COLON3</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_COLON2</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_CDECL/colon2#nd_head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"%s: invalid node in NODE_OP_CDECL"</literal></expr></argument>,

<argument><expr><call><name>ruby_node_name</name><argument_list>(<argument><expr><call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></switch>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_mid</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_aid</name></name> <operator>==</operator> <name>idOROP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lassign</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defined</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>DEFINED_CONST_FROM</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>lassign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_aid</name></name> <operator>==</operator> <name>idOROP</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_aid</name></name> <operator>==</operator> <name>idANDOP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lfin</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_aid</name></name> <operator>==</operator> <name>idOROP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>lassign</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lassign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_CDECL#nd_value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dupn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_CDECL#nd_value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_aid</name></name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_OP_ASGN_AND</name></expr>:</case>

<case>case <expr><name>NODE_OP_ASGN_OR</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lfin</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lassign</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_OP_ASGN_OR</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name><name>lfinish</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>lfin</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>defined_expr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><name>lfinish</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lassign</name> <operator>=</operator> <name><name>lfinish</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lassign</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lassign</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>lassign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>lassign</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN_AND/OR#nd_head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_OP_ASGN_AND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchunless</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lassign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"NODE_OP_ASGN_AND/OR#nd_value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lfin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CALL</name></expr>:</case> 

<case>case <expr><name>NODE_OPCALL</name></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>compile_call_precheck_freeze</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TRUE</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>NODE_QCALL</name></expr>:</case> 

<case>case <expr><name>NODE_FCALL</name></expr>:</case> 

<case>case <expr><name>NODE_VCALL</name></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>compile_call</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>COMPILE_NG</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>NODE_SUPER</name></expr>:</case>

<case>case <expr><name>NODE_ZSUPER</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>keywords</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent_block</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NODE_SUPER</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vargc</name> <init>= <expr><call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vargc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>vargc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>liseq</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>local_body</name> <init>= <expr><name><name>liseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>local_kwd</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lvar_level</name> <init>= <expr><call><name>get_lvar_level</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>j</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>post_len</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>post_start</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>post_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>(</operator><name>post_start</name> <operator>+</operator> <name>j</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>post_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>(</operator><name>post_start</name> <operator>+</operator> <name>j</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name>post_len</name> <operator>+</operator> <name>post_start</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>local_size</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>local_kwd</name><operator>-&gt;</operator><name>rest_start</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newhash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT_MUT</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_kwd</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>local_kwd</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>local_size</name> <operator>-</operator> <call><name>get_local_var_idx</name><argument_list>(<argument><expr><name>liseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_hash_merge_ptr</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>local_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>local_kwd</name><operator>-&gt;</operator><name>rest_start</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lvar_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>local_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>VM_CALL_KW_SPLAT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>invokesuper</name></expr></argument>,

<argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>flag</name> <operator>|</operator> <name>VM_CALL_SUPER</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NODE_ZSUPER</name></expr> ?</condition><then> <expr><name>VM_CALL_ZSUPER</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>VM_CALL_FCALL</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>parent_block</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>parent_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LIST</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_array</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ZLIST</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_VALUES</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"NODE_VALUES: must not be popped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"values item"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>nd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_alen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_HASH</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_hash</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_RETURN</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_return</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_YIELD</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>keywords</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_yield_place</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"Invalid yield"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>invokeblock</name></expr></argument>, <argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LVAR</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <call><name>get_local_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugs</name><argument_list>(<argument><expr><literal type="string">"id: %s idx: %d\n"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>get_lvar_level</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DVAR</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lv</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>ls</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"nd_vid"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_dyna_var_idx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unknown dvar (%"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>ls</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_GVAR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getglobal</name></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>nd_entry</name></name> <operator>|</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_IVAR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"nd_vid"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getinstancevariable</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>get_ivar_ic_value</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CONST</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"nd_vid"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>inline_const_cache</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ic_index</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_getinlinecache</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_setinlinecache</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CVAR</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getclassvariable</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_vid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_NTH_REF</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>nd_nth</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getspecial</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> ,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_nth</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_BACK_REF</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getspecial</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> ,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0x01</literal> <operator>|</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>nd_nth</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_MATCH</name></expr>:</case>

<case>case <expr><name>NODE_MATCH2</name></expr>:</case>

<case>case <expr><name>NODE_MATCH3</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NODE_MATCH</name></expr>:</case>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getspecial</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_MATCH2</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_MATCH3</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idEqTilde</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>compile_named_capture_assign</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LIT</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"lit"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_STR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"nd_lit"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lit</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>frozen_string_literal</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putstring</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>debug_frozen_string_literal</name></name> <operator>||</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_debug</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug_info</name> <init>= <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>lit</name></expr></argument>, <argument><expr><name>id_debug_created_info</name></expr></argument>, <argument><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_str_freeze</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>lit</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DSTR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>compile_dstr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>frozen_string_literal</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug_info</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>debug_frozen_string_literal</name></name> <operator>||</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_debug</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>debug_info</name> <operator>=</operator> <call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>freezestring</name></expr></argument>, <argument><expr><name>debug_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_XSTR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_CALL_RECEIVER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idBackquote</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DXSTR</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_CALL_RECEIVER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_dstr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idBackquote</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_EVSTR</name></expr>:</case>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_evstr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NODE_DREGX</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>compile_dregx</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ONCE</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ic_index</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>block_iseq</name></decl>;</decl_stmt>

<expr_stmt><expr><name>block_iseq</name> <operator>=</operator> <call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ISEQ_TYPE_PLAIN</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>once</name></expr></argument>, <argument><expr><name>block_iseq</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>block_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ARGSCAT</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argscat head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argscat body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argscat head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argscat body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ARGSPUSH</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"arsgpush head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argspush body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"arsgpush head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"argspush body"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newarray</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>concatarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_SPLAT</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"splat"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>splatarray</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DEFN</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>method_iseq</name> <init>= <expr><call><name>NEW_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_defn</name></name></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_METHOD</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"defn/iseq"</literal></expr></argument>, <argument><expr><call><name>rb_iseqw_new</name><argument_list>(<argument><expr><name>method_iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>definemethod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>method_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>method_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DEFS</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type> <name>singleton_method_iseq</name> <init>= <expr><call><name>NEW_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_defn</name></name></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_METHOD</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"defs/iseq"</literal></expr></argument>, <argument><expr><call><name>rb_iseqw_new</name><argument_list>(<argument><expr><name>singleton_method_iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"defs: recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>definesmethod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>singleton_method_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>singleton_method_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ALIAS</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_CBASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"alias arg1"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_1st</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"alias arg2"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_2nd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_set_method_alias</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_VALIAS</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_alias</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_orig</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_set_variable_alias</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_UNDEF</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_CBASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"undef arg"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_undef</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>id_core_undef_method</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_CLASS</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>class_iseq</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>,

<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;class:%"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_CLASS</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><name>VM_DEFINECLASS_TYPE_CLASS</name> <operator>|</operator>

<operator>(</operator><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>nd_super</name></name></expr> ?</condition><then> <expr><name>VM_DEFINECLASS_FLAG_HAS_SUPERCLASS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>

<call><name>compile_cpath</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"super"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_super</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defineclass</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>class_iseq</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>class_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_MODULE</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>module_iseq</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>,

<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;module:%"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_CLASS</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><name>VM_DEFINECLASS_TYPE_MODULE</name> <operator>|</operator>

<call><name>compile_cpath</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defineclass</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_cpath</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>module_iseq</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>module_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_SCLASS</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>singletonclass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>singleton_class</name> <init>= <expr><call><name>NEW_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"singleton class"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ISEQ_TYPE_CLASS</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"sclass#recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>singletonclass</name></expr></argument>, <argument><expr><literal type="string">"singletonclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>defineclass</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>singletonclass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>singleton_class</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_DEFINECLASS_TYPE_SINGLETON_CLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>singleton_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_COLON2</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ic_index</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_const_prefix</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIST_INSN_SIZE_ZERO</name><argument_list>(<argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>inline_const_cache</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_getinlinecache</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>inline_const_cache</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_setinlinecache</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_CALL_RECEIVER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"colon2#nd_head"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_COLON3</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ic_index</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debugi</name><argument_list>(<argument><expr><literal type="string">"colon3#nd_mid"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>inline_const_cache</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_getinlinecache</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>getconstant</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>inline_const_cache</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_setinlinecache</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ic_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DOT2</name></expr>:</case>

<case>case <expr><name>NODE_DOT3</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>excl</name> <init>= <expr><name>type</name> <operator>==</operator> <name>NODE_DOT3</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flag</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>excl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_beg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_end</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>optimizable_range_item_p</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>optimizable_range_item_p</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bv</name> <init>= <expr><ternary><condition><expr><call><name>nd_type</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name></expr> ?</condition><then> <expr><name><name>b</name><operator>-&gt;</operator><name>nd_lit</name></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ev</name> <init>= <expr><ternary><condition><expr><call><name>nd_type</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>nd_lit</name></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_range_new</name><argument_list>(<argument><expr><name>bv</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>excl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>newrange</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_FLIP2</name></expr>:</case>

<case>case <expr><name>NODE_FLIP3</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lend</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>ltrue</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lfalse</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_flip_flop</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>NODE_FLIP2</name></expr></argument>,

<argument><expr><name>ltrue</name></expr></argument>, <argument><expr><name>lfalse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ltrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_SELF</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_NIL</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_TRUE</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_FALSE</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ERRINFO</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>iseq</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>ip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ip</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LVAR_ERRINFO</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DEFINED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>compile_defined_expr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>NODE_POSTEXE</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_index</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>=

<expr><call><name>rb_iseq_new_with_callback_new_callback</name><argument_list>(<argument><expr><name>build_postexe_iseq</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>once_iseq</name> <init>=

<expr><call><name>new_child_iseq_with_callback</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ifunc</name></expr></argument>,

<argument><expr><call><name>rb_fstring</name><argument_list>(<argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_BLOCK</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>once</name></expr></argument>, <argument><expr><name>once_iseq</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>is_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>once_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_KW_ARG</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>end_label</name> <init>= <expr><call><name>NEW_LABEL</name><argument_list>(<argument><expr><call><name>nd_line</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>default_value</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name><operator>-&gt;</operator><name>nd_value</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>default_value</name> <operator>==</operator> <name>NODE_SPECIAL_REQUIRED_KEYWORD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>nd_type</name><argument_list>(<argument><expr><name>default_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIT</name> <operator>||</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name>default_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_NIL</name> <operator>||</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name>default_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_TRUE</name> <operator>||</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name>default_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>ERROR_ARGS</name> <literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>ng</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>kw_bits_idx</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keyword_idx</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>checkkeyword</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>kw_bits_idx</name> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>keyword_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSNL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>branchif</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE_POPPED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"keyword default argument"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>end_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_DSYM</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>compile_dstr</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>intern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_ATTRASGN</name></expr>:</case><block>{<block_content>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>nd_mid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>else_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>branches</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>idASET</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>private_recv_p</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name> <operator>&amp;&amp;</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LIST</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_alen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>

<call><name>nd_type</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_STR</name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>current_block</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>frozen_string_literal</name></name> <operator>&amp;&amp;</operator>

<call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>option</name><operator>-&gt;</operator><name>specialized_instruction</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_head</name><operator>-&gt;</operator><name>nd_lit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"recv"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_recv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>COMPILE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name><operator>-&gt;</operator><name>nd_next</name><operator>-&gt;</operator><name>nd_head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_aset_with</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>idASET</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>setup_args</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_args</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asgnflag</name> <init>= <expr><call><name>COMPILE_RECV</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><literal type="string">"recv"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>asgnflag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>|=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>asgnflag</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"argc"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debugp_param</name><argument_list>(<argument><expr><literal type="string">"nd_mid"</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_attrset_id</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <call><name>rb_id_attrset</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>else_label</name> <operator>=</operator> <call><name>qcall_branch_start</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>branches</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_BLOCKARG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>topn</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>asgnflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_SPLAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>asgnflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>setn</name></expr></argument>, <argument><expr><call><name>FIXNUM_INC</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_SEQ</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ADD_SEND_WITH_FLAG</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qcall_branch_end</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>else_label</name></expr></argument>, <argument><expr><name>branches</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>NODE_LAMBDA</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>NEW_CHILD_ISEQ</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nd_body</name></name></expr></argument>, <argument><expr><call><name>make_name_for_block</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ISEQ_TYPE_BLOCK</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putspecialobject</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CALL_WITH_BLOCK</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>idLambda</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>UNKNOWN_NODE</name><argument_list>(<argument><expr><literal type="string">"iseq_compile_each"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>COMPILE_NG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>ng</name>:</label>

<expr_stmt><expr><call><name>debug_node_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_NG</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>debug_node_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>insn_data_length</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>insn_len</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>calc_sp_depth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>insn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>comptime_insn_stack_increase</name><argument_list>(<argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>insn</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>, <argument><expr><name><name>insn</name><operator>-&gt;</operator><name>operands</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>opobj_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RBasic</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator>struct <name>RBasic</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>insn_data_to_s_detail</name><parameter_list>(<parameter><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%-20s "</literal></expr></argument>, <argument><expr><call><name>insn_name</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name> <init>= <expr><operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>LABEL_FORMAT</name></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>label_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_ISEQ</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iseq</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>opobj_inspect</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_LINDEX</name></expr>:</case>

<case>case <expr><name>TS_NUM</name></expr>:</case> 

<case>case <expr><name>TS_VALUE</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>opobj_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ID</name></expr>:</case> 

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>opobj_inspect</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator>

<operator>(</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_IC</name></expr>:</case> 

<case>case <expr><name>TS_IVC</name></expr>:</case> 

<case>case <expr><name>TS_ISE</name></expr>:</case> 

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;ic:%d&gt;"</literal></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;calldata:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", %d&gt;"</literal></expr></argument>, <argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_CDHASH</name></expr>:</case> 

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;ch&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Dl_info</name></type> <name>info</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dladdr</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;%p&gt;"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unsupported: TS_BUILTIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default><block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"unknown operand type: %c"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dump_disasm_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>link</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>dump_disasm_list_with_cursor</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dump_disasm_list_with_cursor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>link</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LINK_ELEMENT</name> <modifier>*</modifier></type><name>curr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LABEL</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- raw disasm--------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>link</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>curr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>curr</name> <operator>==</operator> <name>link</name></expr> ?</condition><then> <expr><literal type="string">"*"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>link</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_ELEMENT_INSN</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><name>link</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>insn_data_to_s_detail</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%04d %-65s(%4u)\n"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_info</name><operator>.</operator><name>line_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>insn_data_length</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_LABEL</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><name>lobj</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>link</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>LABEL_FORMAT</name><literal type="string">" [sp: %d]%s\n"</literal></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>label_no</name></name></expr></argument>, <argument><expr><name><name>lobj</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>dest</name> <operator>==</operator> <name>lobj</name></expr> ?</condition><then> <expr><literal type="string">" &lt;---"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_TRACE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>TRACE</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><operator>(</operator><name>TRACE</name> <operator>*</operator><operator>)</operator><name>link</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"trace: %0x\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>ISEQ_ELEMENT_ADJUST</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ADJUST</name> <modifier>*</modifier></type><name>adjust</name> <init>= <expr><operator>(</operator><name>ADJUST</name> <operator>*</operator><operator>)</operator><name>link</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"adjust: [label: %d]\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name></name></expr> ?</condition><then> <expr><name><name>adjust</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>label_no</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"dump_disasm_list error: %ld\n"</literal></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>link</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"---------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_insns_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>insn_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_insns_name_array</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>VM_INSTRUCTION_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>VM_INSTRUCTION_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><call><name>insn_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LABEL</name> <modifier>*</modifier></type>

<name>register_label</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>labels_table</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_to_symbol_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NEW_LABEL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>label</name> <operator>=</operator> <operator>(</operator><name>LABEL</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>LABEL_REF</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>label</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_exception_sym2type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>symRescue</name></decl>, <decl><type ref="prev"/><name>symEnsure</name></decl>, <decl><type ref="prev"/><name>symRetry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>symBreak</name></decl>, <decl><type ref="prev"/><name>symRedo</name></decl>, <decl><type ref="prev"/><name>symNext</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>symRescue</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>symRescue</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"rescue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symEnsure</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ensure"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symRetry</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"retry"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symBreak</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symRedo</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"redo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symNext</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symRescue</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_RESCUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symEnsure</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_ENSURE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symRetry</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_RETRY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symBreak</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_BREAK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symRedo</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_REDO</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>symNext</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CATCH_TYPE_NEXT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"invalid exception symbol: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_build_from_ary_exception</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>labels_table</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>exception</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>eiseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>lstart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lcont</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_to_array_type</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"wrong exception entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_exception_sym2type</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eiseq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>eiseq</name> <operator>=</operator> <call><name>rb_iseqw_to_iseq</name><argument_list>(<argument><expr><call><name>rb_iseq_load</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>lstart</name> <operator>=</operator> <call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lend</name> <operator>=</operator> <call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lcont</name> <operator>=</operator> <call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>NUM2UINT</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CATCH_TYPE_RESCUE</name> <operator>||</operator>

<name>type</name> <operator>==</operator> <name>CATCH_TYPE_BREAK</name> <operator>||</operator>

<name>type</name> <operator>==</operator> <name>CATCH_TYPE_NEXT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>sp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>lcont</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_CATCH_ENTRY</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>lend</name></expr></argument>, <argument><expr><name>eiseq</name></expr></argument>, <argument><expr><name>lcont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>COMPILE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type>

<name>insn_make_insn_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>st_init_numtable_with_size</name><argument_list>(<argument><expr><name>VM_INSTRUCTION_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>VM_INSTRUCTION_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><call><name>insn_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>table</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>iseq_build_load_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseqw</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>loaded_iseq</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseqw</name> <operator>=</operator> <call><name>rb_iseq_load</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cISeq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseqw</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"ISEQ is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>loaded_iseq</name> <operator>=</operator> <call><name>rb_iseqw_to_iseq</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>loaded_iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_build_callinfo_from_hash</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>orig_argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_arg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vmid</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"mid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vflag</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vorig_argc</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"orig_argc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vkw_arg</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"kw_arg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vmid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mid</name> <operator>=</operator> <call><name>SYM2ID</name><argument_list>(<argument><expr><name>vmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vflag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>NUM2UINT</name><argument_list>(<argument><expr><name>vflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vorig_argc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>orig_argc</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>vorig_argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vkw_arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>vkw_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>rb_callinfo_kwarg_bytes</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>kw_arg</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>kw</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>vkw_arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>kw</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><call><name>new_callinfo</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>orig_argc</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>kw_arg</name></expr></argument>, <argument><expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>VM_CALL_ARGS_SIMPLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_event_flag_t</name></type>

<name>event_name_to_flag</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_EVENT</name><parameter_list>(<parameter><type><name>ev</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (sym == ID2SYM(rb_intern(#ev))) return ev;</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_EVENT</name></cpp:undef>

<return>return <expr><name>RUBY_EVENT_NONE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_build_from_ary_body</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>anchor</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>labels_wrapper</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>labels_table</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>labels_wrapper</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>COMPILE_OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>insn_table</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>insn_table</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>insn_table</name> <operator>=</operator> <call><name>insn_make_insn_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>event</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>event</name> <operator>=</operator> <call><name>event_name_to_flag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>RUBY_EVENT_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ADD_TRACE</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ADD_LABEL</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>line_no</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>insn_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>insn</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>argc</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>insn_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>insn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insn_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>,

<argument><expr><literal type="string">"unknown instruction: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>COMPILE_NG</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>insn_id</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>COMPILE_ERROR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>,

<argument><expr><literal type="string">"operand size mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>COMPILE_NG</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>compile_data_calloc2</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_ELEM</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>,

<argument><expr><operator>(</operator><name>LINK_ELEMENT</name><operator>*</operator><operator>)</operator><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>,

<argument><expr><operator>(</operator>enum <name>ruby_vminsn_type</name><operator>)</operator><name>insn_id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>insn_op_type</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>insn_id</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_LINDEX</name></expr>:</case>

<case>case <expr><name>TS_NUM</name></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>NUM2INT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>iseq_build_load_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>rb_to_symbol_type</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_global_entry</name><argument_list>(<argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TS_IC</name></expr>:</case>

<case>case <expr><name>TS_IVC</name></expr>:</case> 

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NUM2UINT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>is_size</name></name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>iseq_build_callinfo_from_hash</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_ID</name></expr>:</case>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>rb_to_symbol_type</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>map</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>cdhash_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>rb_to_array_type</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sym</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>=

<expr><call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name> <operator>|</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VALUE</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<decl_stmt><decl><type><name>long</name></type> <name>funcptr</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>LONG_LONG</name></type> <name>funcptr</name> <init>= <expr><call><name>NUM2LL</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>funcptr</name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"unknown operand: %c"</literal></expr></argument>, <argument><expr><call><name>insn_op_type</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>insn_id</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_ELEM</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>,

<argument><expr><operator>(</operator><name>LINK_ELEMENT</name><operator>*</operator><operator>)</operator><call><name>new_insn_core</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>line_no</name></expr></argument>,

<argument><expr><operator>(</operator>enum <name>ruby_vminsn_type</name><operator>)</operator><name>insn_id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"unexpected object for instruction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>labels_wrapper</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>validate_labels</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>iseq_setup</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ARRAY</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_to_array_type(v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SYMBOL</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_to_symbol_type(v)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>int_param</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"invalid %+"</literal><name>PRIsVALUE</name><literal type="string">" Fixnum: %+"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>sym</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type>

<name>iseq_build_kw</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>keywords</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>default_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>sym</name></decl>, <decl><type ref="prev"/><name>default_val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>dvs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>keyword</name> <init>= <expr><call><name>ZALLOC</name><argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYM</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ID2SYM(rb_intern(#s))</cpp:value></cpp:define>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>int_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>SYM</name><argument_list>(<argument><expr><name>kwbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ids</name> <operator>=</operator> <operator>(</operator><name>ID</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SYM</name></cpp:undef>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>default_values</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>SYM2ID</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<label><name>default_values</name>:</label> 

<expr_stmt><expr><name>default_len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>default_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>

<return>return <expr><name>keyword</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>default_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dvs</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>default_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_ARRAY</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>default_val</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>default_val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"keyword default has unsupported len %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>SYM2ID</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dvs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>default_val</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>default_values</name></name> <operator>=</operator> <name>dvs</name></expr>;</expr_stmt>

<return>return <expr><name>keyword</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_mark_insn_storage</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type><name>storage</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INSN</name> <modifier>*</modifier></type><name>iobj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>INSN</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>storage</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>padding</name> <init>= <expr><call><name>calc_padding</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>storage</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><name>pos</name> <operator>+</operator> <name>size</name> <operator>+</operator> <name>padding</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>storage</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>offset</name> <operator>&gt;</operator> <name><name>storage</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>storage</name> <operator>=</operator> <name><name>storage</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STRICT_ALIGNMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>padding</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><name>iobj</name> <operator>=</operator> <operator>(</operator><name>INSN</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>storage</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iobj</name><operator>-&gt;</operator><name>operands</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name><name>iobj</name><operator>-&gt;</operator><name>insn_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>OPERAND_AT</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_build_from_ary</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>misc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>locals</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>params</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>exception</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYM</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ID2SYM(rb_intern(#s))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>arg_size</name></decl>, <decl><type ref="prev"/><name>local_size</name></decl>, <decl><type ref="prev"/><name>stack_max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>labels_table</name> <init>= <expr><call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>labels_wrapper</name> <init>= <expr><call><name>Data_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_mark_set</name></expr></argument>, <argument><expr><name>st_free_table</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg_opt_labels</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>SYM</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keywords</name> <init>= <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>SYM</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sym_arg_rest</name> <init>= <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"#arg_rest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_ANCHOR</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name></name> <operator>=</operator> <name>tbl</name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>ID</name> <operator>*</operator><operator>)</operator><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lv</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_arg_rest</name> <operator>==</operator> <name>lv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>ID</name><operator>)</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SYM2ID</name><argument_list>(<argument><expr><call><name>CHECK_SYMBOL</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_PARAM</name><parameter_list>(<parameter><type><name>F</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int_param(&amp;iseq-&gt;body-&gt;param.F, params, SYM(F))</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>lead_num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>post_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>post_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>rest_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>block_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INT_PARAM</name></cpp:undef>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_PARAM</name><parameter_list>(<parameter><type><name>F</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>F = (int_param(&amp;x, misc, SYM(F)) ? (unsigned int)x : 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>arg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INT_PARAM</name><argument_list>(<argument><expr><name>stack_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INT_PARAM</name></cpp:undef>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>arg_opt_labels</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>arg_opt_labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opt_table</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ent</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>arg_opt_labels</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LABEL</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>register_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>opt_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name> <operator>=</operator> <name>opt_table</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg_opt_labels</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">":opt param is not an array: %+"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>arg_opt_labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <call><name>iseq_build_kw</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">":keywords param is not an array: %+"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Qtrue</name> <operator>==</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>SYM</name><argument_list>(<argument><expr><name>ambiguous_param0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>int_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>SYM</name><argument_list>(<argument><expr><name>kwrest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>keyword</name> <init>= <expr><operator>(</operator>struct <name>rb_iseq_param_keyword</name> <operator>*</operator><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>keyword</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SYM</name></cpp:undef>

<expr_stmt><expr><call><name>iseq_calc_param_size</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_build_from_ary_exception</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_build_from_ary_body</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>labels_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>arg_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>=</operator> <name>local_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name> <operator>=</operator> <name>stack_max</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_dvar_defined</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_RESCUE</name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_ENSURE</name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_EVAL</name> <operator>||</operator>

<name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_MAIN</name></expr>

)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>body</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_local_defined</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>caller_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>realpath</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cfp</name> <init>=

<expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><call><name>rb_vm_get_sourceline</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>path</name> <operator>=</operator> <call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>realpath</name> <operator>=</operator> <call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>line</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>path</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;compiled&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>realpath</name> <operator>=</operator> <operator>*</operator><name>path</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_insn_func_t</name></type> <name>func</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

}</block></struct></type> <name>accessor_args</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>method_for_self</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>func</name></decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>build</name>)<parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>, <decl><type ref="prev"/><name>realpath</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>accessor_args</name></type> <name>acc</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>acc</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>acc</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>acc</name><operator>.</operator><name>line</name></name> <operator>=</operator> <call><name>caller_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>=

<expr><call><name>rb_iseq_new_with_callback_new_callback</name><argument_list>(<argument><expr><name>build</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>acc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_iseq_new_with_callback</name><argument_list>(<argument><expr><name>ifunc</name></expr></argument>,

<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>acc</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_METHOD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>for_self_aref</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>accessor_args</name> <modifier>*</modifier><specifier>const</specifier></type> <name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>line</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>iseq_set_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_call_c_function</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>args</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>for_self_aset</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>LINK_ANCHOR</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>accessor_args</name> <modifier>*</modifier><specifier>const</specifier></type> <name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>line</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ID</name></type> <name><name>vars</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><name>idUScore</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>iseq_set_local_table</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_GETLOCAL</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>putobject</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt_call_c_function</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>args</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ADD_INSN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_method_for_self_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>func</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_for_self</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>for_self_aref</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_method_for_self_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>func</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_for_self</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>for_self_aset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IBF_ISEQ_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_ISEQ_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>ibf_offset_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_OFFSET</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ibf_offset_t)(VALUE)(ptr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_MAJOR_VERSION</name></cpp:macro> <cpp:value>ISEQ_MAJOR_VERSION</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_DEVEL</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_DEVEL_VERSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_MINOR_VERSION</name></cpp:macro> <cpp:value>(ISEQ_MINOR_VERSION * 10000 + IBF_DEVEL_VERSION)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_MINOR_VERSION</name></cpp:macro> <cpp:value>ISEQ_MINOR_VERSION</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>ibf_header</name> <block>{

<decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>minor_version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iseq_list_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>global_object_list_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>iseq_list_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>global_object_list_offset</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_dump_buffer</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>obj_table</name></decl>;</decl_stmt> 

}</block>;</struct>

<struct>struct <name>ibf_dump</name> <block>{

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iseq_table</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_buffer</name></name></type> <name>global_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_buffer</name></name> <modifier>*</modifier></type><name>current_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type> <name>iseq_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>ibf_load_buffer</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj_list</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>obj_list_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>obj_list_offset</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_load</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_header</name></name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseq_list</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load_buffer</name></name></type> <name>global_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loader_obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load_buffer</name></name> <modifier>*</modifier></type><name>current_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_pos</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"dump size exceeds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>pos</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_align</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>align</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>pos</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>%</operator> <name>align</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>padding</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>align</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>pos</name> <operator>%</operator> <name>align</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <name>size</name> <operator>&gt;=</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"dump size exceeds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init> <condition><expr><name>size</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>padding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>pos</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_write_byte</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byte</name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_overwrite</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>size</name> <operator>+</operator> <name>offset</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"ibf_dump_overwrite: overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type>

<name>ibf_load_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>beg</name> <init>= <expr><operator>*</operator><name>offset</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<return>return <expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>beg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>ibf_load_alloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><call><name>ruby_xmalloc2</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>x</name> <operator>*</operator> <name>y</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buff</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_W_ALIGN</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RUBY_ALIGNOF(type) &gt; 1 ? ibf_dump_align(dump, RUBY_ALIGNOF(type)) : (void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_W</name><parameter_list>(<parameter><type><name>b</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(IBF_W_ALIGN(type), (type *)(VALUE)IBF_WP(b, type, n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_WV</name><parameter_list>(<parameter><type><name>variable</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ibf_dump_write(dump, &amp;(variable), sizeof(variable))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_WP</name><parameter_list>(<parameter><type><name>b</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ibf_dump_write(dump, (b), sizeof(type) * (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_R</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type *)ibf_load_alloc(load, IBF_OFFSET(val), sizeof(type), (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_ZERO</name><parameter_list>(<parameter><type><name>variable</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memset(&amp;(variable), 0, sizeof(variable))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_table_lookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_table_find_or_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>ibf_table_lookup</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>table</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>index</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ibf_dump_object_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>obj_list_offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>obj_list_size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>ibf_load_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>object_index</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>ibf_load_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>index_iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>

<name>ibf_dump_object_table_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>obj_table</name> <init>= <expr><call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>obj_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qnil</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>obj_table</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_dump_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ibf_table_find_or_insert</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_table</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_dump_id</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>rb_id2sym</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>

<name>ibf_load_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>id_index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sym</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>id_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_sym2id</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ibf_offset_t</name></type> <name>ibf_dump_iseq_each</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_dump_iseq</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>ibf_table_find_or_insert</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_dump_gentry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_dump_id</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_gentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>gid</name> <init>= <expr><call><name>ibf_load_id</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><name>ID</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_global_entry</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>

<name>ibf_load_byte</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>&gt;=</operator> <name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid bytecode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name><index>[<expr><operator>(</operator><operator>*</operator><name>offset</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_write_small_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <literal type="number">8</literal> <operator>||</operator> <name>CHAR_BIT</name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<enum>enum <block>{ <decl><name>max_byte_length</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>bytes</name><index>[<expr><name>max_byte_length</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>bytes</name><index>[<expr><name>max_byte_length</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>x</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bytes</name><index>[<expr><name>max_byte_length</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>bytes</name> <operator>+</operator> <name>max_byte_length</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_small_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <literal type="number">8</literal> <operator>||</operator> <name>CHAR_BIT</name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<union>union <block>{ <decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt> <decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt> }</block> <decl><name>x</name></decl>;</union>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <operator>*</operator><name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<return>return <expr><name><name>x</name><operator>.</operator><name>v</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<enum>enum <block>{ <decl><name>max_byte_length</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><name><name>buffer</name><index>[<expr><operator>*</operator><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>n</name> <init>=

<expr><ternary><condition><expr><name>c</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>:

<expr><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">9</literal></expr> </then><else>: <expr><call><name>ntz_int32</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>c</name> <operator>&gt;&gt;</operator> <name>n</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid byte sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>|=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name><name>buffer</name><index>[<expr><operator>*</operator><name>offset</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<return>return <expr><name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_builtin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>bf</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type>

<name>ibf_load_builtin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ibf_load_ptr</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"%s: table is not provided."</literal></expr></argument>, <argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"%s: index (%d) mismatch (expect %s but %s)."</literal></expr></argument>, <argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>&amp;</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iseq_size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>code_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>orig_code</name> <init>= <expr><call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>code_index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>code_index</name><operator>&lt;</operator><name>iseq_size</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>insn</name> <init>= <expr><name><name>orig_code</name><index>[<expr><name>code_index</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>op_index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>insn</name> <operator>&gt;=</operator> <literal type="number">0x100</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid instruction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>op_index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>op_index</name></expr>]</index></name></expr>;</condition> <incr><expr><name>op_index</name><operator>++</operator></expr><operator>,</operator> <expr><name>code_index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><name><name>orig_code</name><index>[<expr><name>code_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>wv</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>types</name><index>[<expr><name>op_index</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_dump_iseq</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_IC</name></expr>:</case>

<case>case <expr><name>TS_IVC</name></expr>:</case>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>is_entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>i</name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<block>{<block_content>

<goto>goto <name>skip_wv</name>;</goto>

</block_content>}</block>

<case>case <expr><name>TS_ID</name></expr>:</case>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <call><name>ibf_dump_id</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>ID</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <call><name>ibf_dump_gentry</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"TS_FUNCPTR is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>skip_wv</name>;</goto>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<expr_stmt><expr><call><name>ibf_dump_builtin</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> struct <name>rb_builtin_function</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>skip_wv</name>;</goto>

<default>default:</default>

<expr_stmt><expr><name>wv</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>wv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>skip_wv</name>:</label><empty_stmt>;</empty_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>op_index</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>offset</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>ibf_load_code</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>bytecode_offset</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>bytecode_size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>iseq_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>code_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>bytecode_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>iseq_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>load_body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd_entries</name> <init>= <expr><name><name>load_body</name><operator>-&gt;</operator><name>call_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is_entries</name> <init>= <expr><name><name>load_body</name><operator>-&gt;</operator><name>is_entries</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>code_index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>code_index</name><operator>&lt;</operator><name>iseq_size</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>insn</name> <init>= <expr><name><name>code</name><index>[<expr><name>code_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>op_index</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>op_index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>op_index</name></expr>]</index></name></expr>;</condition> <incr><expr><name>op_index</name><operator>++</operator></expr><operator>,</operator> <expr><name>code_index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>types</name><index>[<expr><name>op_index</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TS_IC</name></expr>:</case>

<case>case <expr><name>TS_IVC</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name><name>is_entries</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>cd_entries</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_ID</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_id</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><name>ID</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_gentry</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"TS_FUNCPTR is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_load_builtin</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>code_index</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>op_index</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"operand size mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>iseq_size</name></name> <operator>=</operator> <name>code_index</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>code_index</name> <operator>==</operator> <name>iseq_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>reading_pos</name> <operator>==</operator> <name>bytecode_offset</name> <operator>+</operator> <name>bytecode_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>code</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_param_opt_table</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>opt_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>opt_num</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>ibf_load_param_opt_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>opt_table_offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_num</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>opt_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>opt_num</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>opt_table_offset</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>opt_num</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>table</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_param_keyword</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>kw</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name></type> <name>dump_kw</name> <init>= <expr><operator>*</operator><name>kw</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dv_num</name> <init>= <expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name> <operator>-</operator> <name><name>kw</name><operator>-&gt;</operator><name>required_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><ternary><condition><expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>dvs</name> <init>= <expr><ternary><condition><expr><name>dv_num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>dv_num</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>kw</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ID</name><operator>)</operator><call><name>ibf_dump_id</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>dv_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dvs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>dump_kw</name><operator>.</operator><name>table</name></name> <operator>=</operator> <call><name>IBF_W</name><argument_list>(<argument><expr><name>ids</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump_kw</name><operator>.</operator><name>default_values</name></name> <operator>=</operator> <call><name>IBF_W</name><argument_list>(<argument><expr><name>dvs</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>dv_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dump_kw</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type>

<name>ibf_load_param_keyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>param_keyword_offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>param_keyword_offset</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><call><name>IBF_R</name><argument_list>(<argument><expr><name>param_keyword_offset</name></expr></argument>, <argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><call><name>IBF_R</name><argument_list>(<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dv_num</name> <init>= <expr><name><name>kw</name><operator>-&gt;</operator><name>num</name></name> <operator>-</operator> <name><name>kw</name><operator>-&gt;</operator><name>required_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>dvs</name> <init>= <expr><call><name>IBF_R</name><argument_list>(<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>default_values</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>dv_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>kw</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_id</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>dv_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>dvs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>dvs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>kw</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw</name><operator>-&gt;</operator><name>default_values</name></name> <operator>=</operator> <name>dvs</name></expr>;</expr_stmt>

<return>return <expr><name>kw</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_insns_info_body</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>offset</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>ibf_load_insns_info_body</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>body_offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>body_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr>struct <name>iseq_insn_info_entry</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line_no</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <operator>(</operator><name>rb_event_flag_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>entries</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_insns_info_positions</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>offset</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type>

<name>ibf_load_insns_info_positions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>positions_offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>positions_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <macro><name>ALLOC_N</name><argument_list>(<argument>unsigned int</argument>, <argument>size</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>last</name> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>positions</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_local_table</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_dump_id</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name> <modifier>*</modifier></type>

<name>ibf_load_local_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>local_table_offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>IBF_R</name><argument_list>(<argument><expr><name>local_table_offset</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_id</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>table</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_catch_table</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>table</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>iseq_indices</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>iseq_indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_dump_iseq</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>iseq_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>offset</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type>

<name>ibf_load_catch_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>catch_table_offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>ruby_xmalloc</name><argument_list>(<argument><expr><call><name>iseq_catch_table_bytes</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>catch_table_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>iseq_index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>catch_type</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cont</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sp</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iseq</name> <operator>=</operator> <call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>table</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_ci_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>ci_size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ci_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>ibf_dump_id</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name> <init>= <expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>kwarg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>kwarg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keyword</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>kwarg</name><operator>-&gt;</operator><name>keywords</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>offset</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_load_ci_entries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>,

<parameter><decl><type><name>ibf_offset_t</name></type> <name>ci_entries_offset</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ci_size</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>cd_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>ci_entries_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><call><name>ZALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_call_data</name></expr></argument>, <argument><expr><name>ci_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>cd_ptr</name> <operator>=</operator> <name>cds</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ci_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mid_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mid_index</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>ibf_load_id</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>mid_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>argc</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kwlen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>kwlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kwarg</name> <operator>=</operator> <call><name>rb_xmalloc_mul_add</name><argument_list>(<argument><expr><name>kwlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_callinfo_kwarg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>kwarg</name><operator>-&gt;</operator><name>keyword_len</name></name> <operator>=</operator> <name>kwlen</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>kwlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keyword</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>kwarg</name><operator>-&gt;</operator><name>keywords</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name> <operator>=</operator> <call><name>vm_ci_new</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>kwarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_iseq_each</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_pathobj_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_base_label_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_label_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>iseq_start</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_buffer</name></name> <modifier>*</modifier></type><name>saved_buffer</name> <init>= <expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_buffer</name></name></type> <name>buffer</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>obj_table</name></name> <operator>=</operator> <call><name>ibf_dump_object_table_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name>buffer</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>bytecode_offset</name> <init>= <expr><call><name>ibf_dump_code</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>bytecode_size</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>bytecode_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>param_opt_table_offset</name> <init>= <expr><call><name>ibf_dump_param_opt_table</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>param_keyword_offset</name> <init>= <expr><call><name>ibf_dump_param_keyword</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>insns_info_body_offset</name> <init>= <expr><call><name>ibf_dump_insns_info_body</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>positions</name> <operator>=</operator> <call><name>rb_iseq_insns_info_decode_positions</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>insns_info_positions_offset</name> <init>= <expr><call><name>ibf_dump_insns_info_positions</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>positions</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>positions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>local_table_offset</name> <init>= <expr><call><name>ibf_dump_local_table</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>catch_table_size</name> <init>= <expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr> ?</condition><then> <expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>catch_table_offset</name> <init>= <expr><call><name>ibf_dump_catch_table</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_iseq_index</name> <init>= <expr><call><name>ibf_dump_iseq</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>local_iseq_index</name> <init>= <expr><call><name>ibf_dump_iseq</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>ci_entries_offset</name> <init>= <expr><call><name>ibf_dump_ci_entries</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>local_obj_list_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>local_obj_list_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_object_list</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_obj_list_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_obj_list_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>body_offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>param_flags</name> <init>=

<expr><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_BODY_OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_BODY_OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(body_offset - (x))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>bytecode_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>bytecode_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>param_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>param_opt_table_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>param_keyword_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>location_pathobj_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>location_base_label_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>location_label_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>column</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>column</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>insns_info_body_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>insns_info_positions_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>local_table_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>catch_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>catch_table_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>parent_iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>local_iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><name>ci_entries_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>flip_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>is_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>catch_except_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IBF_BODY_OFFSET</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>iseq_length_bytes</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <name>saved_buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iseq_length_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq_length_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>body_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>local_obj_list_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>local_obj_list_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>obj_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>offset</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>body_offset</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_location_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>str_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_load_iseq_each</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>load_body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>rb_iseq_constant_body_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load_buffer</name></name> <modifier>*</modifier></type><name>saved_buffer</name> <init>= <expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>iseq_start</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>iseq_length_bytes</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>body_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load_buffer</name></name></type> <name>buffer</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name> <operator>+</operator> <name>iseq_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>iseq_length_bytes</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>obj_list_offset</name></name> <operator>=</operator> <operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>obj_list_size</name></name> <operator>=</operator> <operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>obj_list</name></name> <operator>=</operator> <call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>obj_list_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_resize</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>obj_list</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>obj_list_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name>buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><name>reading_pos</name> <operator>=</operator> <name>body_offset</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_BODY_OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_BODY_OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(offset - (x))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>iseq_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>bytecode_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>bytecode_size</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>param_flags</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>param_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_lead_num</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_opt_num</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_rest_start</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_post_start</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_post_num</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_block_start</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>param_opt_table_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>param_keyword_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_pathobj_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_base_label_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_label_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>location_first_lineno</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>location_node_id</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>location_code_location_beg_pos_lineno</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>location_code_location_beg_pos_column</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>location_code_location_end_pos_lineno</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>location_code_location_end_pos_column</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>insns_info_body_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>insns_info_positions_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>insns_info_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>local_table_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>catch_table_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>catch_table_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_iseq_index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>local_iseq_index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ibf_offset_t</name></type> <name>ci_entries_offset</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name><operator>)</operator><call><name>IBF_BODY_OFFSET</name><argument_list>(<argument><expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_snum_t</name></type> <name>variable_flip_count</name> <init>= <expr><operator>(</operator><name>rb_snum_t</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>local_table_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>is_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>ci_size</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>stack_max</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>catch_except_p</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IBF_BODY_OFFSET</name></cpp:undef>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>stack_max</name></name> <operator>=</operator> <name>stack_max</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>param_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>=</operator> <name>param_lead_num</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>=</operator> <name>param_opt_num</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>=</operator> <name>param_rest_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>=</operator> <name>param_post_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name> <operator>=</operator> <name>param_post_num</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>=</operator> <name>param_block_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>=</operator> <name>local_table_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>is_size</name></name> <operator>=</operator> <name>is_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>ci_size</name></name> <operator>=</operator> <name>ci_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>insns_info_size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COVERAGE_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_ORIGINAL_ISEQ_CLEAR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>flip_count</name></name> <operator>=</operator> <name>variable_flip_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name> <operator>=</operator> <name>location_first_lineno</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>node_id</name></name> <operator>=</operator> <name>location_node_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name>location_code_location_beg_pos_lineno</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <name>location_code_location_beg_pos_column</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name>location_code_location_end_pos_lineno</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <name>location_code_location_end_pos_column</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>catch_except_p</name></name> <operator>=</operator> <name>catch_except_p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>is_entries</name></name> <operator>=</operator> <call><name>ZALLOC_N</name><argument_list>(<argument><expr>union <name>iseq_inline_storage_entry</name></expr></argument>, <argument><expr><name>is_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_load_ci_entries</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>ci_entries_offset</name></expr></argument>, <argument><expr><name>ci_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load_body</name><operator>-&gt;</operator><name>call_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name> <operator>=</operator> <call><name>ibf_load_param_opt_table</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>param_opt_table_offset</name></expr></argument>, <argument><expr><name>param_opt_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <call><name>ibf_load_param_keyword</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>param_keyword_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>=</operator> <operator>(</operator><name>param_flags</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name> <operator>=</operator> <call><name>ibf_load_insns_info_body</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>insns_info_body_offset</name></expr></argument>, <argument><expr><name>insns_info_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name> <operator>=</operator> <call><name>ibf_load_insns_info_positions</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>insns_info_positions_offset</name></expr></argument>, <argument><expr><name>insns_info_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>local_table</name></name> <operator>=</operator> <call><name>ibf_load_local_table</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>local_table_offset</name></expr></argument>, <argument><expr><name>local_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>catch_table</name></name> <operator>=</operator> <call><name>ibf_load_catch_table</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>catch_table_offset</name></expr></argument>, <argument><expr><name>catch_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>=</operator> <call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>parent_iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load_body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>local_iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_load_code</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>bytecode_offset</name></expr></argument>, <argument><expr><name>bytecode_size</name></expr></argument>, <argument><expr><name>iseq_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<expr_stmt><expr><call><name>rb_iseq_insns_info_encode_positions</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_iseq_translate_threaded_code</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>realpath</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>path</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>location_pathobj_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>realpath</name> <operator>=</operator> <name>path</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pathobj</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"path object size mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>realpath</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected realpath %"</literal><name>PRIxVALUE</name>

<literal type="string">"(%x), path=%+"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>realpath</name></expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>realpath</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unexpected path object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_iseq_pathobj_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr></argument>, <argument><expr><call><name>ibf_load_location_str</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>location_base_label_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>, <argument><expr><call><name>ibf_load_location_str</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>location_label_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_ENABLE_LOCAL_BUFFER</name></expr></cpp:if>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <name>saved_buffer</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>verify_call_cache</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>ibf_dump_iseq_list_arg</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>offset_list</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_dump_iseq_list_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_iseq_list_arg</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump_iseq_list_arg</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_iseq_each</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>dump</name></name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>offset_list</name></name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_iseq_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ibf_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>offset_list</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_iseq_list_arg</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>dump</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>offset_list</name></name> <operator>=</operator> <name>offset_list</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr></argument>, <argument><expr><name>ibf_dump_iseq_list_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offsets</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>NUM2UINT</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>offset_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ibf_dump_align</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>iseq_list_offset</name></name> <operator>=</operator> <call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>iseq_list_size</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>size</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_OBJECT_INTERNAL</name></cpp:macro> <cpp:value>FL_PROMOTED0</cpp:value></cpp:define>

<struct>struct <name>ibf_object_header</name> <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name><range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>special_const</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>frozen</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>internal</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block>;</struct>

<enum>enum <name>ibf_object_class_index</name> <block>{

<decl><name>IBF_OBJECT_CLASS_OBJECT</name></decl>,

<decl><name>IBF_OBJECT_CLASS_ARRAY</name></decl>,

<decl><name>IBF_OBJECT_CLASS_STANDARD_ERROR</name></decl>,

<decl><name>IBF_OBJECT_CLASS_NO_MATCHING_PATTERN_ERROR</name></decl>,

<decl><name>IBF_OBJECT_CLASS_TYPE_ERROR</name></decl>,

}</block>;</enum>

<struct>struct <name>ibf_object_regexp</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>srcstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>option</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_object_hash</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name><name>keyval</name><index>[<expr><name>FLEX_ARY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_object_struct_range</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>class_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>excl</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_object_bignum</name> <block>{

<decl_stmt><decl><type><name>ssize_t</name></type> <name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BDIGIT</name></type> <name><name>digits</name><index>[<expr><name>FLEX_ARY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<enum>enum <name>ibf_object_data_type</name> <block>{

<decl><name>IBF_OBJECT_DATA_ENCODING</name></decl>,

}</block>;</enum>

<struct>struct <name>ibf_object_complex_rational</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>ibf_object_symbol</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>str</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_ALIGNED_OFFSET</name><parameter_list>(<parameter><type><name>align</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((offset) - 1) / (align) + 1) * (align))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IBF_OBJBODY</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(const type *)ibf_load_check_offset(load, IBF_ALIGNED_OFFSET(RUBY_ALIGNOF(type), offset))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type>

<name>ibf_load_check_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"object offset out of range: %"</literal><name>PRIdSIZE</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>offset</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void ibf_dump_object_unsupported(struct ibf_dump *dump, VALUE obj)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_unsupported</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>, <argument><expr><literal type="string">"ibf_dump_object_unsupported: %s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_unsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_class</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>ibf_object_class_index</name></name></type> <name>cindex</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cindex</name> <operator>=</operator> <name>IBF_OBJECT_CLASS_OBJECT</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_cArray</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cindex</name> <operator>=</operator> <name>IBF_OBJECT_CLASS_ARRAY</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_eStandardError</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cindex</name> <operator>=</operator> <name>IBF_OBJECT_CLASS_STANDARD_ERROR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_eNoMatchingPatternError</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cindex</name> <operator>=</operator> <name>IBF_OBJECT_CLASS_NO_MATCHING_PATTERN_ERROR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_eTypeError</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cindex</name> <operator>=</operator> <name>IBF_OBJECT_CLASS_TYPE_ERROR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_obj_info_dump</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unsupported class"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>ibf_object_class_index</name></name></type> <name>cindex</name> <init>= <expr><operator>(</operator>enum <name>ibf_object_class_index</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>cindex</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>IBF_OBJECT_CLASS_OBJECT</name></expr>:</case>

<return>return <expr><name>rb_cObject</name></expr>;</return>

<case>case <expr><name>IBF_OBJECT_CLASS_ARRAY</name></expr>:</case>

<return>return <expr><name>rb_cArray</name></expr>;</return>

<case>case <expr><name>IBF_OBJECT_CLASS_STANDARD_ERROR</name></expr>:</case>

<return>return <expr><name>rb_eStandardError</name></expr>;</return>

<case>case <expr><name>IBF_OBJECT_CLASS_NO_MATCHING_PATTERN_ERROR</name></expr>:</case>

<return>return <expr><name>rb_eNoMatchingPatternError</name></expr>;</return>

<case>case <expr><name>IBF_OBJECT_CLASS_TYPE_ERROR</name></expr>:</case>

<return>return <expr><name>rb_eTypeError</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_object_class: unknown class (%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>cindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_float</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>dbl</name> <init>= <expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>IBF_W</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbl</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>double</name> <modifier>*</modifier></type><name>dblp</name> <init>= <expr><call><name>IBF_OBJBODY</name><argument_list>(<argument><expr><name>double</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><operator>*</operator><name>dblp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_string</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>encindex</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encindex</name> <operator>&gt;</operator> <name>RUBY_ENCINDEX_BUILTIN_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>encindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc_name</name> <init>= <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>encindex</name> <operator>=</operator> <name>RUBY_ENCINDEX_BUILTIN_MAX</name> <operator>+</operator> <call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>enc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_WP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encindex</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name>reading_pos</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encindex</name> <operator>&gt;</operator> <name>RUBY_ENCINDEX_BUILTIN_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enc_name_str</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>encindex</name> <operator>-</operator> <name>RUBY_ENCINDEX_BUILTIN_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>encindex</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>enc_name_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_regexp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>srcstr</name> <init>= <expr><call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_object_regexp</name></name></type> <name>regexp</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>regexp</name><operator>.</operator><name>option</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>rb_reg_options</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regexp</name><operator>.</operator><name>srcstr</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>srcstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_byte</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>regexp</name><operator>.</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name><name>regexp</name><operator>.</operator><name>srcstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_regexp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_object_regexp</name></name></type> <name>regexp</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>regexp</name><operator>.</operator><name>option</name></name> <operator>=</operator> <call><name>ibf_load_byte</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regexp</name><operator>.</operator><name>srcstr</name></name> <operator>=</operator> <call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>srcstr</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>regexp</name><operator>.</operator><name>srcstr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>reg</name> <init>= <expr><call><name>rb_reg_compile</name><argument_list>(<argument><expr><name>srcstr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>regexp</name><operator>.</operator><name>option</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>reg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_array</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_array</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_dump_object_hash_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>key_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>val_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ibf_dump_object_hash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>key_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>val_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_rehash</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_struct</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cRange</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_object_struct_range</name></name></type> <name>range</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>IBF_ZERO</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>range</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>range</name><operator>.</operator><name>class_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_range_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>range</name><operator>.</operator><name>excl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>range</name><operator>.</operator><name>beg</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>range</name><operator>.</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr>struct <name>ibf_object_struct_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_WV</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>, <argument><expr><literal type="string">"ibf_dump_object_struct: unsupported class %"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_struct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_struct_range</name></name> <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>IBF_OBJBODY</name><argument_list>(<argument><expr>struct <name>ibf_object_struct_range</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>beg</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>range</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>end</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>range</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_range_new</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>range</name><operator>-&gt;</operator><name>excl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_bignum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><call><name>BIGNUM_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>slen</name> <init>= <expr><ternary><condition><expr><call><name>BIGNUM_SIGN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>len</name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BDIGIT</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>BIGNUM_DIGITS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>IBF_W</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>, <argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_WP</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>BDIGIT</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_bignum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_bignum</name></name> <modifier>*</modifier></type><name>bignum</name> <init>= <expr><call><name>IBF_OBJBODY</name><argument_list>(<argument><expr>struct <name>ibf_object_bignum</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><name><name>bignum</name><operator>-&gt;</operator><name>slen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>sign</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>bignum</name><operator>-&gt;</operator><name>slen</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name><name>bignum</name><operator>-&gt;</operator><name>slen</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_integer_unpack</name><argument_list>(<argument><expr><name><name>bignum</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>INTEGER_PACK_LITTLE_ENDIAN</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>sign</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>INTEGER_PACK_NEGATIVE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_data_is_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>IBF_OBJECT_DATA_ENCODING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>IBF_W</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>long</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_WP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ibf_dump_object_unsupported</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>IBF_OBJBODY</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>ibf_object_data_type</name></name></type> <name>type</name> <init>= <expr><operator>(</operator>enum <name>ibf_object_data_type</name><operator>)</operator><name><name>body</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>body</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>IBF_OBJECT_DATA_ENCODING</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>encobj</name> <init>= <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_find</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>encobj</name></expr>;</return>

</block_content>}</block>

</block_content>}</block></switch>

<return>return <expr><call><name>ibf_load_object_unsupported</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_complex_rational</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>RCOMPLEX</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><call><name>RCOMPLEX</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>imag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>IBF_W</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>long</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_complex_rational</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_complex_rational</name></name> <modifier>*</modifier></type><name>nums</name> <init>= <expr><call><name>IBF_OBJBODY</name><argument_list>(<argument><expr>struct <name>ibf_object_complex_rational</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>a</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>nums</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name><name>nums</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><ternary><condition><expr><name><name>header</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_COMPLEX</name></expr> ?</condition><then>

<expr><call><name>rb_complex_new</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_rational_new</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_symbol</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str_index</name> <init>= <expr><call><name>ibf_dump_object</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>str_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object_symbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str_index</name> <init>= <expr><call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>ibf_load_object</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>str_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_intern_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>ibf_dump_object_function</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ibf_dump_object_function</name></type> <name><name>dump_object_functions</name><index>[<expr><name>RUBY_T_MASK</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_class</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_float</name></expr>, 

<expr><name>ibf_dump_object_string</name></expr>, 

<expr><name>ibf_dump_object_regexp</name></expr>, 

<expr><name>ibf_dump_object_array</name></expr>, 

<expr><name>ibf_dump_object_hash</name></expr>, 

<expr><name>ibf_dump_object_struct</name></expr>, 

<expr><name>ibf_dump_object_bignum</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_data</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_complex_rational</name></expr>, 

<expr><name>ibf_dump_object_complex_rational</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_symbol</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

<expr><name>ibf_dump_object_unsupported</name></expr>, 

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_object_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name></type> <name>header</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name> <init>=

<expr><operator>(</operator><name><name>header</name><operator>.</operator><name>type</name></name> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>header</name><operator>.</operator><name>special_const</name></name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>header</name><operator>.</operator><name>frozen</name></name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>header</name><operator>.</operator><name>internal</name></name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>IBF_WV</name><argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ibf_object_header</name></name></type>

<name>ibf_load_object_object_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name> <init>= <expr><call><name>ibf_load_byte</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_object_header</name></name></type> <name>header</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>special_const</name></name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>frozen</name></name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>

<return>return <expr><name>header</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ibf_offset_t</name></type>

<name>ibf_dump_object_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_object_header</name></name></type> <name>obj_header</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>current_offset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>IBF_ZERO</name><argument_list>(<argument><expr><name>obj_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>type</name></name> <operator>=</operator> <call><name>TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current_offset</name> <operator>=</operator> <call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<goto>goto <name>dump_object</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>special_const</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>frozen</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_object_object_header</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>obj_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write_small_value</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>

<label><name>dump_object</name>:</label>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>special_const</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj_header</name><operator>.</operator><name>frozen</name></name> <operator>=</operator> <ternary><condition><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_FREEZE</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_object_object_header</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>obj_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>dump_object_functions</name><index>[<expr><name><name>obj_header</name><operator>.</operator><name>type</name></name></expr>]</index>)<argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>current_offset</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>ibf_load_object_function</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ibf_load_object_function</name></type> <name><name>load_object_functions</name><index>[<expr><name>RUBY_T_MASK</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_class</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_float</name></expr>, 

<expr><name>ibf_load_object_string</name></expr>, 

<expr><name>ibf_load_object_regexp</name></expr>, 

<expr><name>ibf_load_object_array</name></expr>, 

<expr><name>ibf_load_object_hash</name></expr>, 

<expr><name>ibf_load_object_struct</name></expr>, 

<expr><name>ibf_load_object_bignum</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_data</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_complex_rational</name></expr>, 

<expr><name>ibf_load_object_complex_rational</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_symbol</name></expr>,

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

<expr><name>ibf_load_object_unsupported</name></expr>, 

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ibf_load_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>object_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>object_index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>object_index</name> <operator>&gt;=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_list</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"object index out of range: %"</literal><name>PRIdVALUE</name></expr></argument>, <argument><expr><name>object_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_list</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>object_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>offsets</name> <init>= <expr><operator>(</operator><name>ibf_offset_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_list_offset</name></name> <operator>+</operator> <name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>buff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><name><name>offsets</name><index>[<expr><name>object_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_object_header</name></name></type> <name>header</name> <init>= <expr><call><name>ibf_load_object_object_header</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_object: list=%#x offsets=%p offset=%#x\n"</literal></expr></argument>,

<argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_list_offset</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>offsets</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_object: type=%#x special=%d frozen=%d internal=%d\n"</literal></expr></argument>,

<argument><expr><name><name>header</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>special_const</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>frozen</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"object offset out of range: %u"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>special_const</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>reading_pos</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ibf_load_small_value</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reading_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call>(<modifier>*</modifier><name>load_object_functions</name><index>[<expr><name><name>header</name><operator>.</operator><name>type</name></name></expr>]</index>)<argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_list</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>object_index</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_object: index=%#"</literal><name>PRIxVALUE</name><literal type="string">" obj=%#"</literal><name>PRIxVALUE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>object_index</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<struct>struct <name>ibf_dump_object_list_arg</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>offset_list</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ibf_dump_object_list_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_object_list_arg</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump_object_list_arg</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_dump_object_object</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>dump</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>offset_list</name></name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_object_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>ibf_offset_t</name> <modifier>*</modifier></type><name>obj_list_offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>obj_list_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>obj_table</name> <init>= <expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name><operator>-&gt;</operator><name>obj_table</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>offset_list</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name><name>obj_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump_object_list_arg</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>dump</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>offset_list</name></name> <operator>=</operator> <name>offset_list</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>obj_table</name></expr></argument>, <argument><expr><name>ibf_dump_object_list_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IBF_W_ALIGN</name><argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>obj_list_offset</name> <operator>=</operator> <call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><name><name>obj_table</name><operator>-&gt;</operator><name>num_entries</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>NUM2UINT</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>offset_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>IBF_WV</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>obj_list_size</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>size</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mark_set</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mark_set</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>ibf_dump_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name> <init>= <expr><operator>(</operator>struct <name>ibf_dump</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dump</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>st_memsize</name><argument_list>(<argument><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ibf_dump_type</name> <init>= <expr><block>{

<expr><literal type="string">"ibf_dump"</literal></expr>,

<expr><block>{<expr><name>ibf_dump_mark</name></expr>, <expr><name>ibf_dump_free</name></expr>, <expr><name>ibf_dump_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_WB_PROTECTED</name> <operator>|</operator> <name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_dump_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dumper_obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>dumper_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_table</name></name> <operator>=</operator> <call><name>ibf_dump_object_table_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>iseq_table</name></name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>dump</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_ibf_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_dump</name></name> <modifier>*</modifier></type><name>dump</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_header</name></name></type> <name>header</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dump_obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>!=</operator> <name>iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"should be top of iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>ISEQ_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"should not compile with coverage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dump_obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>ibf_dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ibf_dump_type</name></expr></argument>, <argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_setup</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>dump_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>RUBY_PLATFORM</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>RUBY_PLATFORM</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_iseq</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>magic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'Y'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>magic</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>magic</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'R'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>magic</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>major_version</name></name> <operator>=</operator> <name>IBF_MAJOR_VERSION</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>minor_version</name></name> <operator>=</operator> <name>IBF_MINOR_VERSION</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_iseq_list</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_object_list</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>.</operator><name>global_object_list_offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>header</name><operator>.</operator><name>global_object_list_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>size</name></name> <operator>=</operator> <call><name>ibf_dump_pos</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt_str</name> <init>= <expr><name>opt</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>StringValuePtr</name><argument_list>(<argument><expr><name>opt_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>extra_size</name></name> <operator>=</operator> <call><name>RSTRING_LENINT</name><argument_list>(<argument><expr><name>opt_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_write</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>extra_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>header</name><operator>.</operator><name>extra_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ibf_dump_overwrite</name><argument_list>(<argument><expr><name>dump</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>dump</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ibf_dump_free</name><argument_list>(<argument><expr><name>dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>dump_obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dump_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ibf_offset_t</name> <modifier>*</modifier></type>

<name>ibf_iseq_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>ibf_offset_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name> <operator>+</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>iseq_list_offset</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_ibf_load_iseq_complete</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name> <init>= <expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>prev_src_iseq</name> <init>= <expr><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ibf_offset_t</name></type> <name>offset</name> <init>= <expr><call><name>ibf_iseq_list</name><argument_list>(<argument><expr><name>load</name></expr></argument>)</argument_list></call><index>[<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>index</name></name></expr>]</index></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"rb_ibf_load_iseq_complete: index=%#x offset=%#x size=%#x\n"</literal></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,

<argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ibf_load_iseq_each</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA_CLEAR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_NOT_LOADED_YET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_init_trace</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>prev_src_iseq</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LAZY_LOAD</name></expr></cpp:if>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_complete</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ibf_load_iseq_complete</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>ibf_load_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>index_iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>iseq_index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>index_iseq</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: index_iseq=%p iseq_list=%p\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>index_iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>iseq_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>iseq_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseqv</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>iseq_list</name></name></expr></argument>, <argument><expr><name>iseq_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: iseqv=%p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>iseqv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>iseqv</name> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseqv</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseq_imemo_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: new iseq=%p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_NOT_LOADED_YET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>obj</name></name> <operator>=</operator> <name><name>load</name><operator>-&gt;</operator><name>loader_obj</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>iseq_index</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: iseq=%p loader_obj=%p index=%d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>loader_obj</name></name></expr></argument>, <argument><expr><name>iseq_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>iseq_list</name></name></expr></argument>, <argument><expr><name>iseq_index</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>USE_LAZY_LOAD</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: loading iseq=%p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_ibf_load_iseq_complete</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ibf_load_iseq_complete</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IBF_ISEQ_DEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ibf_load_iseq: iseq=%p loaded %p\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_load_setup_bytes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>loader_obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bytes</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>loader_obj</name></name> <operator>=</operator> <name>loader_obj</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator>struct <name>ibf_header</name> <operator>*</operator><operator>)</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_offset</name></name> <operator>=</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>global_object_list_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_size</name></name> <operator>=</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>global_object_list_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>iseq_list</name></name></expr></argument>, <argument><expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list</name></name></expr></argument>, <argument><expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_resize</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list</name></name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>load</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"broken binary format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><literal type="string">"YARB"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unknown binary format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>major_version</name></name> <operator>!=</operator> <name>IBF_MAJOR_VERSION</name> <operator>||</operator>

<name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>minor_version</name></name> <operator>!=</operator> <name>IBF_MINOR_VERSION</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unmatched version file (%u.%u for %u.%u)"</literal></expr></argument>,

<argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>minor_version</name></name></expr></argument>, <argument><expr><name>IBF_MAJOR_VERSION</name></expr></argument>, <argument><expr><name>IBF_MINOR_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>ibf_header</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>RUBY_PLATFORM</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unmatched platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>iseq_list_offset</name></name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unaligned iseq list offset: %u"</literal></expr></argument>,

<argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>iseq_list_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_offset</name></name> <operator>%</operator> <call><name>RUBY_ALIGNOF</name><argument_list>(<argument><expr><name>ibf_offset_t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unaligned object list offset: %u"</literal></expr></argument>,

<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_load_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>loader_obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LENINT</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ibf_header</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"broken binary format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_LAZY_LOAD</name></expr></cpp:if>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ibf_load_setup_bytes</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><call><name>StringValuePtr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>load</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_loader_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name> <init>= <expr><operator>(</operator>struct <name>ibf_load</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>iseq_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>obj_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ibf_loader_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name> <init>= <expr><operator>(</operator>struct <name>ibf_load</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>load</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>ibf_loader_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ibf_load</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ibf_load_type</name> <init>= <expr><block>{

<expr><literal type="string">"ibf_loader"</literal></expr>,

<expr><block>{<expr><name>ibf_loader_mark</name></expr>, <expr><name>ibf_loader_free</name></expr>, <expr><name>ibf_loader_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_WB_PROTECTED</name> <operator>|</operator> <name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_ibf_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loader_obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>ibf_load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ibf_load_type</name></expr></argument>, <argument><expr><name>load</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_load_setup</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_ibf_load_bytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bytes</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loader_obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>ibf_load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ibf_load_type</name></expr></argument>, <argument><expr><name>load</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_load_setup_bytes</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>ibf_load_iseq</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_ibf_load_extra_data</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ibf_load</name></name> <modifier>*</modifier></type><name>load</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loader_obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>ibf_load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ibf_load_type</name></expr></argument>, <argument><expr><name>load</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>extra_str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ibf_load_setup</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>loader_obj</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>extra_str</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name><name>load</name><operator>-&gt;</operator><name>global_buffer</name><operator>.</operator><name>buff</name></name> <operator>+</operator> <name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>load</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>extra_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>loader_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>extra_str</name></expr>;</return>

</block_content>}</block></function>

</unit>
